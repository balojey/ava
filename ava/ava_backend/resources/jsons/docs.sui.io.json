[
    {
      "title": "Action Request | Sui Documentation",
      "url": "https://docs.sui.io/standards/closed-loop-token/action-request",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nAction Request\nToken Policy\nSpending\nRules\nCoin/Token API comparison\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nClosed-Loop TokenAction Request\nAction Request\n\nThe main difference between tokens and coins is that tokens do not allow transfers, conversions, or spends by default. There is an authorization mechanism, however, that allows these actions. This mechanism is called an ActionRequest. You can choose to allow or disallow any of the actions independently (see the Request confirmation section).\n\nProtected actions​\n\nTokens have four protected actions that create an ActionRequest:\n\nFunction\tAction name\tDescription\tSpecial fields in ActionRequest\ntoken::from_coin\tfrom_coin\tConvert a coin into a token\t-\ntoken::to_coin\tto_coin\tConvert a token into a coin\t-\ntoken::transfer\ttransfer\tTransfer a token to a recipient\tContains recipient field\ntoken::spend\tspend\tSpend a token\tContains spent_balance field\nActionRequest structure​\n\nActionRequest is defined in the sui::token module and contains the following fields:\n\nname: Name of the performed action, standard ones are transfer, spend, to_coin and from_coin, and you can create custom actions.\namount: The amount of the token that is being transferred, spent, converted, and so on.\nsender: The account that initiated the action.\nrecipient: The account that receives the token in transfer action (use for custom actions).\nspent_balance: The balance of a spent token in the spend action (use in custom actions).\n\nRules can use these fields to determine whether the action should be allowed or not. Rules are custom modules that implement restriction logic. See Rules for more details.\n\nAn example of a function creating an ActionRequest:\n\n// module: sui::token\npublic fun transfer<T>(\n    t: Token<T>, recipient: address, ctx: &mut TxContext\n): ActionRequest<T>;\n\nRequest confirmation​\n\nThere are three ways to confirm an ActionRequest using a:\n\nTreasuryCap - you (or an application storing the TreasuryCap) can call the token::confirm_with_treasury_cap function to confirm any request. This method is useful for applications that store the TreasuryCap and implement custom logic; it also allows you to mint and transfer tokens, bypassing the restrictions.\nTokenPolicy - create a shared TokenPolicy and set up allowed actions and requirements for each action. This way, applications or wallets know which actions are considered public and so they are able to perform them.\nTokenPolicyCap - use the capability managing the TokenPolicy to confirm requests. This can be useful for applications that have the TreasuryCap wrapped and inaccessible; and you need to authorize some administrator action.\nINFO\n\nYou can't use TokenPolicyCap to confirm spend requests.\n\nConfirming with TreasuryCap​\n\nUse the TreasuryCap to confirm any action request for the token. It's useful for administrator actions (like mint and transfer), as well as for simple applications that don't require a token policy and wrap the TreasuryCap into the main object.\n\nThe signature for the token::confirm_with_treasury_cap function is:\n\n// module: sui::token\npublic fun confirm_with_treasury_cap<T>(\n    treasury_cap: &mut TreasuryCap<T>,\n    request: ActionRequest<T>,\n    ctx: &mut TxContext\n): (String, u64, address, Option<address>);\n\n\nAn example of a transaction implemented in TypeScript with sui.js, confirming an action request with a TreasuryCap. Here the admin account owns the TreasuryCap, which is used to mint and confirm the transfer request for the token:\n\nlet tx = new TransactionBlock();\nlet tokenType = '0x....::my_token::MY_TOKEN';\nlet treasuryCapArg = tx.object('0x....');\n\n// mint 10 tokens using the `TreasuryCap`\nlet token = tx.moveCall({\n    target: '0x2::token::mint',\n    arguments: [ treasuryCapArg, tx.pure.u64(10) ],\n    typeArguments: [ tokenType ],\n});\n\n// transfer the token to a recipient; receive an `ActionRequest`\nlet request = tx.moveCall({\n    target: '0x2::token::transfer',\n    arguments: [ token, tx.pure.address('0x...') ],\n    typeArguments: [ tokenType ],\n});\n\n// confirm the request with the `TreasuryCap`\ntx.moveCall({\n    target: '0x2::token::confirm_with_treasury_cap',\n    arguments: [ treasuryCapArg, request ],\n    typeArguments: [ tokenType ],\n});\n\n// submit the transaction\n// ...\n\nConfirming with TokenPolicy​\n\nTokenPolicy is a way of enabling certain actions network-wide. After sharing, the TokenPolicy is available to everyone. Hence, wallets or other clients can use it to confirm allowed operations.\n\nThe signature for the token::confirm_request function is:\n\n// module: sui::token\npublic fun confirm_request<T>(\n    treasury_cap: &TokenPolicy<T>,\n    request: ActionRequest<T>,\n    ctx: &mut TxContext\n): (String, u64, address, Option<address>);\n\nINFO\n\nIf it's a spend request, use the confirm_request_mut function instead.\n\nAn example of a client transfer request confirmation in JavaScript:\n\nlet tx = new TransactionBlock();\nlet tokenType = '0x....::my_token::MY_TOKEN';\nlet myTokenArg = tx.object('0x...token_object');\nlet receiverArg = tx.pure.address('0x...receiver');\nlet tokenPolicyArg = tx.object('0x...token_policy');\n\nlet request = tx.moveCall({\n    target: '0x2::token::transfer',\n    arguments: [ myTokenArg, receiverArg ],\n    typeArguments: [ tokenType ],\n});\n\n// expecting the `TokenPolicy` to have the `transfer` operation allowed\ntx.moveCall({\n    target: '0x2::token::confirm_request',\n    arguments: [ tokenPolicyArg, request ],\n    typeArguments: [ tokenType ],\n});\n\n// submit the transaction\n// ...\n\nConfirming with TokenPolicyCap​\n\nUse TokenPolicyCap to confirm action requests. A convenient approach when the TreasuryCap is wrapped in another object, and TokenPolicy does not allow certain action or has rules that make the default way of confirming impossible.\n\nINFO\n\nYou can't use TokenPolicyCap to confirm spend requests.\n\n// module: sui::token\n\npublic fun confirm_with_policy_cap<T>(\n    token_policy_cap: &TokenPolicyCap<T>,\n    request: ActionRequest<T>,\n    ctx: &mut TxContext\n): (String, u64, address, Option<address>);\n\n\nAn example of a client transfer request confirmation in JavaScript:\n\nlet tx = new TransactionBlock();\nlet tokenType = '0x....::my_token::MY_TOKEN';\nlet myTokenArg = tx.object('0x...token_object');\nlet receiverArg = tx.pure.address('0x...receiver');\nlet tokenPolicyCapArg = tx.object('0x...token_policy_cap');\n\nlet request = tx.moveCall({\n    target: '0x2::token::transfer',\n    arguments: [ myTokenArg, receiverArg ],\n    typeArguments: [ tokenType ],\n});\n\n// confirming the request with the TokenPolicyCap\ntx.moveCall({\n    target: '0x2::token::confirm_with_policy_cap',\n    arguments: [ tokenPolicyCapArg, request ],\n    typeArguments: [ tokenType ],\n});\n\n// submit the transaction\n// ...\n\nApproving actions​\n\nActionRequests can collect approvals - witness stamps from applications or rules. They carry the confirmation that a certain module or a rule has approved the action. This mechanic allows gating actions behind certain requirements.\n\nThe signature for the token::add_approval function is:\n\n// module: sui::token\npublic fun add_approval<T, W: drop>(\n    _t: W, request: &mut ActionRequest<T>, _ctx: &mut TxContext\n);\n\n\nApprovals are mostly used for rules, but they can carry confirmations from any module.\n\nCreating a custom request​\n\nAnyone can create a new ActionRequest using the token::new_request function. You can use it to create custom actions and rules, not necessarily related to the token itself.\n\nINFO\n\nBecause you can create an ActionRequest freely for any type T, you can't use them as a proof of the action. Their purpose is authorization, not proof.\n\nThe signature for the token::new_request function is:\n\npublic fun new_request<T>(\n    name: vector<u8>,\n    amount: u64,\n    recipient: option<address>,\n    spent_balance: option<Balance<T>>,\n    ctx: &mut TxContext\n): ActionRequest<T>;\n\nEdit this page\nPrevious\nClosed-Loop Token\nNext\nToken Policy\nProtected actions\nActionRequest structure\nRequest confirmation\nConfirming with TreasuryCap\nConfirming with TokenPolicy\nConfirming with TokenPolicyCap\nApproving actions\nCreating a custom request\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Token Policy | Sui Documentation",
      "url": "https://docs.sui.io/standards/closed-loop-token/token-policy",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nAction Request\nToken Policy\nSpending\nRules\nCoin/Token API comparison\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nClosed-Loop TokenToken Policy\nToken Policy\n\nTokenPolicy is a shared object that you, as the token owner, can create using the TreasuryCap. Having a publicly available TokenPolicy enables on-chain discovery of allowed actions and their conditions. This is useful for wallets and other services that want to provide a better user experience for token holders.\n\nCreate and share​\n\nYou create a new TokenPolicy using the token::new_policy function. The function takes the TreasuryCap as an argument and returns a TokenPolicy object and a managing capability.\n\n// module: sui::token\npublic fun new_policy<T>(\n    treasury_cap: &TreasuryCap<T>,\n    ctx: &mut TxContext\n): (TokenPolicy<TokenType>, TokenPolicyCap<TokenType>);\n\n\nYou must use the token::share_policy function to share the TokenPolicy object.\n\nAllow and disallow​\n\nTo allow methods without any conditions, use the token::allow function. The function takes a TokenPolicy and TokenPolicyCap as arguments. If allowed, the action can be confirmed in the TokenPolicy using the token::confirm_request function (see ActionRequest).\n\n// module sui::token\npublic fun allow<T>(\n    policy: &mut TokenPolicy<T>,\n    policy_cap: &TokenPolicyCap<T>,\n    action: String,\n    ctx: &mut TxContext\n);\n\n\nSimilarly, you can use the token::disallow function to completely disable an action; it takes the same arguments as token::allow.\n\nAdding rules​\n\nTokenPolicy can specify custom conditions for each action. These conditions are called rules and are typically implemented as separate Move modules. The identifier of the rule is its type. See Rules for more information.\n\nThe pseudo-code structure of the TokenPolicy is as follows. Each action can have multiple rules associated with it.\n\nTokenPolicy\n  rules:\n    - action: \"transfer\"\n      rules:\n        - 0x0...::denylist::Denylist\n    - action: \"to_coin\"\n      rules:\n        - 0x0...::limiter::Limiter\n        - 0x0...::allowlist::Allowlist\n    ...\n\n\nTo add a rule for an action, use the token::add_rule_for_action function. The function takes a TokenPolicy and TokenPolicyCap as arguments. The rule is specified by its type (for example, 0x0...::denylist::Denylist).\n\n// module: sui::token\npublic fun add_rule_for_action<T, Rule: drop>(\n    policy: &mut TokenPolicy<T>,\n    policy_cap: &TokenPolicyCap<T>,\n    action: String,\n    ctx: &mut TxContext\n);\n\n\nSignature for the reverse operation token::remove_rule_for_action is symmetrical to token::add_rule_for_action.\n\nConsume spent balance​\n\nSpent balance can be consumed from the TokenPolicy using the token::flush function. It requires a TreasuryCap.\n\n// module sui::token\npublic fun flush<T>(\n    policy: &mut TokenPolicy<T>,\n    treasury_cap: &mut TreasuryCap<T>,\n    ctx: &mut TxContext\n);\n\nCheatsheet: TokenPolicy API​\nFunction\tNote\nnew_policy\tCreate a new TokenPolicy using the TreasuryCap\nallow\tAllow an action in the TokenPolicy\ndisallow\tDisallow an action in the TokenPolicy\nadd_rule_for_action\tAdd a rule for an action in the TokenPolicy\nremove_rule_for_action\tRemove a rule for an action in the TokenPolicy\nconfirm_request\tConfirm an ActionRequest with a TokenPolicy\nconfirm_request_mut\tSimilar to confirm_request but only works for spend action\nflush\tFlush the spent balance from the TokenPolicy (see Spending)\nEdit this page\nPrevious\nAction Request\nNext\nSpending\nCreate and share\nAllow and disallow\nAdding rules\nConsume spent balance\nCheatsheet: TokenPolicy API\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture/indexer-functions",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui ArchitectureSui Indexer\nSui Indexer\n\nSui Indexer is an off-Full node data service that serves data from the Sui protocol, including both data directly generated from chain and derivative data.\n\nFunctions​\n\nSui Indexer provides three main functionalities:\n\nIngest data from a Full node to a relational database. Data on Full nodes is stored as BCS bytes in embedded RocksDB, thus the query capabilities are very limited. The indexer pulls checkpoint blob data, schematizing them into various tables like objects, transactions, and so on with proper indices.\nServe online transaction processing (OLTP) RPC requests. With data in relational databases, Sui indexer spins a stateless reader binary as JSON RPC server with an interface.\nAnalytical indexer. Other than OLTP data ingestion and requests, indexer also supports some analytical data ingestion like transactions per second (TPS) and daily active user (DAU) metrics.\nRun an indexer​\n\nRefer to the Sui Indexer README in the crates/sui-indexer directory of the Sui repo to run an indexer with a local or managed Postgres-compatible database.\n\nFuture enahancements​\n\nTwo planned enhancements for Sui indexer are:\n\nExpand Sui indexer to be able to run on MySQL compatible DB\nEncapsulate the deployment steps into a docker-compose-like script for easier initial setup.\nEdit this page\nPrevious\nConsensus\nNext\nProtocol Upgrades\nFunctions\nRun an indexer\nFuture enahancements\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture/consensus",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui ArchitectureConsensus\nConsensus\n\nThe basic purpose of consensus in blockchains is to agree on a consistent order and ensure the availability of transactions.\n\nOn Sui, consensus has a simple API: validators submit different user transactions to consensus concurrently, and the consensus outputs a consistent stream of transactions across all well-behaving validators.\n\nByzantine-fault tolerant (BFT) consensus protocols are a rich area of research. The next-generation consensus engine set to roll out in Sui is based on the Mysticeti protocol. The protocol optimizes for both low latency and high throughput because:\n\nIt allows multiple validators to propose blocks in parallel, utilizing the full bandwidth of the network and providing censorship resistance. These are features of the DAG-based consensus protocols.\nIt takes only three rounds of messages to commit blocks from the DAGs, same as pBFT and matches the theoretical minimum.\nThe commit rule allows voting and certifying leaders on blocks in parallel, further reducing the median and tail latencies.\nThe commit rule also tolerates unavailable leaders without significantly increasing the commit latencies.\n\nFor more details including correctness proofs, the Mysticeti paper is the best source.\n\nEdit this page\nPrevious\nLife of a Transaction\nNext\nSui Indexer\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture/transaction-lifecycle",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui ArchitectureLife of a Transaction\nLife of a Transaction\n\nA transaction on the Sui network goes through many different steps during its life cycle.\n\nLife cycle overview​\n\nAt a high level, the following figure outlines the life cycle of a transaction on the Sui blockchain.\n\nThe following steps align with those in the preceding image.\n\nThe first step of the process is the creation of a transaction. A user with a private key creates and signs a user transaction to either mutate objects they own, or a mix of objects they own and shared objects.\n\nSui sends the transaction to each validator (often through a Full node). Validators perform a series of validity and safety checks, sign it, and return the signed transaction to the client.\n\nThe client then collects the responses from a set of validators that account for at least 2/3 stake on Sui (a supermajority) to form a transaction certificate. As a result, unlike consensus-based blockchains, Sui validators do not need to propagate signatures on a best-effort basis (gossip signatures) or aggregate certificates. This effort is now the responsibility of the client or gateway.\n\nAfter assembling the certificate, the client sends it back to all validators, who check its validity and acknowledge its receipt to the client. If the transaction involves owned objects exclusively, Sui can process the transaction certificate immediately and execute it without waiting for the consensus engine (direct fast path). All certificates are forwarded to the Sui DAG-based consensus protocol (also operated by the Sui validators).\n\nConsensus eventually outputs a total order of certificates; the validators check and execute those that contain shared objects.\n\nClients can collect a supermajority of validator responses, assemble them into an effect certificate, and use it as proof of the settlement of the transaction.\n\nSubsequently, Sui forms checkpoints for every consensus commit, which it also uses to drive the reconfiguration protocol.\n\nThe complete Sui Lutris paper provides additional detail on how the safety and liveness protocols operate, as well as proofs of security for them in the standard distributed systems model with Byzantine participants in partial synchrony. The following sections provide more detail on the various stages in the life of a transaction.\n\nSubmission​\n\nAll transactions on Sui begin when they are submitted to the network. For example, imagine you want to transfer an NFT that you own in your wallet to your friend. First, you would create a transaction using a wallet or some other app. The transaction includes your gas payment object and a command to transfer the NFT object to your friend's address. Before the wallet or app submits the transaction to the network, it must also sign it.\n\nAfter the transaction is signed, the wallet or app submits the transaction to a Sui Full node on behalf of the user.\n\nCertification​\n\nCertification happens after a transaction gets submitted to a Full node. Upon submission, the Full node begins the process of certifying the transaction. The Full node cannot certify the transaction on its own because it does not have a complete view of transactions across the network. Consequently, the Full node must send the transaction to a validator. The validator performs a validity check on the transaction and signs it if it passes. To be considered valid, the transaction must pass the following checks:\n\nThe transaction has a valid user signature.\nThe initiator of the transaction must have access to all the owned input objects the transaction uses. In the previous NFT example, the validity check makes sure you own the NFT you're trying to send to a friend.\nAll the shared input objects used by the transaction exist.\nThe gas coin is a Coin<SUI> object, and it contains at least as much gas as specified in the transaction's gas budget.\n\nIf all the validity checks pass, the validator then attempts to lock all the owned input objects to the given transaction digest. This ensures each owned input object can only be used by one transaction at a time and is the way that Sui prevents double-spending. In other words, this makes sure that you send your NFT to only one friend instead of trying to send the same NFT to all your friends.\n\nIf the locking succeeds, the validator signs the transaction using its BLS private key and returns the signature to the Full node. A single validator signature is not enough, though. The Full node must collect signatures from enough validators to form a supermajority.\n\nINFO\n\nFull nodes collect signatures from validators in parallel to minimize latency.\n\nAfter the Full node collects a supermajority, or quorum, of validator signatures, the transaction is considered certified. To be precise, the Full node has formed a transaction certificate.\n\nBecause of the locking step described previously, it is impossible to concurrently form certificates for two different transactions that attempt to use the same owned object. This is true even if there are some dishonest validators that illegally sign both transactions, because of a principle in distributed computing called \"quorum intersection\".\n\nIf fewer than 1/3rd of the validators are dishonest (Byzantine), then the set of signers for any two certificates must have an overlap that includes at least one honest validator. And, crucially, because that validator is honest, it never signs two transactions that attempt to access the same input object at the same version. After the transaction completes, the input object version changes and can be accessed again by subsequent transactions.\n\nExecution​\n\nFull nodes send transactions that have a certificate to validators for execution. Each validator verifies the signatures on the certificate. If the certificate signatures are valid, then the validator can be sure that the transaction is valid and is not attempting to double-spend any objects.\n\nThen, each validator does the following, based on whether the transaction:\n\nDoes not access any shared input objects, in which case it executes it immediately.\nDoes access shared input objects, in which case it submits the object to Sui's consensus layer, which orders the transaction with respect to other transactions using the same shared objects and then executes it.\nCertified Effects​\n\nAfter the transaction executes, the validator signs the effects of the transaction and returns them to the Full node. The transaction effects are essentially a list of all the actions that the transaction took, which mainly include:\n\nAll the objects that were mutated, created, wrapped, unwrapped, or deleted.\nThe gas that was spent.\nThe execution status (Success or an error code) of the transaction.\n\nEventually, the Full node collects effects signatures from a supermajority of validators. This collection of signatures, plus the effects themselves, is called an effects certificate.\n\nTIP\n\nAn effects certificate is a guarantee of transaction finality.\n\nAfter you or a Full node observes an effects certificate, you are guaranteed that the transaction is going to be included in a checkpoint, which means that the transaction cannot be reverted.\n\nIf you wanted, you could present the effects certificate to your friend to prove that you sent them the NFT. The presence of the validator signatures means that an effects certificate cannot be forged.\n\nCheckpoints​\n\nInclusion in a checkpoint is the final stage in the life of a transaction. As validators execute transactions, they submit them to consensus.\n\nWhile transactions that use shared input objects must be sent to consensus before they are executed, owned-input-only transactions are also sent to consensus. The difference is that owned-input-only transactions are executed first.\n\nThe consensus layer produces a universally agreed-upon ordering of transactions. This ordering is the starting point for the creation of checkpoints.\n\nThe validators take chunks of ordered transactions from the consensus layer and use them to form a checkpoint. Each chunk of transactions is first made causally complete and causally ordered - this means that the validators add any missing dependencies to the list of transactions and order them so that dependencies always appear before dependents in checkpoints.\n\nThen the validator constructs a checkpoint, which (among other data) contains a list of transaction digests as well as the digests of the transaction effects of each transaction. Because checkpoints must be complete, the network sometimes has to wait for the availability of all transactions to form the checkpoints, which may take a couple of commits to process. This process typically completes in the order of a few seconds.\n\nAt this point, the transaction has reached the end of its life cycle and is included in the permanent record of transaction activity on the Sui network.\n\nTransaction finality​\n\nTransaction finality is the point at which the execution of a transaction becomes irreversible and its details cannot be altered or changed.\n\nThe network round trip of sending a transaction and receiving a validator signature takes less than half a second to complete. At this point the sender knows the transaction is irrevocable and is going to be processed within the epoch, no matter what. The transaction has reached finality; honest validators deem invalid any subsequent transactions using the same owned input objects during the same epoch.\n\nSettlement finality​\n\nAfter a validator executes a transaction, it returns signed effects from that transaction to the network.\n\nAfter the supermajority of validators have executed the transaction, and an effects certificate exists, the effects of the transaction (transfers, newly minted objects, and so on) have been implemented. At this point, the network can process transactions that depend on those effects.\n\nFor transactions that involve owned objects only, this happens before consensus in under half a second. If a transaction includes shared objects, it happens shortly after consensus, which can take a few seconds. At this point, the transaction reached settlement finality because now you can process more transactions on the same input objects. See Object Ownership for more information.\n\nAn example path to an effects certificate​\n\nAs a real-world example, suppose you want to pay the local coffee shop 10 SUI for your morning coffee. How can the coffee shop be sure that the payment is complete and allow you to take your coffee?\n\nStep 1: Transaction creation\n\nYou open the wallet app on your phone, scan the coffee shop's QR code that contains the recipient on-chain address. The wallet app constructs a transaction that transfers 10 Sui from your Sui address to the coffee shop's address. You review the transaction details and approve it. The wallet app then signs the transaction with your private key. Now you have a signed transaction.\n\nStep 2: Transaction broadcast\n\nYour wallet app submits the signed transaction to a Full node. The Full node broadcasts the transaction to all validators in the network.\n\nStep 3: Transaction certification\n\nValidators receive the transaction from the Full node. After examining its validity, a validator locks the referenced owned objects, and returns its signature of the transaction to the Full node.\n\nAfter the Full node collects a quorum of signatures, it forms a transaction certificate. The transaction certificate contains the transaction and signatures from the supermajority of validators.\n\nStep 4: Transaction finalization\n\nThe Full node broadcasts the transaction certificate to all validators. Validators receive the transaction certificate, verify its validity (for example, there are indeed enough signatures), execute the transaction, and unlock the previously locked owned objects. Transaction effects are the output of an executed transaction. Validators sign the transaction effects and return them to the Full node, along with their signatures.\n\nThe Full node verifies that effects returned from validators are identical. After it collects a supermajority of signatures, it forms an EffectsCertificate object. The effects certificate contains the transaction effects and signatures from a supermajority of validators.\n\nAt this point, as your wallet app gets back the effects certificate from the Full node, you can share this effect certified transaction with the coffee shop. The coffee shop can then be sure that the transaction is executed and irreversible.\n\nCheckpoint processing​\n\nThe process in the previous section demonstrates a finalized transaction through an effects certificate. As the process shows, the Full node plays the quorum driving role.\n\nWhat if the Full node goes offline before it collects a quorum of validator-signed effects? Your wallet app will probably retry the process with a different Full node. Unfortunately, your phone runs out of battery before it sends the signed transaction to a new Full node.\n\nNo worries. The coffee shop shortly notices your payment arrive in its terminal, connected to a different Full node. This Full node learns about your transaction through checkpoints.\n\nAs mentioned, a checkpoint contains a list of transactions. If a transaction appears in a certified checkpoint (a checkpoint that has been signed by a supermajority of validators), it is considered finalized.\n\nThe Full node that the coffee shop's terminal connects to knows about your transaction through state sync. In this case, as long as one validator receives the transaction certificate from your original Full node, the transaction will highly likely finalize even without an effects certificate. The coffee shop is assured of payment and can give you your coffee.\n\nLocal execution on Full node​\n\nBefore the Full node sends back an effects certificate to your wallet app, it may try to execute the transaction locally, if the request asks it to.\n\nThe purpose of this extra step is to keep the Full node up to date as much as possible, especially when the wallet app frequently hits the same Full node. In this coffee shop example, this might be trivial, but for a high frequency application, such as gaming, it could be important.\n\nWhen an app constructs a transaction, it typically requests that the Full node choose a gas object for it. Gas objects are owned objects, meaning that if the Full node is stale and not aware of the right version of the object, it could lead to invalid transactions, or worse, client equivocation if the client software does not handle it properly. Executing on Full node before returning EffectsCertificate is one way to avoid this situation. A request can ask for such behavior by using the WaitForLocalExecution parameter. See Sponsored Transactions for more on client equivocation.\n\nUsing WaitForLocalExecution is not always the best choice, however. For example, with this coffee payment it adds a layer of end-to-end latency without significant benefits. In this case, using the WaitForEffects parameter instead to have a slightly shorter user-perceived latency.\n\nEpoch change​\n\nPeriodically (~24 hours), the Sui network enters the process of epoch change. During epoch change, the network calculates and distributes staking rewards, validators metadata take effect, and other network processes are performed. All user transactions are delayed until the new epoch begins.\n\nIf your transaction is submitted at epoch boundary, in rare perfect timing, it is possible that a quorum of validators already decided to not accept any new transaction certificates in the current epoch. Of course, this means your coffee purchase is not be checkpointed either. For any transactions that are certified but not finalized, they are reverted if executed, or its owned objects are unlocked and not yet executed. In this case, the transaction certificate does not guarantee finality. In the new epoch, this transaction certificate will become void because validator signatures are signed over epoch ID. To continue this transaction, a new transaction certificate is necessary with the new epoch ID. The standard Full node implementation handles this automatically.\n\nVerifying finality​\n\nAssume your wallet app crashed during the original transaction. If the app stores the signed transaction locally before sending it to the Full node, which is best practice, then when the app restarts it tries to verify if the transaction has been finalized first. If it has, then no other steps are necessary. If it hasn't, then the app needs to resubmit the transaction.\n\nThe wallet app can query the Full node with the getTransactionBlock method. Assuming the Full node is honest:\n\nIf the response contains transaction details, the transaction must have been finalized. It is either executed with WaitForLocalExecution, or executed as a checkpointed transaction.\nIf the response is None, it could mean the transaction was dropped in some step, or is already finalized but this Full node does not know yet. In this scenario, the safer option is to resubmit the transaction.\n\nBefore a transaction is locally executed, its effects are not reflected on the Full node. The same idea applies to the coffee shop's Full node. Your transaction was not submitted through this Full node, hence it does not have a chance to locally execute it before it's included in a checkpoint. This Full node must wait for the transaction to be checkpointed and state synced, which normally takes a few seconds. After the Full node receives this transaction in a checkpoint, it is executed and has effects updated locally, for example the coffee shop's balance increases.\n\nSummary​\n\nHopefully, you now have a better understanding of how a transaction gets certified and finalized.\n\nA transaction certificate does not always guaranteed finality, even though it's highly likely. Specifically, a transaction certificate might become void after an epoch change.\n\nAn effects certificate guarantees finality - it takes a supermajority of validators to execute the transaction and commit to the effects.\n\nAn inclusion in a certified checkpoint guarantees finality - it takes a supermajority of validators to certify the checkpoint, in which every transaction is executed and effects-committed.\n\nEdit this page\nPrevious\nUnderstand Sui Security\nNext\nConsensus\nLife cycle overview\nSubmission\nCertification\nExecution\nCertified Effects\nCheckpoints\nTransaction finality\nSettlement finality\nAn example path to an effects certificate\nCheckpoint processing\nLocal execution on Full node\nEpoch change\nVerifying finality\nSummary\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Understand Sui Security | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture/sui-security",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui ArchitectureUnderstand Sui Security\nUnderstand Sui Security\n\nThis page provides an overview of the major guarantees Sui provides in terms of security.\n\nSui asset owners and smart contract designers can start learning here about the mechanisms available to secure their assets, and the assurances Sui provides for them. Smart contract designers can also learn about the overall Sui security architecture to ensure the asset types they design leverage Sui to provide a secure experience to the asset holders.\n\nSecurity features​\n\nSui is designed to provide very high security guarantees to asset owners. Assets on Sui can be used only by their owners, according to the logic pre-defined by smart contracts that can be audited, and that the network will be available to process them correctly despite some of the validators operating Sui not following the protocol correctly (fault tolerance).\n\nThe security features of the Sui system ensure a number of properties:\n\nOnly the owner of an owned asset can authorize a transaction that operates on this asset. Authorization is performed through the use of a private signature key that is known only to the asset owner.\nEveryone can operate on shared assets or immutable assets, but additional access control logic can be implemented by the smart contract.\nTransactions operate on assets according to predefined rules set by the smart contract creator that defined the asset type. These are expressed using the Move language.\nOnce a transaction is finalized, its effects - namely changes to the assets it operates on or new assets created - will be persisted, and the resulting assets will be available for further processing.\nThe Sui system operates through a protocol between a set of independent validators. Yet all its security properties are preserved when a small subset of the validators do not follow the protocol.\nAll operations in Sui can be audited to ensure any assets have been correctly processed. This implies all operations on Sui are visible to all, and users may wish to use multiple different addresses to protect their privacy.\nValidators are determined periodically through users of Sui locking and delegating SUI tokens to one or more validators.\nSecurity architecture​\n\nThe Sui system is operated by a set of validators that process transactions. They implement the Sui protocol that allows them to reach agreement on valid transactions submitted and processed in the system.\n\nThe agreement protocols Sui uses tolerate a fraction of validators not following the Sui protocol correctly, through the use of Byzantine fault tolerant broadcast and consensus. Specifically, each validator has some voting power, assigned to it through the process of users staking / voting for them using their SUI tokens. Sui maintains all its security properties if over 2/3 of the stake is assigned to validators that follow the protocol. However, a number of auditing properties are maintained even if more validators are faulty.\n\nAddresses and ownership​\n\nA Sui transaction is valid and can proceed only if the owner of all owned assets it operates on digitally signs it with their private signature key. This signature key can be kept private by the user and not be shared with anyone else. As a result, it is not feasible for any other party to operate on an owned asset of a user undetected, even if all validators do not follow the protocol.\n\nA private signature key also corresponds to a public address on the Sui network that can be used to send a user assets or allow smart contracts to define custom access control logic. A user may have one or more addresses corresponding to multiple signature keys for convenience or privacy reasons. An address does not need any pre-registration, and sending an asset to an address automatically creates this address on the network. However, this means that users should be careful to check the recipient address of transfers, or parties involved in any other operations, as sending assets to an incorrect address may have irrevocable effects.\n\nSmart contracts define asset types and their logic​\n\nAll assets have a type that is defined within a Sui Smart Contract. Sui provides a few system contracts, such as these used to manage the SUI native token, yet also allows anyone to write and submit custom smart contracts. A transaction on an asset type can call operations defined in only the smart contract that defined the asset type, and is constrained by the logic in the contract.\n\nFor this reason, users are encouraged to operate on their assets using smart contracts they trust, that they or others they trust have audited, and understand the logic they define for operations on their assets. Sui smart contracts are defined as immutable assets to allow third parties to audit them and also prevent their modification to increase assurance.\n\nThe Move smart contract language is designed with ease of audit and verification in mind. You may be interested in our introduction to Smart Contracts in Move.\n\nShared assets allow multiple users to operate on them through transactions; that may include some of their owned assets as well as one or more shared assets. These shared assets represent data and logic used to implement protocols that mediate between different users in a safe way, according to the smart contract that defined the type of the shared asset. Sui allows all users to create transactions involving shared assets. But the smart contract type may define additional restrictions on which address and how the shared assets may be used.\n\nTransaction finality​\n\nA valid transaction submitted to all validators has to be certified and its certificate also has to be submitted to all validators to be finalized. Even if a subset of validators do not follow the protocol, the transaction can be finalized through the remaining validators that correctly follow the Sui protocol. This is achieved through the use of cryptographic Byzantine fault tolerant agreement protocols for broadcast and consensus defined by the Sui protocol. These protocols ensure both safety, meaning that the incorrect validators cannot convince correct clients of incorrect state, and liveness, meaning that incorrect validators cannot prevent transaction processing.\n\nAll transactions in Sui have to be associated with a gas asset to cover the cost of processing by Sui. A valid transaction may result in successful execution or an aborted execution. An execution may abort due to a condition within the smart contract defining the asset, or because it has ran out of sufficient gas to pay for the cost of execution. In cases of success, the effects of the operation will be finalized; otherwise, the state of assets in the transaction is not changed. However, the gas asset is always charged some amount of gas, to alleviate denial-of-service attacks on the system as a whole.\n\nA user client can perform the process of submitting the transaction and certificate itself or rely on third party services to submit the transaction and interact with validators. Such third parties need not have user private signature keys and cannot forge transactions on the users' behalf. They can reassure a user client a transaction has been finalized through a set of signatures from validators attesting to the transactions finality and its effects. After that point, the users can be assured that changes the transaction resulted in will persist on the state of Sui.\n\nAuditing and privacy​\n\nSui validators provide facilities for users to read all assets they store, as well as the historical record of transactions they have processed that led to these assets. Validators also provide cryptographic evidence of the full chain of transactions that contributed to an asset state. User clients can request and validate this chain of evidence to ensure all operations were correct and the result of the collective agreement between validators. Services that operate full replicas, mirroring the state of one or more validators, perform such audits routinely.\n\nThe public auditability of Sui also implies that all transactions and assets within Sui are publicly visible. Users that are mindful of their privacy may use multiple addresses to benefit from some degree of pseudonymity, or third-party custodial or non-custodial services. Specific smart contracts with additional cryptographic privacy protections can also be provided by third parties.\n\nCensorship-resistance and openness​\n\nSui uses the established Delegated Proof-of Stake model to periodically determine its set of validators. Users can lock and delegate their SUI tokens in each epoch to determine the committee of validators that operate the Sui network in the next epoch. Anyone with over a minimum amount of delegated stake can operate a Sui validator.\n\nValidators operate the network and provide rewards to users that stake their Sui to support them as validators, through gas fee income. Validators with poor reliability, and in turn the users that delegated their stake to them, may receive a lower reward. But user stake cannot be confiscated away either by malicious validators or anyone in the network.\n\nThis mechanism ensures that validators are accountable to Sui users and can be rotated out at the first sign of unreliability or misbehavior, including noticed attempts to censor valid transactions. Through choices of validators, and the protocol they are willing to operate, Sui users also have a meaningful say on the future evolution of the Sui system.\n\nFurther reading​\n\nIf you are looking for an in-depth technical explanation of the computer science behind Sui security, you may have a look at our white paper on the Sui Smart Contracts Platform.\n\nEdit this page\nPrevious\nSui Architecture\nNext\nLife of a Transaction\nSecurity features\nSecurity architecture\nAddresses and ownership\nSmart contracts define asset types and their logic\nTransaction finality\nAuditing and privacy\nCensorship-resistance and openness\nFurther reading\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Operator Guides | Sui Documentation",
      "url": "https://docs.sui.io/guides/operator",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator Guides\nOperator Guides\n\nOperator guides demonstrate how to run Full nodes on Sui, whether as a validator or operator of a Full node to support your dApp, as well as how to integrate SUI into an exchange.\n\nSui Full node operators​\n\nGuides that inform Full node operators include:\n\nSui Full Node Configuration\nSui validators​\n\nGuides that inform validators how to operate on Sui include:\n\nValidator Committee\nValidator Configuration\nValidator Tasks\nSui Full node operators and validators​\n\nGuides that benefit both Full node operators and validators include:\n\nData Management\nGenesis\nSnapshots\nArchives\nExchange integration guide​\n\nThe Sui Exchange Integration Guide provides step-by-step instructions on how to integrate SUI into a cryptocurrency exchange.\n\nEdit this page\nPrevious\nDev Cheat Sheet\nNext\nSui Full Node Configuration\nSui Full node operators\nSui validators\nSui Full node operators and validators\nExchange integration guide\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Wrapped Objects | Sui Documentation",
      "url": "https://docs.sui.io/concepts/object-ownership/wrapped",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nObject Ownership\nAddress-Owned Objects\nImmutable Objects\nShared Objects\nWrapped Objects\nDynamic Fields\nTransfers\nEvents\nObject and Package Versioning\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersObject ModelObject OwnershipWrapped Objects\nWrapped Objects\n\nIn many programming languages, you organize data structures in layers by nesting complex data structures in another data structure. In Move, you can organize data structures by putting a field of struct type in another, like the following:\n\nstruct Foo has key {\n    id: UID,\n    bar: Bar,\n}\n\nstruct Bar has store {\n    value: u64,\n}\n\n\nTo embed a struct type in a Sui object struct (with a key ability), the struct type must have the store ability.\n\nIn the preceding example, Bar is a normal struct, but it is not a Sui object since it doesn't have the key ability.\n\nThe following code turns Bar into an object, which you can still wrap in Foo:\n\nstruct Bar has key, store {\n    id: UID,\n    value: u64,\n}\n\n\nNow Bar is also a Sui object type. If you put a Sui object of type Bar into a Sui object of type Foo, the object type Foo wraps the object type Bar. The object type Foo is the wrapper or wrapping object.\n\nThere are some interesting consequences of wrapping a Sui object into another. When an object is wrapped, the object no longer exists independently on-chain. You can no longer look up the object by its ID. The object becomes part of the data of the object that wraps it. Most importantly, you can no longer pass the wrapped object as an argument in any way in Sui Move calls. The only access point is through the wrapping object.\n\nIt is not possible to create circular wrapping behavior, where A wraps B, B wraps C, and C also wraps A.\n\nAt some point, you can then take out the wrapped object and transfer it to an address, modify it, delete it, or freeze it. This is called unwrapping. When an object is unwrapped, it becomes an independent object again, and can be accessed directly on-chain. There is also an important property about wrapping and unwrapping: the object's ID stays the same across wrapping and unwrapping.\n\nThere are a few ways to wrap a Sui object into another Sui object, and their use cases are typically different. This section describes three different ways to wrap a Sui object with typical use cases.\n\nDirect wrapping​\n\nIf you put a Sui object type directly as a field in another Sui object type (as in the preceding example), it is called direct wrapping. The most important property achieved through direct wrapping is that the wrapped object cannot be unwrapped unless the wrapping object is destroyed. In the preceding example, to make Bar a standalone object again, unpack (and hence delete) the Foo object. Direct wrapping is the best way to implement object locking, which is to lock an object with constrained access. You can unlock it only through specific contract calls.\n\nThe following example implementation of a trusted swap demonstrates how to use direct wrapping. Assume there is an NFT-style Object type that has scarcity and style. In this example, scarcity determines how rare the object is (presumably the more scarce the higher its market value), and style determines the object content/type or how it's rendered. If you own some of these objects and want to trade your objects with others, you want to make sure it's a fair trade. You are willing to trade an object only with another one that has identical scarcity, but want a different style (so that you can collect more styles).\n\nFirst, define such an object type:\n\nstruct Object has key, store {\n    id: UID,\n    scarcity: u8,\n    style: u8,\n}\n\n\nIn a real application, you might make sure that there is a limited supply of the objects, and there is a mechanism to mint them to a list of owners. For simplicity and demonstration purposes, this example simplifies creation:\n\npublic fun new(scarcity: u8, style: u8, ctx: &mut TxContext): Object {\n    Object { id: object::new(ctx), scarcity, style }\n}\n\n\n\nYou can also enable a swap/trade between your object and others' objects. For example, define a function that takes two objects from two addresses and swaps their ownership. But this doesn't work in Sui. Only object owners can send a transaction to mutate the object. So one person cannot send a transaction that would swap their own object with someone else's object.\n\nAnother common solution is to send your object to a pool - such as an NFT marketplace or a staking pool - and perform the swap in the pool (either right away, or later when there is demand). Other chapters explore the concept of shared objects that can be mutated by anyone, and show how it enables anyone to operate in a shared object pool. This chapter focuses on how to achieve the same effect using owned objects. Transactions using only owned objects are faster and less expensive (in terms of gas) than using shared objects, since they do not require consensus in Sui.\n\nTo swap objects, the same address must own both objects. Anyone who wants to swap their object can send their objects to the third party, such as a site that offers swapping services, and the third party helps perform the swap and send the objects to the appropriate owner. To ensure that you retain custody of your objects (such as coins and NFTs) and not give full custody to the third party, use direct wrapping. To define a wrapper object type:\n\nstruct SwapRequest has key {\n    id: UID,\n    owner: address,\n    object: Object,\n    fee: Balance<SUI>,\n}\n\n\nSwapRequest defines a Sui object type, wraps the object to swap, and tracks the original owner of the object. You might need to also pay the third party some fee for this swap. To define an interface to request a swap by someone who owns an Object:\n\npublic fun request_swap(\n    object: Object,\n    fee: Coin<SUI>,\n    service: address,\n    ctx: &mut TxContext,\n) {\n    assert!(coin::value(&fee) >= MIN_FEE, EFeeTooLow);\n\n    let request = SwapRequest {\n        id: object::new(ctx),\n        owner: tx_context::sender(ctx),\n        object,\n        fee: coin::into_balance(fee),\n    };\n\n    transfer::transfer(request, service)\n}\n\n\n\nIn the preceding function, you must pass the object by value so that it's fully consumed and wrapped into SwapRequest to request swapping an object. The example also provides a fee (in the type of Coin<SUI>) and checks that the fee is sufficient. The example turns Coin into Balance when it's put into the wrapper object. This is because Coin is a Sui object type and used only to pass around as Sui objects (such as transaction inputs or objects sent to addresses). For coin balances that need to be embedded in other structs, use Balance instead because to avoid the overhead of carrying around an unnecessary UID field.\n\nThe wrapper object is then sent to the service operator, with the address specified in the call as service.\n\nThe function interface for the function that the service operator can call to perform a swap between two objects sent from two addresses resembles:\n\npublic fun execute_swap(s1: SwapRequest, s2: SwapRequest): Balance<SUI>;\n\n\nWhere s1 and s2 are two wrapped objects that were sent from different object owners to the service operator. Both wrapped objects are passed by value because they eventually need to be unpacked.\n\nFirst, unpack the two object to obtain the inner fields:\n\nlet SwapRequest {id: id1, owner: owner1, object: o1, fee: fee1} = s1;\nlet SwapRequest {id: id2, owner: owner2, object: o2, fee: fee2} = s2;\n\n\nThen, check that the swap is legitimate (the two objects have identical scarcity and different styles):\n\nassert!(o1.scarcity == o2.scarcity, EBadSwap);\nassert!(o1.style != o2.style, EBadSwap);\n\n\nTo perform the actual swap:\n\ntransfer::transfer(o1, owner2);\ntransfer::transfer(o2, owner1);\n\n\nThe preceding code sends o1 to the original owner of o2, and sends o2 to the original owner of o1. The service can then delete the wrapping SwapRequest objects:\n\nobject::delete(id1);\nobject::delete(id2);\n\n\nFinally, the service merges together the fee1 and fee2, and returns it. The service provider can then turn it into a coin, or merge it into some larger pool where it collects all fees:\n\nbalance::join(&mut fee1, fee2);\nfee1\n\n\nAfter this call, the two objects are swapped and the service provider takes the service fee.\n\nSince the contract defined only one way to deal with SwapRequest - execute_swap - there is no other way the service operator can interact with SwapRequest despite its ownership.\n\nFind the full source code in the trusted_swap example.\n\nTo view a more complex example of how to use direct wrapping, see the escrow example.\n\nWrapping through Option​\n\nWhen Sui object type Bar is directly wrapped into Foo, there is not much flexibility: a Foo object must have a Bar object in it, and to take out the Bar object you must destroy the Foo object. However, for more flexibility, the wrapping type might not always have the wrapped object in it, and the wrapped object might be replaced with a different object at some point.\n\nTo demonstrate this use case, design a simple game character: A warrior with a sword and shield. A warrior might have a sword and shield, or might not have either. The warrior should be able to add a sword and shield, and replace the current ones at any time. To design this, define a SimpleWarrior type:\n\nstruct SimpleWarrior has key {\n    id: UID,\n    sword: Option<Sword>,\n    shield: Option<Shield>,\n}\n\n\nEach SimpleWarrior type has an optional sword and shield wrapped in it, defined as:\n\nstruct Sword has key, store {\n    id: UID,\n    strength: u8,\n}\n\nstruct Shield has key, store {\n    id: UID,\n    armor: u8,\n}\n\n\nWhen you create a new warrior, set the sword and shield to none to indicate there is no equipment yet:\n\npublic fun create_warrior(ctx: &mut TxContext) {\n    let warrior = SimpleWarrior {\n        id: object::new(ctx),\n        sword: option::none(),\n        shield: option::none(),\n    };\n    transfer::transfer(warrior, tx_context::sender(ctx))\n}\n\n\nYou can then define functions to equip new swords or new shields:\n\npublic fun equip_sword(warrior: &mut SimpleWarrior, sword: Sword, ctx: &mut TxContext) {\n    if (option::is_some(&warrior.sword)) {\n        let old_sword = option::extract(&mut warrior.sword);\n        transfer::transfer(old_sword, tx_context::sender(ctx));\n    };\n    option::fill(&mut warrior.sword, sword);\n}\n\n\nThe function in the preceding example passes a warrior as a mutable reference of SimpleWarrior, and passes a sword by value to wrap it into the warrior.\n\nNote that because Sword is a Sui object type without drop ability, if the warrior already has a sword equipped, the warrior can't drop that sword. If you call option::fill without first checking and taking out the existing sword, an error occurs. In equip_sword, first check whether there is already a sword equipped. If so, remove it out and send it back to the sender. To a player, this returns an equipped sword to their inventory when they equip the new sword.\n\nFind the source code in the simple_warrior example.\n\nTo view a more complex example, see hero.\n\nWrapping through vector​\n\nThe concept of wrapping objects in a vector field of another Sui object is very similar to wrapping through Option: an object can contain 0, 1, or many of the wrapped objects of the same type.\n\nWrapping through vector resembles:\n\nstruct Pet has key, store {\n    id: UID,\n    cuteness: u64,\n}\n\nstruct Farm has key {\n    id: UID,\n    pets: vector<Pet>,\n}\n\n\nThe preceding example wraps a vector of Pet in Farm, and can be accessed only through the Farm object.\n\nEdit this page\nPrevious\nShared Objects\nNext\nDynamic (Object) Fields\nDirect wrapping\nWrapping through Option\nWrapping through vector\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Table and Bag | Sui Documentation",
      "url": "https://docs.sui.io/concepts/dynamic-fields/tables-bags",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nObject Ownership\nDynamic Fields\nTable and Bag\nTransfers\nEvents\nObject and Package Versioning\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersObject ModelDynamic FieldsTable and Bag\nTable and Bag\n\nYou can extend existing objects using dynamic fields. Note that it's possible to delete an object that still has (potentially non-drop) dynamic fields. This might not be a concern when adding a small number of statically known additional fields to an object, but is particularly undesirable for on-chain collection types that could be holding unboundedly many key-value pairs as dynamic fields.\n\nThis topic describes two such collections -- Table and Bag -- built using dynamic fields, but with additional support to count the number of entries they contain, and protect against accidental deletion when non-empty.\n\nThe types and function discussed in this section are built into the Sui framework in modules table and bag. As with dynamic fields, there is also an object_ variant of both: ObjectTable in object_table and ObjectBag in object_bag. The relationship between Table and ObjectTable, and Bag and ObjectBag are the same as between a field and an object field: The former can hold any store type as a value, but objects stored as values are hidden when viewed from external storage. The latter can only store objects as values, but keeps those objects visible at their ID in external storage.\n\nTables​\nmodule sui::table {\n\nstruct Table<K: copy + drop + store, V: store> has key, store { /* ... */ }\n\npublic fun new<K: copy + drop + store, V: store>(\n    ctx: &mut TxContext,\n): Table<K, V>;\n\n}\n\n\nTable<K, V> is a homogeneous map, meaning that all its keys have the same type as each other (K), and all its values have the same type as each other as well (V). It is created with sui::table::new, which requires access to a &mut TxContext because Tables are objects themselves, which can be transferred, shared, wrapped, or unwrapped, just like any other object.\n\nSee sui::object_table::ObjectTable for the object-preserving version of Table.\n\nBags​\nmodule sui::bag {\n\nstruct Bag has key, store { /* ... */ }\n\npublic fun new(ctx: &mut TxContext): Bag;\n\n}\n\n\nBag is a heterogeneous map, so it can hold key-value pairs of arbitrary types (they don't need to match each other). Note that the Bag type does not have any type parameters for this reason. Like Table, Bag is also an object, so creating one with sui::bag::new requires supplying a &mut TxContext to generate an ID.\n\nSee sui::bag::ObjectBag for the object-preserving version of Bag.\n\nThe following sections explain the collection APIs. They use sui::table as the basis for code examples, with explanations where other modules differ.\n\nInteracting with collections​\n\nAll collection types come with the following functions, defined in their respective modules:\n\nmodule sui::table {\n\npublic fun add<K: copy + drop + store, V: store>(\n    table: &mut Table<K, V>,\n    k: K,\n    v: V,\n);\n\npublic fun borrow<K: copy + drop + store, V: store>(\n    table: &Table<K, V>,\n    k: K\n): &V;\n\npublic fun borrow_mut<K: copy + drop + store, V: store>(\n    table: &mut Table<K, V>,\n    k: K\n): &mut V;\n\npublic fun remove<K: copy + drop + store, V: store>(\n    table: &mut Table<K, V>,\n    k: K,\n): V;\n\n}\n\n\nThese functions add, read, write, and remove entries from the collection, respectively, and all accept keys by value. Table has type parameters for K and V so it is not possible to call these functions with different instantiations of K and V on the same instance of Table, however Bag does not have these type parameters, and so does permit calls with different instantiations on the same instance.\n\nINFO\n\nLike with dynamic fields, it is an error to attempt to overwrite an existing key, or access or remove a non-existent key.\n\nThe extra flexibility of Bag's heterogeneity means the type system doesn't statically prevent attempts to add a value with one type, and then borrow or remove it at another type. This pattern fails at runtime, similar to the behavior for dynamic fields.\n\nQuerying length​\n\nIt is possible to query all collection types for their length and check whether they are empty using the following family of functions:\n\nmodule sui::table {\n\npublic fun length<K: copy + drop + store, V: store>(\n    table: &Table<K, V>,\n): u64;\n\npublic fun is_empty<K: copy + drop + store, V: store>(\n    table: &Table<K, V>\n): bool;\n\n}\n\n\nBag has these functions, but they are not generic on K and V because Bag does not have these type parameters.\n\nQuerying for containment​\n\nTables can be queried for key containment with:\n\nmodule sui::table {\n\npublic fun contains<K: copy + drop + store, V: store>(\n    table: &Table<K, V>\n    k: K\n): bool;\n\n}\n\n\nThe equivalent functions for Bag are:\n\nmodule sui::bag {\n\npublic fun contains<K: copy + drop + store>(bag: &Bag, k: K): bool;\n\npublic fun contains_with_type<K: copy + drop + store, V: store>(\n    bag: &Bag,\n    k: K\n): bool;\n\n}\n\n\nThe first function tests whether bag contains a key-value pair with key k: K, and the second function additionally tests whether its value has type V.\n\nClean-up​\n\nCollection types protect against accidental deletion when they might not be empty. This protection comes from the fact that they do not have drop, so must be explicitly deleted, using this API:\n\nmodule sui::table {\n\npublic fun destroy_empty<K: copy + drop + store, V: store>(\n    table: Table<K, V>,\n);\n\n}\n\n\nThis function takes the collection by value. If it contains no entries, it is deleted, otherwise the call fails. sui::table::Table also has a convenience function:\n\nmodule sui::table {\n\npublic fun drop<K: copy + drop + store, V: drop + store>(\n    table: Table<K, V>,\n);\n\n}\n\n\nYou can call the convenience function only for tables where the value type also has drop ability, which allows it to delete tables whether they are empty or not.\n\nNote that drop is not called implicitly on eligible tables before they go out of scope. It must be called explicitly, but it is guaranteed to succeed at runtime.\n\nBag and ObjectBag cannot support drop because they could be holding a variety of types, some of which may have drop and some which may not.\n\nObjectTable does not support drop because its values must be objects, which cannot be dropped (because they must contain an id: UID field and UID does not have drop).\n\nEquality​\n\nEquality on collections is based on identity, for example, an instance of a collection type is only considered equal to itself and not to all collections that hold the same entries:\n\nlet t1 = sui::table::new<u64, u64>(ctx);\nlet t2 = sui::table::new<u64, u64>(ctx);\n\nassert!(&t1 == &t1, 0);\nassert!(&t1 != &t2, 1);\n\n\nThis is unlikely to be the definition of equality that you want.\n\nEdit this page\nPrevious\nDynamic (Object) Fields\nNext\nTransfers\nTables\nBags\nInteracting with collections\nQuerying length\nQuerying for containment\nClean-up\nEquality\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Keys and Addresses | Sui Documentation",
      "url": "https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nTransaction Authentication\nKeys and Addresses\nSignatures\nMultisig\nOffline Signing\nIntent Signing\nzkLogin\nCheckpoint Verification\nSui Architecture\nTokenomics\nResearch Papers\nCryptographyTransaction AuthenticationKeys and Addresses\nKeys and Addresses\n\nSui adheres to widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 (and its variation, SLIP-0010) and its variation SLIP-0010, BIP-44, and BIP-39, to facilitate key management for users. At present, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig for signed transactions.\n\nFollow the relevant link for more information on each wallet specification:\n\nBIP-32\nBIP-39\nBIP-44\nSLIP-0010\nKey derivation scheme​\n\nSui follows SLIP-0010 for managing wallets that support the Ed25519 (EdDSA) signing scheme.\n\nFor managing wallets that support the Ed25519 (EdDSA) signing scheme, Sui follows SLIP-0010, which enforces wallets to always derive child private keys from parent private keys using the hardened key path.\n\nSui follows BIP-32 for managing wallets that support the ECDSA Secp256k1 and ECDSA Secp256r1 signing scheme.\n\nBIP-32 defines the hierarchical deterministic wallet structure to logically associate a set of keys. Grouping keys in this manner reduces the overhead of keeping track of a large number of private keys for a user. This method also lets custodians issue distinct managed addresses for each user account under one source of control. Using BIP-32 decouples the private key derivation from the public key derivation, enabling the watch-only wallet use case, where a chain of public keys and its addresses can be derived, while the private key can be kept offline for signing.\n\nKey derivation path​\n\nBIP-44 further defines the five levels of the derivation path with their exact meanings: m / purpose' / coin_type' / account' / change / address_index. In this structure, the slashes indicate new levels, or children, in the hierarchy.\n\nThe purpose level is generally set to 44, corresponding to the BIP number. In Sui, however, the purpose level distinguishes different signing schemes: 44 is set for Ed25519, 54 for ECDSA Secp256k1 and 74 for Secp256r1. While it is non-standard to set the purpose level to a value that is not 44, it is common to use the purpose field to distinguish different signing schemes. BIP-49 and BIP-84, for example, are used to identify script types in Bitcoin. Sui chose 54 to indicate ECDSA Secp256k1 because there is no existing BIP under 54, avoiding confusion with any Bitcoin standard.\n\nThe coin_type value is managed with a repository of all other cryptocurrencies. Both signature schemes use Sui's registered coin_type, 784 (SUI on a telephone keypad).\n\nThe account level is usually used for logically separating user accounts and creating specific account categories.\n\nIt is generally accepted that, while account-based currencies define only the first three levels, UTXO-based currencies add change and address level definitions. Because Sui's object-oriented data model is neither UTXO nor account-based (it in fact combines both), it employs all five levels for maximum compatibility.\n\nScheme\tPath\tComments\nEd25519\tm/44'/784'/{account}'/{change}'/{address}'\tEach level of the derivation path is hardened.\nECDSA Secp256k1\tm/54'/784'/{account}'/{change}/{address}\tThe first three levels are hardened.\nECDSA Secp256r1\tm/74'/784'/{account}'/{change}/{address}\tThe first three levels are hardened.\nMnemonics support​\n\nAfter Sui defines the deterministic way to derive the master key from a seed, BIP-39 is introduced to make the seed more human-readable and memorizable using mnemonics. Sui accepts 12, 15, 18, 21, and 24 words from the BIP-39 word list that is properly checksummed, corresponding to 128, 160, 192, 224, and 256 bits of entropy. Sui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.\n\nAddress format​\n\nFor deriving a 32-byte Sui address, Sui hashes the signature scheme flag 1-byte concatenated with public key bytes using the BLAKE2b (256 bits output) hashing function. Sui address currently supports pure Ed25519, Secp256k1, Secp256r1, and MultiSig with corresponding flag bytes of 0x00, 0x01, 0x02, and 0x03, respectively.\n\nExample​\n\nSui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.\n\nTypeScript\nCLI\nconst keypair = Ed25519Keypair.deriveKeypair(TEST_MNEMONIC, `m/44'/784'/0'/0'/0'`);\nconst address = keypair.getPublicKey().toSuiAddress();\n\n\nSee more test vectors for pure Ed25519 or ECDSA Secp256k1.\n\nEdit this page\nPrevious\nTransaction Authentication\nNext\nSignatures\nKey derivation scheme\nKey derivation path\nMnemonics support\nAddress format\nExample\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-api/sui-graphql/reference/queries/owner",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nPage Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.\n\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Migrating to GraphQL | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/advanced/graphql-migration",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nMigrating to GraphQL\nMigrating to Move 2024\nAsset Tokenization\nCustom Indexer\nOn-Chain Randomness\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesAdvanced TopicsMigrating to GraphQL\nMigrating to GraphQL\n\nThis guide compares JSON-RPC queries to their equivalent GraphQL counterpart. While it is possible to systematically rewrite JSON-RPC queries (for example, sui_getTotalTransactionBlocks) to their GraphQL counterparts using this guide, it is recommended that you revisit your application's query patterns to take full advantage of the flexibility that GraphQL offers in serving queries that touch multiple potentially nested endpoints (for example transactions, balances, coins), and use the following examples to get a flavor of how the two APIs express similar concepts.\n\nFor a comprehensive list of all available GraphQL features, consult the reference.\n\nExample 1: Get total transaction blocks​\n\nThe goal is to get the total number of transaction blocks in the network.\n\nJSON-RPC\nGraphQL\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getTotalTransactionBlocks\",\n  \"params\": []\n}\n\nExample 2: Get a specific transaction block​\n\nThe goal is to get the transaction block by its digest.\n\nJSON-RPC\nGraphQL\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getTransactionBlock\",\n  \"params\": [\n    \"Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF\",\n    {\n      \"showInput\": true,\n      \"showRawInput\": false,\n      \"showEffects\": true,\n      \"showEvents\": true,\n      \"showObjectChanges\": false,\n      \"showBalanceChanges\": false\n    }\n  ]\n}\n\nExample 3: Get coin objects owned by an address​\n\nThe goal is to return all Coin<0x2::sui::SUI> objects an address owns.\n\nJSON-RPC\nGraphQL\nquery {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getCoins\",\n  \"params\": [\n    \"0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9\", //owner\n    \"0x2::sui::SUI\",                                                      //coin type\n    \"0xe5c651321915b06c81838c2e370109b554a448a78d3a56220f798398dde66eab\", //cursor\n    3 //limit\n  ]\n}\n\nRelated links​\nGraphQL reference: Auto-generated GraphQL reference for Sui RPC.\nGraphQL quick-start: Querying Sui RPC with GraphQL gets you started using GraphQL to query the Sui RPC for on-chain data.\nGraphQL concepts: GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.\nEdit this page\nPrevious\nAdvanced Topics\nNext\nMigrating to Move 2024\nExample 1: Get total transaction blocks\nExample 2: Get a specific transaction block\nExample 3: Get coin objects owned by an address\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Environment Setup | Sui Documentation",
      "url": "https://docs.sui.io/references/contribute/sui-environment",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui Environment Setup\nDocs Contribution\nContribute to Sui Repositories\nSubmit a SIP\nLocalize Sui Documentation\nCode of Conduct\nStyle Guide\nContributeSui Environment Setup\nSui Environment Setup\n\nBefore you start developing with Sui and Move, you should familiarize yourself with how to contribute to Sui, how Sui is structured, what tools and SDKs exist, and what plugins are available to use in your IDE.\n\nFork the Sui repository​\n\nThe recommended way to contribute to the Sui repository is to fork the project, make changes on your fork, then submit a pull request (PR). The Sui repository is available on GitHub: https://github.com/MystenLabs/sui.\n\nTo create a local Sui repository:\n\nGo to the Sui repository on GitHub.\n\nClick the Fork button to create a copy of the repository in your account.\n\nIn your forked repository on GitHub, click the green Code <> button and copy the HTTPS URL GitHub provides.\n\nOpen a terminal or console on your system at the location you want to save the repository locally. Type git clone and paste the URL you copied in the previous step and press Enter.\n\nType cd sui to make sui the active directory.\n\nYou can use any branching strategy you prefer on your Sui fork. Make your changes locally and push to your repository, submitting PRs to the official Sui repository from your fork as needed.\n\nTIP\n\nBe sure to synchronize your fork frequently to keep it up-to-date with active development.\n\nSui repository and how to contribute​\n\nThe Sui repo is a monorepo, containing all the source code that is used to build and run the Sui network, as well as this documentation.\n\nThe root folder of the Sui monorepo has the following top-level folders:\n\napps: Contains the source code for the main web applications that Mysten Labs runs, Sui Wallet.\ncrates: Contains all the Rust crates that are part of the Sui system.\ndapps: Contains some examples of decentralized applications built on top of Sui, such as Kiosk or Sponsored Transactions.\ndashboards: Currently empty.\ndoc: Contains deprecated documentation related to Move and Sui.\ndocker: Contains the docker files needed to spin up a node, an indexer, a Full node or other services.\ndocs: Contains this documentation and the source for this site.\nexamples: Contains examples of apps written for Sui and smart contracts written in Move.\nexternal-crates: Contains the source code for the Move programming language.\nkiosk: Contains the source code of the Mysten Labs Kiosk extensions and rules, as well as examples.\nnarwhal: Contains the source code of Narwhal and partially synchronous Bullshark, a DAG-based mempool, and efficient BFT consensus.\nnre: Contains information about node and network reliability engineering.\nscripts: Contains a number of scripts that are used internally.\nsdk: Contains the source code for different tools and SDKs, such as the Sui TypeScript SDK, Kiosk SDK, BCS, zkLogin, dApp kit, and others.\nsui-execution: Contains the source code responsible for abstracting access to the execution layer.\n\nThe following primary directories offer a good starting point for exploring the Sui codebase:\n\nmove - Move VM, compiler, and tools.\nnarwhal - Mempool and consensus.\ntypescript-sdk - the Sui TypeScript SDK.\nwallet - Chrome extension wallet for Sui.\nsui - the Sui command line tool.\nsui-core - Core Sui components.\nsui-execution - Execution Layer (programmable transactions, execution integration).\nsui-framework - Move system packages (0x1, 0x2, 0x3, 0xdee9).\nsui-network - Networking interfaces.\nsui-node - Validator and Full node software.\nsui-protocol-config - On-chain system configuration and limits.\nsui-sdk - The Sui Rust SDK.\nsui-types - Sui object types, such as coins and gas.\nDevelopment branches​\n\nThe Sui repository includes four primary branches: devnet, testnet, mainnet, and main.\n\nThe devnet branch includes the latest stable build of Sui. Choose the devnet branch if you want to build or test on Sui Devnet. If you encounter an issue or find a bug, it may already be fixed in the main branch. To submit a PR, you should push commits to your fork of the main branch.\n\nThe testnet branch includes the code running on the Sui Testnet network.\n\nThe mainnet branch includes the code running on the Sui Mainnet network.\n\nThe main branch includes the most recent changes and updates. Use the main branch if you want to contribute to the Sui project or to experiment with cutting-edge functionality. The main branch might include unreleased changes and experimental features, so use it at your own risk.\n\nEdit this page\nPrevious\nDocs Contribution\nNext\nDocs Contribution\nFork the Sui repository\nSui repository and how to contribute\nDevelopment branches\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-api/json-rpc-format",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nJSON-RPC API Format\n\nSuiJSON is a JSON-based format with restrictions that allow Sui to align JSON inputs more closely with Move call arguments.\n\nThis table shows the restrictions placed on JSON types to make them SuiJSON compatible:\n\nJSON\tSuiJSON Restrictions\tMove Type Mapping\nNumber\tMust be unsigned integer\tu8, u6, u32, u64 (encoded as String), u128 (encoded as String), u256 (encoded as String)\nString\tNo restrictions\tVector<u8>, Address, ObjectID, TypeTag, Identifier, Unsigned integer (256 bit max)\nBoolean\tNo restrictions\tBool\nArray\tMust be homogeneous JSON and of SuiJSON type\tVector\nNull\tNot allowed\tN/A\nObject\tNot allowed\tN/A\nType coercion reasoning​\n\nDue to the loosely typed nature of JSON/SuiJSON and the strongly typed nature of Move types, you sometimes need to overload SuiJSON types to represent multiple Move types.\n\nFor example SuiJSON::Number can represent both u8 and u32. This means you have to coerce and sometimes convert types.\n\nWhich type you coerce depends on the expected Move type. For example, if the Move function expects a u8, you must have received a SuiJSON::Number with a value less than 256. More importantly, you have no way to easily express Move addresses in JSON, so you encode them as hex strings prefixed by 0x.\n\nAdditionally, Move supports u128 and u256 but JSON doesn't. As a result Sui allows encoding numbers as strings.\n\nType coercion rules​\nMove Type\tSuiJSON Representations\tValid Examples\tInvalid Examples\nBool\tBool\ttrue, false\t\nu8\tSupports 3 formats: Unsigned number < 256. Decimal string with value < 256. One byte hex string prefixed with 0x.\t7 \"70\" \"0x43\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 300: U8 must be less than 256 \" 9\": Spaces not allowed in string \"9A\": Hex num must be prefixed with 0x \"0x09CD\": Too large for U8\nu16\tThree formats are supported Unsigned number < 65536. Decimal string with value < 65536. Two byte hex string prefixed with 0x.\t712 \"570\" \"0x423\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 98342300: U16 must be less than 65536 \" 19\": Spaces not allowed in string \"9EA\": Hex num must be prefixed with 0x \"0x049C1D\": Too large for U16\nu32\tThree formats are supported Unsigned number < 4294967296. Decimal string with value < 4294967296. One byte hex string prefixed with 0x.\t9823247 \"987120\" \"0x4BADE93\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 123456789123456: U32 must be less than 4294967296 \" 9\": Spaces not allowed in string \"9A\": Hex num must be prefixed with 0x \"0x3FF1FF9FFDEFF\": Too large for U32\nu64\tSupports two formats Decimal string with value < U64::MAX. Up to 8 byte hex string prefixed with 0x.\t\"747944370\" \"0x2B1A39A15E\"\t123434: Although this is a valid U64 number, it must be encoded as a string\nu128\tTwo formats are supported Decimal string with value < U128::MAX. Up to 16 byte hex string prefixed with 0x.\t\"74794734937420002470\" \"0x2B1A39A1514E1D8A7CE\"\t34: Although this is a valid U128 number, it must be encoded as a string\nu256\tTwo formats are supported Decimal string with value < U256::MAX. Up to 32 byte hex string prefixed with 0x.\t\"747947349374200024707479473493742000247\" \"0x2B1762FECADA39753FCAB2A1514E1D8A7CE\"\t123434: Although this is a valid U256 number, it must be encoded as a string 0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de\nAddress\t32 byte hex string prefixed with 0x\t\"0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de\"\t0xbc33: string too short bc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de: missing 0x prefix 0xG2B1A39A1514E1D8A7CE45919CFEB4FEE70B4E01: invalid hex char G\nObjectID\t32 byte hex string prefixed with 0x\t\"0x1b879f00b03357c95a908b7fb568712f5be862c5cb0a5894f62d06e9098de6dc\"\tSimilar to above\nIdentifier\tTypically used for module and function names. Encoded as one of the following: A String whose first character is a letter and the remaining characters are letters, digits or underscore. A String whose first character is an underscore, and there is at least one further letter, digit or underscore\t\"function\", \"_function\", \"some_name\", \"____some_name\", \"Another\"\t\"_\": missing trailing underscore, digit or letter, \"8name\": cannot start with digit, \".function\": cannot start with period, \" \": cannot be empty space, \"func name\": cannot have spaces\nVector<Move Type>\tHomogeneous vector of aforementioned types including nested vectors of primitive types (only \"flat\" vectors of ObjectIDs are allowed)\t[1,2,3,4]: simple U8 vector [[3,600],[],[0,7,4]]: nested U32 vector [\"0x2B1A39A1514E1D8A7CE45919CFEB4FEE\", \"0x2B1A39A1514E1D8A7CE45919CFEB4FEF\"]: ObjectID vector\t[1,2,3,false]: not homogeneous JSON [1,2,null,4]: invalid elements [1,2,\"7\"]: although Sui allows encoding numbers as strings meaning this array can evaluate to [1,2,7], the array is still ambiguous so it fails the homogeneity check.\nVector<u8>\tFor convenience, Sui allows: U8 vectors represented as UTF-8 (and ASCII) strings.\t\"√®ˆbo72 √∂†∆˚–œ∑π2ie\": UTF-8 \"abcdE738-2 _=?\": ASCII\t\nEdit this page\nType coercion reasoning\nType coercion rules\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Debugging | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app/debug",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dAppDebugging\nDebugging\n\nMove does not currently have a native debugger. You can use the std::debug module, however, to print arbitrary values to the console. Monitoring variable values in this manner can provide insight into the logic of your modules. To do so, first declare an alias to the debug module in your source file for more concise access:\n\nuse std::debug;\n\n\nThen in places where you want to print out a value v, regardless of its type, add the following code:\n\ndebug::print(&v);\n\n\nor the following if v is already a reference:\n\ndebug::print(v);\n\n\nThe debug module also provides a function to print out the current stacktrace:\n\ndebug::print_stack_trace();\n\n\nAlternatively, any call to abort or assertion failure also prints the stacktrace at the point of failure.\n\nUsing debug in my_module​\n\nTo see the module in action, update your my_module code to include debug calls. Specifically, update the new_sword function so that you print the value of forge before and after updating swords_created. Also, include a print_stack_trace so that the function looks like the following:\n\npublic fun new_sword(\n    forge: &mut Forge,\n    magic: u64,\n    strength: u64,\n    ctx: &mut TxContext,\n): Sword {\n    debug::print(forge);\n    forge.swords_created = forge.swords_created + 1;\n    debug::print(forge);\n    debug::print_stack_trace();\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n\n\nTo see the results, run the module's tests.\n\n$ sui move test\n\n\nThe response prints out the expected results as the test calls the new_sword function.\n\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING my_first_package\nRunning Move unit tests\n[ PASS    ] 0x0::my_module::test_module_init\n[debug] 0x0::my_module::Forge {\n  id: 0x2::object::UID {\n    id: 0x2::object::ID {\n      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96\n    }\n  },\n  swords_created: 0\n}\n[debug] 0x0::my_module::Forge {\n  id: 0x2::object::UID {\n    id: 0x2::object::ID {\n      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96\n    }\n  },\n  swords_created: 1\n}\nCall Stack:\n    [0] 0000000000000000000000000000000000000000000000000000000000000000::my_module::test_module_init\n\n        Code:\n            [35] LdU64(7)\n            [36] MutBorrowLoc(3)\n            [37] Call(15)\n          > [38] Call(5)\n            [39] LdConst(0)\n            [40] CallGeneric(2)\n            [41] ImmBorrowLoc(3)\n\n        Locals:\n            [0] -\n            [1] { { { <OBJECT-ID-WITHOUT-0x> } }, 1 }\n            [2] -\n            [3] { 2, { 00000000000000000000000000000000000000000000000000000000000000ad, [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0, 0 } }\n\n\nOperand Stack:\n\n[ PASS    ] 0x0::my_module::test_sword_transactions\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\n\nThe output shows the value of the swords_created field of the Forge change after the increment. The stack trace shows the bytecode instructions that have been executed so far, and the next few instructions to execute.\n\nINFO\n\nThe specific bytecode offsets and the indices of the local variables might vary depending on the version of the Sui toolchain.\n\nRelated links​\nPublish a Package: Publish the example to the Sui network.\nEdit this page\nPrevious\nPublish a Package\nNext\nClient App with Sui TypeScript SDK\nUsing debug in my_module\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Write a Move Package | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app/write-package",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dAppWrite a Move Package\nWrite a Move Package\n\nTo begin, open a terminal or console at the location you plan to store your package. Use the sui move new command to create an empty Move package with the name my_first_package:\n\n$ sui move new my_first_package\n\n\nRunning the previous command creates a directory with the name you provide (my_first_package in this case). The command populates the new directory with a skeleton Move project that consists of a sources directory and a Move.toml manifest file. Open the manifest with a text editor to review its contents:\n\nmy_first_package/Move.toml\n[package]\nname = \"my_first_package\"\nedition = \"2024.beta\" # edition = \"legacy\" to use legacy (pre-2024) Move\n# license = \"\"           # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\n# authors = [\"...\"]      # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision can be a branch, a tag, and a commit hash.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n\n# To resolve a version conflict and force a specific version for dependency\n# override use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n\n[addresses]\nmy_first_package = \"0x0\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies]\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n\n[dev-addresses]\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n# alice = \"0xB0B\"\n\n\nThe manifest file contents include available sections of the manifest and comments that provide additional information. In Move, you prepend the hash mark (#) to a line to denote a comment.\n\n[package]: Contains metadata for the package. By default, the sui move new command populates only the name value of the metadata. In this case, the example passes my_first_package to the command, which becomes the name of the package. You can delete the first # of subsequent lines of the [package] section to provide values for the other available metadata fields.\n[dependencies]: Lists the other packages that your package depends on to run. By default, the sui move new command lists the Sui package on GitHub (Testnet version) as the lone dependency.\n[addresses]: Declares named addresses that your package uses. By default, the section includes the package you create with the sui move new command and an address of 0x0. The publish process replaces the 0x0 address with an actual on-chain address.\n[dev-dependencies]: Includes only comments that describe the section.\n[dev-addresses]: Includes only comments that describe the section.\nDefining the package​\n\nYou have a package now but it doesn't do anything. To make your package useful, you must add logic contained in .move source files that define modules. Use a text editor or the command line to create your first package source file named my_module.move in the sources directory of the package:\n\n$ touch my_first_package/sources/my_module.move\n\n\nPopulate the my_module.move file with the following code:\n\nmodule my_first_package::my_module {\n\n    // Part 1: These imports are provided by default\n    // use sui::object::{Self, UID};\n    // use sui::transfer;\n    // use sui::tx_context::{Self, TxContext};\n\n    // Part 2: struct definitions\n    public struct Sword has key, store {\n        id: UID,\n        magic: u64,\n        strength: u64,\n    }\n\n    public struct Forge has key {\n        id: UID,\n        swords_created: u64,\n    }\n\n    // Part 3: Module initializer to be executed when this module is published\n    fun init(ctx: &mut TxContext) {\n        let admin = Forge {\n            id: object::new(ctx),\n            swords_created: 0,\n        };\n        // Transfer the forge object to the module/package publisher\n        transfer::transfer(admin, ctx.sender());\n    }\n\n    // Part 4: Accessors required to read the struct fields\n    public fun magic(self: &Sword): u64 {\n        self.magic\n    }\n\n    public fun strength(self: &Sword): u64 {\n        self.strength\n    }\n\n    public fun swords_created(self: &Forge): u64 {\n        self.swords_created\n    }\n\n    // Part 5: Public/entry functions (introduced later in the tutorial)\n\n    // Part 6: Tests\n\n}\n\n\nThe comments in the preceding code highlight different parts of a typical Move source file.\n\nPart 1: Imports - Code reuse is a necessity in modern programming. Move supports this concept with use aliases that allow your module to refer to types and functions declared in other modules. In this example, the module imports from object, transfer, and tx_context modules, but it does not need to do so explicitly, because the compiler provides these use statements by default. These modules are available to the package because the Move.toml file defines the Sui dependency (along with the sui named address) where they are defined.\n\nPart 2: Struct declarations - Structs define types that a module can create or destroy. Struct definitions can include abilities provided with the has keyword. The structs in this example, for instance, have the key ability, which indicates that these structs are Sui objects that you can transfer between addresses. The store ability on the structs provides the ability to appear in other struct fields and be transferred freely.\n\nPart 3: Module initializer - A special function that is invoked exactly once when the module publishes.\n\nPart 4: Accessor functions - These functions allow the fields of the module's structs to be read from other modules.\n\nAfter you save the file, you have a complete Move package.\n\nRelated links​\nBuild and Test Packages: Continue this example to build and test your package to get it ready for publishing.\nSui Move CLI: Available Move commands the CLI provides.\nEdit this page\nPrevious\nYour First Sui dApp\nNext\nBuild and Test Packages\nDefining the package\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Publish a Package | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app/publish",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dAppPublish a Package\nPublish a Package\n\nBefore you can call functions in a Move package (beyond an emulated Sui execution scenario), that package must be available on the Sui network. When you publish a package, you are actually creating an immutable Sui object on the network that anyone can access.\n\nTo publish your package to the Sui network, use the publish CLI command in the root of your package. Use the --gas-budget flag to set a value for the maximum amount of gas the transaction can cost. If the cost of the transaction is more than the budget you set, the transaction fails and your package doesn't publish.\n\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\n$ sui client publish --gas-budget 5000000\n\n\nIf the publish transaction is successful, your terminal or console responds with the details of the publish transaction separated into sections, including transaction data, transaction effects, transaction block events, object changes, and balance changes.\n\nIn the Object Changes table, you can find the information about the package you just published in the Published Objects section. Your response has the actual PackageID that identifies the package (instead of <PACKAGE-ID>) in the form 0x123...ABC.\n\n╭─────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                      │\n├─────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                    │\n│  ...                                                                │\n|                                                                     |\n│ Mutated Objects:                                                    │\n│  ...                                                                │\n|                                                                     |\n│ Published Objects:                                                  │\n│  ┌──                                                                │\n│  │ PackageID: <PACKAGE-ID>                                          │\n│  │ Version: 1                                                       │\n│  │ Digest: <DIGEST-HASH>                                            │\n│  │ Modules: my_module                                               │\n│  └──                                                                │\n╰─────────────────────────────────────────────────────────────────────╯\n\n\nYour currently active address now has three objects (or more, if you had objects prior to this example). Assuming you are using a new address, running the sui objects command reveals what those objects are.\n\n$ sui client objects\n\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  10                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  <PACKAGE-ID>::my_module::Forge                                      │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  10                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                            │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  10                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  0x0000..0002::package::UpgradeCap                                   │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n\n\nThe objectId field is the unique identifier of each object.\n\nCoin object: You received the Coin object from the Testnet faucet. It's value is slightly less than when you received it because of the cost of gas for the publish transaction.\nForge object: Recall that the init function runs when the package gets published. The init function for this example package creates a Forge object and transfers it to the publisher (you).\nUpgradeCap object: Each package you publish results in the receipt of an UpgradeCap object. You use this object to upgrade the package later or to burn it so the package cannot be upgraded.\nInteract with the package​\n\nNow that the package is on chain, you can call its functions to interact with the package. You can use the sui client call command to make individual calls to package functions, or you can construct more advanced blocks of transactions using the sui client ptb command. The ptb part of the command stands for programmable transaction blocks. In basic terms, PTBs allow you to group commands together in a single transaction for more efficient and cost-effective network activity.\n\nFor example, you can create a new Sword object defined in the package by calling the new_sword function in the my_module package, and then transfer the Sword object to any address:\n\n$ sui client ptb \\\n\t--assign forge @<FORGE-ID> \\\n\t--assign to_address @<TO-ADDRESS> \\\n\t--move-call <PACKAGE-ID>::my_module::new_sword forge 3 3 \\\n\t--assign sword \\\n\t--transfer-objects \"[sword]\" to_address \\\n\t--gas-budget 20000000\n\nINFO\n\nYou can pass literal addresses and objects IDs by prefixing them with '@'. This is needed to distinguish a hexadecimal value from an address in some situations.\n\nFor addresses that are in your local wallet, you can use their alias instead (passing them without '@', for example, --transfer-objects my_alias).\n\nMake sure to replace <FORGE-ID>, <TO-ADDRESS>, and <PACKAGE-ID> with the actual objectId of the Forge object, the address of the recipient (your address in this case), and the packageID of the package, respectively.\n\nAfter the transaction executes, you can check the status of the Sword object by using the sui client objects command again. Provided you used your address as the <TO-ADDRESS>, you should now see a total of four objects:\n\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  11                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  <PACKAGE-ID>::my_module::Forge                                      │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  11                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                            │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  11                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  <PACKAGE-ID>::my_module::Sword                                      │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  <OBJECT-ID>                                                         │ │\n│ │ version    │  10                                                                  │ │\n│ │ digest     │  <DIGEST-HASH>                                                       │ │\n│ │ objectType │  0x0000..0002::package::UpgradeCap                                   │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n\n\nCongratulations! You have successfully published a package to the Sui network and modified the blockchain state by using a programmable transaction block.\n\nRelated links​\nDebugging: Print values to aid in logic debugging.\nPackage Upgrades: Upgrading packages published on the Sui network.\nPublish a Move Package: More details about using the CLI to publish a package.\nProgrammable Transaction Blocks: PTBs are collections of transactions that are executed together.\nSui Client PTB CLI: The client ptb command allows you to specify the transactions for execution in a programmable transaction block directly from your CLI or through bash scripts.\nApp Examples: End-to-end examples that include smart contract logic and frontend code.\nEdit this page\nPrevious\nBuild and Test Packages\nNext\nDebugging\nInteract with the package\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/app-examples/trustless-swap/frontend",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nBlackjack\nCoin Flip\nDistributed Counter\nOracles\nPlinko\nReview Rating\nTic-Tac-Toe\nTrustless Swap\nBackend\nIndexing and API Service\nFrontend\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesApp ExamplesTrustless SwapFrontend\nTrustless Swap Frontend\nMULTI-PAGE GUIDE\n\nThis is the third in a three-part guide on how to build a trustless atomic swap on Sui.\n\nIn this final part of the app example, you build a frontend (UI) that allows end-users to discover trades and interact with listed escrows.\n\nPrerequisites​\nINFO\n\nYou can view the complete source code for this app example in the Sui repository.\n\nBefore getting started, make sure you:\n\nUnderstand the mechanism behind the Escrow smart contract backend.\nCheck out indexing service guide to learn how we index on-chain data and API endpoints exposed to serve data query requests.\nInstall pnpm through this guide as we will use it as our package manager.\nCheck out Sui Typescript SDK for basic usage on how to interact with Sui with Typescript.\nCheck out Sui dApp Kit to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.\nCheck out React Router as we use it to navigate between different routes in our UI website.\ndApp Kit provides a set of hooks for making query and mutation calls to Sui blockchain. These hooks are thin wrappers around query and mutation hooks from @tanstack/react-query. Please check out @tanstack/react-query to learn the basic usage for managing, caching, mutating server state.\nThis project is bootstrapped through pnpm create @mysten/dapp. Please check out @mysten/create-dapp for how to scaffold a React.js Sui dApp project quickly.\nOverview​\n\nThe UI design consists of three parts:\n\nA header containing the button allowing users to connect their wallet and navigate to other pages.\nA place for users to manage their owned objects to be ready for escrow trading called Manage Objects.\nA place for users to discover, create, and execute trades called Escrows.\nWARNING\n\nThe following code snippets are not the full source code. The snippets are meant to focus on relevant logic important to the functionality of the example and features of Sui.\n\nSet up providers​\n\nSet up and configure several providers at the root of your React.js tree to ensure different libraries including dApp Kit, @tanstack/react-query, react-router-dom work as expected.\n\nsrc/main.tsx\nimport { createNetworkConfig, SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';\nimport { getFullnodeUrl } from '@mysten/sui.js/client';\nimport { Theme } from '@radix-ui/themes';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { RouterProvider } from 'react-router-dom';\n\nimport { router } from '@/routes/index.tsx';\n\nconst queryClient = new QueryClient();\n\nconst { networkConfig } = createNetworkConfig({\n\tlocalnet: { url: getFullnodeUrl('localnet') },\n\tdevnet: { url: getFullnodeUrl('devnet') },\n\ttestnet: { url: getFullnodeUrl('testnet') },\n\tmainnet: { url: getFullnodeUrl('mainnet') },\n});\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n\t<React.StrictMode>\n\t\t<Theme appearance=\"light\">\n\t\t\t<QueryClientProvider client={queryClient}>\n\t\t\t\t<SuiClientProvider networks={networkConfig} defaultNetwork=\"testnet\">\n\t\t\t\t\t<WalletProvider autoConnect>\n\t\t\t\t\t\t<RouterProvider router={router} />\n\t\t\t\t\t</WalletProvider>\n\t\t\t\t</SuiClientProvider>\n\t\t\t</QueryClientProvider>\n\t\t</Theme>\n\t</React.StrictMode>,\n);\n\nConnect wallet​\n\nThe dApp Kit comes with a pre-built React.js component called ConnectButton displaying a button to connect and disconnect a wallet. The connecting and disconnecting wallet logic is handled seamlessly so you don't need to worry about repeating yourself doing the same logic all over again.\n\nPlace the ConnectButton in the header:\n\nsrc/components/Header.tsx\nimport { ConnectButton } from '@mysten/dapp-kit';\nimport { Box, Button, Container, Flex, Heading } from '@radix-ui/themes';\n\nexport function Header() {\n\treturn (\n\t\t<Container>\n\t\t\t<Box className=\"connect-wallet-wrapper\">\n\t\t\t\t<ConnectButton />\n\t\t\t</Box>\n\t\t</Container>\n\t);\n}\n\nType definitions​\n\nAll the type definitions are in src/types/types.ts.\n\nApiLockedObject and ApiEscrowObject represent the Locked and Escrow indexed data model the indexing and API service return.\n\nEscrowListingQuery and LockedListingQuery are the query parameters model to provide to the API service to fetch from the endpoints /escrow and /locked accordingly.\n\nsrc/types/types.ts\nexport type ApiLockedObject = {\n\tid?: string;\n\tobjectId: string;\n\tkeyId: string;\n\tcreator?: string;\n\titemId: string;\n\tdeleted: boolean;\n};\n\nexport type ApiEscrowObject = {\n\tid: string;\n\tobjectId: string;\n\tsender: string;\n\trecipient: string;\n\tkeyId: string;\n\titemId: string;\n\tswapped: boolean;\n\tcancelled: boolean;\n};\n\nexport type EscrowListingQuery = {\n\tescrowId?: string;\n\tsender?: string;\n\trecipient?: string;\n\tcancelled?: string;\n\tswapped?: string;\n\tlimit?: string;\n};\n\nexport type LockedListingQuery = {\n\tdeleted?: string;\n\tkeyId?: string;\n\tlimit?: string;\n};\n\nExecute transaction hook​\n\nIn the frontend, you might need to execute a transaction block in multiple places, hence it's better to extract the transaction execution logic and reuse it everywhere. Let's examine the execute transaction hook.\n\nsrc/hooks/useTransactionExecution.ts\nimport { useSignTransactionBlock, useSuiClient } from '@mysten/dapp-kit';\nimport { SuiTransactionBlockResponse } from '@mysten/sui.js/client';\nimport { TransactionBlock } from '@mysten/sui.js/transactions';\nimport toast from 'react-hot-toast';\n\nexport function useTransactionExecution() {\n\tconst client = useSuiClient();\n\tconst { mutateAsync: signTransactionBlock } = useSignTransactionBlock();\n\n\tconst executeTransaction = async (\n\t\ttxb: TransactionBlock,\n\t): Promise<SuiTransactionBlockResponse | void> => {\n\t\ttry {\n\t\t\tconst signature = await signTransactionBlock({\n\t\t\t\ttransactionBlock: txb,\n\t\t\t});\n\n\t\t\tconst res = await client.executeTransactionBlock({\n\t\t\t\ttransactionBlock: signature.transactionBlockBytes,\n\t\t\t\tsignature: signature.signature,\n\t\t\t\toptions: {\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t\tshowObjectChanges: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\ttoast.success('Successfully executed transaction!');\n\t\t\treturn res;\n\t\t} catch (e: any) {\n\t\t\ttoast.error(`Failed to execute transaction: ${e.message as string}`);\n\t\t}\n\t};\n\n\treturn executeTransaction;\n}\n\n\nThe hook logic is straightforward. A TransactionBlock is the input, sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.\n\nUse the useSuiClient() hook from dApp Kit to retrieve the Sui client instance configured in the Set up providers step. The useSignTransactionBlock() function is another hook from dApp kit that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, the executeTransactionBlock() on the Sui client instance of the Sui TypeScript SDK. Use react-hot-toast as another dependency to toast transaction status to users.\n\nGenerate demo data​\nINFO\n\nThe full source code of the demo bear smart contract is available at Trading Contracts Demo directory\n\nYou need a utility function to create a dummy object representing a real world asset so you can use it to test and demonstrate escrow users flow on the UI directly.\n\nsrc/mutations/demo.ts\nimport { useCurrentAccount } from '@mysten/dapp-kit';\nimport { TransactionBlock } from '@mysten/sui.js/transactions';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n\nimport { CONSTANTS } from '@/constants';\nimport { useTransactionExecution } from '@/hooks/useTransactionExecution';\n\n// SPDX-License-Identifier: Apache-2.0\nexport function useGenerateDemoData() {\n\tconst account = useCurrentAccount();\n\tconst executeTransaction = useTransactionExecution();\n\tconst queryClient = useQueryClient();\n\n\treturn useMutation({\n\t\tmutationFn: async () => {\n\t\t\tif (!account?.address) throw new Error('You need to connect your wallet!');\n\t\t\tconst txb = new TransactionBlock();\n\n\t\t\tconst bear = txb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.demoContract.packageId}::demo_bear::new`,\n\t\t\t\targuments: [txb.pure.string(`A happy bear`)],\n\t\t\t});\n\n\t\t\ttxb.transferObjects([bear], txb.pure.address(account.address));\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\t\tonSuccess: () => {\n\t\t\tqueryClient.invalidateQueries({\n\t\t\t\tqueryKey: ['getOwnedObjects'],\n\t\t\t});\n\t\t},\n\t});\n}\n\n\nAs previously mentioned, the example uses @tanstack/react-query to query, cache, and mutate server state. Server state is data only available on remote servers, and the only way to retrieve or update this data is by interacting with these remote servers. In this case, it could be from an API or directly from Sui blockchain RPC.\n\nWhen you execute a transaction call to mutate data on the Sui blockchain, use the useMutation() hook. The useMutation() hook accepts several inputs, however, you only need two of them for this example. The first parameter, mutationFn, accepts the function to execute the main mutating logic, while the second parameter, onSuccess, is a callback that runs when the mutating logic succeeds.\n\nThe main mutating logic is fairly straightforward, executing a Move call of a package named demo_bear::new to create a dummy bear object and transfer it to the connected wallet account, all within the same TransactionBlock. The example reuses the executeTransaction() hook from the Execute Transaction Hook step to execute the transaction.\n\nAnother benefit of wrapping the main mutating logic inside useMutation() is that you can access and manipulate the cache storing server state. The example fetches the cache from remote servers by using query call in an appropriate callback. In this case, it is the onSuccess callback. When the transaction succeeds, invalidate the cache data at the cache key called getOwnedObjects, then @tanstack/react-query handles the re-fetching mechanism for the invalidated data automatically. Do this by using invalidateQueries() on the @tanstack/react-query configured client instance retrieved by useQueryClient() hook in the Setup Providers step.\n\nNow the logic to create a dummy bear object exists. You just need to attach it into the button in the header.\n\nsrc/components/Header.tsx\nimport { useGenerateDemoData } from '@/mutations/demo';\n\nexport function Header() {\n\tconst { mutate: demoBearMutation, isPending } = useGenerateDemoData();\n\treturn (\n\t\t<Container>\n\t\t\t<Box>\n\t\t\t\t<Button\n\t\t\t\t\tclassName=\"cursor-pointer\"\n\t\t\t\t\tdisabled={isPending}\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tdemoBearMutation();\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tNew Demo Bear\n\t\t\t\t</Button>\n\t\t\t</Box>\n\t\t</Container>\n\t);\n}\n\nLock/unlock owned-object mutation​\n\nLocking and unlocking of owned objects are two crucial on-chain actions in this application and are very likely to be used all over. Hence, it's beneficial to extract their logic into separated mutating functions to enhance reusability and encapsulation.\n\nLock owned objects​\n\nTo lock the object, execute the lock Move function identified by {PACKAGE_ID}::lock::lock. The implementation is similar to what's in previous mutation functions, use useMutation() from @tanstack/react-query to wrap the main logic inside it. The lock function requires an object to be locked and its type because our smart contract lock function is generic and requires type parameters. After creating a Locked object and its Key object, transfer them to the connected wallet account within the same transaction block.\n\nsrc/mutations/locked.ts\nexport function useLockObjectMutation() {\n\tconst account = useCurrentAccount();\n\tconst executeTransaction = useTransactionExecution();\n\n\treturn useMutation({\n\t\tmutationFn: async ({ object }: { object: SuiObjectData }) => {\n\t\t\tif (!account?.address) throw new Error('You need to connect your wallet!');\n\t\t\tconst txb = new TransactionBlock();\n\n\t\t\tconst [locked, key] = txb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.escrowContract.packageId}::lock::lock`,\n\t\t\t\targuments: [txb.object(object.objectId)],\n\t\t\t\ttypeArguments: [object.type!],\n\t\t\t});\n\n\t\t\ttxb.transferObjects([locked, key], txb.pure.address(account.address));\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\t});\n}\n\nUnlock owned objects​\n\nTo unlock the object, execute the unlock Move function identified by {PACKAGE_ID}::lock::unlock. The implementation is straightforward, call the unlock function supplying the Locked object, its corresponding Key, the struct type of the original object, and transfer the unlocked object to the current connected wallet account. Also, implement the onSuccess callback to invalidate the cache data at query key locked after one second to force react-query to re-fetch the data at corresponding query key automatically.\n\nsrc/mutations/locked.ts\nexport function useUnlockMutation() {\n\tconst account = useCurrentAccount();\n\tconst executeTransaction = useTransactionExecution();\n\tconst client = useSuiClient();\n\tconst queryClient = useQueryClient();\n\n\treturn useMutation({\n\t\tmutationFn: async ({\n\t\t\tlockedId,\n\t\t\tkeyId,\n\t\t\tsuiObject,\n\t\t}: {\n\t\t\tlockedId: string;\n\t\t\tkeyId: string;\n\t\t\tsuiObject: SuiObjectData;\n\t\t}) => {\n\t\t\tif (!account?.address) throw new Error('You need to connect your wallet!');\n\t\t\tconst key = await client.getObject({\n\t\t\t\tid: keyId,\n\t\t\t\toptions: {\n\t\t\t\t\tshowOwner: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (\n\t\t\t\t!key.data?.owner ||\n\t\t\t\ttypeof key.data.owner === 'string' ||\n\t\t\t\t!('AddressOwner' in key.data.owner) ||\n\t\t\t\tkey.data.owner.AddressOwner !== account.address\n\t\t\t) {\n\t\t\t\ttoast.error('You are not the owner of the key');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst txb = new TransactionBlock();\n\n\t\t\tconst item = txb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.escrowContract.packageId}::lock::unlock`,\n\t\t\t\ttypeArguments: [suiObject.type!],\n\t\t\t\targuments: [txb.object(lockedId), txb.object(keyId)],\n\t\t\t});\n\n\t\t\ttxb.transferObjects([item], txb.pure.address(account.address));\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\t\tonSuccess: () => {\n\t\t\tsetTimeout(() => {\n\t\t\t\t// invalidating the queries after a small latency\n\t\t\t\t// because the indexer works in intervals of 1s.\n\t\t\t\t// if we invalidate too early, we might not get the latest state.\n\t\t\t\tqueryClient.invalidateQueries({\n\t\t\t\t\tqueryKey: [QueryKey.Locked],\n\t\t\t\t});\n\t\t\t}, 1_000);\n\t\t},\n\t});\n}\n\nCreate/accept/cancel escrow mutations​\n\nTo create, accept, or cancel escrows, it's better to implement mutations for each of these actions to allow reusability and encapsulation.\n\nCreate escrows​\n\nTo create escrows, include a mutating function through the useCreateEscrowMutation hook in src/mutations/escrow.ts. The mutation implementation is pretty straightforward. It accepts the escrowed item to be traded and the ApiLockedObject from another party as parameters. Then, call the {PACKAGE_ID}::shared::create Move function and provide the escrowed item, the key id of the locked object to exchange, and the recipient of the escrow (locked object's owner).\n\nsrc/mutations/escrow.ts\nexport function useCreateEscrowMutation() {\n\tconst currentAccount = useCurrentAccount();\n\tconst executeTransaction = useTransactionExecution();\n\n\treturn useMutation({\n\t\tmutationFn: async ({ object, locked }: { object: SuiObjectData; locked: ApiLockedObject }) => {\n\t\t\tif (!currentAccount?.address) throw new Error('You need to connect your wallet!');\n\n\t\t\tconst txb = new TransactionBlock();\n\t\t\ttxb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.escrowContract.packageId}::shared::create`,\n\t\t\t\targuments: [\n\t\t\t\t\ttxb.object(object.objectId!),\n\t\t\t\t\ttxb.pure.id(locked.keyId),\n\t\t\t\t\ttxb.pure.address(locked.creator!),\n\t\t\t\t],\n\t\t\t\ttypeArguments: [object.type!],\n\t\t\t});\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\t});\n}\n\nAccept escrows​\n\nTo accept the escrow, create a mutation through the useAcceptEscrowMutation hook in src/mutations/escrow.ts. The implementation should be fairly familiar to you now. The accept function accepts the escrow ApiEscrowObject and the locked object ApiLockedObject. The {PACKAGE_ID}::shared::swap Move call is generic, thus it requires the type parameters of the escrowed and locked objects. Query the objects details by using multiGetObjects on Sui client instance. Lastly, execute the {PACKAGE_ID}::shared::swap Move call and transfer the returned escrowed item to the connected wallet account. When the mutation succeeds, invalidate the cache to allow automatic re-fetch of the data.\n\nsrc/mutations/escrow.ts\nimport { ApiEscrowObject, ApiLockedObject } from '@/types/types';\n\nexport function useAcceptEscrowMutation() {\n\tconst currentAccount = useCurrentAccount();\n\tconst client = useSuiClient();\n\tconst executeTransaction = useTransactionExecution();\n\tconst queryClient = useQueryClient();\n\n\treturn useMutation({\n\t\tmutationFn: async ({\n\t\t\tescrow,\n\t\t\tlocked,\n\t\t}: {\n\t\t\tescrow: ApiEscrowObject;\n\t\t\tlocked: ApiLockedObject;\n\t\t}) => {\n\t\t\tif (!currentAccount?.address) throw new Error('You need to connect your wallet!');\n\t\t\tconst txb = new TransactionBlock();\n\n\t\t\tconst escrowObject = await client.multiGetObjects({\n\t\t\t\tids: [escrow.itemId, locked.itemId],\n\t\t\t\toptions: {\n\t\t\t\t\tshowType: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst escrowType = escrowObject.find((x) => x.data?.objectId === escrow.itemId)?.data?.type;\n\n\t\t\tconst lockedType = escrowObject.find((x) => x.data?.objectId === locked.itemId)?.data?.type;\n\n\t\t\tif (!escrowType || !lockedType) {\n\t\t\t\tthrow new Error('Failed to fetch types.');\n\t\t\t}\n\n\t\t\tconst item = txb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.escrowContract.packageId}::shared::swap`,\n\t\t\t\targuments: [\n\t\t\t\t\ttxb.object(escrow.objectId),\n\t\t\t\t\ttxb.object(escrow.keyId),\n\t\t\t\t\ttxb.object(locked.objectId),\n\t\t\t\t],\n\t\t\t\ttypeArguments: [escrowType, lockedType],\n\t\t\t});\n\n\t\t\ttxb.transferObjects([item], txb.pure.address(currentAccount.address));\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\n\t\tonSuccess: () => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tqueryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });\n\t\t\t}, 1_000);\n\t\t},\n\t});\n}\n\nCancel escrows​\n\nTo cancel the escrow, create a mutation through the useCancelEscrowMutation hook in src/mutations/escrow.ts. The cancel function accepts the escrow ApiEscrowObject and its on-chain data. The {PACKAGE_ID}::shared::return_to_sender Move call is generic, thus it requires the type parameters of the escrowed object. Next, execute {PACKAGE_ID}::shared::return_to_sender and transfer the returned escrowed object to the creator of the escrow.\n\nsrc/mutations/escrow.ts\nexport function useCancelEscrowMutation() {\n\tconst currentAccount = useCurrentAccount();\n\tconst executeTransaction = useTransactionExecution();\n\tconst queryClient = useQueryClient();\n\n\treturn useMutation({\n\t\tmutationFn: async ({\n\t\t\tescrow,\n\t\t\tsuiObject,\n\t\t}: {\n\t\t\tescrow: ApiEscrowObject;\n\t\t\tsuiObject: SuiObjectData;\n\t\t}) => {\n\t\t\tif (!currentAccount?.address) throw new Error('You need to connect your wallet!');\n\t\t\tconst txb = new TransactionBlock();\n\n\t\t\tconst item = txb.moveCall({\n\t\t\t\ttarget: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,\n\t\t\t\targuments: [txb.object(escrow.objectId)],\n\t\t\t\ttypeArguments: [suiObject?.type!],\n\t\t\t});\n\n\t\t\ttxb.transferObjects([item], txb.pure.address(currentAccount?.address!));\n\n\t\t\treturn executeTransaction(txb);\n\t\t},\n\n\t\tonSuccess: () => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tqueryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });\n\t\t\t}, 1_000);\n\t\t},\n\t});\n}\n\nLocked dashboard​\n\nThe UI has a tab for users to manage their owned objects to be ready for escrow trading. The code of this tab lives in the file src/routes/LockedDashBoard.tsx. In this tab, there are two sub-tabs:\n\nMy Locked Objects tab to list out all of owned Locked objects.\nLock Own Objects tab to lock owned objects.\nMy Locked Objects tab​\n\nLet's take a look at the My Locked Objects tab by examining src/components/locked/OwnedLockedList.tsx. Focus on the logic on how to retrieve this list.\n\nsrc/components/locked/OwnedLockedList.tsx\nimport { useCurrentAccount, useSuiClientInfiniteQuery } from '@mysten/dapp-kit';\n\nimport { InfiniteScrollArea } from '@/components/InfiniteScrollArea';\nimport { CONSTANTS } from '@/constants';\n\nimport { LockedObject } from './LockedObject';\n\n/**\n * Similar to the `ApiLockedList` but fetches the owned locked objects\n * but fetches the objects from the on-chain state, instead of relying on the indexer API.\n */\nexport function OwnedLockedList() {\n\tconst account = useCurrentAccount();\n\tconst { data, isLoading, fetchNextPage, hasNextPage, isFetchingNextPage } =\n\t\tuseSuiClientInfiniteQuery(\n\t\t\t'getOwnedObjects',\n\t\t\t{\n\t\t\t\tfilter: {\n\t\t\t\t\tStructType: CONSTANTS.escrowContract.lockedType,\n\t\t\t\t},\n\t\t\t\towner: account?.address!,\n\t\t\t\toptions: {\n\t\t\t\t\tshowContent: true,\n\t\t\t\t\tshowOwner: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: !!account?.address,\n\t\t\t\tselect: (data) => data.pages.flatMap((page) => page.data),\n\t\t\t},\n\t\t);\n\treturn (\n\t\t<>\n\t\t\t<InfiniteScrollArea\n\t\t\t\tloadMore={() => fetchNextPage()}\n\t\t\t\thasNextPage={hasNextPage}\n\t\t\t\tloading={isFetchingNextPage || isLoading}\n\t\t\t>\n\t\t\t\t{data?.map((item) => <LockedObject key={item.data?.objectId} object={item.data!} />)}\n\t\t\t</InfiniteScrollArea>\n\t\t</>\n\t);\n}\n\n\nFetch the owned Locked objects directly from Sui blockchain using the useSuiClientInfiniteQuery() hook from dApp Kit. This hook is a thin wrapper around Sui blockchain RPC calls, reference the documentation to learn more about these RPC hooks. Basically, supply the RPC endpoint you want to execute, in this case it's the getOwnedObjects endpoint. Supply the connected wallet account and the Locked object struct type to the call. The struct type is usually identified by the format of {PACKAGE_ID}::{{MODULE_NAME}}::{{STRUCT_TYPE}}. The returned data is stored inside the cache at query key getOwnedObjects. Recall the previous section where you invalidate the data at this key after the mutation succeeds, the useSuiClientInfiniteQuery() hook automatically re-fetches the data, thus you don't have to worry about the out-dated data living in your frontend application.\n\nLockedObject and Locked component​\n\nThe <LockedObject /> (src/components/locked/LockedObject.tsx) component is mainly responsible for mapping an on-chain SuiObjectData Locked object to its corresponding ApiLockedObject, which is finally delegated to the <Locked /> component for rendering. The <LockedObject /> fetches the locked item object ID if the prop itemId is not supplied by using dApp Kit useSuiClientQuery() hook to call the getDynamicFieldObject RPC endpoint. Recalling that in this smart contract, the locked item is put into a dynamic object field.\n\nThe <Locked /> (src/components/locked/partials/Locked.tsx) component is mainly responsible for rendering the ApiLockedObject. It also consists of several on-chain interactions: unlock the locked objects and create an escrow out of the locked object.\n\nsrc/components/locked/LockedObject.tsx\n/**\n * Acts as a wrapper between the `Locked` object fetched from API\n * and the on-chain object state.\n *\n * Accepts an `object` of type `::locked::Locked`, fetches the itemID (though the DOF)\n * and then renders the `Locked` component.\n *\n * ItemId is optional because we trust the API to return the correct itemId for each Locked.\n */\nexport function LockedObject({\n\tobject,\n\titemId,\n\thideControls,\n}: {\n\tobject: SuiObjectData;\n\titemId?: string;\n\thideControls?: boolean;\n}) {\n\tconst owner = () => {\n\t\tif (!object.owner || typeof object.owner === 'string' || !('AddressOwner' in object.owner))\n\t\t\treturn undefined;\n\t\treturn object.owner.AddressOwner;\n\t};\n\n\tconst getKeyId = (item: SuiObjectData) => {\n\t\tif (!(item.content?.dataType === 'moveObject') || !('key' in item.content.fields)) return '';\n\t\treturn item.content.fields.key as string;\n\t};\n\n\t// Get the itemID for the locked object (We've saved it as a DOF on the SC).\n\tconst suiObjectId = useSuiClientQuery(\n\t\t'getDynamicFieldObject',\n\t\t{\n\t\t\tparentId: object.objectId,\n\t\t\tname: {\n\t\t\t\ttype: CONSTANTS.escrowContract.lockedObjectDFKey,\n\t\t\t\tvalue: {\n\t\t\t\t\tdummy_field: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tselect: (data) => data.data,\n\t\t\tenabled: !itemId,\n\t\t},\n\t);\n\n\treturn (\n\t\t<Locked\n\t\t\tlocked={{\n\t\t\t\titemId: itemId || suiObjectId.data?.objectId!,\n\t\t\t\tobjectId: object.objectId,\n\t\t\t\tkeyId: getKeyId(object),\n\t\t\t\tcreator: owner(),\n\t\t\t\tdeleted: false,\n\t\t\t}}\n\t\t\thideControls={hideControls}\n\t\t/>\n\t);\n}\n\nLock owned object​\n\nYou have all the logic you need to implement this UI. Use the same useSuiClientInfiniteQuery() hook to query all the owned objects of the connected wallet. Filter out objects that do not exist in the Object Display display.data.image_url as you can assume the valid NFTs conform to the Object Display and have an image in the metadata. Lastly, use the lock mutation from useLockObjectMutation() hook whenever the user clicks the lock button.\n\nsrc/components/locked/LockOwnedObjects.tsx\nexport function LockOwnedObjects() {\n\tconst account = useCurrentAccount();\n\n\tconst { mutate: lockObjectMutation, isPending } = useLockObjectMutation();\n\n\tconst { data, fetchNextPage, isFetchingNextPage, hasNextPage, refetch } =\n\t\tuseSuiClientInfiniteQuery(\n\t\t\t'getOwnedObjects',\n\t\t\t{\n\t\t\t\towner: account?.address!,\n\t\t\t\toptions: {\n\t\t\t\t\tshowDisplay: true,\n\t\t\t\t\tshowType: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: !!account,\n\t\t\t\tselect: (data) =>\n\t\t\t\t\tdata.pages\n\t\t\t\t\t\t.flatMap((page) => page.data)\n\t\t\t\t\t\t.filter((x) => !!x.data?.display && !!x.data?.display?.data?.image_url),\n\t\t\t},\n\t\t);\n\n\treturn (\n\t\t<InfiniteScrollArea\n\t\t\tloadMore={() => fetchNextPage()}\n\t\t\thasNextPage={hasNextPage}\n\t\t\tloading={isFetchingNextPage}\n\t\t>\n\t\t\t{data?.map((obj) => (\n\t\t\t\t<SuiObjectDisplay object={obj.data!}>\n\t\t\t\t\t<div className=\"text-right flex items-center justify-between\">\n\t\t\t\t\t\t<p className=\"text-sm\">Lock the item so it can be used for escrows.</p>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tclassName=\"cursor-pointer\"\n\t\t\t\t\t\t\tdisabled={isPending}\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tlockObjectMutation(\n\t\t\t\t\t\t\t\t\t{ object: obj.data! },\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tonSuccess: () => refetch(),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<LockClosedIcon />\n\t\t\t\t\t\t\tLock Item\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</div>\n\t\t\t\t</SuiObjectDisplay>\n\t\t\t))}\n\t\t</InfiniteScrollArea>\n\t);\n}\n\nEscrow dashboard​\n\nThe UI has a place for users to discover, create, and execute trades. The code of this tab lives in the file src/routes/EscrowDashboard.tsx. In this tab, there are three sub-tabs:\n\nRequested Escrows tab to list out all of the escrow requested for locked objects.\nBrowse Locked Objects tab to browse locked objects to trade for.\nMy Pending Requests tab to browse escrows you have initiated for third-party locked objects.\nRequested escrows​\n\nLet's take a look at the Requested Escrows tab by examining src/components/escrows/EscrowList.tsx. This time, the data is retrieved by using useInfiniteQuery directly from react-query. Fetch the data by calling the API service that you already implemented in the Escrow Indexing and API Service Guide. Call the /escrows endpoint to fetch all the escrows requested to you. The rationale behind using an API service to fetch the data is because the indexed data includes additional information that allows query efficiency and flexibility. You can fetch specific escrows satisfying different configured query clauses rather than limited query features of Sui blockchain RPC endpoints.\n\nsrc/components/escrows/EscrowList.tsx\nimport { constructUrlSearchParams, getNextPageParam } from '@/utils/helpers';\n\nconst { data, fetchNextPage, hasNextPage, isLoading, isFetchingNextPage } = useInfiniteQuery({\n\tinitialPageParam: null,\n\tqueryKey: [QueryKey.Escrow, params, escrowId],\n\tqueryFn: async ({ pageParam }) => {\n\t\tconst data = await fetch(\n\t\t\tCONSTANTS.apiEndpoint +\n\t\t\t\t'escrows' +\n\t\t\t\tconstructUrlSearchParams({\n\t\t\t\t\t...params,\n\t\t\t\t\t...(pageParam ? { cursor: pageParam as string } : {}),\n\t\t\t\t\t...(escrowId ? { objectId: escrowId } : {}),\n\t\t\t\t}),\n\t\t);\n\t\treturn data.json();\n\t},\n\tselect: (data) => data.pages.flatMap((page) => page.data),\n\tgetNextPageParam,\n});\n\n\nThe Escrow component renders the details of an escrow by providing ApiEscrowObject as a rendering property. There is some data you need to fetch to gather necessary escrow information for display in the UI:\n\nQuery the escrowed item object directly from Sui blockchain by using useSuiClientQuery('getObject') as this is the only way to have its Object Display metadata.\nFetch the ApiLockedObject corresponding to the escrow's key ID from the API service as this is the most efficient way to fetch the locked object in a complex query.\nFetch the on-chain Locked object corresponding to the returned ApiLockedObject to pass it onto <LockedObject />.\nsrc/components/escrows/Escrow.tsx\nexport function Escrow({ escrow }: { escrow: ApiEscrowObject }) {\n\tconst account = useCurrentAccount();\n\tconst [isToggled, setIsToggled] = useState(true);\n\tconst { mutate: acceptEscrowMutation, isPending } = useAcceptEscrowMutation();\n\tconst { mutate: cancelEscrowMutation, isPending: pendingCancellation } =\n\t\tuseCancelEscrowMutation();\n\n\tconst suiObject = useSuiClientQuery('getObject', {\n\t\tid: escrow?.itemId,\n\t\toptions: {\n\t\t\tshowDisplay: true,\n\t\t\tshowType: true,\n\t\t},\n\t});\n\n\tconst lockedData = useQuery({\n\t\tqueryKey: [QueryKey.Locked, escrow.keyId],\n\t\tqueryFn: async () => {\n\t\t\tconst res = await fetch(`${CONSTANTS.apiEndpoint}locked?keyId=${escrow.keyId}`);\n\t\t\treturn res.json();\n\t\t},\n\t\tselect: (data) => data.data[0],\n\t\tenabled: !escrow.cancelled,\n\t});\n\n\tconst { data: suiLockedObject } = useGetLockedObject({\n\t\tlockedId: lockedData.data?.objectId,\n\t});\n\n\t...\n}\n\n\nAs the last step, reuse the accept and cancel escrow mutations in corresponding buttons.\n\nBrowse locked objects​\n\nThe src/components/locked/ApiLockedList.tsx component renders all the on-chain locked objects based on the LockedListingQuery property. Call the API service to fetch the ApiLockedObject data using the provided query parameters. One caveat around the API service is that the creator field of the ApiLockedObject could be stale because the Locked object has the store ability. This means that the object can be transferred freely, hence, the ownership might not be correctly tracked by the API service. That's why you still fetch from the Sui blockchain as an additional step to define the object with latest on-chain information to ensure its data correctness in regards to ownership.\n\nsrc/components/locked/ApiLockedList.tsx\nconst { data, fetchNextPage, hasNextPage, isLoading, isFetchingNextPage } = useInfiniteQuery({\n\tinitialPageParam: null,\n\tqueryKey: [QueryKey.Locked, params, lockedId],\n\tqueryFn: async ({ pageParam }) => {\n\t\tconst data = await (\n\t\t\tawait fetch(\n\t\t\t\tCONSTANTS.apiEndpoint +\n\t\t\t\t\t'locked' +\n\t\t\t\t\tconstructUrlSearchParams({\n\t\t\t\t\t\tdeleted: 'false',\n\t\t\t\t\t\t...(pageParam ? { cursor: pageParam as string } : {}),\n\t\t\t\t\t\t...(params || {}),\n\t\t\t\t\t}),\n\t\t\t)\n\t\t).json();\n\n\t\tconst objects = await suiClient.multiGetObjects({\n\t\t\tids: data.data.map((x: ApiLockedObject) => x.objectId),\n\t\t\toptions: {\n\t\t\t\tshowOwner: true,\n\t\t\t\tshowContent: true,\n\t\t\t},\n\t\t});\n\n\t\treturn {\n\t\t\tsuiObjects: objects.map((x) => x.data),\n\t\t\tapi: data,\n\t\t};\n\t},\n\tselect: (data) => data.pages,\n\tgetNextPageParam,\n\tenabled: !lockedId,\n});\n\nMy Pending Requests tab​\n\nThe My Pending Requests tab uses the same <EscrowList /> component as Requested Escrows tab as they're both trying to display the escrows. The only difference is that the former fetches all the escrows with current wallet as recipient, while the latter fetches all the escrows with current wallet as sender.\n\nEdit this page\nPrevious\nIndexing and API Service\nNext\nDev Cheat Sheet\nPrerequisites\nOverview\nSet up providers\nConnect wallet\nType definitions\nExecute transaction hook\nGenerate demo data\nLock/unlock owned-object mutation\nCreate/accept/cancel escrow mutations\nLocked dashboard\nEscrow dashboard\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Build and Test Packages | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app/build-test",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dAppBuild and Test Packages\nBuild and Test Packages\n\nIf you followed Write a Move Package, you have a basic module that you need to build. If you didn't, then either start with that topic or use your package, substituting that information where appropriate.\n\nBuilding your package​\n\nMake sure your terminal or console is in the directory that contains your package (my_first_package if you're following along). Use the following command to build your package:\n\n$ sui move build\n\n\nA successful build returns a response similar to the following:\n\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING my_first_package\n\n\nIf the build fails, you can use the verbose error messaging in output to troubleshoot and resolve root issues.\n\nNow that you have designed your asset and its accessor functions, it's time to test the package code before publishing.\n\nTesting a package​\n\nSui includes support for the Move testing framework. Using the framework, you can write unit tests that analyze Move code much like test frameworks for other languages, such as the built-in Rust testing framework or the JUnit framework for Java.\n\nAn individual Move unit test is encapsulated in a public function that has no parameters, no return values, and has the #[test] annotation. The testing framework executes such functions when you call the sui move test command from the package root (my_move_package directory as per the current running example):\n\n$ sui move test\n\n\nIf you execute this command for the package created in Write a Package, you see the following output. Unsurprisingly, the test result has an OK status because there are no tests written yet to fail.\n\nBUILDING Sui\nBUILDING MoveStdlib\nBUILDING my_first_package\nRunning Move unit tests\nTest result: OK. Total tests: 0; passed: 0; failed: 0\n\n\nTo actually test your code, you need to add test functions. Start with adding a basic test function to the my_module.move file, inside the module definition:\n\n#[test]\nfun test_sword_create() {\n    // Create a dummy TxContext for testing\n    let mut ctx = tx_context::dummy();\n\n    // Create a sword\n    let sword = Sword {\n        id: object::new(&mut ctx),\n        magic: 42,\n        strength: 7,\n    };\n\n    // Check if accessor functions return correct values\n    assert!(sword.magic() == 42 && sword.strength() == 7, 1);\n}\n\n\nAs the code shows, the unit test function (test_sword_create()) creates a dummy instance of the TxContext struct and assigns it to ctx. The function then creates a sword object using ctx to create a unique identifier and assigns 42 to the magic parameter and 7 to strength. Finally, the test calls the magic and strength accessor functions to verify that they return correct values.\n\nThe function passes the dummy context, ctx, to the object::new function as a mutable reference argument (&mut), but passes sword to its accessor functions as a read-only reference argument, &sword.\n\nNow that you have a test function, run the test command again:\n\n$ sui move test\n\n\nAfter running the test command, however, you get a compilation error instead of a test result:\n\nerror[E06001]: unused value without 'drop'\n   ┌─ ./sources/my_module.move:59:65\n   │\n 9 │       public struct Sword has key, store {\n   │                     ----- To satisfy the constraint, the 'drop' ability would need to be added here\n   ·\n52 │           let sword = Sword {\n   │               ----- The local variable 'sword' still contains a value. The value does not have the 'drop' ability and must be consumed before the function returns\n   │ ╭─────────────────────'\n53 │ │             id: object::new(&mut ctx),\n54 │ │             magic: 42,\n55 │ │             strength: 7,\n56 │ │         };\n   │ ╰─────────' The type 'my_first_package::my_module::Sword' does not have the ability 'drop'\n   · │\n59 │           assert!(sword.magic() == 42 && sword.strength() == 7, 1);\n   │                                                                   ^ Invalid return\n\n\nThe error message contains all the necessary information to debug the code. The faulty code is meant to highlight one of the Move language's safety features.\n\nThe Sword struct represents a game asset that digitally mimics a real-world item. Obviously, a real sword cannot simply disappear (though it can be explicitly destroyed), but there is no such restriction on a digital one. In fact, this is exactly what's happening in the test function - you create an instance of a Sword struct that simply disappears at the end of the function call. If you saw something disappear before your eyes, you'd be dumbfounded, too.\n\nOne of the solutions (as suggested in the error message), is to add the drop ability to the definition of the Sword struct, which would allow instances of this struct to disappear (be dropped). The ability to drop a valuable asset is not a desirable asset property in this case, so another solution is needed. Another way to solve this problem is to transfer ownership of the sword.\n\nTo get the test to work, we will need to use the transfer module, which is imported by default. Add the following lines to the end of the test function (after the assert! call) to transfer ownership of the sword to a freshly created dummy address:\n\n// Create a dummy address and transfer the sword\nlet dummy_address = @0xCAFE;\ntransfer::public_transfer(sword, dummy_address);\n\n\nRun the test command again. Now the output shows a single successful test has run:\n\nBUILDING MoveStdlib\nBUILDING Sui\nBUILDING my_first_package\nRunning Move unit tests\n[ PASS    ] 0x0::my_module::test_sword_create\nTest result: OK. Total tests: 1; passed: 1; failed: 0\n\nTIP\n\nUse a filter string to run only a matching subset of the unit tests. With a filter string provided, the sui move test checks the fully qualified (<address>::<module_name>::<fn_name>) name for a match.\n\nExample:\n\n$ sui move test sword\n\n\nThe previous command runs all tests whose name contains sword.\n\nYou can discover more testing options through:\n\n$ sui move test -h\n\nSui-specific testing​\n\nThe previous testing example uses Move but isn't specific to Sui beyond using some Sui packages, such as sui::tx_context and sui::transfer. While this style of testing is already useful for writing Move code for Sui, you might also want to test additional Sui-specific features. In particular, a Move call in Sui is encapsulated in a Sui transaction, and you might want to test interactions between different transactions within a single test (for example, one transaction creating an object and the other one transferring it).\n\nSui-specific testing is supported through the test_scenario module that provides Sui-related testing functionality otherwise unavailable in pure Move and its testing framework.\n\nThe test_scenario module provides a scenario that emulates a series of Sui transactions, each with a potentially different user executing them. A test using this module typically starts the first transaction using the test_scenario::begin function. This function takes an address of the user executing the transaction as its argument and returns an instance of the Scenario struct representing a scenario.\n\nAn instance of the Scenario struct contains a per-address object pool emulating Sui object storage, with helper functions provided to manipulate objects in the pool. After the first transaction finishes, subsequent test transactions start with the test_scenario::next_tx function. This function takes an instance of the Scenario struct representing the current scenario and an address of a user as arguments.\n\nUpdate your my_module.move file to include a function callable from Sui that implements sword creation. With this in place, you can then add a multi-transaction test that uses the test_scenario module to test these new capabilities. Put this functions after the accessors (Part 5 in comments).\n\npublic fun sword_create(magic: u64, strength: u64, ctx: &mut TxContext): Sword {\n    // Create a sword\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n\n\nThe code of the new functions uses struct creation and Sui-internal modules (tx_context) in a way similar to what you have seen in the previous sections. The important part is for the function to have correct signatures.\n\nWith the new function included, add another test function to make sure it behaves as expected.\n\n#[test]\nfun test_sword_transactions() {\n    use sui::test_scenario;\n\n    // Create test addresses representing users\n    let initial_owner = @0xCAFE;\n    let final_owner = @0xFACE;\n\n    // First transaction executed by initial owner to create the sword\n    let mut scenario = test_scenario::begin(initial_owner);\n    {\n        // Create the sword and transfer it to the initial owner\n        let sword = sword_create(42, 7, scenario.ctx());\n        transfer::public_transfer(sword, initial_owner);\n    };\n\n    // Second transaction executed by the initial sword owner\n    scenario.next_tx(initial_owner);\n    {\n        // Extract the sword owned by the initial owner\n        let sword = scenario.take_from_sender<Sword>();\n        // Transfer the sword to the final owner\n        transfer::public_transfer(sword, final_owner);\n    };\n\n    // Third transaction executed by the final sword owner\n    scenario.next_tx(final_owner);\n    {\n        // Extract the sword owned by the final owner\n        let sword = scenario.take_from_sender<Sword>();\n        // Verify that the sword has expected properties\n        assert!(sword.magic() == 42 && sword.strength() == 7, 1);\n        // Return the sword to the object pool (it cannot be simply \"dropped\")\n        scenario.return_to_sender(sword)\n    };\n    scenario.end();\n}\n\n\nThere are some details of the new testing function to pay attention to. The first thing the code does is create some addresses that represent users participating in the testing scenario. The test then creates a scenario by starting the first transaction on behalf of the initial sword owner.\n\nThe initial owner then executes the second transaction (passed as an argument to the test_scenario::next_tx function), who then transfers the sword they now own to the final owner. In pure Move there is no notion of Sui storage; consequently, there is no easy way for the emulated Sui transaction to retrieve it from storage. This is where the test_scenario module helps - its take_from_sender function allows an address-owned object of a given type (Sword) executing the current transaction to be available for Move code manipulation. For now, assume that there is only one such object. In this case, the test transfers the object it retrieves from storage to another address.\n\nTIP\n\nTransaction effects, such as object creation and transfer become visible only after a given transaction completes. For example, if the second transaction in the running example created a sword and transferred it to the administrator's address, it would only become available for retrieval from the administrator's address (via test_scenario, take_from_sender, or take_from_address functions) in the third transaction.\n\nThe final owner executes the third and final transaction that retrieves the sword object from storage and checks if it has the expected properties. Remember, as described in Testing a package, in the pure Move testing scenario, after an object is available in Move code (after creation or retrieval from emulated storage), it cannot simply disappear.\n\nIn the pure Move testing function, the function transfers the sword object to the fake address to handle the disappearing problem. The test_scenario package provides a more elegant solution, however, which is closer to what happens when Move code actually executes in the context of Sui - the package simply returns the sword to the object pool using the test_scenario::return_to_sender function. For scenarios where returning to the sender is not desirable or if you would like to simply destroy the object, the test_utils module also provides the generic destroy<T> function, that can be used on any type T regardless of its ability. It is advisable to check out other useful functions in the test_scenario and test_utils modules as well.\n\nRun the test command again to see two successful tests for our module:\n\nBUILDING Sui\nBUILDING MoveStdlib\nBUILDING my_first_package\nRunning Move unit tests\n[ PASS    ] 0x0::my_module::test_sword_create\n[ PASS    ] 0x0::my_module::test_sword_transactions\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\nModule initializers​\n\nEach module in a package can include a special initializer function that runs at publication time. The goal of an initializer function is to pre-initialize module-specific data (for example, to create singleton objects). The initializer function must have the following properties for it to execute at publication:\n\nFunction name must be init\nThe parameter list must end with either a &mut TxContext or a &TxContext type\nNo return values\nPrivate visibility\nOptionally, the parameter list starts by accepting the module's one-time witness by value\n\nFor example, the following init functions are all valid:\n\nfun init(ctx: &TxContext)\nfun init(ctx: &mut TxContext)\nfun init(otw: EXAMPLE, ctx: &TxContext)\nfun init(otw: EXAMPLE, ctx: &mut TxContext)\n\nWhile the sui move command does not support publishing explicitly, you can still test module initializers using the testing framework by dedicating the first transaction to executing the initializer function.\n\nThe init function for the module in the running example creates a Forge object.\n\n/// Module initializer to be executed when this module is published\nfun init(ctx: &mut TxContext) {\n    let admin = Forge {\n        id: object::new(ctx),\n        swords_created: 0,\n    };\n\n    // Transfer the forge object to the module/package publisher\n    transfer::transfer(admin, ctx.sender());\n}\n\n\nThe tests you have so far call the init function, but the initializer function itself isn't tested to ensure it properly creates a Forge object. To test this functionality, add a new_sword function to take the forge as a parameter and to update the number of created swords at the end of the function. If this were an actual module, you'd replace the sword_create function with new_sword. To keep the existing tests from failing, however, we will keep both functions.\n\n/// Constructor for creating swords\npublic fun new_sword(\n    forge: &mut Forge,\n    magic: u64,\n    strength: u64,\n    ctx: &mut TxContext,\n): Sword {\n    forge.swords_created = forge.swords_created + 1;\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n\n\nNow, create a function to test the module initialization:\n\n#[test]\nfun test_module_init() {\n    use sui::test_scenario;\n\n    // Create test addresses representing users\n    let admin = @0xAD;\n    let initial_owner = @0xCAFE;\n\n    // First transaction to emulate module initialization\n    let mut scenario = test_scenario::begin(admin);\n    {\n        init(scenario.ctx());\n    };\n\n    // Second transaction to check if the forge has been created\n    // and has initial value of zero swords created\n    scenario.next_tx(admin);\n    {\n        // Extract the Forge object\n        let forge = scenario.take_from_sender<Forge>();\n        // Verify number of created swords\n        assert!(forge.swords_created() == 0, 1);\n        // Return the Forge object to the object pool\n        scenario.return_to_sender(forge);\n    };\n\n    // Third transaction executed by admin to create the sword\n    scenario.next_tx(admin);\n    {\n        let mut forge = scenario.take_from_sender<Forge>();\n        // Create the sword and transfer it to the initial owner\n        let sword = forge.new_sword(42, 7, scenario.ctx());\n        transfer::public_transfer(sword, initial_owner);\n        scenario.return_to_sender(forge);\n    };\n    scenario.end();\n}\n\n\nAs the new test function shows, the first transaction (explicitly) calls the initializer. The next transaction checks if the Forge object has been created and properly initialized. Finally, the admin uses the Forge to create a sword and transfer it to the initial owner.\n\nYou can refer to the source code for the package (with all the tests and functions properly adjusted) in the first_package module in the sui/examples directory.\n\nRelated links​\nPublish a Package: Continue the example by publishing your package to the Sui network.\nPackage Upgrades: Upgrading packages published on the Sui network.\nEdit this page\nPrevious\nWrite a Move Package\nNext\nPublish a Package\nBuilding your package\nTesting a package\nSui-specific testing\nModule initializers\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/exchange-integration",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesSui Exchange Integration Guide\nSui Exchange Integration Guide\n\nThis topic describes how to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange. The specific requirements and processes to implement an integration vary between exchanges. Rather than provide a step-by-step guide, this topic provides information about the primary tasks necessary to complete an integration. After the guidance about how to configure an integration, you can also find information and code samples related to staking on the Sui network.\n\nRequirements to configure a SUI integration​\n\nThe requirements to configure a SUI integration include:\n\nA Sui Full node. You can operate your own Sui Full node or use a Full node from a node operator.\nSuggested hardware requirements to run a Sui Full node:\nCPU: 8 physical cores / 16 vCPUs\nRAM: 128 GB\nStorage (SSD): 4 TB NVMe drive\n\nFor best results, run Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also fun a Full node on macOS.\n\nConfigure a Sui Full node​\n\nYou can set up and configure a Sui Full node using Docker or directly from source code in the Sui GitHub repository.\n\nSet up Sui addresses​\n\nSui addresses do not require on-chain initialization, you can spend from an address if it corresponds to your private key. You can derive a 32-byte Sui address by hashing the signature scheme flag byte concatenated with public key bytes flag || pubkey using the BLAKE2b (256 bits output) hashing function.\n\nCurrently, Sui address supports these signature schemes: pure Ed25519, Secp256k1, Secp256r1 and multisig. The corresponding flag bytes are 0x00, 0x01, 0x02, 0x03 respectively.\n\nThe following code sample demonstrates how to derive a Sui address in Rust:\n\nlet flag = 0x00; // 0x00 = ED25519, 0x01 = Secp256k1, 0x02 = Secp256r1, 0x03 = multiSig\n// Hash the [flag, public key] bytearray using Blake2b\nlet mut hasher = DefaultHash::default();\nhasher.update([flag]);\nhasher.update(pk);\nlet arr = hasher.finalize();\nlet sui_address_string = hex::encode(arr);\n\nDisplaying addresses​\n\nSui supports both addresses with and without a 0x prefix. Sui recommends that you always include the 0x prefix in API calls and when you display user addresses.\n\nTrack balance changes for an address​\n\nYou can track balance changes by calling sui_getBalance at predefined intervals. This call returns the total balance for an address. The total includes any coin or token type, but this document focuses on SUI. You can track changes in the total balance for an address between subsequent sui_getBalance requests.\n\nThe following bash example demonstrates how to use sui_getBalance for address 0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3. If you use a network other than Devnet, replace the value for rpc with the URL to the appropriate Full node.\n\nrpc=\"https://fullnode.devnet.sui.io:443\"\naddress=\"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"\ndata=\"{\\\"jsonrpc\\\": \\\"2.0\\\", \\\"method\\\": \\\"sui_getBalance\\\", \\\"id\\\": 1, \\\"params\\\": [\\\"$address\\\"]}\"\ncurl -X POST -H 'Content-type: application/json' --data-raw \"$data\" $rpc\n\n\nThe response is a JSON object that includes the totalBalance for the address:\n\n{\n  \"jsonrpc\":\"2.0\",\n  \"result\":{\n     \"coinType\":\"0x2::sui::SUI\",\n     \"coinObjectCount\":40,\n     \"totalBalance\":10000000000,\n     \"lockedBalance\":{\n\n     }\n  },\n  \"id\":1\n}\n\n\nThe following example demonstrates using sui_getBalance in Rust:\n\nuse std::str::FromStr;\nuse sui_sdk::types::base_types::SuiAddress;\nuse sui_sdk::{SuiClient, SuiClientBuilder};\n\n\n#[tokio::main]\nasync fn main() -> Result<(), anyhow::Error> {\n   let sui = SuiClientBuilder::default().build(\n      \"https://fullnode.devnet.sui.io:443\",\n   ).await.unwrap();\n   let address = SuiAddress::from_str(\"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\")?;\n   let objects = sui.read_api().get_balance(address).await?;\n   println!(\"{:?}\", objects);\n   Ok(())\n}\n\nUse events to track balance changes for an address​\n\nYou can also track the balance for an address by subscribing to all of the events emitted from it. Use a filter to include only the events related to SUI coins, such as when the address acquires a coin or pays for a gas fee. The following example demonstrates how to filter events for an address using bash and cURL:\n\nrpc=\"https://fullnode.devnet.sui.io:443\"\naddress=\"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"\ndata=\"{\\\"jsonrpc\\\": \\\"2.0\\\", \\\"id\\\":1, \\\"method\\\": \\\"sui_getEvents\\\", \\\"params\\\": [{\\\"Recipient\\\": {\\\"AddressOwner\\\": \\\"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\\\"}}, null, null, true ]}\"\ncurl -X POST -H 'Content-type: application/json' --data-raw \"$data\" $rpc\n\n\nThe response can include a large number of events. Add pagination to the response using the nextCursor key in the request. You can determine the corresponding txDigest and eventSeq from the id field of a transaction.\n\nYou can add the txDigest value instead of the first null within the params. The second null is an integer that defines how many results (up to 1000) to return and the true means ascending order. You can use the nextCursor so the response starts from a desired point.\n\nThe id field of any transaction looks like:\n\n\"id\": {\n    \"txDigest\": \"GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2\",\n    \"eventSeq\": 6019\n}\n\n\nWith this data, create a nextCursor as follows:\n\nnextCursor : {\"txDigest\": \"GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2\",\"eventSeq\": 6019}\n\nBlocks vs checkpoints​\n\nSui is a DAG-based blockchain and uses checkpoints for node synchronization and global transaction ordering. Checkpoints differ from blocks in the following ways:\n\nSui creates checkpoints and adds finalized transactions. Note that transactions are finalized even before they are included in a checkpoint\nCheckpoints do not fork, roll back, or reorganize.\nSui creates one checkpoint about every 3 seconds.\nCheckpoint API operations​\n\nSui Checkpoint API operations include:\n\nsui_getCheckpoint - Retrieves the specified checkpoint.\nsui_getLatestCheckpointSequenceNumber - Retrieves the sequence number of the most recently executed checkpoint.\nsui_getCheckpoints - Retrieves a paginated list of checkpoints that occurred during the specified interval. Pending a future release.\nSUI balance transfer​\n\nTo transfer a specific amount of SUI between addresses, you need a SUI token object with that specific value. In Sui, everything is an object, including SUI tokens. The amount of SUI in each SUI token object varies. For example, an address could own 3 SUI tokens with different values: one of 0.1 SUI, a second of 1.0 SUI, and a third with 0.005 SUI. The total balance for the address equals the sum of the values of the individual SUI token objects, in this case, 1.105 SUI.\n\nYou can merge and split SUI token objects to create token objects with specific values. To create a SUI token worth .6 SUI, split the token worth 1 SUI into two token objects worth .6 SUI and .4 SUI.\n\nTo transfer a specific amount of SUI, you need a SUI token worth that specific amount. To get a SUI token with that specific value, you might need to split or merge existing SUI tokens. Sui supports several methods to accomplish this, including some that do not require you to manually split or merge coins.\n\nSui API operations for transfers​\n\nSui supports the following API operations related to transferring SUI between addresses:\n\nsui_transferObject Because SUI tokens are objects, you can transfer SUI tokens just like any other object. This method requires a gas token, and is useful in niche cases only.\n\nsui_payAllSui This method accepts an array of SUI token IDs. It merges all existing tokens into one, deducts the gas fee, then sends the merged token to the recipient address.\n\nThe method is especially useful if you want to transfer all SUI from an address. To merge together all coins for an address, set the recipient as the same address. This is a native Sui method so is not considered a transaction in Sui.\n\nsui_paySui This operation accepts an array of SUI token IDs, an array of amounts, and an array of recipient addresses.\n\nThe amounts and recipients array map one to one. Even if you use only one recipient address, you must include it for each amount in the amount array.\n\nThe operation merges all of the tokens provided into one token object and settles the gas fees. It then splits the token according to the amounts in the amounts array and sends the first token to the first recipient, the second token to the second recipient, and so on. Any remaining SUI on the token stays in the source address.\n\nThe benefits of this method include: no gas fees for merging or splitting tokens, and the abstracted token merge and split. The sui_paySui operation is a native function, so the merge and split operations are not considered Sui transactions. The gas fees for them match typical transactions on Sui.You can use this operation to split coins in your own address by setting the recipient as your own address. Note that the total value of the input coins must be greater than the total value of the amounts to send.\n\nsui_pay This method is similar to sui_paySui, but it accepts any kind of coin or token instead of only SUI. You must include a gas token, and all of the coins or tokens must be the same type.\n\nsui_transferSui This method accepts only one SUI token object and an amount to send to the recipient. It uses the same token for gas fees, so the amount to transfer must be strictly less than the value of the SUI token used.\n\nSigning transactions​\n\nRefer to Sui Signatures for more details on signature validity requirements.\n\nSUI Staking​\n\nThe Sui blockchain uses a Delegated Proof-of-Stake mechanism (DPoS). This allows SUI token holders to stake their SUI tokens to any validator of their choice. When someone stakes their SUI tokens, it means those tokens are locked for the entire epoch. Users can withdraw their stake at any time, but new staking requests become active only at the start of the next epoch.\n\nSUI holders who stake their tokens to validators earn rewards for helping secure the Sui network. Sui determines rewards for staking based on stake rewards on the network, and distributes them at the end of each epoch.\n\nThe total voting power in the Sui Network is always 10,000. The voting power of each individual validator is similar to basis points. For example, a voting power of 101 = 1.01%. Sui's quorum threshold (number of votes needed to confirm a transaction) is 6,667 (which is greater than 2/3). The voting power for a single validator is capped at 1,000 (10%) regardless of how much stake the validator has.\n\nStaking functions​\n\nSui supports the following API operations related to staking. You can find the source code in the sui_system module.\n\nrequest_add_stake Add user stake to a validator's staking pool.\npublic fun request_add_stake(\n   self: &mut SuiSystemState,\n   stake: Coin<SUI>,\n   validator_address: address,\n   ctx: &mut TxContext,\n) {\n   validator_set::request_add_stake(\n       &mut self.validators,\n       validator_address,\n       coin::into_balance(stake),\n       option::none(),\n       ctx,\n   );\n}\n\nrequest_add_stake_mul_coin Add user stake to a validator's staking pool using multiple coins.\npublic fun request_add_stake_mul_coin(\n   self: &mut SuiSystemState,\n   delegate_stakes: vector<Coin<SUI>>,\n   stake_amount: option::Option<u64>,\n   validator_address: address,\n   ctx: &mut TxContext,\n) {\n   let balance = extract_coin_balance(delegate_stakes, stake_amount, ctx);\n   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::none(), ctx);\n}\n\nrequest_add_stake_with_locked_coin Add user stake to a validator's staking pool using a locked SUI coin.\npublic fun request_add_stake_with_locked_coin(\n   self: &mut SuiSystemState,\n   stake: LockedCoin<SUI>,\n   validator_address: address,\n   ctx: &mut TxContext,\n) {\n   let (balance, lock) = locked_coin::into_balance(stake);\n   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::some(lock), ctx);\n}\n\nrequest_withdraw_stake Withdraw some portion of a user stake from a validator's staking pool.\npublic fun request_withdraw_stake(\n   self: &mut SuiSystemState,\n   delegation: &mut Delegation,\n   staked_sui: &mut StakedSui,\n   principal_withdraw_amount: u64,\n   ctx: &mut TxContext,\n) {\n   validator_set::request_withdraw_stake(\n       &mut self.validators,\n       delegation,\n       staked_sui,\n       principal_withdraw_amount,\n       ctx,\n   );\n}\n\nEdit this page\nPrevious\nNode Tools\nRequirements to configure a SUI integration\nConfigure a Sui Full node\nSet up Sui addresses\nDisplaying addresses\nTrack balance changes for an address\nUse events to track balance changes for an address\nBlocks vs checkpoints\nCheckpoint API operations\nSUI balance transfer\nSui API operations for transfers\nSigning transactions\nSUI Staking\nStaking functions\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/validator-tasks",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesValidator Tasks\nValidator Tasks\n\nThis guide focuses on running the Sui node software as a validator.\n\nRequirements​\n\nTo run a Sui Validator a machine with the following is required:\n\nCPU: 24 physical cores (or 48 virtual cores)\nMemory: 128 GB\nStorage: 4 TB NVME\nNetwork: 1 Gbps\nDeployment​\n\nYou can deploy Sui node in a number of ways.\n\nThere are pre-built container images available in Docker Hub.\n\nAnd pre built linux/amd64 binaries available in S3 that you can can fetch using one of the following methods:\n\nwget https://releases.sui.io/$SUI_SHA/sui-node\n\ncurl https://releases.sui.io/$SUI_SHA/sui-node -o sui-node\n\n\nTo build directly from source:\n\ngit clone https://github.com/MystenLabs/sui.git && cd sui\ngit checkout [SHA|BRANCH|TAG]\ncargo build --release --bin sui-node\n\n\nConfiguration and guides are available for the following deployment options:\n\nSystemd\nAnsible\nDocker Compose\nConfiguration​\n\nSui node runs with a single configuration file provided as an argument, example:\n\n./sui-node --config-path /opt/sui/config/validator.yaml.\n\nSee Validator for configuration templates.\n\nConnectivity​\n\nSui node uses the following ports by default:\n\nprotocol/port\treachability\tpurpose\nTCP/8080\tinbound\tprotocol/transaction interface\nUDP/8081\tinbound/outbound\tnarwhal primary interface\nUDP/8082\tinbound/outbound\tnarwhal worker interface\nTCP/8083\tlocalhost\tsui -> narwhal interface\nUDP/8084\tinbound/outbound\tpeer to peer state sync interface\nTCP/8443\toutbound\tmetrics pushing\nTCP/9184\tlocalhost\tmetrics scraping\n\nTo run a validator successfully, it is critical that ports 8080-8084 are open as outlined, including the specific protocol (TCP/UDP).\n\nNetwork Buffer​\n\nFrom load testing Sui validator networks, it has been determined that the default Linux network buffer sizes are too small. We recommend increasing them using one of the following two methods:\n\nOption 1: With /etc/sysctl.d/​\n\nThese settings can be added to a new sysctl file specifically for the sui-node, or appended to an existing file. Modifications made in this way will persist across system restarts.\n\n# Create a new sysctl file for the sui-node\nsudo nano /etc/sysctl.d/100-sui-node.conf\n\n# Add these lines to the file, overwriting existing settings if necessary.\nnet.core.rmem_max = 104857600\nnet.core.wmem_max = 104857600\nnet.ipv4.tcp_rmem = 8192 262144 104857600\nnet.ipv4.tcp_wmem = 8192 262144 104857600\n\n# Apply the settings immediately, before the next restart\nsudo sysctl --system\n\nOption 2: With sysctl command​\n\nThese modifications do not persist across system restarts. Therefore, the commands should be run each time the host restarts.\n\nsudo sysctl -w net.core.wmem_max=104857600\nsudo sysctl -w net.core.rmem_max=104857600\nsudo sysctl -w net.ipv4.tcp_rmem=\"8192 262144 104857600\"\nsudo sysctl -w net.ipv4.tcp_wmem=\"8192 262144 104857600\"\n\nVerification​\n\nTo verify that the system settings have indeed been updated, check the output of the following command:\n\nsudo sysctl -a | egrep [rw]mem\n\nStorage​\n\nAll Sui node related data is stored by default under /opt/sui/db/. This is controlled in the Sui node configuration file.\n\n$ cat /opt/sui/config/validator.yaml | grep db-path\n  db-path: /opt/sui/db/authorities_db\n  db-path: /opt/sui/db/consensus_db\n\n\nEnsure that you have an appropriately sized disk mounted for the database to write to.\n\nTo check the size of the local Sui node databases:\ndu -sh /opt/sui/db/\ndu -sh /opt/sui/db/authorities_db\ndu -sh /opt/sui/db/consensus_db\n\nTo delete the local Sui node databases:\nsudo systemctl stop sui-node\nsudo rm -rf /opt/sui/db/authorities_db /opt/sui/db/consensus_db\n\nKey management​\n\nThe following keys are used by Sui node:\n\nkey\tscheme\tpurpose\nprotocol.key\tbls12381\ttransactions, narwhal consensus\naccount.key\ted25519\tcontrols assets for staking\nnetwork.key\ted25519\tnarwhal primary, sui state sync\nworker.key\ted25519\tvalidate narwhal workers\n\nThese are configured in the Sui node configuration file.\n\nMonitoring​\nMetrics​\n\nSui node exposes metrics via a local HTTP interface. These can be scraped for use in a central monitoring system as well as viewed directly from the node.\n\nView all metrics:\ncurl -s http://localhost:9184/metrics\n\nSearch for a particular metric:\ncurl http://localhost:9184/metrics | grep <METRIC>\n\n\nSui node also pushes metrics to a central Sui metrics proxy.\n\nLogs​\n\nLogs are controlled using the RUST_LOG environment variable.\n\nThe RUST_LOG_JSON=1 environment variable can optionally be set to enable logging in JSON structured format.\n\nDepending on your deployment method, these are configured in the following places:\n\nAnsible\nNative systemd\nDocker Compose\n\nTo view and follow the Sui node logs:\n\njournalctl -u sui-node -f\n\n\nTo search for a particular match\n\njournalctl -u sui-node -g <SEARCH_TERM>\n\nIf using Docker Compose, look at the examples in the README.\n\nIt is possible to change the logging configuration while a node is running using the admin interface.\n\nTo view the currently configured logging values:\n\ncurl localhost:1337/logging\n\n\nTo change the currently configured logging values:\n\ncurl localhost:1337/logging -d \"info\"\n\nDashboards​\n\nPublic dashboard for network wide visibility:\n\nSui Testnet Validators\nSoftware updates​\n\nWhen an update is required to the Sui node software the following process can be used. Follow the relevant Systemd or Docker Compose runbook depending on your deployment type. It is highly unlikely that you will want to restart with a clean database.\n\nSystemd\nDocker Compose\nState sync​\n\nCheckpoints in Sui contain the permanent history of the network. They are comparable to blocks in other blockchains with one big difference being that they are lagging instead of leading. All transactions are final and executed prior to being included in a checkpoint.\n\nThese checkpoints are synchronized between validators and fullnodes via a dedicated peer to peer state sync interface.\n\nInter-validator state sync is always permitted however there are controls available to limit what fullnodes are allowed to sync from a specific validator.\n\nThe default and recommended max-concurrent-connections: 0 configuration does not affect inter-validator state sync, but will restrict all fullnodes from syncing. The Sui node configuration can be modified to allow a known fullnode to sync from a validator:\n\np2p-config:\n  anemo-config:\n    max-concurrent-connections: 0\n  seed-peers:\n    - address: <multiaddr>  # The p2p address of the fullnode\n      peer-id: <peer-id>    # hex encoded network public key of the node\n    - address: ...          # another permitted peer\n      peer-id: ...\n\nChain operations​\n\nThe following chain operations are executed using the sui CLI. This binary is built and provided as a release similar to sui-node, examples:\n\nwget https://releases.sui.io/$SUI_SHA/sui\nchmod +x sui\n\ncurl https://releases.sui.io/$SUI_SHA/sui -o sui\nchmod +x sui\n\n\nIt is recommended and often required that the sui binary release/version matches that of the deployed network.\n\nUpdating on-chain metadata​\n\nYou can leverage Validator Tool to perform majority of the following tasks.\n\nAn active/pending validator can update its on-chain metadata by submitting a transaction. Some metadata changes take effect immediately, including:\n\nname\ndescription\nimage url\nproject url\n\nOther metadata (keys, addresses, and so on) only come into effect at the next epoch.\n\nTo update metadata, a validator makes a MoveCall transaction that interacts with the System Object. For example:\n\nto update name to new_validator_name, use the Sui Client CLI to call sui_system::update_validator_name:\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client call --package 0x3 --module sui_system --function update_validator_name --args 0x5 \\\"new_validator_name\\\" --gas-budget 10000\n\nto update p2p address starting from next epoch to /ip4/192.168.1.1, use the Sui Client CLI to call sui_system::update_validator_next_epoch_p2p_address:\nsui client call --package 0x3 --module sui_system --function update_validator_next_epoch_p2p_address --args 0x5 \"[4, 192, 168, 1, 1]\" --gas-budget 10000\n\n\nSee the full list of metadata update functions here.\n\nOperation cap​\n\nTo avoid touching account keys too often and allowing them to be stored off-line, validators can delegate the operation ability to another address. This address can then update the reference gas price and tallying rule on behalf of the validator.\n\nUpon creating a Validator, an UnverifiedValidatorOperationCap is created as well and transferred to the validator address. The holder of this Cap object (short for \"Capability\") therefore could perform operational actions for this validator. To authorize another address to conduct these operations, a validator transfers the object to another address that they control. The transfer can be done by using Sui Client CLI: sui client transfer.\n\nTo rotate the delegatee address or revoke the authorization, the current holder of Cap transfers it to another address. In the event of compromised or lost keys, the validator could create a new Cap object to invalidate the incumbent one. This is done by calling sui_system::rotate_operation_cap:\n\nsui client call --package 0x3 --module sui_system --function rotate_operation_cap --args 0x5 --gas-budget 10000\n\n\nBy default the new Cap object is transferred to the validator address, which then could be transferred to the new delegatee address. At this point, the old Cap becomes invalidated and no longer represents eligibility.\n\nTo get the current valid Cap object's ID of a validator, use the Sui Client CLI sui client objects command after setting the holder as the active address.\n\nUpdating the gas price survey quote​\n\nTo update the gas price survey quote of a validator, which is used to calculate the reference gas price at the end of the epoch, the sender needs to hold a valid UnverifiedValidatorOperationCap. The sender could be the validator itself, or a trusted delegatee. To do so, call sui_system::request_set_gas_price:\n\nsui client call --package 0x3 --module sui_system --function request_set_gas_price --args 0x5 {cap_object_id} {new_gas_price} --gas-budget 10000\n\nReporting/un-reporting validators​\n\nTo report a validator or undo an existing reporting, the sender needs to hold a valid UnverifiedValidatorOperationCap. The sender could be the validator itself, or a trusted delegatee. To do so, call sui_system::report_validator/undo_report_validator:\n\nsui client call --package 0x3 --module sui_system --function report_validator/undo_report_validator --args 0x5 {cap_object_id} {reportee_address} --gas-budget 10000\n\n\nAfter a validator is reported by 2f + 1 other validators by voting power, their staking rewards will be slashed.\n\nJoining the validator set​\n\nIn order for a Sui address to join the validator set, they need to first sign up as a validator candidate by calling sui_system::request_add_validator_candidate with their metadata and initial configs:\n\nsui client call --package 0x3 --module sui_system --function request_add_validator_candidate --args 0x5 {protocol_pubkey_bytes} {network_pubkey_bytes} {worker_pubkey_bytes} {proof_of_possession} {name} {description} {image_url} {project_url} {net_address} {p2p_address} {primary_address} {worker_address} {gas_price} {commission_rate} --gas-budget 10000\n\n\nAfter an address becomes a validator candidate, any address (including the candidate address itself) can start staking with the candidate's staking pool. Refer to our dedicated staking FAQ on how staking works. Once a candidate's staking pool has accumulated at least sui_system::MIN_VALIDATOR_JOINING_STAKE amount of stake, the candidate can call sui_system::request_add_validator to officially add themselves to next epoch's active validator set:\n\nsui client call --package 0x3 --module sui_system --function request_add_validator --args 0x5 --gas-budget 10000000\n\nLeaving the validator set​\n\nTo leave the validator set starting next epoch, the sender needs to be an active validator in the current epoch and should call sui_system::request_remove_validator:\n\nsui client call --package 0x3 --module sui_system --function request_remove_validator --args 0x5 --gas-budget 10000\n\n\nAfter the validator is removed at the next epoch change, the staking pool will become inactive and stakes can only be withdrawn from an inactive pool.\n\nPrivate security fixes​\n\nThere might be instances where urgent security fixes need to be rolled out before publicly announcing it's presence (issues affecting liveliness, invariants such as SUI supply, governance, and so on). To not be actively exploited, Mysten Labs will release signed security binaries incorporating such fixes with a delay in publishing the source code until a large percentage of our validators have patched the vulnerability.\n\nThis release process is different and we expect us to announce the directory for such binaries out of band. Our public key to verify these binaries would be stored here\n\nThere is also a script available that downloads all the necessary signed binaries and docker artifacts incorporating the security fixes.\n\nUsage ./download_private.sh <directory-name>\n\nYou can also download and verify specific binaries that may not be included by the above script using the download_and_verify_private_binary.sh script.\n\nUsage: ./download_and_verify_private_binary.sh <directory-name> <binary-name>\n\nEdit this page\nPrevious\nValidator Committee\nNext\nNode Tools\nRequirements\nDeployment\nConfiguration\nConnectivity\nNetwork Buffer\nOption 1: With /etc/sysctl.d/\nOption 2: With sysctl command\nVerification\nStorage\nKey management\nMonitoring\nMetrics\nLogs\nDashboards\nSoftware updates\nState sync\nChain operations\nUpdating on-chain metadata\nOperation cap\nUpdating the gas price survey quote\nReporting/un-reporting validators\nJoining the validator set\nLeaving the validator set\nPrivate security fixes\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/archives",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesSui Archives\nSui Archives\n\nA Sui archive is a history of all transaction data on Sui, trailing behind the latest checkpoint by 10 minutes. As a Sui node operator, you can write this history to an object store like S3, GCS, or similar for safe keeping. Saving this archive data is considered a best practice because Sui prunes transactions on Full nodes to remove historical transactions and their effects. Peer nodes, for example, might not catch up with all transactions and effects through synchronization if they lag behind the current epoch by more than the latest few epochs. Instead of relying on synchronization, peer nodes can fallback to downloading this information from an archive.\n\nSui Archival nodes (Full nodes that write to an archive) don't store historical state on local storage and don't help query historical data. They serve the purpose of enabling peer nodes to catch up to the latest checkpoint and are useful for auditing and verifying the complete history of all transactions on the network.\n\nCreate an Archival node​\n\nTo start storing transaction history as an archive, you need to modify your node configuration. Open your fullnode.yaml file and add the following configuration. By default, the fullnode.yaml file is located in your ~/.sui/sui_config directory.\n\nstate-archive-write-config:\n  object-store-config:\n    object-store: \"S3\"\n    bucket: \"<bucket_name>\"\n    aws-access-key-id: \"<AWS_ACCESS_KEY_ID>\"\n    aws-secret-access-key: \"<AWS_SECRET_ACCESS_KEY>\"\n    aws-region: \"<aws_region>\"\n    object-store-connection-limit: 20\n  concurrency: 5\n  use-for-pruning-watermark: false\nstate-archive-read-config:\n  - object-store-config:\n      object-store: \"S3\"\n      # Use the same bucket which is being used in `state-archive-write-config`\n      bucket: \"<bucket_name>\"\n      aws-access-key-id: \"<AWS_ACCESS_KEY_ID>\"\n      aws-secret-access-key: \"<AWS_SECRET_ACCESS_KEY>\"\n      aws-region: \"<aws_region>\"\n      object-store-connection-limit: 20\n    concurrency: 5\n    # This should be set to true in this case. Setting this to true\n    # would prevent pruning of local transaction data until it is archived\n    # in the bucket\n    use-for-pruning-watermark: true\n\nSet up archival fallback​\n\nTo enable your node to fallback to an archive in case of lag, add this to your fullnode.yaml file:\n\nAmazon S3\nGoogle Cloud Storage\nstate-archive-read-config:\n  - object-store-config:\n      object-store: \"S3\"\n      # Use mysten-testnet-archives for testnet \n      # Use mysten-mainnet-archives for mainnet\n      bucket: \"mysten-<testnet|mainnet>-archives\"\n      # Use your AWS account access key id\n      aws-access-key-id: \"<AWS-ACCESS-KEY-ID>\"\n      # Use your AWS account secret access key\n      aws-secret-access-key: \"<AWS-SECRET-ACCESS-KEY>\"\n      aws-region: \"<AWS-REGION>\"\n      object-store-connection-limit: 20\n    # How many objects to read ahead when catching up  \n    concurrency: 5\n    # Whether to prune local state based on latest checkpoint in archive.\n    # This should stay false for most use cases\n    use-for-pruning-watermark: false\n\n\nEven though these buckets are publicly readable, you need to make sure to properly grant the correct policies to read them via AWS, for example:\n\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:ListBucket\",\n                \"s3:GetObject\",\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": [\n                \"arn:aws:s3:::mysten-mainnet-archives/*\",\n                \"arn:aws:s3:::mysten-mainnet-archives\"\n            ]\n        }\n    ]\n}\n\nEdit this page\nPrevious\nDatabase Snapshots\nNext\nGenesis\nCreate an Archival node\nSet up archival fallback\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/node-tools",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesNode Tools\nNode Tools\n\nThis guide focuses on using the Sui CLI validator commands.\n\nINFO\n\nThis tool only supports pending validators and active validators at the moment.\n\nPreparation​\n\nMake sure you have completed all the prerequisites.\n\nBuild the sui binary, which you need for the genesis ceremony. This step can be done on any machine you like. It does not have to be done on the machine on which you will run the validator.\n\nClone the git repo:\n\ngit clone git@github.com:MystenLabs/sui.git && cd sui\n\nCheck out the commit to use for the testnet:\n\ngit checkout testnet\n\nBuild sui binary\n\ncargo build --bin sui\n\nRemember the path to your binary:\n\nexport SUI_BINARY=\"$(pwd)/target/debug/sui\"\n\nRun the following command to set up your Sui account and CLI environment.\n\nIf this is the first time running this program, it will ask you to provide a Sui Fullnode Server URL and a meaningful environment alias. It will also generate a random key pair in sui.keystore and a config client.yaml. Swap in your validator account key if you already have one.\n\nIf you already set it up, simply make sure a. rpc is correct in client.yaml. b. active_address is correct in client.yaml. b. sui.keystore contains your account key pair.\n\nIf at this point you can't find where client.yaml or sui.keystore is or have other questions, read Sui Client CLI tutorial.\n\n$ sui client\n\n\nTo test you are connected to the network and configured your config correctly, run the following command to display your validator info.\n\n$ sui validator display-metadata\n\nUsing Sui CLI​\nPrint help info​\n$ sui validator --help\n\nDisplay validator metadata​\n$ sui validator display-metadata\n\n\nor\n\n$ sui validator display-metadata <validator-address>\n\n\nto print another validator's information.\n\nUpdate validator metadata​\n\nRun the following to see how to update validator metadata. Read description carefully about when the change will take effect.\n\n$ sui validator update-metadata --help\n\n\nYou can update the following on-chain metadata:\n\nname\ndescription\nimage URL\nproject URL\nnetwork address\np2p address\nprimary address\nworker address\nprotocol public key\nnetwork public key\nworker public key\n\nNotably, only the first 4 metadata listed above take effect immediately.\n\nIf you change any metadata from points 5 to 11, they will be changed only after the next epoch - for these, you'll want to restart the validator program immediately after the next epoch, with the new key files and/or updated validator.yaml config. Particularly, make sure the new address is not behind a firewall.\n\nRun the following to see how to update each metadata.\n\n$ sui validator update-metadata --help\n\nOperation cap​\n\nOperation Cap allows a validator to authorizer another account to perform certain actions on behalf of this validator. Read about Operation Cap here.\n\nThe Operation Cap holder (either the valdiator itself or the delegatee) updates its Gas Price and reports validator peers with the Operation Cap.\n\nUpdate gas price​\n\nTo update Gas Price, run\n\n$ sui validator update-gas-price <gas-price>\n\n\nif the account itself is a validator and holds the Operation Cap. Or\n\n$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>\n\n\nif the account is a delegatee.\n\nReport validators​\n\nTo report validators peers, run\n\n$ sui validator report-validator <reportee-address>\n\n\nAdd --undo-report false if it intents to undo an existing report.\n\nSimilarly, if the account is a delegatee, add --operation-cap-id <operation-cap-id> option to the command.\n\nif the account itself is a validator and holds the Operation Cap. Or\n\n$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>\n\n\nif the account is a delegatee.\n\nBecome a validator / join committee​\n\nTo become a validator candidate, first run\n\n$ sui validator make-validator-info <name> <description> <image-url> <project-url> <host-name> <gas_price>\n\n\nThis will generate a validator.info file and key pair files. The output of this command includes:\n\nFour key pair files (Read more here). ==Set their permissions with the minimal visibility (chmod 600, for example) and store them securely==. They are needed when running the validator node as covered below. a. If you follow this guide thoroughly, this key pair is actually copied from your sui.keystore file.\nvalidator.info file that contains your validator info. Double check all information is correct.\n\nThen run\n\n$ sui validator become-candidate {path-to}validator.info\n\n\nto submit an on-chain transaction to become a validator candidate. The parameter is the file path to the validator.info generated in the previous step. Make sure the transaction succeeded (printed in the output).\n\nAt this point you are validator candidate and can start to accept self staking and delegated staking.\n\nIf you haven't, start a fullnode now to catch up with the network. When you officially join the committee but is not fully up-to-date, you cannot make meaningful contribution to the network and may be subject to peer reporting hence face the risk of reduced staking rewards for you and your delegators.\n\nOnce you collect enough staking amount, run\n\n$ sui validator join-committee\n\n\nto become a pending validator. A pending validator will become active and join the committee starting from next epoch.\n\nLeave committee​\n\nTo leave committee, run\n\n$ sui validator leave-committee\n\n\nThen you will be removed from committee starting from next epoch.\n\nGenerate the payload to create PoP​\n\nSerialize the payload that is used to generate Proof of Possession. This is allows the signer to take the payload offline for an Authority protocol BLS keypair to sign.\n\n$ sui validator serialize-payload-pop --account-address $ACCOUNT_ADDRESS --protocol-public-key $BLS_PUBKEY\nSerialized payload: $PAYLOAD_TO_SIGN\n\nEdit this page\nPrevious\nValidator Tasks\nNext\nSui Exchange Integration Guide\nPreparation\nUsing Sui CLI\nGenerate the payload to create PoP\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/validator-committee",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesValidator Committee\nValidator Committee\n\nA set of independent validators participate on the Sui network, each running its own instance of the Sui software on a separate machine (or a sharded cluster of machines the same entity operates). Each validator handles read and write requests sent by clients, verifying transactions and updating on-chain information.\n\nTo learn how to set up and run a Sui Validator node, including how staking and rewards work, see Sui Validator Node Configuration.\n\nSui uses Delegated Proof-of-Stake (DPoS) to determine which validators operate the network and their voting power. Validators are incentivized to participate in good faith via a share of transaction fees, staking rewards, and slashing stake and staking rewards in case of misbehavior.\n\nEpochs​\n\nOperation of the Sui network is temporally partitioned into non-overlapping, approximate fixed-duration (~24-hour) epochs. During a particular epoch, the set of validators participating in the network and their voting power is fixed. At an epoch boundary, reconfiguration might occur and can change the set of validators participating in the network and their voting power. Conceptually, reconfiguration starts a new instance of the Sui protocol with the previous epoch's final state as genesis and the new set of validators as the operators. Besides validator set changes, tokenomics operations such as staking/un-staking, and distribution of staking rewards are also processed at epoch boundaries.\n\nQuorums​\n\nA quorum is a set of validators whose combined voting power is greater than two-thirds (>2/3) of the total during a particular epoch. For example, in a Sui instance operated by four validators that all have the same voting power, any group containing three validators is a quorum.\n\nThe quorum size of >2/3 ensures Byzantine fault tolerance (BFT). A validator commits a transaction (durably store the transaction and update its internal state with the effects of the transaction) only if it is accompanied by cryptographic signatures from a quorum. Sui calls the combination of the transaction and the quorum signatures on its bytes a certificate. The policy of committing only certificates ensures Byzantine fault tolerance: if >2/3 of the validators faithfully follow the protocol, they are guaranteed to eventually agree on both the set of committed certificates and their effects.\n\nWrite requests​\n\nA validator can handle two types of write requests: transactions and certificates. At a high level, a client:\n\nCommunicates a transaction to a quorum of validators to collect the signatures required to form a certificate.\nSubmits a certificate to a validator to commit state changes on that validator.\nTransactions​\n\nWhen a validator receives a transaction from a client, it first performs transaction validity checks (validity of the sender's signature). If the checks pass, the validator locks all owned-objects and signs the transaction bytes, then returns the signature to the client. The client repeats this process with multiple validators until it has collected signatures on its transaction from a quorum, thereby forming a certificate.\n\nThe process of collecting validator signatures on a transaction into a certificate and the process of submitting certificates can be performed in parallel. The client can simultaneously multicast transactions/certificates to an arbitrary number of validators. Alternatively, a client can outsource either or both of these tasks to a third-party service provider. This provider must be trusted for liveness (it can refuse to form a certificate), but not for safety (it cannot change the effects of the transaction, and does not need the user's secret key).\n\nCertificates​\n\nAfter the client forms a certificate, it submits it to the validators, which perform certificate validity checks. These checks ensure the signers are validators in the current epoch, and the signatures are cryptographically valid. If the checks pass, the validators execute the transaction inside the certificate. Execution of a transaction either succeeds and commits all of its effects or aborts and has no effect other than debiting the transaction's gas input. Some reasons a transaction might abort include an explicit abort instruction, a runtime error such as division by zero, or exceeding the maximum gas budget. Whether it succeeds or aborts, the validator durably stores the certificate indexed by the hash of its inner transaction.\n\nIf a client collects a quorum of signatures on the effects of the transaction, then the client has a promise of finality. This means that transaction effects persist on the shared database and are actually committed and visible to everyone by the end of the epoch. This does not mean that the latency is a full epoch, because you can use the effects certificate to convince anyone of the transactions finality, as well as to access the effects and issue new transactions. As with transactions, you can parallelize the process of sharing a certificate with validators and (if desired) outsource to a third-party service provider.\n\nThe role of Narwhal and Bullshark​\n\nSui takes advantage of Narwhal and Bullshark as its mempool and consensus engines. Narwhal/Bullshark (N/B) is also implemented in Sui so that when Byzantine agreement is required it uses a high-throughput DAG-based consensus to manage shared locks while execution on different shared objects is parallelized.\n\nNarwhal enables the parallel ordering of transactions into batches that are collected into concurrently proposed blocks, and Bullshark defines an algorithm for executing the DAG that these blocks form. N/B combined builds a DAG of blocks, concurrently proposed, and creates an order between those blocks as a byproduct of the building of the DAG. But that order is overlaid on top of the causal order of Sui transactions (the \"payload\" of Narwhal/Bullshark here), and does not substitute for it:\n\nN/B operates in OX, rather than XO mode (O = order, X = execute); the execution occurs after the Narwhal/Bullshark ordering.\nThe output of N/B is therefore a sequence of transactions, with interdependencies stored in the transaction data itself.\n\nConsensus sequences certificates of transactions. These represent transactions that have already been presented to 2/3 of validators that checked that all their owned objects are available to be operated on and signed the transaction. Upon a certificate being sequenced, Sui sets the lock of the shared objects at the next available version to map to the execution of that certificate. So for example if you have a shared object X at version 2, and you sequence certificate T, Sui stores T -> [(X, 2)]. That is all you do when Sui reaches consensus, and as a result Sui can ingest a lot of sequenced transactions.\n\nNow, after this is done Sui can execute all certificates that have their locks set, on one or multiple cores. Obviously, transactions for earlier versions of objects need to be processed first (causally), and that reduces the degree of concurrency. The read and write set of the transaction can be statically determined from its versioned object inputs--execution can only read/write an object that was an input to the transaction, or that was created by the transaction.\n\nEdit this page\nPrevious\nGenesis\nNext\nValidator Tasks\nEpochs\nQuorums\nWrite requests\nTransactions\nCertificates\nThe role of Narwhal and Bullshark\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/genesis",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesGenesis\nGenesis\n\nGenesis is the initial state of the Sui blockchain. To launch a network, the initial committee of validators collaborate by providing their validator information (public keys, network addresses, and so on) to a shared workspace. After all of the initial validators have contributed their information, Sui generates the initial, unsigned genesis checkpoint (checkpoint with sequence number 0) and each validator provides their signature. Sui aggregates these signatures to form a certificate on the genesis checkpoint. Sui bundles this checkpoint, as well as the initial objects, together into a single genesis.blob file that is used to initialize the state when running the sui-node binary for both validators and Full nodes.\n\nGenesis blob locations​\n\nThe genesis.blob files for each network are in the sui-genesis repository.\n\nSee Sui Full Node for how to get the genesis.blob file for each network.\n\nEdit this page\nPrevious\nSui Archives\nNext\nValidator Committee\nGenesis blob locations\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/snapshots",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesDatabase Snapshots\nDatabase Snapshots\n\nDatabase snapshots provide a point-in-time view of a database's store. In Sui, the database snapshot captures a running database's view of the Sui network from a particular node at the end of an epoch. While validators can enable snapshots, they are typically most valuable for Full node operators.\n\nSnapshots of the Sui network enable Full node operators a way to bootstrap a Full node without having to execute all the transactions that occurred after genesis. You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your Full node. With snapshots stored in the cloud, you're more easily able to recover quickly from catastrophic failures in your system or hardware.\n\nTo maintain a healthy Sui network, Sui encourages the Sui community to bring up additional snapshots to ensure stronger data availability across the network.\n\nSupported snapshot types​\n\nSui supports two types of snapshots:\n\nRocksDB snapshots are a point-in-time view of a database store. This means that the snapshot keeps the state of the system at the moment it generates the snapshot, including non-pruned data, additional indices, and other data.\nFormal snapshots are database agnostic with a minimalistic format, in other words they contain only the data necessary to restore a node to a valid state at the specified epoch, thus they have a much smaller storage footprint and are generally faster to restore from when compared to database snapshots. Formal snapshots are also supported natively by the Sui protocol. In this context, this means that we can cryptographically verify the contents of the formal snapshot against a commitment from the committee at the epoch we are restoring to. This verification happens automatically and by default during a Formal snapshot restore (unless explicitly bypassed).\nINFO\n\nFormal snapshots are not suitable for use if you are running an RPC node that does any historical data lookups. For more information on node data management, see Data Management.\n\nYou can configure a Full node snapshot to generate a state snapshot at the end of each epoch. A single Full node can generate RocksDB snapshots, Formal snapshots, or both.\n\nFormal snapshots​\n\nFormal snapshots provide a mechanism for a node to restore to a canonical state (the state of a full pruned and compacted node at the end of an epoch) at some prior point in time without having to execute all the transactions that have occurred since genesis. Unlike existing database snapshots, these formal snapshots have the following properties:\n\nMinimalism: Formal snapshots currently contain only the end of epoch live object set (the set of all object versions eligible for use as input objects for future transactions). Sui syncs all other critical chain information from the chain or derives it. Thus, formal snapshots contain only the necessary data required for a node to startup at epoch boundary and participate in the network.\nAgnosticism: Formal snapshots are by nature agnostic to the underlying database choice or implementation of the protocol. As the live object set is protocol defined, so is the formal snapshot.\nVerifiability: Formal snapshots have first-class support in the core Sui protocol. As such, they must be trustless/verifiable by the node operator upon download. To support this, the protocol signs a commitment to the live object state at end of epoch, which formal snapshots are checked against at restore time. If this verification fails, the node state is moved back to the state before the snapshot restore attempt.\n\nBecause these snapshots do not contain indexes, they are most immediately useful for validators and state sync Full nodes (SSFNs). You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your Full node. With snapshots stored in the cloud, you can recover from catastrophic failures in your system or hardware more efficiently.\n\nEnabling snapshots​\n\nFull nodes do not take snapshots by default. To enable this feature you must apply specific configs to your Full node.\n\nFollow these steps to change the configs for a Full node:\n\nStop your node, if it's running.\nOpen your fullnode.yaml config file and apply config updates as the following sections show.\nSave the fullnode.yaml file and restart the node.\nEnabling DB snapshots​\n\nAdd an entry to the config file for db-checkpoint-config. Using Amazon's S3 service as an example:\n\ndb-checkpoint-config:\n  perform-db-checkpoints-at-epoch-end: true\n  perform-index-db-checkpoints-at-epoch-end: true\n  object-store-config:\n    object-store: \"S3\"\n    bucket: \"<BUCKET-NAME>\"\n    aws-access-key-id: “<ACCESS-KEY>”\n    aws-secret-access-key: “<SHARED-KEY>”\n    aws-region: \"<BUCKET-REGION>\"\n    object-store-connection-limit: 20\n\nobject-store: The remote object store to upload snapshots. Set as Amazon's S3 service in the example.\nbucket: The S3 bucket name to store the snapshots.\naws-access-key-id and aws-secret-access-key: AWS authentication information with write access to the bucket.\naws-region: Region where bucket exists.\nobject-store-connection-limit: Number of simultaneous connections to the object store.\nEnabling Formal snapshots​\n\nAdd an entry to the config file for state-snapshot-write-config. Using Amazon's S3 service as an example:\n\nstate-snapshot-write-config:\n  object-store-config:\n    object-store: \"S3\"\n    bucket: \"<BUCKET-NAME>\"\n    aws-access-key-id: “<ACCESS-KEY>”\n    aws-secret-access-key: “<SHARED-KEY>”\n    aws-region: \"<BUCKET-REGION>\"\n    object-store-connection-limit: 200\n\n\nThe configuration settings shown in the example are specific to AWS S3, but GCS, Azure Storage, and Cloudflare R2 are all supported.\n\nRestoring a Full node using snapshots​\nRestoring using RocksDB snapshots​\n\nTo restore from a RocksDB snapshot, follow these steps:\n\nDownload the snapshot for the epoch you want to restore to your local disk. There is one snapshot per epoch in s3 bucket.\n\nPlace the snapshot into the directory that the db-config value points to in your fullnode.yaml file. For example, if the db-config value points to /opt/sui/db/authorities_db/full_node_db and you want to restore from epoch 10, then copy the snapshot to the directory with this command:\n\nYou can use the aws cli (provided you have credentials to associate with the download): aws s3 cp s3://<BUCKET_NAME>/epoch_10 /opt/sui/db/authorities_db/full_node_db/live --recursive.\n\nAn alternative is to use sui-tool to copy the files:\n\nsui-tool download-db-snapshot --epoch \"<EPOCH-NUMBER>\" \\\n    --network <NETWORK> --snapshot-bucket <BUCKET-NAME> \\\n    --snapshot-bucket-type <TYPE> --path <PATH-TO-NODE-DB> \\\n    --num-parallel-downloads 25 \\\n    --skip-indexes \\\n    --no-sign-request\n\n--epoch: The epoch that you want to download, for example 200. Mysten Labs hosted buckets will only keep the last 90 epochs.\n--network: Network to download snapshot for. Defaults to \"mainnet\".\n--path: Path to snapshot directory on local filesystem.\n--no-sign-request: If set, --snapshot-bucket and --snapshot-bucket-type are ignored, and Cloudflare R2 is used.\n--snapshot-bucket: Source snapshot bucket name, eg mysten-mainnet-snapshots.\n--snapshot-bucket-type: Snapshot bucket type. GCS and S3 currently supported.\n--skip-indexes: Skips downloading the very large indexes/ dir, used by jsonrpc on the fullnode\n\nThe following environment variables are used if --no-sign-request is not set:\n\nAWS: AWS_SNAPSHOT_ACCESS_KEY_ID, AWS_SNAPSHOT_SECRET_ACCESS_KEY, AWS_SNAPSHOT_REGION\nGCS: GCS_SNAPSHOT_SERVICE_ACCOUNT_FILE_PATH\nAZURE: AZURE_SNAPSHOT_STORAGE_ACCOUNT, AZURE_SNAPSHOT_STORAGE_ACCESS_KEY\n\nMake sure you update the ownership of the downloaded directory to the sui user (whichever linux user you run sui-node as) sudo chown -R sui:sui /opt/sui/db/authorities_db/full_node_db/live.\n\nStart the Sui node.\n\nINFO\n\nWhen you restore a Full node from a snapshot, write it to the path /opt/sui/db/authorities_db/full_node_db/live. To restore a Validator node, use the path /opt/sui/db/authorities_db/live.\n\nRestoring using Formal snapshots​\n\nTo restore using a Formal snapshot, use the sui-tool binary. sui-tool can be downloaded along with other sui binaries. See Install Sui for more details.\n\nThe following steps can be used to restore a node from a Formal snapshot:\n\nIf it's running, stop the node.\n\nRun the command:\n\nsui-tool download-formal-snapshot --epoch \"<EPOCH-NUMBER>\" --genesis \"<PATH-TO-GENESIS-BLOB>\" \\\n     --network <NETWORK> --snapshot-bucket <BUCKET-NAME> --snapshot-bucket-type <TYPE> \\\n     --path <PATH-TO-NODE-DB> --num-parallel-downloads 50 --no-sign-request\n\n--epoch: The epoch that you want to download, for example 200. Mysten Labs hosted buckets will only keep the last 90 epochs.\n--genesis: The path to the location of the network's genesis.blob.\n--network: Network to download snapshot for. Defaults to \"mainnet\".\n--path: Path to snapshot directory on local filesystem.\n--no-sign-request: If set, --snapshot-bucket and --snapshot-bucket-type are ignored, and Cloudflare R2 is used.\n--snapshot-bucket: Source snapshot bucket name, eg mysten-mainnet-snapshots.\n--snapshot-bucket-type: Snapshot bucket type. GCS and S3 currently supported.\n\nThe following environment variables are used if --no-sign-request is not set:\n\nAWS: AWS_SNAPSHOT_ACCESS_KEY_ID, AWS_SNAPSHOT_SECRET_ACCESS_KEY, AWS_SNAPSHOT_REGION\nGCS: GCS_SNAPSHOT_SERVICE_ACCOUNT_FILE_PATH\nAZURE: AZURE_SNAPSHOT_STORAGE_ACCOUNT, AZURE_SNAPSHOT_STORAGE_ACCESS_KEY\nMysten Labs managed snapshots​\n\nMysten Labs hosts two tiers of snapshot storage access. High throughput, Requester Pays enabled buckets, and free, permissionless buckets.\n\nHigh throughput, Requester Pays enabled buckets:\n\nGCS and S3 are both setup with requester pays. This means that you'll need to provide a set of valid AWS/GCP credentials when downloading from these buckets. Requester Pays means you are charged for the egress costs of pulling the snapshot data.\nIf you are looking for the best download speeds, we recommend using the S3 buckets with transfer acceleration enabled.\n\nFree, permissionless buckets:\n\nThese are currently hosted on Cloudflare R2, currently only in North America, but we plan on adding more regions soon.\nSince the bucket is open to the internet, there's no need to provide any cloud credentials.\nBucket Names​\n\nS3 Testnet: s3://mysten-testnet-snapshots/, s3://mysten-testnet-formal/ Mainnet: s3://mysten-mainnet-snapshots/, s3://mysten-mainnet-formal/\n\nGCS Testnet: gs://mysten-testnet-snapshots/, gs://mysten-testnet-formal/ Mainnet: gs://mysten-mainnet-snapshots/, gs://mysten-mainnet-formal/\n\nEdit this page\nPrevious\nData Management\nNext\nSui Archives\nSupported snapshot types\nFormal snapshots\nEnabling snapshots\nEnabling DB snapshots\nEnabling Formal snapshots\nRestoring a Full node using snapshots\nRestoring using RocksDB snapshots\nRestoring using Formal snapshots\nMysten Labs managed snapshots\nBucket Names\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/data-management",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesData Management\nData Management\n\nManaging the data on your Sui Full node is critical to ensuring a healthy Sui network. This topic provides a high-level description of data management on Sui Full nodes that you can use to optimize your Full node configuration. For more information about Sui Full nodes, such as pruning policies and archival settings, see Run a Sui Full Node.\n\nBasic Sui Full node functionality​\n\nThe minimal version of a Sui Full node executes all of the transactions Sui validators commit. Sui Full nodes also orchestrate the submitting of new transactions to the system:\n\nThe preceding image shows how data flows through a Full node:\n\nState sync protocol: A Sui Full node performs the following to achieve state synchronization:\nRetrieves the information about the committed checkpoints via the p2p gossip-like protocol\nExecutes the transactions locally to verify that effects match the effects certified by the quorum of the validators\nUpdates the local state with the latest object values accordingly.\nRPCs: A Sui Full node exposes Sui RPC endpoints for querying the latest state of the system, including both the latest state metadata (such as, sui_getProtocolConfig), and the latest state object data (sui_getObject).\nTransaction submission: Each Sui Full node orchestrates transaction submission to the quorum of the Sui Validators, and, optionally if configured, locally executes the finalized transactions (called fast path execution), which circumvents the wait for checkpoint synchronization.\nSui Full node Data and RPC types​\n\nA Sui Full Node stores multiple categories of data in its permanent store.\n\nINFO\n\nThe per-epoch Sui store is beyond the scope of this topic. Sui uses the per-epoch store (resets at the start of each epoch) internally for authority and consensus operations.\n\nSui Full nodes store the following types of data:\n\nTransactions with associated effects and events: Sui uses a unique transaction digest to retrieve information about a transaction, including its effects and emitted events. Sui Full nodes don't require the historic transaction information for basic Full node operations. To conserve drive space, you can enable pruning to remove this historical data.\nCheckpoints: Sui groups committed transactions in checkpoints, and then uses those checkpoints to achieve state synchronization. Checkpoints keep transaction digests that contain additional integrity metadata. Sui Full nodes don't require data from checkpoints to execute and submit transactions, so you can configure pruning for this data as well.\nObjects: Transactions that mutate objects create new object versions. Each object has a unique pair of (objectId, version) used to identify the object. Sui Full nodes don't require historic object versions to execute and submit transactions, so you can configure your Full node to also prune this data.\nIndexing information: A Full node default configuration is to post-process the committed transactions: it indexes the committed information to enable efficient aggregation and filtering queries. For example, the indexing can be useful for retrieving all the historic transactions of a given sender, or finding all the objects owned by an address.\n\nSui Full nodes support more than 40 RPC types that includes the following categories:\n\nGeneral metadata, such as sui_getProtocolConfig and sui_getChainIdentier. These requests don't depend on additional indexing and don't require historic data to process.\nDirect lookups, such as sui_getObject, sui_getEvents. These requests don't depend on additional indexing, but require historic data in some cases, such as sui_tryGetPastObject and sui_getTransactionBlock.\nAccumulation and filtering queries,such as suix_getOwnedObjects and suix_getCoins. These requests depend on additional indexing, and require historic data in some cases, such as suix_queryTransactionBlocks.\nINFO\n\nSui plans to migrate the RPC endpoints that require additional indexing away from Sui Full nodes in the near future. This plan decouples the storage that is backing transaction execution from the storage that is better suited for data indexing.\n\nSui Archival data​\n\nA Sui archive instance stores the full Sui transaction history since genesis in a database agnostic format. This includes information about transactions (with client authentication), effects, events, and checkpoints. As such, archival storage can be used for data auditing and for replaying historic transactions.\n\nINFO\n\nThe current archival storage format doesn't include historic object versions.\n\nAs a Full node operator, you can enable archival fallback for your Full node by specifying the URL to upload archival data. Currently, Mysten Labs manages a Sui archive and stores it in AWS S3. To ensure a healthy network, we encourage the Sui community to set up additional archives to ensure archival data availability across the network. In a typical configuration, an archive trails behind the latest checkpoint by approximately 10 minutes.\n\nA Full Node that starts from scratch can replay (and thus re-verify) transactions that occurred since Sui genesis from the given archive via configuring Archival Fallback in the fullnode.yaml configuration file to point to the S3 bucket that stores the archive.\n\nA Sui Full node that fails to retrieve checkpoints from its peers via state sync protocol falls back to downloading the missing checkpoints from its pre-configured archive. This fallback enables a Full node to catch up with the rest of the system regardless of the pruning policies of its peers.\n\nSui Full node pruning policies​\n\nAs described previously, sustainable disk usage requires Sui Full nodes to prune the information about historic object versions as well as historic transactions with the corresponding effects and events, including old checkpoint data.\n\nBoth transaction and object pruners run in the background. The logical deletion of entries from RocksDB ultimately triggers the physical compaction of data on disk, which is governed by RocksDB background jobs: the pruning effect on disk usage is not immediate and might take multiple days.\n\nTo learn more about object pruning policies, see Object pruning. You can configure the pruner in two modes:\n\naggressive pruning (num-epochs-to-retain: 0): Preferred option. Sui prunes old object versions as soon as possible.\nepoch-based pruning (num-epochs-to-retain: X): Sui prunes old object versions after X epochs.\nTIP\n\nTesting indicates that aggressive pruning results in more efficient Full Node operation.\n\nTo learn more about transaction pruning policies, see Transaction pruning. To configure transaction pruning, specify the num-epochs-to-retain-for-checkpoints: X config option. The checkpoints, including their transactions, effects and events are pruned up to X epochs ago. We suggest setting transaction pruning to 2 epochs.\n\nSet an archiving watermark​\n\nIn case your Full node is configured to upload committed information to an archive, you should ensure that pruning doesn't occur until after the corresponding data is uploaded. To do so, set the use-for-pruning-watermark: true in the Fullnode.yaml file as described in Archival fallback.\n\nSui Full node key-value store backup​\n\nTo enable historic data queries for the Sui Full nodes that prune old transactional data, Full node RPC implementation is configured to fallback for querying missing transactional data from a remote store.\n\nIf the information about the transaction digest, effects, events, or checkpoints is not available locally, a Full node automatically retrieves the historical data from a cloud-based key-value store (currently managed by MystenLabs). Note that the current key-value store implementation keeps historic transactional data only: we plan to provide support for a similar setup for retrieving the historic object versions in a future release.\n\nPruning policy examples​\n\nUse the examples in this section to configure your Sui Full node. You can copy the examples, and then, optionally, modify the values as appropriate for your environment.\n\nValidator and minimal Full node​\n\nThis configuration keeps disk usage to a minimum. It is suitable for most validators. A Full node with this configuration cannot answer queries that require indexing or historic data.\n\n# Do not generate or maintain indexing of Sui data on the node\nenable-index-processing: false\n\nauthority-store-pruning-config:\n  # default values\n  num-latest-epoch-dbs-to-retain: 3\n  epoch-db-pruning-period-secs: 3600\n  max-checkpoints-in-batch: 10\n  max-transactions-in-batch: 1000\n  # end of default values\n\n  # Prune historic object versions as soon as possible.\n  num-epochs-to-retain: 0\n  # Prune historic transactions of the past epochs\n  num-epochs-to-retain-for-checkpoints: 2\n  periodic-compaction-threshold-days: 1\n  # Smooth pruning traffic throughout an epoch\n  smooth: true\n\nFull node with indexing but no history​\n\nThis setup manages secondary indexing in addition to the latest state, but aggressively prunes historic data. A Full node with this configuration:\n\nAnswers RPC queries that require indexing, like suix_getBalance().\nAnswers RPC queries that require historic transactions via a fallback to retrieve the data from a remote key-value store: sui_getTransactionBlock().\nCannot answer RPC queries that require historic object versions: sui_tryGetPastObject().\nThe showBalanceChanges filter of sui_getTransactionBlock() query relies on historic object versions, so it can't work with this configuration.\nauthority-store-pruning-config:\n  # default values\n  num-latest-epoch-dbs-to-retain: 3\n  epoch-db-pruning-period-secs: 3600\n  max-checkpoints-in-batch: 10\n  max-transactions-in-batch: 1000\n  # end of default values\n\n  # Prune historic object versions\n  num-epochs-to-retain: 0\n  # Prune historic transactions of the past epochs\n  num-epochs-to-retain-for-checkpoints: 2\n  periodic-compaction-threshold-days: 1\n  # Smooth pruning traffic throughout an epoch\n  smooth: true\n\nFull node with full object history but pruned transaction history​\n\nThis configuration manages the full object history while still pruning historic transactions. A Full node with this configuration can answer all historic and indexing queries (using the transaction query fallback for transactional data), including the ones that require historic objects such as the showBalanceChanges filter of sui_getTransactionBlock().\n\nThe main caveat is that the current setup enables transaction pruner to go ahead of object pruner. The object pruner might not be able to properly clean up the objects modified by the transactions that have been already pruned. You should closely monitor the disk space growth on a Full node with this configuration.\n\nIn addition to the regular (pruned) snapshots, Mysten Labs also maintains special RocksDB snapshots with full history of object versions available for the operators using this configuration.\n\nauthority-store-pruning-config:\n  # default values\n  num-latest-epoch-dbs-to-retain: 3\n  epoch-db-pruning-period-secs: 3600\n  max-checkpoints-in-batch: 10\n  max-transactions-in-batch: 1000\n  # end of default values\n\n  # No pruning of object versions (use u64::max for num of epochs)\n  num-epochs-to-retain: 18446744073709551615\n  # Prune historic transactions of the past epochs\n  num-epochs-to-retain-for-checkpoints: 2\n  periodic-compaction-threshold-days: 1\n  # Smooth pruning traffic throughout an epoch\n  smooth: true\n\nEdit this page\nPrevious\nSui Validator Node Configuration\nNext\nDatabase Snapshots\nBasic Sui Full node functionality\nSui Full node Data and RPC types\nSui Archival data\nSui Full node pruning policies\nSet an archiving watermark\nSui Full node key-value store backup\nPruning policy examples\nValidator and minimal Full node\nFull node with indexing but no history\nFull node with full object history but pruned transaction history\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/versioning",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nObject Ownership\nDynamic Fields\nTransfers\nEvents\nObject and Package Versioning\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersObject ModelObject and Package Versioning\nObject and Package Versioning\n\nYou reference every object stored on chain by an ID and version. When a transaction modifies an object, it writes the new contents to an on-chain reference with the same ID but a later version. This means that a single object (with ID I) might appear in multiple entries in the distributed store:\n\n(I, v0) => ...\n(I, v1) => ...  # v0 < v1\n(I, v2) => ...  # v1 < v2\n\n\nDespite appearing multiple times in the store, only one version of the object is available to transactions - the latest version (v2 in the previous example). Moreover, only one transaction can modify the object at that version to create a new version, guaranteeing a linear history (v1 was created in a state where I was at v0, and v2 was created in a state where I was at v1).\n\nVersions are strictly increasing and (ID, version) pairs are never re-used. This structure allows node operators to prune their stores of old object versions that are now inaccessible, if they choose. This is not a requirement, though, as node operators might keep prior object versions around to serve requests for an object's history, either from other nodes that are catching up, or from RPC requests.\n\nMove objects​\n\nSui uses Lamport timestamps in its versioning algorithm for objects. The use of Lamport timestamps guarantees that versions never get re-used as the new version for objects touched by a transaction is one greater than the latest version among all input objects to the transaction. For example, a transaction transferring an object O at version 5 using a gas object G at version 3 updates both O and G versions to 1 + max(5, 3) = 6 (version 6).\n\nThe following sections detail the relevance of Lamport versions for maintaining the \"no (ID, version) re-use\" invariant or for accessing an object as a transaction input changes depending on that object's ownership.\n\nAddress-owned objects​\n\nYou must reference address-owned transaction inputs at a specific ID and version. When a validator signs a transaction with an owned object input at a specific version, that version of the object is locked to that transaction. Validators reject requests to sign other transactions that require the same input (same ID and version).\n\nIf F + 1 validators sign one transaction that takes an object as input, and a different F + 1 validators sign a different transaction that takes the same object as input, that object (and all the other inputs to both transactions) is equivocated, meaning they cannot be used for any further transactions in that epoch. This is because neither transaction can form a quorum without relying on a signature from a validator that has already committed the object to a different transaction, which it cannot get. All locks are reset at the end of the epoch, which frees the objects again.\n\nINFO\n\nOnly an object's owner can equivocate it, but this is not a desirable thing to do. You can avoid equivocation by carefully managing the versions of address-owned input objects: never attempt to execute two different transactions that use the same object. If you don't get a definite success or failure response from the network for a transaction, assume that the transaction might have gone through, and do not re-use any of its objects for different transactions.\n\nImmutable objects​\n\nLike address-owned objects, you reference immutable objects at an ID and version, but they do not need to be locked as their contents and versions do not change. Their version is relevant because they could have started life as an address-owned object before being frozen. The given version identifies the point at which they became immutable.\n\nShared objects​\n\nSpecifying a shared transaction input is slightly more complex. You reference it by its ID, the version it was shared at, and a flag indicating whether it is accessed mutably. You don't specify the precise version the transaction accesses because consensus decides that during transaction scheduling. When scheduling multiple transactions that touch the same shared object, validators agree the order of those transactions, and pick each transaction's input versions for the shared object accordingly (one transaction's output version becomes the next transaction's input version, and so on).\n\nShared transaction inputs that you reference immutably participate in scheduling, but don't modify the object or increment its version.\n\nWrapped objects​\n\nYou can't access wrapped objects by their ID in the object store, you must access them by the object that wraps them. Consider the following example that creates a make_wrapped function with an Inner object, wrapped in an Outer object, which is returned to the transaction sender.\n\nmodule example::wrapped {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    struct Inner has key, store {\n        id: UID,\n        x: u64,\n    }\n\n    struct Outer has key {\n        id: UID,\n        inner: Inner,\n    }\n\n    entry fun make_wrapped(ctx: &mut TxContext) {\n        let inner = Inner {\n            id: object::new(ctx),\n            x: 42,\n        };\n\n        let outer = Outer {\n            id: object::new(ctx),\n            inner,\n        };\n\n        transfer::transfer(outer, tx_context::sender(ctx));\n    }\n}\n\n\nThe owner of Outer in this example must specify it as the transaction input and then access its inner field to read the instance of Inner. Validators refuse to sign transactions that directly specify wrapped objects (like the inner of an Outer) as inputs. As a result, you don't need to specify a wrapped object's version in a transaction that reads that object.\n\nWrapped objects can eventually become \"unwrapped\", meaning that they are once again accessible at their ID:\n\nmodule example::wrapped {\n    // ...\n\n    entry fun unwrap(outer: Outer, ctx: &TxContext) {\n        let Outer { id, inner } = outer;\n        object::delete(id);\n        transfer::transfer(inner, tx_context::sender(ctx));\n    }\n}\n\n\nThe unwrap function in the previous code takes an instance of Outer, destroys it, and sends the Inner back to the sender. After calling this function, the previous owner of Outer can access Inner directly by its ID because it is now unwrapped. Wrapping and unwrapping of an object can happen multiple times across its lifespan, and the object retains its ID across all those events.\n\nThe Lamport timestamp-based versioning scheme ensures that the version that an object is unwrapped at is always greater than the version it was wrapped at, to prevent version re-use.\n\nAfter a transaction, W, where object I is wrapped by object O, the O version is greater than or equal to the I version. This means one of the following conditions is true:\nI is an input so has a strictly lower version.\nI is new and has an equal version.\nAfter a later transaction unwrapping I out of O, the following must be true:\nThe O input version is greater than or equal to its version after W because it is a later transaction, so the version can only have increased.\nThe I version in the output must be strictly greater than the O input version.\n\nThis leads to the following chain of inequalities for I's version before wrapping:\n\nless than or equal to O's version after wrapping\nless than or equal to O's version before unwrapping\nless than I's version after unwrapping\n\nSo the I version before wrapping is less than the I version after unwrapping.\n\nDynamic fields​\n\nFrom a versioning perspective, values held in dynamic fields behave like wrapped objects:\n\nThey are only accessible via the field's parent object, not as direct transaction inputs.\nBased on the previous point, you do not need to supply their IDs or versions with the transaction inputs.\nLamport timestamp-based versioning makes sure that when a field contains an object and a transaction removes that field, its value becomes accessible by its ID and the value's version has been incremented to a previously unused version.\nINFO\n\nOne distinction dynamic fields have to wrapped objects is that if a transaction modifies a dynamic object field, its version is incremented in that transaction, where a wrapped object's version would not be.\n\nAdding a new dynamic field to a parent object also creates a Field object, responsible for associating the field name and value with that parent. Unlike other newly created objects, the ID for the resulting instance of Field is not created using sui::object::new. Instead, it is computed as a hash of the parent object ID and the type and value of the field name, so that you can use it to look-up the Field via its parent and name.\n\nWhen you remove a field, Sui deletes its associated Field, and if you add a new field with the same name, Sui creates a new instance with the same ID. Versioning using Lamport timestamps, coupled with dynamic fields being only accessible through their parent object, ensures that (ID, version) pairs are not reused in the process:\n\nThe transaction that deletes the original field increments the parent's version to be greater than the deleted field's version.\nThe transaction that creates the new version of the same field creates the field with a version that is greater than the parent's version.\n\nSo the version of the new Field instance is greater than the version of the deleted Field.\n\nPackages​\n\nMove packages are also versioned and stored on chain, but follow a different versioning scheme to objects because they are immutable from their inception. This means that you refer to package transaction inputs (for example, the package that a function is from for a Move call transaction) by just their ID, and are always loaded at their latest version.\n\nUser packages​\n\nEvery time you publish or upgrade a package, Sui generates a new ID. A newly published package has its version set to 1, whereas an upgraded package's version is one greater than the package it is upgrading. Unlike objects, older versions of a package remain accessible even after being upgraded. For example, imagine a package P that is published and upgraded twice. It might be represented in the store as:\n\n(0x17fb7f87e48622257725f584949beac81539a3f4ff864317ad90357c37d82605, 1) => P v1\n(0x260f6eeb866c61ab5659f4a89bc0704dd4c51a573c4f4627e40c5bb93d4d500e, 2) => P v2\n(0xd24cc3ec3e2877f085bc756337bf73ae6976c38c3d93a0dbaf8004505de980ef, 3) => P v3\n\n\nIn this example, all three versions of the same package are at different IDs. The packages have increasing versions but it is possible to call into v1, even though v2 and v3 exist on chain.\n\nFramework packages​\n\nFramework packages (such as the Move standard library at 0x1,the Sui Framework at 0x2, Sui System at 0x3 and Deepbook at 0xdee9) are a special-case because their IDs must remain stable across upgrades. The network can upgrade framework packages while preserving their IDs via a system transaction, but can only perform this operation on epoch boundaries because they are considered immutable like other packages. New versions of framework packages retain the same ID as their predecessor, but increment their version by one:\n\n(0x1, 1) => MoveStdlib v1\n(0x1, 2) => MoveStdlib v2\n(0x1, 3) => MoveStdlib v3\n\n\nThe prior example shows the on-chain representation of the first three versions of the Move standard library.\n\nPackage versions​\n\nSui smart contracts are organized into upgradeable packages and, as a result, multiple versions of any given package can exist on chain. Before someone can use an on-chain package, you must publish its first, original version. When you upgrade a package, you create a new version of that package. Each upgrade of a package is based on the immediately preceding version of that package in the versions history. In other words, you can upgrade the nth version of a package from only the nth - 1 version. For example, you can upgrade a package from version 1 to 2, but afterwards you can upgrade that package only from version 2 to 3; you're not allowed to upgrade from version 1 to 3.\n\nThere is a notion of versioning in package manifest files, existing in both the package section and in the dependencies section. For example, consider the manifest code that follows:\n\n[package]\nname = \"some_pkg\"\nversion = \"1.0.0\"\n\n[dependencies]\nanother_pkg = { git = \"https://github.com/another_pkg/another_pkg.git\" , version = \"2.0.0\"}\n\n\nAt this point, the version references in the manifest are used only for user-level documentation as the publish and upgrade commands do not leverage this information. If you publish a package with a certain package version in the manifest file and then modify and re-publish the same package with a different version (using publish command rather than upgrade command), the two are considered different packages, rather than on-chain versions of the same package. You cannot use any of these packages as a dependency override to stand in for the other one. While you can specify this type of override when building a package, it results in an error when publishing or upgrading on chain.\n\nEdit this page\nPrevious\nEvents\nNext\nMove Concepts\nMove objects\nAddress-owned objects\nImmutable objects\nShared objects\nWrapped objects\nDynamic fields\nPackages\nUser packages\nFramework packages\nPackage versions\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Transactions | Sui Documentation",
      "url": "https://docs.sui.io/concepts/transactions",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nTransactions\nProgrammable Transaction Blocks\nSponsored Transactions\nGas Smashing\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersTransactions\nTransactions\n\nAll updates to the Sui database happen via transactions. This topic describes the transaction types supported by Sui and explains how their execution changes the ledger. There are only two kinds of transactions on Sui:\n\nProgrammable transaction blocks, which anyone can submit on the network. For information on these transactions, see Programmable Transaction Blocks.\nSystem transactions, which only validators can directly submit and are responsible for keeping the network running (changing epochs, starting checkpoints, and so on).\nTransaction metadata​\n\nAll Sui transactions have the following common metadata:\n\nSender address: The address of the user sending this transaction.\nGas input: An object reference pointing to the object that will be used to pay for this transaction's execution and storage. This object must be owned by the user and must be of type sui::coin::Coin<SUI> (i.e., the Sui native currency).\nGas price: An unsigned integer specifying the number of native tokens per gas unit this transaction will pay. The gas price must always be nonzero.\nMaximum gas budget: The maximum number of gas units that can be expended by executing this transaction. If this budget is exceeded, transaction execution will abort and have no effects other than debiting the gas input object. Consequently, the gas input object must have a value higher than the gas price multiplied by the max gas, and this product is the maximum amount that the gas input object will be debited for the transaction.\nEpoch: The Sui epoch this transaction is intended for.\nType: A call, publish, or native transaction and its type-specific-data (see below).\nAuthenticator: A cryptographic signature and a public key that both verifies against the signature and is cryptographically committed to by the sender address.\nExpiration: An epoch reference that sets a deadline after which validators will no longer consider the transaction valid. The optional expiration epoch reference enables users to define transactions that either execute and commit by a set time (current epoch less than or equal to expiration epoch), or never execute after the deadline passes. By default, there is no deadline for when a transaction must execute.\nTransactions flow - example​\n\nHere's an example showing how objects and transactions are connected to each other in Sui.\n\nIn the following example there are two objects:\n\nObject A is a coin of type SUI with a total balance of 5 SUI\nObject B with 2 SUI coins that belongs to John\n\nTom decides to send 1 SUI coin to Alice. In this case, Object A is the input to this transaction and 1 SUI coin is debited from this object. The output of the transaction is two objects:\n\nObject A with 4 SUI coins that still belongs to Tom\nnew created Object C with 1 SUI coin that belongs now to Alice\n\nAt the same time, John decides to send 2 SUI coins to Anna. Because the relationship between objects and transactions is written in a directed acyclic graph (DAG), and both transactions interact with different objects, this transaction executes in parallel with the transaction that sends coins from Tom to Alice. This transaction changes only the owner of Object B from John to Anna.\n\nAfter receiving 2 SUI coins, Anna sent them immediately to Tom. Now Tom has 6 SUI coins (4 from Object A and 2 from Object B).\n\nFinally, Tom sends all of his SUI coins to John. For this transaction, the input is actually two objects (Object A and Object B). Object B is destroyed, and its value is added to Object A. As a result, the transaction's output is only Object A with a value of 6 SUI.\n\ntx-1\ntx-1\ntx-2\ntx-3\ntx-4\ntx-4\nObject A\n 5 SUI\n Tom\nObject C\n 1 SUI\n Alice\nObject A\n 4 SUI\n Tom\nObject B\n 2 SUI\n John\nObject B\n 2 SUI\n Anna\nObject B\n 2 SUI\n Tom\nObject A\n 6 SUI\n John\nLimits on transactions, objects, and data​\n\nSui has some limits on transactions and the data used in them, such as a maximum size and number of objects used. You can find the these limits in the sui-protocol-config crate of the Sui repo. The limits are defined in the ProtocolConfig struct and values set in the get_for_version_impl function.\n\nEdit this page\nPrevious\nConventions\nNext\nProgrammable Transaction Blocks\nTransaction metadata\nTransactions flow - example\nLimits on transactions, objects, and data\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Conventions | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/conventions",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewConventions\nConventions\n\nThe following recommendations are based on 2024 Move.\n\nAdd section titles​\n\nUse titles in code comments to create sections for your Move code files. Structure your titles using === on either side of the title.\n\nmodule conventions::comments {\n  // === Imports ===\n\n  // === Errors ===\n\n  // === Constants ===\n\n  // === Structs ===\n\n  // === Method Aliases ===\n\n  // === Public-Mutative Functions ===\n\n  // === Public-View Functions ===\n\n  // === Admin Functions ===\n\n  // === Public-Package Functions ===\n\n  // === Private Functions ===\n\n  // === Test Functions ===\n}\n\nCRUD functions names​\n\nThese are the available CRUD functions:\n\nadd: Adds a value.\nnew: Creates an object.\ndrop: Drops a struct.\nempty: Creates a struct.\nremove: Removes a value.\nexists_: Checks if a key exists.\ncontains: Checks if a collection contains a value.\ndestroy_empty: Destroys an object or data structure that has values with the drop ability.\nto_object_name: Transforms an Object X to Object Y.\nfrom_object_name: Transforms an Object Y to Object X.\nproperty_name: Returns an immutable reference or a copy.\nproperty_name_mut: Returns a mutable reference.\nPotato structs​\n\nDo not use 'potato' in the name of structs. The lack of abilities define it as a potato pattern.\n\nmodule conventions::request {\n  // ✅ Right\n  struct Request {}\n\n  // ❌ Wrong\n  struct RequestPotato {}\n}\n\nRead functions​\n\nBe mindful of the dot syntax when naming functions. Avoid using the object name on function names.\n\nmodule conventions::profile {\n\n  struct Profile {\n    age: u64\n  }\n\n  // ✅ Right\n  public fun age(self: &Profile):  u64 {\n    self.age\n  }\n\n  // ❌ Wrong\n  public fun profile_age(self: &Profile): u64 {\n    self.age\n  }\n}\n\nmodule conventions::defi {\n\n  use conventions::profile::{Self, Profile};\n\n  public fun get_tokens(profile: &Profile) {\n\n   // ✅ Right\n   let name = profile.age();\n\n   // ❌ Wrong\n   let name2 = profile.profile_age();\n  }\n}\n\nEmpty function​\n\nName the functions that create data structures as empty.\n\nmodule conventions::collection {\n\n  struct Collection has copy, drop, store {\n    bits: vector<u8>\n  }\n\n  public fun empty(): Collection {\n    Collection {\n      bits: vector[]\n    }\n  }\n}\n\nNew function​\n\nName the functions that create objects as new.\n\nmodule conventions::object {\n\n  use sui::object::{Self, UID};\n  use sui::tx_context::TxContext;\n\n  struct Object has key, store {\n    id: UID\n  }\n\n  public fun new(ctx:&mut TxContext): Object {\n    Object {\n      id: object::new(ctx)\n    }\n  }\n}\n\nShared objects​\n\nLibrary modules that share objects should provide two functions: one to create the object and another to share it. It allows the caller to access its UID and run custom functionality before sharing it.\n\nmodule conventions::profile {\n\n  use sui::object::{Self, UID};\n  use sui::tx_context::TxContext;\n  use sui::transfer::share_object;\n\n  struct Profile has key {\n    id: UID\n  }\n\n  public fun new(ctx:&mut TxContext): Profile {\n    Profile {\n      id: object::new(ctx)\n    }\n  }\n\n  public fun share(profile: Profile) {\n    share_object(profile);\n  }\n}\n\nReference functions​\n\nName the functions that return a reference as <PROPERTY-NAME>_mut or <PROPERTY-NAME>, replacing with <PROPERTY-NAME\\> the actual name of the property.\n\nmodule conventions::profile {\n\n  use std::string::String;\n\n  use sui::object::UID;\n\n  struct Profile has key {\n    id: UID,\n    name: String,\n    age: u8\n  }\n\n  // profile.name()\n  public fun name(self: &Profile): &String {\n    &self.name\n  }\n\n  // profile.age_mut()\n  public fun age_mut(self: &mut Profile): &mut u8 {\n    &mut self.age\n  }\n}\n\nSeparation of concerns​\n\nDesign your modules around one object or data structure. A variant structure should have its own module to avoid complexity and bugs.\n\nmodule conventions::wallet {\n\n  use sui::object::UID;\n\n  struct Wallet has key, store {\n    id: UID,\n    amount: u64\n  }\n}\n\nmodule conventions::claw_back_wallet {\n\n  use sui::object::UID;\n\n  struct Wallet has key {\n    id: UID,\n    amount: u64\n  }\n}\n\nErrors​\n\nUse PascalCase for errors, start with an E and be descriptive.\n\nmodule conventions::errors {\n  // ✅ Right\n  const ENameHasMaxLengthOf64Chars: u64 = 0;\n\n  // ❌ Wrong\n  const INVALID_NAME: u64 = 0;\n}\n\nStruct property comments​\n\nDescribe the properties of your structs.\n\nmodule conventions::profile {\n\n  use std::string::String;\n\n  use sui::object::UID;\n\n  struct Profile has key, store {\n    id: UID,\n    /// The age of the user\n    age: u8,\n    /// The first name of the user\n    name: String\n  }\n}\n\nDestroy functions​\n\nProvide functions to delete objects. Destroy empty objects with the function destroy_empty. Use the function drop for objects that have types that can be dropped.\n\nmodule conventions::wallet {\n\n  use sui::object::{Self, UID};\n  use sui::balance::{Self, Balance};\n  use sui::sui::SUI;\n\n  struct Wallet<Value> has key, store {\n    id: UID,\n    value: Value\n  }\n\n  // Value has drop\n  public fun drop<Value: drop>(self: Wallet<Value>) {\n    let Wallet { id, value: _ } = self;\n    object::delete(id);\n  }\n\n  // Value doesn't have drop\n  // Throws if the `wallet.value` is not empty.\n  public fun destroy_empty(self: Wallet<Balance<SUI>>) {\n    let Wallet { id, value } = self;\n    object::delete(id);\n    balance::destroy_zero(value);\n  }\n}\n\nPure functions​\n\nKeep your functions pure to maintain composability. Do not use transfer::transfer or transfer::public_transfer inside core functions.\n\nmodule conventions::amm {\n\n  use sui::transfer;\n  use sui::coin::Coin;\n  use sui::object::UID;\n  use sui::tx_context::{Self, TxContext};\n\n  struct Pool has key {\n    id: UID\n  }\n\n  // ✅ Right\n  // Return the excess coins even if they have zero value.\n  public fun add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>): (Coin<LpCoin>, Coin<CoinX>, Coin<CoinY>) {\n    // Implementation omitted.\n    abort(0)\n  }\n\n  // ✅ Right\n  public fun add_liquidity_and_transfer<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, recipient: address) {\n    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);\n    transfer::public_transfer(lp_coin, recipient);\n    transfer::public_transfer(coin_x, recipient);\n    transfer::public_transfer(coin_y, recipient);\n  }\n\n  // ❌ Wrong\n  public fun impure_add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, ctx: &mut TxContext): Coin<LpCoin> {\n    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);\n    transfer::public_transfer(coin_x, tx_context::sender(ctx));\n    transfer::public_transfer(coin_y, tx_context::sender(ctx));\n\n    lp_coin\n  }\n}\n\nCoin argument​\n\nPass the Coin object by value with the right amount directly because it's better for transaction readability from the frontend.\n\nmodule conventions::amm {\n\n  use sui::coin::Coin;\n  use sui::object::UID;\n\n  struct Pool has key {\n    id: UID\n  }\n\n  // ✅ Right\n  public fun swap<CoinX, CoinY>(coin_in: Coin<CoinX>): Coin<CoinY> {\n    // Implementation omitted.\n    abort(0)\n  }\n\n  // ❌ Wrong\n  public fun exchange<CoinX, CoinY>(coin_in: &mut Coin<CoinX>, value: u64): Coin<CoinY> {\n    // Implementation omitted.\n    abort(0)\n  }\n}\n\nAccess control​\n\nTo maintain composability, use capabilities instead of addresses for access control.\n\nmodule conventions::access_control {\n\n  use sui::sui::SUI;\n  use sui::object::UID;\n  use sui::balance::Balance;\n  use sui::coin::{Self, Coin};\n  use sui::table::{Self, Table};\n  use sui::tx_context::{Self, TxContext};\n\n  struct Account has key, store {\n    id: UID,\n    balance: u64\n  }\n\n  struct State has key {\n    id: UID,\n    accounts: Table<address, u64>,\n    balance: Balance<SUI>\n  }\n\n  // ✅ Right\n  // With this function, another protocol can hold the `Account` on behalf of a user.\n  public fun withdraw(state: &mut State, account: &mut Account, ctx: &mut TxContext): Coin<SUI> {\n    let authorized_balance = account.balance;\n\n    account.balance = 0;\n\n    coin::take(&mut state.balance, authorized_balance, ctx)\n  }\n\n  // ❌ Wrong\n  // This is less composable.\n  public fun wrong_withdraw(state: &mut State, ctx: &mut TxContext): Coin<SUI> {\n    let sender = tx_context::sender(ctx);\n\n    let authorized_balance = table::borrow_mut(&mut state.accounts, sender);\n    let value = *authorized_balance;\n    *authorized_balance = 0;\n    coin::take(&mut state.balance, value, ctx)\n  }\n}\n\nData storage in owned vs shared objects​\n\nIf your dApp data has a one to one relationship, it's best to use owned objects.\n\nmodule conventions::vesting_wallet {\n\n  use sui::sui::SUI;\n  use sui::coin::Coin;\n  use sui::object::UID;\n  use sui::table::Table;\n  use sui::balance::Balance;\n  use sui::tx_context::TxContext;\n\n  struct OwnedWallet has key {\n    id: UID,\n    balance: Balance<SUI>\n  }\n\n  struct SharedWallet has key {\n    id: UID,\n    balance: Balance<SUI>,\n    accounts: Table<address, u64>\n  }\n\n  /*\n  * A vesting wallet releases a certain amount of coin over a period of time.\n  * If the entire balance belongs to one user and the wallet has no additional functionalities, it is best to store it in an owned object.\n  */\n  public fun new(deposit: Coin<SUI>, ctx: &mut TxContext): OwnedWallet {\n    // Implementation omitted.\n    abort(0)\n  }\n\n  /*\n  * If you wish to add extra functionality to a vesting wallet, it is best to share the object.\n  * For example, if you wish the issuer of the wallet to be able to cancel the contract in the future.\n  */\n  public fun new_shared(deposit: Coin<SUI>, ctx: &mut TxContext) {\n    // Implementation omitted.\n    // It shares the `SharedWallet`.\n    abort(0)\n  }\n}\n\nAdmin capability​\n\nIn admin-gated functions, the first parameter should be the capability. It helps the autocomplete with user types.\n\nmodule conventions::social_network {\n\n  use std::string::String;\n\n  use sui::object::UID;\n\n  struct Account has key {\n    id: UID,\n    name: String\n  }\n\n  struct Admin has key {\n    id: UID,\n  }\n\n  // ✅ Right\n  // cap.update(&mut account, b\"jose\");\n  public fun update(_: &Admin, account: &mut Account, new_name: String) {\n    // Implementation omitted.\n    abort(0)\n  }\n\n  // ❌ Wrong\n  // account.update(&cap, b\"jose\");\n  public fun set(account: &mut Account, _: &Admin, new_name: String) {\n    // Implementation omitted.\n    abort(0)\n  }\n}\n\nEdit this page\nPrevious\nCustom Upgrade Policies\nNext\nTransactions\nAdd section titles\nCRUD functions names\nPotato structs\nRead functions\nEmpty function\nNew function\nShared objects\nReference functions\nSeparation of concerns\nErrors\nStruct property comments\nDestroy functions\nPure functions\nCoin argument\nAccess control\nData storage in owned vs shared objects\nAdmin capability\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "One-Time Witness | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/one-time-witness",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewOne-Time Witness\nOne-Time Witness\n\nA one-time witness (OTW) is a special type that is guaranteed to have at most one instance. It is useful for limiting certain actions to only happen once (for example, creating a coin). In Move, a type is considered a OTW if:\n\nIts name is the same as its module's names, all uppercased.\nIt has the drop ability and only the drop ability.\nIt has no fields, or a single bool field.\n\nThe only instance of this type is passed to its module's init function when the package containing it is published.\n\nTo check whether a type could be used as a OTW, pass an instance of it to sui::types::is_one_time_witness.\n\nmodule examples::mycoin {\n\n    /// Name matches the module name\n    struct MYCOIN has drop {}\n\n    /// The instance is received as the first argument\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        /* ... */\n    }\n}\n\n\nThe following example illustrates how you could use a OTW:\n\n/// This example illustrates how One Time Witness works.\n///\n/// One Time Witness (OTW) is an instance of a type which is guaranteed to\n/// be unique across the system. It has the following properties:\n///\n/// - created only in module initializer\n/// - named after the module (uppercased)\n/// - cannot be packed manually\n/// - has a `drop` ability\nmodule examples::one_time_witness_registry {\n    use sui::tx_context::TxContext;\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::transfer;\n\n    // This dependency allows us to check whether type\n    // is a one-time witness (OTW)\n    use sui::types;\n\n    /// For when someone tries to send a non OTW struct\n    const ENotOneTimeWitness: u64 = 0;\n\n    /// An object of this type will mark that there's a type,\n    /// and there can be only one record per type.\n    struct UniqueTypeRecord<phantom T> has key {\n        id: UID,\n        name: String\n    }\n\n    /// Expose a public function to allow registering new types with\n    /// custom names. With a `is_one_time_witness` call we make sure\n    /// that for a single `T` this function can be called only once.\n    public fun add_record<T: drop>(\n        witness: T,\n        name: String,\n        ctx: &mut TxContext\n    ) {\n        // This call allows us to check whether type is an OTW;\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n\n        // Share the record for the world to see. :)\n        transfer::share_object(UniqueTypeRecord<T> {\n            id: object::new(ctx),\n            name\n        });\n    }\n}\n\n/// Example of spawning an OTW.\nmodule examples::my_otw {\n    use std::string;\n    use sui::tx_context::TxContext;\n    use examples::one_time_witness_registry as registry;\n\n    /// Type is named after the module but uppercased\n    struct MY_OTW has drop {}\n\n    /// To get it, use the first argument of the module initializer.\n    /// It is a full instance and not a reference type.\n    fun init(witness: MY_OTW, ctx: &mut TxContext) {\n        registry::add_record(\n            witness, // here it goes\n            string::utf8(b\"My awesome record\"),\n            ctx\n        )\n    }\n}\n\nEdit this page\nPrevious\nEntry Functions\nNext\nPackage Upgrades\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Entry Functions | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/entry-functions",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewEntry Functions\nEntry Functions\n\nThe entry modifier allows a function to be called directly from a programmable transaction block, as an \"entrypoint\" to the module.\n\nWhen called this way, parameters passed to entry functions must be inputs to the transaction block, not the results of previous transactions in that block, and not modified by previous transactions in that block. Entry functions are also only allowed to return types that have drop.\n\nThese restrictions prevent third parties using the scriptable nature of programmable transaction blocks to bypass the fact that entry functions are not otherwise allowed to be called from other modules.\n\npublic vs entry functions​\n\nThe public modifier also allows a function to be called from a programmable transaction block. It additionally allows the function to be called from other modules, and does not impose the same restrictions on where the function's parameters can come from and what it can return, so in many cases public is the right way to expose your function to the outside world. entry is useful if:\n\nYou want strong guarantees that your function is not being combined with third-party module functions, in programmable transaction blocks. The canonical example of this is a swap protocol that does not want to interact with a flash loan provider: If the swap protocol exposes only entry functions to perform swaps, it will not be possible to pass in a flash loaned Coin, because that coin will be the output of some previous transaction.\nYou do not want the function's signature to appear in your module's ABI. public function signatures must be maintained by upgrades while entry function signatures do not.\n\nIt is also possible to create a public entry function, which can be called by other modules and by programmable transaction blocks but is restricted like an entry function in the latter case. This is rarely useful -- you probably only want one of public or entry.\n\nExample​\nmodule entry_functions::example {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    struct Foo has key {\n        id: UID,\n        bar: u64,\n    }\n\n    /// Entry functions can accept a reference to the `TxContext`\n    /// (mutable or immutable) as their last parameter.\n    entry fun share(bar: u64, ctx: &mut TxContext) {\n        transfer::share_object(Foo {\n            id: object::new(ctx),\n            bar,\n        })\n    }\n\n    /// Parameters passed to entry functions called in a programmable\n    /// transaction block (like `foo`, below) must be inputs to the\n    /// transaction block, and not results of previous transactions.\n    entry fun update(foo: &mut Foo, ctx: &TxContext) {\n        foo.bar = tx_context::epoch(ctx);\n    }\n\n    /// Entry functions can return types that have `drop`.\n    entry fun bar(foo: &Foo): u64 {\n        foo.bar\n    }\n\n    /// This function cannot be `entry` because it returns a value\n    /// that does not have `drop`.\n    public fun foo(ctx: &mut TxContext): Foo {\n        Foo { id: object::new(ctx), bar: 0 }\n    }\n}\n\nEdit this page\nPrevious\nModule Initializers\nNext\nOne-Time Witness\npublic vs entry functions\nExample\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Package Upgrades | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/packages",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nUpgrading Packages\nCustom Upgrade Policies\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewPackage Upgrades\nPackage Upgrades\n\nA Move package on Sui includes one or more modules that define that package's interaction with on-chain objects. You develop the logic for those modules using Move, which you then compile into an object. Finally, you publish your package object onto a Sui network. On chain, anyone can view your package contents and the logic it employs to manipulate other on-chain objects using a Sui network explorer.\n\nPackages are immutable​\n\nAfter you publish a package object on chain to a network, it lives there forever. You cannot directly change the code of an on-chain package object. After a package object appears on chain, other packages can use the modules that the original package provides. Bad actors aside, imagine if someone changed the logic in their on-chain package to correct unintentional behavior that was overlooked during development. This would cause a ripple effect, changing the logic of every package that uses that module to perform in ways the developers might have never intended.\n\nUpgrading packages​\n\nWhile you can't manipulate on-chain packages directly, you do have the ability to upgrade them. Upgrading on-chain packages provides a way to improve your code or add features without affecting packages that use the original package. When you upgrade a package, you're creating a new object on chain instead of modifying the original package. See Upgrading Packages to learn more about the process.\n\nUsing Sui Client CLI to upgrade packages​\n\nThe Sui Client CLI upgrade command offers an approachable way to upgrade packages when the CLI active address owns the UpgradeCap object associated with those packages.\n\nUsing the Sui CLI is useful to get started with upgrades, or in the early stages of package development, but protecting the ability to upgrade a package on chain using a single key can pose a security risk for several reasons:\n\nThe entity owning that key might make changes that are in their own interests but not the interests of the broader community.\nUpgrades might happen without enough time for package users to consult on the change or stop using the package if they disagree.\nThe key might get lost.\nMaking packages immutable​\n\nYou can make a package immutable when it goes live to mitigate the single-key risk using the Move sui::package::make_immutable function to destroy its UpgradeCap. Making the package immutable, however, prevents future bug fixes and new features, which might not be practical or desired.\n\nTo protect your package from single-key risk on chain, see Custom Upgrade Policies.\n\nEdit this page\nPrevious\nOne-Time Witness\nNext\nUpgrading Packages\nPackages are immutable\nUpgrading packages\nUsing Sui Client CLI to upgrade packages\nMaking packages immutable\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Module Initializers | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/init",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewModule Initializers\nModule Initializers\n\nThe module initializer function, init, is special in that it executes only once - when you publish the associated module - and must have the following properties:\n\nFunction name must be init\nThe parameter list must end with either a &mut TxContext or a &TxContext type\nNo return values\nPrivate visibility\nOptionally, the parameter list starts by accepting the module's one-time witness by value\n\nFor example, the following init functions are all valid:\n\nfun init(ctx: &TxContext)\nfun init(ctx: &mut TxContext)\nfun init(otw: EXAMPLE, ctx: &TxContext)\nfun init(otw: EXAMPLE, ctx: &mut TxContext)\n\nEvery function that fits this criteria will be run when the package is first published, and at no other time, including when the package is upgraded. This means that an init function that was introduced during an upgrade (to a new or existing module) will never run.\n\nThe following example demonstrates a valid init function in a module:\n\nmodule examples::one_timer {\n    use sui::transfer;\n    use sui::object::{Self, UID};\n    use sui::tx_context::{Self, TxContext};\n\n    /// The one of a kind - created in the module initializer.\n    struct CreatorCapability has key {\n        id: UID\n    }\n\n    /// This function is only called once on module publish.\n    /// Use it to make sure something has happened only once, like\n    /// here - only module author will own a version of a\n    /// `CreatorCapability` struct.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(CreatorCapability {\n            id: object::new(ctx),\n        }, tx_context::sender(ctx))\n    }\n}\n\nEdit this page\nPrevious\nCollections\nNext\nEntry Functions\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Strings | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/strings",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewStrings\nStrings\n\nMove does not have a native type for strings, but it has a useful wrapper.\n\nmodule examples::strings {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n\n    // Use this dependency to get a type wrapper for UTF-8 strings\n    use std::string::{Self, String};\n\n    /// A dummy Object that holds a String type\n    struct Name has key, store {\n        id: UID,\n\n        /// Here it is - the String type\n        name: String\n    }\n\n    /// Create a name Object by passing raw bytes\n    public fun issue_name_nft(\n        name_bytes: vector<u8>, ctx: &mut TxContext\n    ): Name {\n        Name {\n            id: object::new(ctx),\n            name: string::utf8(name_bytes)\n        }\n    }\n}\n\nString literals​\n\nDefine string literals in Move as byte strings. To do so, prepend b to your string.\n\nconst IMAGE_URL: vector<u8> = b\"https://api.capy.art/capys/\";\n\nlet keys = vector[\n            utf8(b\"name\"),\n            utf8(b\"link\"),\n            utf8(b\"image_url\"),\n            utf8(b\"description\"),\n            utf8(b\"project_url\"),\n            utf8(b\"creator\"),\n        ];\n\nEdit this page\nPrevious\nMove Concepts\nNext\nCollections\nString literals\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Collections | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts/collections",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove OverviewCollections\nCollections\n\nCollections provide a convenient way to work with groups of data. The Sui framework provides several modules that provide collection logic:\n\nbag​\n\nA bag is a heterogeneous map-like collection. The collection is similar to sui::table in that its keys and values are not stored within the Bag value, but instead are stored using Sui's object system. The Bag struct acts only as a handle into the object system to retrieve those keys and values. This means that Bag values with exactly the same key-value mapping will not be equal, with ==, at runtime.\n\nTo learn more, see Table and Bag or the framework definition on GitHub.\n\ndynamic_field​\n\nIn addition to the fields declared in its type definition, a Sui object can have dynamic fields that can be added after the object has been constructed. Unlike ordinary field names (which are always statically declared identifiers) a dynamic field name can be any value with the copy, drop, and store abilities (for example, an integer, a boolean, or a string). This gives Sui programmers the flexibility to extend objects on-the-fly, and it also serves as a building block for core collection types.\n\nTo learn more, see Dynamic Fields or the framework definition on GitHub.\n\ndynamic_object_field​\n\nSimilar to sui::dynamic_field, this module allows for the access of dynamic fields. But unlike, sui::dynamic_field the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist within storage, which may be important for external tools. The difference is otherwise not observable from within Move.\n\nTo learn more, see Dynamic Fields or the framework definition on GitHub.\n\nlinked_table​\n\nSimilar to sui::table but the values are linked together, allowing for ordered insertion and removal.\n\nTo learn more, see the framework definition on GitHub.\n\nobject_bag​\n\nSimilar to sui::bag, an ObjectBag is a heterogeneous map-like collection. But unlike sui::bag, the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist in storage, which might be important for external tools. The difference is otherwise not observable from within Move.\n\nTo learn more, see Table and Bag or the framework definition on GitHub.\n\nobject_table​\n\nSimilar to sui::table, an ObjectTable<K, V> is a map-like collection. But unlike sui::table, the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist within in storage, which may be important for external tools. The difference is otherwise not observable from within Move.\n\nTo learn more, see Table and Bag or the framework definition on GitHub.\n\npriority_queue​\n\nPriority queue implemented using a max heap.\n\nTo learn more, see the framework definition on GitHub.\n\ntable​\n\nA table is a map-like collection. But unlike a traditional collection, its keys and values are not stored within the Table value, but instead are stored using Sui's object system. The Table struct acts only as a handle into the object system to retrieve those keys and values. Note that this means that Table values with exactly the same key-value mapping will not be equal, with ==, at runtime.\n\nTo learn more, see Table and Bag or the framework definition on GitHub.\n\ntable_vec​\n\nA basic scalable vector library implemented using Table.\n\nTo learn more, see the framework definition on GitHub.\n\nvec_map​\n\nA map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries are not sorted by key--entries are included in insertion order. All operations are O(N) in the size of the map--the intention of this data structure is only to provide the convenience of programming against a map API. Large maps should use handwritten parent/child relationships instead. Maps that need sorted iteration rather than insertion order iteration should also be handwritten.\n\nTo learn more, see the framework definition on GitHub.\n\nvec_set​\n\nThe main object for vec_set is a set data structure backed by a vector. The set is guaranteed not to contain duplicate keys. All operations are O(N) in the size of the set. The intention of this data structure is only to provide the convenience of programming against a set API. Sets that need sorted iteration rather than insertion order iteration should be handwritten.\n\nTo learn more, see the framework definition on GitHub.\n\nEdit this page\nPrevious\nStrings\nNext\nModule Initializers\nbag\ndynamic_field\ndynamic_object_field\nlinked_table\nobject_bag\nobject_table\npriority_queue\ntable\ntable_vec\nvec_map\nvec_set\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "GraphQL for the Sui RPC | Sui Documentation",
      "url": "https://docs.sui.io/concepts/graphql-rpc",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersGraphQL for the Sui RPC\nGraphQL for the Sui RPC\n\nThis section explains some of the common concepts when working with GraphQL, such as altering behavior using HTTP headers, re-using query snippets with variables and fragments, consuming paginated queries, and understanding and working within the limits enforced by the service.\n\nJump to the following sections for more details:\n\nHeaders\nVariables\nFragments\nPagination\nLimits\n\nFor more details on GraphQL fundamentals, see the introductory documentation from GraphQL and GitHub.\n\nHeaders​\n\nThe service accepts the following optional headers:\n\nx-sui-rpc-version to specify which RPC version to use (currently only one version is supported),\nx-sui-rpc-show-usage returns the response with extra query complexity information.\n\nBy default, each request returns the service's version in the response header: x-sui-rpc-version.\n\ncurl -i -X POST https://sui-mainnet.mystenlabs.com/graphql \\\n     --header 'x-sui-rpc-show-usage: true'                 \\\n     --header 'Content-Type: application/json'             \\\n     --data '{\n          \"query\": \"query { epoch { referenceGasPrice } }\"\n     }'\n\n\nThe response for the previous request looks similar to the following:\n\nHTTP/2 200\ncontent-type: application/json\ncontent-length: 159\nx-sui-rpc-version: 2024.1.0\ndate: Tue, 30 Jan 2024 23:50:43 GMT\nvia: 1.1 google\nalt-svc: h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000\n\n{\n  \"data\": {\n    \"epoch\": {\n      \"referenceGasPrice\": \"1000\"\n    }\n  },\n  \"extensions\": {\n    \"usage\": {\n      \"inputNodes\": 2,\n      \"outputNodes\": 2,\n      \"depth\": 2,\n      \"variables\": 0,\n      \"fragments\": 0,\n      \"queryPayload\": 37\n    }\n  }\n}\n\nVariables​\n\nVariables offer a way to introduce dynamic inputs to a re-usable/static query. Declare variables in the parameters to a query or mutation, using the $ symbol and its type (in this example Int), which must be a scalar, enum, or input type. In the query body, refer to it by its name (prefixed with the $ symbol).\n\nIf you declare a variable but don't use it or define it (supply a value) in the query, the query fails to execute.\n\nTo learn more, read the GraphQL documentation on Variables.\n\nIn the following example, a variable supplies the ID of the epoch being queried.\n\nquery ($epochID: Int) {\n  epoch(id: $epochID) {\n    referenceGasPrice\n  }\n}\n\n\nVariables:\n\n{\n   \"epochID\": 100\n}\n\nIn the IDE​\n\nWhen using the online IDE, supply variables as a JSON object to the query in the Variables pane at the bottom of the main editing window. You receive a warning if you supply a variable but don't declare it.\n\nIn requests​\n\nWhen making a request to the GraphQL service (for example, using curl), pass the query and variables as two fields of a single JSON object:\n\n curl -X POST https://sui-testnet.mystenlabs.com/graphql \\\n    --header 'Content-Type: application/json' \\\n    --data '{\n     \"query\": \"query ($epochID: Int) { epoch(id: $epochID) { referenceGasPrice } }\",\n     \"variables\": { \"epochID\": 100 }\n   }'\n\nFragments​\n\nFragments are reusable units that you can include in queries as needed. To learn more, consult the official GraphQL documentation. The following example uses fragments to factor out a reusable snippet representing a Move value.\n\nquery DynamicField {\n  object(\n    address: \"0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac\"\n  ) {\n    dynamicField(\n      name: {\n        type: \"0x2::kiosk::Listing\",\n        bcs: \"NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1VhfwA\",\n      }\n    ) {\n      ...DynamicFieldSelect\n    }\n  }\n}\n\nfragment DynamicFieldSelect on DynamicField {\n  name {\n    ...MoveValueFields\n  }\n  value {\n    ...DynamicFieldValueSelection\n  }\n}\n\nfragment DynamicFieldValueSelection on DynamicFieldValue {\n  __typename\n  ... on MoveValue {\n    ...MoveValueFields\n  }\n  ... on MoveObject {\n    hasPublicTransfer\n    contents {\n      ...MoveValueFields\n    }\n  }\n}\n\nfragment MoveValueFields on MoveValue {\n  type {\n    repr\n  }\n  data\n  bcs\n}\n\nPagination​\n\nGraphQL supports queries that fetch multiple kinds of data, potentially nested. For example, the following query retrieves the first 20 transaction blocks (along with the digest, the sender's address, the gas object used to pay for the transaction, the gas price, and the gas budget) after a specific transaction block at epoch 97.\n\nquery {\n  epoch(id: 97) {\n    transactionBlocks(first: 10) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        digest\n        sender {\n          address\n        }\n        effects {\n          gasEffects {\n            gasObject {\n              address\n            }\n          }\n        }\n        gasInput {\n          gasPrice\n          gasBudget\n        }\n      }\n    }\n  }\n}\n\n\nIf there are too many transactions to return in a single response, the service applies a limit on the maximum page size for variable size responses (like the transactionBlock query) and you must fetch further results through pagination.\n\nConnections​\n\nFields that return a paginated response accept at least the following optional parameters:\n\nfirst, a limit on page size that is met by dropping excess results from the end.\nafter, a cursor that bounds the results from below, exclusively.\nlast, a limit on page size that is met by dropping excess results from the start.\nbefore, a cursor that bounds the results from above, exclusively.\n\nThey also return a type that conforms to the GraphQL Cursor Connections Specification, meaning its name ends in Connection, and it contains at least the following fields:\n\npageInfo, of type PageInfo, which indicates whether there are more pages before or after the page returned.\nnodes, the content of the paginated response, as a list of the type being paginated (TransactionBlock in the previous example).\nedges, similar to nodes but associating each node with its cursor.\nCursors​\n\nCursors are opaque identifiers for paginated results. The only valid source for a cursor parameter (like after and before) is a cursor field from a previous paginated response (like PageInfo.startCursor, PageInfo.endCursor, or Edge.cursor). The underlying format of the cursor is an implementation detail, and is not guaranteed to remain fixed across versions of the GraphQL service, so do not rely on it -- generating cursors out of thin air is not expected or supported.\n\nCursors are used to bound results from below (with after) and above (with before). In both cases, the bound is exclusive, meaning it does not include the result that the cursor points to in the bounded region.\n\nConsistency​\n\nCursors also guarantee consistent pagination. If the first paginated query reads the state of the network at checkpoint X, then a future call to fetch the next page of results using the cursors returned by the first query continues to read from the network at checkpoint X, even if data for future checkpoints is now available.\n\nThis property requires that cursors that are used together (for example when supplying an after and before bound) are fixed on the same checkpoint, otherwise the query produces an error.\n\nAvailable range​\n\nThe GraphQL service does not support consistent pagination for arbitrarily old cursors. A cursor can grow stale, if the checkpoint it is from is no longer in the available range. You can query the upper- and lower-bounds of that range as follows:\n\n{\n  availableRange {\n    first { sequenceNumber }\n    last { sequenceNumber }\n  }\n}\n\n\nThe results are the first and last checkpoint for which pagination continues to work and produce a consistent result. At the time of writing the available range offers a 5- to 15-minute buffer period to finish pagination.\n\nPage limits​\n\nAfter results are bounded using cursors, a page size limit is applied using the first and last parameters. The service requires these parameters to be less than or equal to the max page size limit, and if you provide neither, it selects a default. In addition to setting a limit, first and last control where excess elements are discarded from. For example, if there are 10 potential results -- R0, R1, ..., R9 -- after cursor bounds have been applied, then\n\na limit of first: 3 would select R0, R1, R2, and\na limit of last: 3 would select R7, R8, R9.\nINFO\n\nIt is an error to apply both a first and a last limit.\n\nExamples​\n\nTo see these principles put into practice, consult the examples for paginating forwards and paginating backwards in the getting started guide.\n\nLimits​\n\nThe GraphQL service for Sui RPC is rate-limited on all available instances to keep network throughput optimized and to protect against excessive or abusive calls to the service.\n\nRate limits​\n\nQueries are rate-limited at the number of attempts per minute to ensure high availability of the service to all users.\n\nQuery limits​\n\nIn addition to rate limits, queries are also validated against a number of rules on their complexity, such as the number of nodes, the depth of the query, or their payload size. Query the serviceConfig field to retrieve these limits. An example of how to query for some of the available limits follows:\n\n{\n  serviceConfig {\n    maxQueryDepth\n    maxQueryNodes\n    maxOutputNodes\n    maxDbQueryCost\n    defaultPageSize\n    maxPageSize\n    requestTimeoutMs\n    maxQueryPayloadSize\n    maxTypeArgumentDepth\n    maxTypeArgumentWidth\n    maxTypeNodes\n    maxMoveValueDepth\n  }\n}\n\nRelated links​\nGraphQL quick-start: Querying Sui RPC with GraphQL gets you started using GraphQL to query the Sui RPC for on-chain data.\nGraphQL migration: Migrating to GraphQL guides you through migrating Sui RPC projects from JSON-RPC to GraphQL.\nGraphQL reference: Auto-generated GraphQL reference for Sui RPC.\nEdit this page\nPrevious\nApp Developers\nNext\nObject Model\nHeaders\nVariables\nIn the IDE\nIn requests\nFragments\nPagination\nConnections\nCursors\nPage limits\nExamples\nLimits\nRate limits\nQuery limits\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/object-model",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nObject Ownership\nDynamic Fields\nTransfers\nEvents\nObject and Package Versioning\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersObject Model\nObject Model\n\nThe basic unit of storage in Sui is the object. In contrast to many other blockchains where storage is centered around accounts containing key-value stores, Sui's storage is centered around objects addressable on-chain by unique IDs. A smart contract is an object (called a Sui Move package), and these smart contracts manipulate objects on the Sui network:\n\nSui Move Package: a set of Sui Move bytecode modules. Each module has a name that's unique within the containing package. The combination of the package's on-chain ID and the name of a module uniquely identify the module. When you publish smart contracts to Sui, a package is the unit of publishing. After you publish a package object, it is immutable and can never be changed or removed. A package object can depend on other package objects that were previously published to Sui.\nSui Move Object: typed data governed by a particular Sui Move module from a Sui Move package. Each object value is a struct with fields that can contain primitive types (such as integers and addresses), other objects, and non-object structs.\nObject metadata​\n\nEach Sui object has the following metadata:\n\nA 32-byte globally unique ID. An object ID is derived from the digest of the transaction that created the object and from a counter encoding the number of IDs generated by the transaction.\nAn 8-byte unsigned integer version that monotonically increases with every transaction that modifies it (see Object and package versioning).\nA 32-byte transaction digest indicating the last transaction that included this object as an output.\nA 33-byte owner field that indicates how this object can be accessed. See Object Ownership for more information.\n\nIn addition to common metadata, objects have a category-specific, variable-sized contents field containing a Binary Canonical Serialization (BCS)-encoded payload.\n\nMove Objects contain their Move type, whether the object can be transferred using public_transfer, and its fields, again encoded as BCS.\nMove Packages contain the bytecode modules in the package, a table identifying which versions of a package introduced each of its types (the type origin table), and a table mapping each of its transitive dependencies to a specific version of that package to use (the linkage table).\nReferring to objects​\n\nThere are a few different ways to concisely refer to an object without specifying its entire contents and metadata, each with slightly different use cases:\n\nID: the globally unique ID of the object mentioned above. ID is a stable identifier for the object across time and is useful for querying the current state of an object or describing which object was transferred between two addresses.\nVersioned ID: an (ID, version) pair. Versioned ID describes the state of the object at a particular point in the object's history and is useful for asking what the value of the object was at some point in the past or determining how fresh some view of an object is now.\nObject Reference: an (ID, version, object digest) triple. The object digest is the hash of the object's contents and metadata. An object reference provides an authenticated view of the object at a particular point in the object's history. Transactions require object inputs to be specified via object references to ensure the transaction's sender and a validator processing the transaction agree on the contents and metadata of the object.\nThe transaction-object DAG: Relating objects and transactions​\n\nTransactions take objects as input, read/write/mutate these inputs, and produce mutated or freshly created objects as output. Each object knows the (hash of the) last transaction that produced it as an output. Thus, a natural way to represent the relationship between objects and transactions is a directed acyclic graph (DAG) where:\n\nNodes are transactions.\nDirected edges go from transaction A to transaction B if an output object of A is an input object of B. They are labeled by the reference of the object in question (which specifies the exact version of the object created by A and used by B).\n\nThe root of this DAG is a genesis transaction that takes no inputs and produces the objects that exist in the system's initial state. The DAG can be extended by identifying mutable transaction outputs that have not yet been consumed by any committed transaction and sending a new transaction that takes these outputs (and optionally, immutable transaction outputs) as inputs.\n\nThe set of objects that are available to be taken as input by a transaction are the live objects, and the global state maintained by Sui consists of the totality of such objects. The live objects for a particular Sui address A are all objects owned by A, along with all shared and immutable objects in the system.\n\nWhen this DAG contains all committed transactions in the system, it forms a complete (and cryptographically auditable) view of the system's state and history. In addition, you can use the scheme above to construct a DAG of the relevant history for a subset of transactions or objects (for example, the objects owned by a single address).\n\nLimits on transactions, objects, and data​\n\nSui has some limits on transactions and data used in transactions, such as a maximum size and number of objects used.\n\nEdit this page\nPrevious\nGraphQL for the Sui RPC\nNext\nObject Ownership\nObject metadata\nReferring to objects\nThe transaction-object DAG: Relating objects and transactions\nLimits on transactions, objects, and data\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Client App with Sui TypeScript SDK | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app/client-tssdk",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dAppClient App with Sui TypeScript SDK\nClient App with Sui TypeScript SDK\n\nThis exercise diverges from the example built in the previous topics in this section. Rather than adding a frontend to the running example, the instruction walks you through setting up dApp Kit in a React App, allowing you to connect to wallets, and query data from Sui RPC nodes to display in your app. You can use it to create your own frontend for the example used previously, but if you want to get a fully functional app up and running quickly, run the following command in a terminal or console to scaffold a new app with all steps in this exercise already implemented:\n\nINFO\n\nYou must use the pnpm or yarn package managers to create Sui project scaffolds. Follow the pnpm install or yarn install instructions, if needed.\n\npnpm create @mysten/dapp --template react-client-dapp\n\n\nor\n\nyarn create @mysten/dapp --template react-client-dapp\n\nWhat is the Sui TypeScript SDK?​\n\nThe Sui TypeScript SDK (@mysten/sui.js) provides all the low-level functionality needed to interact with Sui ecosystem from TypeScript. You can use it in any TypeScript or JavaScript project, including web apps, Node.js apps, or mobile apps written with tools like React Native that support TypeScript.\n\nFor more information on the Sui TypeScript SDK, see the Sui TypeScript SDK documentation.\n\nWhat is dApp Kit?​\n\ndApp Kit (@mysten/dapp-kit) is a collection of React hooks, components, and utilities that make building dApps on Sui straightforward. For more information on dApp Kit, see the dApp Kit documentation.\n\nInstalling dependencies​\n\nTo get started, you need a React app. The following steps apply to any React, so you can follow the same steps to add dApp Kit to an existing React app. If you are starting a new project, you can use Vite to scaffold a new React app.\n\nRun the following command in your terminal or console, and select React as the framework, and then select one of the TypeScript templates:\n\nnpm\nYarn\npnpm\nnpm init vite\n\n\nNow that you have a React app, you can install the necessary dependencies to use dApp Kit:\n\nnpm\nYarn\npnpm\nnpm install @mysten/sui.js @mysten/dapp-kit @tanstack/react-query\n\nSetting up Provider components​\n\nTo use all the features of dApp Kit, wrap your app with a couple of Provider components.\n\nOpen the root component that renders your app (the default location the Vite template uses is src/main.tsx) and integrate or replace the current code with the following.\n\nThe first Provider to set up is the QueryClientProvider from @tanstack/react-query. This Provider manages request state for various hooks in dApp kit. If you're already using @tanstack/react-query, dApp Kit can share the same QueryClient instance.\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n\t<React.StrictMode>\n\t\t<QueryClientProvider client={queryClient}>\n\t\t\t<App />\n\t\t</QueryClientProvider>\n\t</React.StrictMode>,\n);\n\n\nNext, set up the SuiClientProvider. This Provider delivers a SuiClient instance from @mysten/sui.js to all the hooks in dApp Kit. This provider manages which network dApp Kit connects to, and can accept configuration for multiple networks. This exercise connects to devnet.\n\nimport { SuiClientProvider } from '@mysten/dapp-kit';\nimport { getFullnodeUrl } from '@mysten/sui.js/client';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\nconst networks = {\n\tdevnet: { url: getFullnodeUrl('devnet') },\n\tmainnet: { url: getFullnodeUrl('mainnet') },\n};\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n\t<React.StrictMode>\n\t\t<QueryClientProvider client={queryClient}>\n\t\t\t<SuiClientProvider networks={networks} defaultNetwork=\"devnet\">\n\t\t\t\t<App />\n\t\t\t</SuiClientProvider>\n\t\t</QueryClientProvider>\n\t</React.StrictMode>,\n);\n\n\nFinally, set up the WalletProvider from @mysten/dapp-kit, and import styles for the dapp-kit components.\n\nimport '@mysten/dapp-kit/dist/index.css';\n\nimport { SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';\nimport { getFullnodeUrl } from '@mysten/sui.js/client';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\nconst networks = {\n\tdevnet: { url: getFullnodeUrl('devnet') },\n\tmainnet: { url: getFullnodeUrl('mainnet') },\n};\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n\t<React.StrictMode>\n\t\t<QueryClientProvider client={queryClient}>\n\t\t\t<SuiClientProvider networks={networks} defaultNetwork=\"devnet\">\n\t\t\t\t<WalletProvider>\n\t\t\t\t\t<App />\n\t\t\t\t</WalletProvider>\n\t\t\t</SuiClientProvider>\n\t\t</QueryClientProvider>\n\t</React.StrictMode>,\n);\n\nConnecting to a wallet​\n\nWith all Providers set up, you can use dApp Kit hooks and components. To allow users to connect their wallets to your dApp, add a ConnectButton.\n\nimport { ConnectButton } from '@mysten/dapp-kit';\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<header className=\"App-header\">\n\t\t\t\t<ConnectButton />\n\t\t\t</header>\n\t\t</div>\n\t);\n}\n\n\nThe ConnectButton component displays a button that opens a modal on click, enabling the user to connect their wallet. Upon connection, it displays their address, and provides the option to disconnect.\n\nGetting the connected wallet address​\n\nNow that you have a way for users to connect their wallets, you can start using the useCurrentAccount hook to get details about the connected wallet account.\n\nimport { ConnectButton, useCurrentAccount } from '@mysten/dapp-kit';\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<header className=\"App-header\">\n\t\t\t\t<ConnectButton />\n\t\t\t</header>\n\n\t\t\t<ConnectedAccount />\n\t\t</div>\n\t);\n}\n\nfunction ConnectedAccount() {\n\tconst account = useCurrentAccount();\n\n\tif (!account) {\n\t\treturn null;\n\t}\n\n\treturn <div>Connected to {account.address}</div>;\n}\n\nQuerying data from Sui RPC nodes​\n\nNow that you have the account to connect to, you can query for objects the connected account owns:\n\nimport { useCurrentAccount, useSuiClientQuery } from '@mysten/dapp-kit';\n\nfunction ConnectedAccount() {\n\tconst account = useCurrentAccount();\n\n\tif (!account) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<div>Connected to {account.address}</div>;\n\t\t\t<OwnedObjects address={account.address} />\n\t\t</div>\n\t);\n}\n\nfunction OwnedObjects({ address }: { address: string }) {\n\tconst { data } = useSuiClientQuery('getOwnedObjects', {\n\t\towner: address,\n\t});\n\tif (!data) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<ul>\n\t\t\t{data.data.map((object) => (\n\t\t\t\t<li key={object.data?.objectId}>\n\t\t\t\t\t<a href={`https://example-explorer.com/object/${object.data?.objectId}`}>\n\t\t\t\t\t\t{object.data?.objectId}\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t))}\n\t\t</ul>\n\t);\n}\n\n\nYou now have a dApp connected to wallets and can query data from RPC nodes.\n\nRelated links​\n\nThe next step from here is to start interacting with Move modules, constructing transaction blocks, and making Move calls. This exercise continues in the Counter end-to-end example.\n\nEnd-to-End Example: Continue this exercise by creating an app.\nSui 101: Learn the basics of the Sui network and how to interact with on-chain objects using Move.\nSui Move CLI: The move commands in the Sui CLI provide console or terminal interaction with the Move VM.\nEdit this page\nPrevious\nDebugging\nNext\nSui 101\nWhat is the Sui TypeScript SDK?\nWhat is dApp Kit?\nInstalling dependencies\nSetting up Provider components\nConnecting to a wallet\nGetting the connected wallet address\nQuerying data from Sui RPC nodes\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/sponsor-txn",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Sponsored Transaction\n\nSponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction without a user paying the gas. It also discusses the roles in Sponsored Transaction, and a few common use cases. Then it discusses the flow of Sponsored Transaction, mostly for developers who are interested in building a Gas Station or integrate with one. Finally it talks about risk considerations of Sponsored Transaction.\n\nOverview\n\nA transaction on Sui takes a payment to execute. The payment, also known as gas, is a list of 0x2::coin::Coin<0x2::sui::Sui> objects, and paid to Sui validators to secure the network. Although gas is a critical piece in Sui tokenomics, it sometimes adds challenges when new users start to navigate on Sui, especially for web 2.0 users.\n\nSponsored transactions can reduce the onboarding friction for users because the feature streamlines the process for end users. Using sponsored transactions, you can execute a transaction without requiring the user to pay it themselves. Instead, you can act as a sponsor of the transaction, offering your own payment gas objects for the transaction.\n\nRoles in sponsored transactions​\n\nIn a sponsored transaction there are three roles: the user, the gas station, and the sponsor.\n\nThe user is the entity who wants to execute a transaction.\nThe gas station is the entity that fulfills the sponsorship request for the user's transaction by providing the gas payment they own.\nThe sponsor is entity that funds the gas station for its operations.\n\nIt's not uncommon for the gas station and the sponsor to be the same entity. For example, a web3 gaming studio could run its own gas station to sponsor users with real free-to-play gaming experiences at its user acquisition stage. Because it's not always trivial to maintain a gas station for teams of any size, that gaming studio could also leverage third-party gas stations to sponsor transactions they want to promote.\n\nThe remainder of this guide assumes the sponsor uses their own gas station.\n\nUse cases​\n\nThe following sections describe some common scenarios where sponsored transactions offer an improved user experience.\n\nApp-specific sponsorship​\n\nIn this scenario, the sponsor has a specific set of applications they want to sponsor.\n\nIf the transaction is initialized by the user, the sponsor examines the transaction to make sure it's within the set of approved applications before agreeing to provide the gas payment.\nIf the transaction is proposed by the sponsor, the user must examine the transaction and decide if they want to execute it. Examples of this type of transaction might include a rewards claim transaction of a campaign or a \"try it out\" advertisement transaction.\nWildcard sponsorship​\n\nIn this scenario, the sponsor has few restrictions on the type of transactions the gas payment can be used for.\n\nIf the sponsor is a gasless wallet, it may agree to sponsor any valid transactions proposed by its users.\nIn the form of a reward or discount, the sponsor could offer the user a wildcard gas payment, expressly promising to execute any transactions with that gas payment.\n\nA sponsored transaction is not restricted to these use cases. Essentially, a sponsored transaction is any transaction jointly made by the user and the sponsor. As long as the stakeholders can agree on the transaction details, then the number of possible ways to provide sponsored transactions is limited only by the imagination. Because at least two stakeholders are involved in a sponsored transaction, however, there are some [additional risks](#risk} that you should take steps to mitigate.\n\nSponsored transaction flow​\n\nThis section is mostly for developers who are interested in building a gas station or integrating with one.\n\nThe data structure of a transaction resembles the following:\n\n\npub struct SenderSignedTransaction {\n    pub intent_message: IntentMessage<TransactionData>,\n    /// A list of signatures signed by all transaction participants.\n    /// 1. non participant signature must not be present.\n    /// 2. signature order does not matter.\n    pub tx_signatures: Vec<GenericSignature>,\n}\n\npub struct TransactionDataV1 {  // <-- A variant of `TransactionData`\n    pub kind: TransactionKind,  // <-- This is the actual transaction details\n    pub sender: SuiAddress,\n    pub gas_data: GasData,\n    pub expiration: TransactionExpiration,\n}\n\npub struct GasData {\n    pub payment: Vec<ObjectRef>,\n    pub owner: SuiAddress,\n    pub price: u64,\n    pub budget: u64,\n}\n\n\n\nA few details of note for the preceding code:\n\nsender in TransactionDataV1 (a variant of TransactionData) is the user address.\ngas_data in TransactionDataV1 is the gas payment.\nGasData allows a list of gas objects, but the same address must own them, namely the owner in GasData (the sponsor). When owner is equal to sender, then it is a regular/non-sponsored transaction.\ntx_signatures in SenderSignedTransaction is a list of signatures. For a sponsored transaction, the list needs to contain both signatures of the user and the sponsor in some order. The signatures are signed over the entire TransactionData, including GasData.\n\nSo, to construct a correct sponsored transaction, you must first build a TransactionData object. If you are neither the user or the sponsor, you would then pass the transaction to both parties to sign. If you're the sponsor, you would sign the transaction and then pass it and the signature to the other party (in the form of SenderSignedTransaction) for them to sign. In practice, the latter is the more common scenario.\n\nThere are three flows of sponsored transaction.\n\nUser proposed transaction\n\n(swimlane link)\n\nSponsor proposed transaction\n\n(swimlane link)\n\nWildcard gas payment\n\n(swimlane link)\n\nRisk considerations​\n\nBecause at least two stakeholders are involved in a sponsored transaction, you should take steps to mitigate risk.\n\nClient equivocation risk​\n\nClient equivocation happens when more than one legit transaction that shares at least one owned object (such as a gas coin object) at a certain version are submitted to the network simultaneously. On Sui, before a transaction is executed, owned objects in this transaction are locked on validators at specific versions. An honest validator only accepts one transaction and rejects others. Depending on the order validators receive these transactions, validators might accept different transactions. In the event of no single transaction getting accepted by at least 2/3rds of validators, the owned object is locked until end of the epoch.\n\nPractically speaking, client equivocation is rare, mostly caused by buggy client software. After all, no one has incentives to lock their own objects. However, sponsored transactions come with counterparty risks. For example, a malicious user could equivocate the gas station's gas coin object by submitting another transaction that uses one owned object in the gas station signed transaction at the same version. Similarly, a Byzantine gas station could do the same to the user owned objects.\n\nAlthough this risk might seem trivial, it is helpful to be aware of it. Your gas station should actively monitor user behavior and alert on anything abnormal. Whether you're a user taking advantage of sponsored transactions or a developer integrating with a gas station, consider your reputation to minimize the risk of client equivocation.\n\nBoth the user and the sponsor need to sign over the entire TransactionData, including GasData because otherwise a third party (such as a malicious Full node) could snip the partially signed data and cause client equivocation and locking of owned objects.\n\nCensorship risk​\n\nIf you chooses to submit the dual-signed transaction to the sponsor or gas station rather than a Full node, the transaction might be subject to sponsor or gas station censorship. Namely, the sponsor might choose not to submit the transaction to the network, or delay the submission.\n\nYou can mitigate this risk by submitting the transaction directly to a Full node.\n\nEdit this page\nPrevious\nSigning and Sending Transactions\nNext\nBuilding Programmable Transaction Blocks\nRoles in sponsored transactions\nUse cases\nApp-specific sponsorship\nWildcard sponsorship\nSponsored transaction flow\nRisk considerations\nClient equivocation risk\nCensorship risk\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/working-with-ptbs",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nWorking with Programmable Transaction Blocks\n\nProgrammable transaction blocks (PTBs) are key elements of the Sui ecosystem. Understanding PTBs and using them correctly are key fundamentals to creating efficient and cost-effective smart contracts. See Programmable Transaction Blocks to learn about the structure of PTBs on Sui.\n\nThe topics in this section focus on effectively utilizing PTBs in your smart contracts.\n\nBuilding Programmable Transaction Blocks​\n\nTo fully appreciate the possibilities PTBs offer, you must build them. Using tools like the Sui TypeScript SDK, you can begin to understand the power and flexibility they provide.\n\nGo to Building Programmable Transaction Blocks.\n\nCoin Management​\n\nCoin objects on Sui are different than other blockchains in that they are owned objects. Whether you need your smart contract to utilize SUI for gas payments or deal with generic coins, understanding coin management is crucial. Smart contracts use common patterns to accept coins and the PTBs you create must provide the correct interface to those smart contracts to facilitate successful transactions.\n\nGo to Coin Management.\n\nSimulating References​\n\nThe borrow module of the Sui framework offers some features you can use when your PTBs use objects by reference.\n\nGo to Simulating References.\n\nRelated links​\n\nReview this content for a complete picture of PTBs on Sui.\n\nProgrammable Transaction Blocks: Conceptual overview of the PTB architecture.\nLife of a Transaction: Discover the life of a transaction from inception to finality.\nEdit this page\nBuilding Programmable Transaction Blocks\nCoin Management\nSimulating References\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/sign-and-send-txn",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Signing and Sending Transactions\nSigning and Sending Transactions\n\nTransactions in Sui represent calls to specific functionality (like calling a smart contract function) that execute on inputs to define the result of the transaction.\n\nInputs can either be an object reference (either to an owned object, an immutable object, or a shared object), or an encoded value (for example, a vector of bytes used as an argument to a Move call). After a transaction is constructed, usually through using programmable transaction blocks (PTBs), the user signs the transaction and submits it to be executed on chain.\n\nThe signature is provided with the private key owned by the wallet, and its public key must be consistent with the transaction sender's Sui address.\n\nSui uses a SuiKeyPair to produce the signature, which commits to the Blake2b hash digest of the intent message (intent || bcs bytes of tx_data). The signature schemes currently supported are Ed25519 Pure, ECDSA Secp256k1, ECDSA Secp256r1, Multisig, and zkLogin.\n\nYou can instantiate Ed25519 Pure, ECDSA Secp256k1, and ECDSA Secp256r1 using SuiKeyPair and use it to sign transactions. Note that this guide does not apply to Multisig and zkLogin, please refer to their own pages (Multisig and zkLogin respectively) for instructions.\n\nWith a signature and the transaction bytes, a transaction can be submitted to be executed.\n\nWorkflow​\n\nThe following high-level process describes the overall workflow for constructing, signing and executing an on-chain transaction:\n\nConstruct the transaction data by creating a TransactionBlock where multiple transactions are chained. See Building Programmable Transaction Blocks for more information.\nThe SDK's built-in gas estimation and coin selection picks the gas coin.\nSign the transaction to generate a signature.\nSubmit the TransactionBlock and its signature for on-chain execution.\nINFO\n\nIf you want to use a specific gas coin, first find the gas coin object ID to be used to pay for gas, and explicitly use that in the PTB. If there is no gas coin object, use the splitCoin transaction to create a gas coin object. The split coin transaction should be the first transaction call in the PTB.\n\nExamples​\n\nThe following examples demonstrate how to sign and execute transactions using Rust, TypeScript, or the Sui CLI.\n\nTypeScript\nRust\nSui CLI\n\nThere are various ways to instantiate a key pair and to derive its public key and Sui address using the Sui TypeScript SDK.\n\n    import { SuiClient, getFullnodeUrl } from '@mysten/sui.js/client';\n    import { TransactionBlock } from '@mysten/sui.js/transactions';\n    import { type Keypair } from '@mysten/sui.js/cryptography';\n    import { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';\n    import { Secp256k1Keypair } from '@mysten/sui.js/keypairs/secp256k1';\n    import { Secp256r1Keypair } from '@mysten/sui.js/keypairs/secp256r1';\n    import { fromHEX } from '@mysten/bcs';\n    \n    const kp_rand_0 = new Ed25519Keypair();\n    const kp_rand_1 = new Secp256k1Keypair();\n    const kp_rand_2 = new Secp256r1Keypair();\n\n    const kp_import_0 = Ed25519Keypair.fromSecretKey(fromHex(\"0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82\"));\n    const kp_import_1 = Secp256k1Keypair.fromSecretKey(fromHex(\"0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82\"));\n    const kp_import_2 = Secp256r1Keypair.fromSecretKey(fromHex(\"0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82\"));\n\n    // $MNEMONICS refers to 12/15/18/21/24 words from the wordlist, e.g. \"retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire\". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.\n\tconst kp_derive_0 = Ed25519Keypair.deriveKeypair(\"$MNEMONICS\");\n\tconst kp_derive_1 = Secp256k1Keypair.deriveKeypair(\"$MNEMONICS\");\n\tconst kp_derive_2 = Secp256r1Keypair.deriveKeypair(\"$MNEMONICS\");\n\n\tconst kp_derive_with_path_0 = Ed25519Keypair.deriveKeypair(\"$MNEMONICS\", \"m/44'/784'/1'/0'/0'\");\n\tconst kp_derive_with_path_1 = Secp256k1Keypair.deriveKeypair(\"$MNEMONICS\", \"m/54'/784'/1'/0/0\");\n\tconst kp_derive_with_path_2 = Secp256r1Keypair.deriveKeypair(\"$MNEMONICS\", \"m/74'/784'/1'/0/0\");\n\n    // replace `kp_rand_0` with the variable names above.\n    const pk = kp_rand_0.getPublicKey();\n    const sender = pk.toSuiAddress();\n\n    // create an example transaction block.\n    const txb = new TransactionBlock();\n\ttxb.setSender(sender);\n\ttxb.setGasPrice(5);\n\ttxb.setGasBudget(100);\n\tconst bytes = await txb.build();\n    const serializedSignature = (await keypair.signTransactionBlock(bytes)).signature;\n\n    // verify the signature locally\n\texpect(await keypair.getPublicKey().verifyTransactionBlock(bytes, serializedSignature)).toEqual(true);\n\n    // define sui client for the desired network. \n    const client = new SuiClient({ url: getFullnodeUrl('testnet') });\n\n    // execute transaction. \n    let res = client.executeTransactionBlock({\n\t    transactionBlock: bytes,\n\t    signature: serializedSignature,\n    });\n    console.log(res);\n\nNotes​\nThis guide demonstrates how to sign with a single private key. Refer to Multisig when it is preferred to set up more complex signing policies.\nSimilarly, native zkLogin does not follow the above steps, see the docs to understand how to derive a zkLogin address, and produce a zkLogin signature with an ephemeral key pair.\nIf you decide to implement your own signing mechanisms instead of using the previous tools, see the Signatures doc on the accepted signature specifications for each scheme.\nFlag is one byte that differentiates signature schemes. See supported schemes and its flag in Signatures.\nThe execute_transaction_block endpoint takes a list of signatures, so it should contain exactly one user signature, unless you are using sponsored transaction that a second signature for the gas object can be provided. See Sponsored Transactions for more information.\nEdit this page\nPrevious\nAccess On-Chain Time\nNext\nSponsored Transaction\nWorkflow\nExamples\nNotes\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/using-events",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Using Events\nUsing Events\n\nThe Sui network stores countless objects on chain where Move code can perform actions using those objects. Tracking this activity is often desired, for example, to discover how many times a module mints an NFT or to tally the amount of SUI in transactions that a smart contract generates.\n\nTo support activity monitoring, Move provides a structure to emit events on the Sui network. When you establish a connection with the Sui network, you create a two-way interactive communication session between your client and a Sui network node. With an open session, you can subscribe to specific events that the Sui network adds to the stream to create real-time monitoring of events.\n\nMove event structure​\n\nAn event object in Sui consists of the following attributes:\n\nid: JSON object containing the transaction digest ID and event sequence.\npackageId: The object ID of the package that emits the event.\ntransactionModule: The module that performs the transaction.\nsender: The Sui network address that triggered the event.\ntype: The type of event being emitted.\nparsedJson: JSON object describing the event.\nbcs: Binary canonical serialization value.\ntimestampMs: Unix epoch timestamp in milliseconds.\nDiscovering events​\n\nIf you want to subscribe to events on chain, you first need to know what events are available. You typically know or can discover the events your own code emits, but it's not as straightforward when you need to subscribe to on-chain events from packages you don't own. The Sui RPC provides a queryEvents method to query on-chain packages and return available events that you can subscribe to.\n\nFilter events​\n\nYou can filter the events your code targets for either querying or subscribing. Both filter options are similar but have some differences.\n\nEmit events in Move​\n\nTo create an event in your Move modules, add the sui::event dependency.\n\nuse sui::event;\n\n\nWith the dependency added, you can use the emit function to fire an event whenever the action you want to monitor fires. For example, the following code is part of an example application using digital donuts. The collect_profits function handles the collection of SUI and emits an event whenever the function is called. To act on that event, you need to subscribe to it.\n\n/// Take coin from `DonutShop` and transfer it to tx sender.\n/// Requires authorization with `ShopOwnerCap`.\npublic fun collect_profits( _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext ) {\n    let amount = balance::value(&shop.balance);\n    let profits = coin::take(&mut shop.balance, amount, ctx);\n    // simply create new type instance and emit it.\n    event::emit(ProfitsCollected { amount });\n    transfer::public_transfer(profits, tx_context::sender(ctx));\n}\n\nSubscribe to events in Move​\n\nFiring events is not very useful in a vacuum. You also need the ability to listen for those events so that you can act on them. In Sui, you subscribe to those events and provide logic that triggers when the event fires.\n\nSui Full nodes support subscribe functionality using JSON-RPC notifications transmitted through the WebSocket API. You can interact with the RPC directly (suix_subscribeEvent, suix_subscribeTransaction) or you can use an SDK like the Sui TypeScript SDK. The following excerpt from one of the examples uses the TypeScript SDK to create an asynchronous subscription to the filter identified in the filter.\n\nlet unsubscribe = await provider.subscribeEvent({\n    filter: { <PACKAGE_ID> },\n    onMessage: (event) => {\n        console.log(\"subscribeEvent\", JSON.stringify(event, null, 2))\n    }\n});\n\n\nMove smart contracts can call other smart contracts that emit events. For example, Deepbook_utils can call the dee9 smart contract and emit this event. Note that using package, transaction module to query for dee9/clob_v2 misses the following event even though it is actually an event the dee9 package emits. The current workaround for this issue is to know all the packageIds you care about and search those in the queryEvent call.\n\n{\n  \"id\": {\n    \"txDigest\": \"bZnc1E7k1fJYLxWihfre5xCw1tX1CyAN6579zypJeiU\",\n    \"eventSeq\": \"0\"\n  },\n  \"packageId\": \"0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05\",\n  \"transactionModule\": \"deepbook_utils\",\n  \"sender\": \"0x4419ae182ac112bb065bda2146136ed02524ee2611478bfe8ca5d3835bee4af6\",\n  \"type\": \"0xdee9::clob_v2::OrderPlaced<0x2::sui::SUI, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>\",\n  \"parsedJson\": {\n    \"base_asset_quantity_placed\": \"1000000000\",\n    \"client_order_id\": \"20082022\",\n    \"expire_timestamp\": \"1697121171540\",\n    \"is_bid\": false,\n    \"order_id\": \"9223372036854945121\",\n    \"original_quantity\": \"1000000000\",\n    \"owner\": \"0x8c23e5e23c6eb654d69f8ae7de3be23584f435cad81fa4b9cb024b6c989b7818\",\n    \"pool_id\": \"0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7\",\n    \"price\": \"500000\"\n  },\n  \"bcs\": \"2pWctGGQ9KULfmnzNtGuPpggLQrj1ZiUQaxva4neM6QWAtUAkuPAzU2eGrdZaGHti3bsUefDioUwwYoVR3bYBkG7Gxf5JVVSxxqTqzxdg5os5ESwFaP69ZcrNsya4G9rHK4KBac9i3m1MseN38xDwMvAMx3\"\n}\n\n{\n  \"id\": {\n    \"txDigest\": \"896CKHod5GQ4kzhF7EwTAGyhQBdaTb9rQS41dcL76gj8\",\n    \"eventSeq\": \"0\"\n  },\n  \"packageId\": \"0x000000000000000000000000000000000000000000000000000000000000dee9\",\n  \"transactionModule\": \"clob_v2\",\n  \"sender\": \"0xf821d3483fc7725ebafaa5a3d12373d49901bdfce1484f219daa7066a30df77d\",\n  \"type\": \"0xdee9::clob_v2::OrderPlaced<0xbc3a676894871284b3ccfb2eec66f428612000e2a6e6d23f592ce8833c27c973::coin::COIN, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>\",\n  \"parsedJson\": {\n    \"base_asset_quantity_placed\": \"5000000\",\n    \"client_order_id\": \"1696545636947311087\",\n    \"expire_timestamp\": \"1696549236947\",\n    \"is_bid\": true,\n    \"order_id\": \"562414\",\n    \"original_quantity\": \"5000000\",\n    \"owner\": \"0xf995d6df20e18421928ff0648bd583ccdf384ab05791d8be21d32977a37dacfc\",\n    \"pool_id\": \"0xf0f663cf87f1eb124da2fc9be813e0ce262146f3df60bc2052d738eb41a25899\",\n    \"price\": \"274518000000\"\n  },\n  \"bcs\": \"4SgemkCzrqEsTHLFgMcbUtttZCf2CrEH2njjFL1rizCHzvAoYsToGrbFLffQPtGxsSt96Xr4j2SLNeLcBGKeYXDrVYWqivhf3551Mqj71DZBxq5D1Qwfgh1TKeF43Jz4b4XH1nEpkya2Pr8515vzJbHUkpP\"\n}\n\nExamples​\nSubscribe to event​\n\nThis example leverages the Sui TypeScript SDK to subscribe to events the package with ID <PACKAGE_ID> emits. Each time the event fires, the code displays the response to the console.\n\nTypeScript​\n\nTo create the event subscription, you can use a basic Node.js app. You need the Sui TypeScript SDK, so install the module using npm install @mysten/sui.js at the root of your project. In your TypeScript code, import JsonRpcProvider and a connection from the library.\n\nimport { JsonRpcProvider, testnetConnection } from '@mysten/sui.js';\n\n// Package is on Testnet.\nconst provider = new JsonRpcProvider(testnetConnection);\nconst Package = '<PACKAGE_ID>';\n\nconst MoveEventType = '<PACKAGE_ID>::<MODULE_NAME>::<METHOD_NAME>';\n\nconsole.log(\n\tawait provider.getObject({\n\t\tid: Package,\n\t\toptions: { showPreviousTransaction: true },\n\t}),\n);\n\nlet unsubscribe = await provider.subscribeEvent({\n\tfilter: { Package },\n\tonMessage: (event) => {\n\t\tconsole.log('subscribeEvent', JSON.stringify(event, null, 2));\n\t},\n});\n\nprocess.on('SIGINT', async () => {\n\tconsole.log('Interrupted...');\n\tif (unsubscribe) {\n\t\tawait unsubscribe();\n\t\tunsubscribe = undefined;\n\t}\n});\n\nResponse​\n\nWhen the subscribed to event fires, the example displays the following JSON representation of the event.\n\nsubscribeEvent {\n  \"id\": {\n    \"txDigest\": \"HkCBeBLQbpKBYXmuQeTM98zprUqaACRkjKmmtvC6MiP1\",\n    \"eventSeq\": \"0\"\n  },\n  \"packageId\": \"0x2d6733a32e957430324196dc5d786d7c839f3c7bbfd92b83c469448b988413b1\",\n  \"transactionModule\": \"coin_flip\",\n  \"sender\": \"0x46f184f2d68007e4344fffe603c4ccacd22f4f28c47f321826e83619dede558e\",\n  \"type\": \"0x2d6733a32e957430324196dc5d786d7c839f3c7bbfd92b83c469448b988413b1::coin_flip::Outcome\",\n  \"parsedJson\": {\n    \"bet_amount\": \"4000000000\",\n    \"game_id\": \"0xa7e1fb3c18a88d048b75532de219645410705fa48bfb8b13e8dbdbb7f4b9bbce\",\n    \"guess\": 0,\n    \"player_won\": true\n  },\n  \"bcs\": \"3oWWjWKRVu115bnnZphyDcJ8EyF9X4pgVguwhEtcsVpBf74B6RywQupm2X\",\n  \"timestampMs\": \"1687912116638\"\n}\n\nRust SDK​\nuse futures::StreamExt;\nuse sui_sdk::rpc_types::EventFilter;\nuse sui_sdk::SuiClientBuilder;\nuse anyhow::Result;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let sui = SuiClientBuilder::default()\n        .ws_url(\"wss://fullnode.mainnet.sui.io:443\")\n        .build(\"https://fullnode.mainnet.sui.io:443\")\n        .await.unwrap();\n    let mut subscribe_all = sui.event_api().subscribe_event(EventFilter::All(vec![])).await?;\n    loop {\n        println!(\"{:?}\", subscribe_all.next().await);\n    }\n}\n\nFiltering event queries​\n\nTo filter the events returned from your queries, use the following data structures.\n\nINFO\n\nThis set of filters applies only to event querying APIs. It differs from the filters offered for the subscriptions API (see following section). In particular, it does not support combinations like \"All\": [...], \"Any\": [...], \"And\": [_, _], \"Or\": [_, _], and \"Not\": _.\n\nQuery\tDescription\tJSON-RPC Parameter Example\nAll\tAll events\t{\"All\"}\nTransaction\tEvents emitted from the specified transaction\t{\"Transaction\":\"DGUe2TXiJdN3FI6MH1FwghYbiHw+NKu8Nh579zdFtUk=\"}\nMoveModule\tEvents emitted from the specified Move module\t{\"MoveModule\":{\"package\":\"<PACKAGE-ID>\", \"module\":\"nft\"}}\nMoveEventModule\tEvents emitted, defined on the specified Move module.\t{\"MoveEventModule\": {\"package\": \"<DEFINING-PACKAGE-ID>\", \"module\": \"nft\"}}\nMoveEvent\tMove struct name of the event\t{\"MoveEvent\":\"::nft::MintNFTEvent\"}\nEventType\tType of event described in Events section\t{\"EventType\": \"NewObject\"}\nSender\tQuery by sender address\t{\"Sender\":\"0x008e9c621f4fdb210b873aab59a1e5bf32ddb1d33ee85eb069b348c234465106\"}\nRecipient\tQuery by recipient\t{\"Recipient\":{\"AddressOwner\":\"0xa3c00467938b392a12355397bdd3d319cea5c9b8f4fc9c51b46b8e15a807f030\"}}\nObject\tReturn events associated with the given object\t{\"Object\":\"0x727b37454ab13d5c1dbb22e8741bff72b145d1e660f71b275c01f24e7860e5e5\"}\nTimeRange\tReturn events emitted in [start_time, end_time] interval\t{\"TimeRange\":{\"startTime\":1669039504014, \"endTime\":1669039604014}}\nFiltering events for subscription​\n\nTo create a subscription, you can set a filter to return only the set of events you're interested in listening for.\n\nINFO\n\nThis set of filters applies only to event subscription APIs. It differs from the filters offered for the query API (see previous section). In particular, it supports combinations like \"All\": [...], \"Any\": [...], \"And\": [_, _], \"Or\": [_, _], and \"Not\": _.\n\nFilter\tDescription\tJSON-RPC Parameter Example\nPackage\tMove package ID\t{\"Package\":\"<PACKAGE-ID>\"}\nMoveModule\tMove module where the event was emitted\t{\"MoveModule\": {\"package\": \"<PACKAGE-ID>\", \"module\": \"nft\"}}\nMoveEventType\tMove event type defined in the move code\t{\"MoveEventType\":\"<PACKAGE-ID>::nft::MintNFTEvent\"}\nMoveEventModule\tMove event module defined in the move code\t{\"MoveEventModule\": {\"package\": \"<PACKAGE-ID>\", \"module\": \"nft\", \"event\": \"MintNFTEvent\"}}\nMoveEventField\tFilter using the data fields in the move event object\t{\"MoveEventField\":{ \"path\":\"/name\", \"value\":\"NFT\"}}\nSenderAddress\tAddress that started the transaction\t{\"SenderAddress\": \"0x008e9c621f4fdb210b873aab59a1e5bf32ddb1d33ee85eb069b348c234465106\"}\nSender\tSender address\t{\"Sender\":\"0x008e9c621f4fdb210b873aab59a1e5bf32ddb1d33ee85eb069b348c234465106\"}\nTransaction\tTransaction hash\t{\"Transaction\":\"ENmjG42TE4GyqYb1fGNwJe7oxBbbXWCdNfRiQhCNLBJQ\"}\nTimeRange\tTime range in millisecond\t{\"TimeRange\": {\"start_time\": \"1685959791871\", \"end_time\": \"1685959791871\"}}\nEdit this page\nPrevious\nCreate a Non-Fungible Token\nNext\nAccess On-Chain Time\nMove event structure\nDiscovering events\nFilter events\nEmit events in Move\nSubscribe to events in Move\nExamples\nSubscribe to event\nTypeScript\nResponse\nRust SDK\nFiltering event queries\nFiltering events for subscription\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/access-time",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Access On-Chain Time\nAccess On-Chain Time\n\nYou have options when needing to access network-based time for your transactions. If you need a near real-time measurement (within a few seconds), use the immutable reference of time provided by the Clock module in Move. The reference value from this module updates with every network checkpoint. If you don't need as current a time slice, use the epoch_timestamp_ms function to capture the precise moment the current epoch started.\n\nThe sui::clock::Clock module​\n\nTo access a prompt timestamp, you must pass a read-only reference of sui::clock::Clock as an entry function parameter in your transactions. An instance of Clock is provided at address 0x6, no new instances can be created.\n\nExtract a unix timestamp in milliseconds from an instance of Clock using\n\nmodule sui::clock {\n    public fun timestamp_ms(clock: &Clock): u64;\n}\n\n\nThe example below demonstrates an entry function that emits an event containing a timestamp from the Clock:\n\nmodule basics::clock {\n    use sui::{clock::Clock, event};\n\n    public struct TimeEvent has copy, drop, store {\n        timestamp_ms: u64,\n    }\n\n    entry fun access(clock: &Clock) {\n        event::emit(TimeEvent { timestamp_ms: clock.timestamp_ms() });\n    }\n}\n\n\nA call to the previous entry function takes the following form, passing 0x6 as the address for the Clock parameter:\n\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client call --package <EXAMPLE> --module 'clock' --function 'access' --args '0x6' --gas-budget <GAS-AMOUNT>\n\n\nExpect the Clock timestamp to change at the rate the network generates checkpoints, which is every 1 second with Narwhal/Bullshark consensus and every 0.1 to 0.2 seconds with Mysticeti consensus.\n\nSuccessive calls to sui::clock::timestamp_ms in the same transaction always produce the same result (transactions are considered to take effect instantly), but timestamps from Clock are otherwise monotonic across transactions that touch the same shared objects: Successive transactions seeing a greater or equal timestamp to their predecessors.\n\nAny transaction that requires access to a Clock must go through consensus because the only available instance is a shared object. As a result, this technique is not suitable for transactions that must use the single-owner fastpath (see Epoch timestamps for a single-owner-compatible source of timestamps).\n\nTransactions that use the clock must accept it as an immutable reference (not a mutable reference or value). This prevents contention, as transactions that access the Clock can only read it, so do not need to be sequenced relative to each other. Validators refuse to sign transactions that do not meet this requirement and packages that include entry functions that accept a Clock or &mut Clock fail to publish.\n\nThe following functions test Clock-dependent code by manually creating a Clock object and manipulating its timestamp. This is possible only in test code:\n\nmodule sui::clock {\n    #[test_only]\n    public fun create_for_testing(ctx: &mut TxContext);\n\n    #[test_only]\n    public fun share_for_testing(clock: Clock);\n\n    #[test_only]\n    public fun increment_for_testing(clock: &mut Clock, tick: u64);\n\n    #[test_only]\n    public fun set_for_testing(clock: &mut Clock, timestamp_ms: u64);\n\n    #[test_only]\n    public fun destroy_for_testing(clock: Clock);\n}\n\n\nThe next example presents a simple test that creates a Clock, increments it, and then checks its value:\n\nmodule example::clock_tests {\n    use sui::clock::{Self, Clock};\n    use sui::tx_context;\n\n    #[test]\n    fun creating_a_clock_and_incrementing_it() {\n        let ctx = tx_context::dummy();\n        let clock = clock::create_for_testing(&mut ctx);\n\n        clock.increment_for_testing(42);\n        assert!(clock.timestamp_ms() == 42, 1);\n\n        clock.set_for_testing(50);\n        assert!(clock.timestamp_ms() == 50, 1);\n\n        clock.destroy_for_testing();\n    }\n}\n\nEpoch timestamps​\n\nYou can use the following function to access the timestamp for the start of the current epoch for all transactions (including ones that do not go through consensus):\n\nmodule sui::tx_context {\n    public fun epoch_timestamp_ms(ctx: &TxContext): u64;\n}\n\n\nThe preceding function returns the point in time when the current epoch started, as a millisecond granularity unix timestamp in a u64. This value changes roughly once every 24 hours, when the epoch changes.\n\nTests based on sui::test_scenario can use later_epoch (following code), to exercise time-sensitive code that uses epoch_timestamp_ms (previous code):\n\nmodule sui::test_scenario {\n    public fun later_epoch(\n        scenario: &mut Scenario,\n        delta_ms: u64,\n        sender: address,\n    ): TransactionEffects;\n}\n\n\nlater_epoch behaves like sui::test_scenario::next_epoch (finishes the current transaction and epoch in the test scenario), but also increments the timestamp by delta_ms milliseconds to simulate the progress of time.\n\nEdit this page\nPrevious\nUsing Events\nNext\nSigning and Sending Transactions\nThe sui::clock::Clock module\nEpoch timestamps\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/create-nft",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Create a Non-Fungible Token\nCreate a Non-Fungible Token\n\nOn Sui, everything is an object. Moreover, in Sui, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned. So technically, a basic type publishing is enough to create a specific NFT.\n\nmodule examples::devnet_nft {\n    use sui::url::{Self, Url};\n    use std::string;\n    use sui::object::{Self, ID, UID};\n    use sui::event;\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    /// An example NFT that can be minted by anybody\n    struct DevNetNFT has key, store {\n        id: UID,\n        /// Name for the token\n        name: string::String,\n        /// Description of the token\n        description: string::String,\n        /// URL for the token\n        url: Url,\n        // TODO: allow custom attributes\n    }\n\n    // ===== Events =====\n\n    struct NFTMinted has copy, drop {\n        // The Object ID of the NFT\n        object_id: ID,\n        // The creator of the NFT\n        creator: address,\n        // The name of the NFT\n        name: string::String,\n    }\n\n    // ===== Public view functions =====\n\n    /// Get the NFT's `name`\n    public fun name(nft: &DevNetNFT): &string::String {\n        &nft.name\n    }\n\n    /// Get the NFT's `description`\n    public fun description(nft: &DevNetNFT): &string::String {\n        &nft.description\n    }\n\n    /// Get the NFT's `url`\n    public fun url(nft: &DevNetNFT): &Url {\n        &nft.url\n    }\n\n    // ===== Entrypoints =====\n\n    /// Create a new devnet_nft\n    public fun mint_to_sender(\n        name: vector<u8>,\n        description: vector<u8>,\n        url: vector<u8>,\n        ctx: &mut TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let nft = DevNetNFT {\n            id: object::new(ctx),\n            name: string::utf8(name),\n            description: string::utf8(description),\n            url: url::new_unsafe_from_bytes(url)\n        };\n\n        event::emit(NFTMinted {\n            object_id: object::id(&nft),\n            creator: sender,\n            name: nft.name,\n        });\n\n        transfer::public_transfer(nft, sender);\n    }\n\n    /// Transfer `nft` to `recipient`\n    public fun transfer(\n        nft: DevNetNFT, recipient: address, _: &mut TxContext\n    ) {\n        transfer::public_transfer(nft, recipient)\n    }\n\n    /// Update the `description` of `nft` to `new_description`\n    public fun update_description(\n        nft: &mut DevNetNFT,\n        new_description: vector<u8>,\n        _: &mut TxContext\n    ) {\n        nft.description = string::utf8(new_description)\n    }\n\n    /// Permanently delete `nft`\n    public fun burn(nft: DevNetNFT, _: &mut TxContext) {\n        let DevNetNFT { id, name: _, description: _, url: _ } = nft;\n        object::delete(id)\n    }\n}\n\nEdit this page\nPrevious\nLoyalty Tokens\nNext\nUsing Events\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Create Coins and Tokens | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/create-coin",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nRegulated Coin and Deny List\nIn-Game Currency\nLoyalty Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Create Coins and Tokens\nCreate Coins and Tokens\n\nCoins and tokens on Sui are similar. In practice, the terms are used interchangeably, but there are some differences in their implementation. You can learn about these differences in the respective standard documentation, Closed-Loop Token and Coin.\n\nPublishing a coin on Sui is nearly as straightforward as publishing a new type. The main difference is the requirement of a one-time witness when creating a coin.\n\nmodule examples::mycoin {\n    use std::option;\n    use sui::coin::{Self, Coin, TreasuryCap};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    /// The type identifier of coin. The coin will have a type\n    /// tag of kind: `Coin<package_object::mycoin::MYCOIN>`\n    /// Make sure that the name of the type matches the module's name.\n    struct MYCOIN has drop {}\n\n    /// Module initializer is called once on module publish. A treasury\n    /// cap is sent to the publisher, who then controls minting and burning\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(witness, 6, b\"MYCOIN\", b\"\", b\"\", option::none(), ctx);\n        transfer::public_freeze_object(metadata);\n        transfer::public_transfer(treasury, tx_context::sender(ctx))\n    }\n}\n\n\nThe Coin<T> is a generic implementation of a coin on Sui. Access to the TreasuryCap provides control over the minting and burning of coins. Further transactions can be sent directly to the sui::coin::Coin with TreasuryCap object as authorization.\n\nExtending the example further, add a mint function to the module. Use the mint function of the Coin module to create (mint) a coin and then transfer it to an address.\n\npublic fun mint(\n    treasury_cap: &mut TreasuryCap<MYCOIN>, \n    amount: u64, \n    recipient: address, \n    ctx: &mut TxContext,\n) {\n    let coin = coin::mint(treasury_cap, amount, ctx);\n    transfer::public_transfer(coin, recipient)\n}\n\nSui CLI​\n\nIf you published the previous example to a Sui network, you can use the sui client call command to mint coins and deliver them to the address you provide. See Sui CLI for more information on the command line interface.\n\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client call --function mint --module mycoin --package <PACKAGE-ID> --args <TREASURY-CAP-ID> <COIN-AMOUNT> <RECIPIENT-ADDRESS> --gas-budget <GAS-AMOUNT>\n\n\nIf the call is successful your console displays the result, which includes a Balance Changes section with the following information included:\n\n...\n\nOwner: Account Address ( <RECIPIENT-ADDRESS> ) \nCoinType: <PACKAGE-ID>::mycoin::MYCOIN \nAmount: <COIN-AMOUNT>\n\n...\n\nDenyList​\n\nThe Sui framework provides a DenyList singleton, shared object that the bearer of a DenyCap can access to specify a list of addresses that are unable to use a Sui core type. The initial use case for DenyList, however, focuses on limiting access to coins of a specified type. This is useful, for example, when creating a regulated coin on Sui that requires the ability to block certain addresses from using it as inputs to transactions. Regulated coins on Sui satisfy any regulations that require the ability to prevent known bad actors from having access to those coins.\n\nINFO\n\nThe DenyList object is a system object that has the address 0x403. You cannot create it yourself.\n\nCreate regulated coin​\n\nIf you need the ability to deny specific addresses from having access to your coin, you can use the create_regulated_currency function (instead of create_currency) to create it.\n\nBehind the scenes, create_regulated_currency uses the create_currency function to create the coin, but also produces a DenyCap object that allows its bearer to control access to the coin's deny list in a DenyList object. Consequently, the way to create a coin using create_regulated_currency is similar to the previous example, with the addition of a transfer of the DenyCap object to the module publisher.\n\nCreate tokens​\n\nTokens reuse the TreasuryCap defined in the sui::coin module and therefore have the same initialization process. The coin::create_currency function guarantees the uniqueness of the TreasuryCap and forces the creation of a CoinMetadata object.\n\nCoin-like functions perform the minting and burning of tokens. Both require the TreasuryCap:\n\ntoken::mint - mint a token\ntoken::burn - burn a token\n\nSee Closed-Loop Token standard for complete details of working with tokens.\n\nExamples​\n\nSee the following topics for examples of some common use cases for coin and token creation.\n\nRegulated Coin and Deny List: Create a regulated coin and add or remove names from the deny list.\nLoyalty Token: Create a token to reward user loyalty.\nIn-Game Token: Create tokens that can be used only within a mobile game.\nEdit this page\nPrevious\nShared versus Owned Objects\nNext\nRegulated Coin and Deny List\nSui CLI\nDenyList\nCreate regulated coin\nCreate tokens\nExamples\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Shared versus Owned Objects | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101/shared-owned",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101Shared versus Owned Objects\nShared versus Owned Objects\n\nObjects on Sui can be shared (accessible for reads and writes by any transaction) or owned (accessible for reads and writes by transactions signed by their owner). Many applications can be built using a solution that either uses shared objects or only owned objects, with trade-offs for each that need to be weighed.\n\nTransactions that use only owned objects benefit from very low latency to finality, because they do not need to go through consensus. On the other hand, the fact that only the owner of the object can access it complicates processes that need to work with objects owned by multiple parties, and access to very hot objects needs to be coordinated off-chain.\n\nTransactions that access one or more shared objects require consensus to sequence reads and writes to those objects, resulting in a slightly higher gas cost and increased latency.\n\nTransactions that access multiple shared objects, or particularly popular objects, might have increases in latency due to contention. However, the advantage of using shared objects lies in the flexibility of allowing multiple addresses to access the same object in a coordinated manner.\n\nTo summarize, applications that are extremely sensitive to latency or gas costs, that do not need to handle complex multi-party transactions, or that already require an off-chain service could benefit from a design that only uses owned objects. Applications that require coordination between multiple parties will likely benefit from using shared objects.\n\nFor more information on the types of objects that Sui supports, see Object Ownership.\n\nExample: Escrow​\n\nThe Escrow example demonstrates the trade-offs between shared objects and owned objects by implementing the same application in both styles. It implements a service that allows two addresses to perform a trustless swap of objects with each other (a \"trade\") with the service holding their objects in escrow.\n\nLocked<T> and Key​\n\nCode Sample\n\nBoth implementations use a primitive for locking values, which offers the following interface:\n\nmodule escrow::lock {\n    public fun lock<T: store>(obj: T, ctx: &mut TxContext): (Locked<T>, Key);\n    public fun unlock<T: store>(locked: Locked<T>, key: Key): T\n}\n\n\nAny T: store can be locked, to get a Locked<T> and a corresponding Key, and conversely, the locked value and its corresponding key can be consumed to get back the wrapped object.\n\nThe important property that this interface provides is that locked values cannot be modified except by unlocking them first (and later relocking them). Because unlocking consumes the key, tampering with a locked value can be detected by remembering the ID of the key that it was locked with. This prevents situations where one party in a swap changes the object they are offering to reduce its value.\n\nOwned objects​\n\nCode Sample\n\nThe protocol for swapping via escrow implemented using owned objects starts with both parties locking their respective objects.\n\nThis is used to prove that the object has not been tampered with after the swap has been agreed to. If either party doesn't want to proceed at this stage, they just unlock their object.\n\nAssuming both parties are happy to continue, the next step requires both parties to swap the keys.\n\nA third party acts as custodian. The custodian holds objects that are waiting for their counterparts to arrive and when they arrive, it matches them up to complete the swap.\n\npublic fun create<T: key + store>(\n    key: Key,\n    locked: Locked<T>,\n    exchange_key: ID,\n    recipient: address,\n    custodian: address,\n    ctx: &mut TxContext,\n) {\n    let escrow = Escrow {\n        id: object::new(ctx),\n        sender: tx_context::sender(ctx),\n        recipient,\n        exchange_key,\n        escrowed_key: object::id(&key),\n        escrowed: lock::unlock(locked, key),\n    };\n\n    transfer::transfer(escrow, custodian);\n}\n\n\nThe create function prepares the Escrow request and sends it to the custodian. The object being offered by this party is passed in, locked, with its key, and the object being requested is identified by the ID of the key it was locked with. While preparing the request, the offered object is unlocked, while remembering the ID of its key.\n\nAlthough the custodian is trusted to preserve liveness (to complete swaps if it owns both sides of a swap and to return objects if requested), all other correctness properties are maintained in Move: Even though the custodian owns both objects being swapped, the only valid action they are permitted to take is to match them up with their correct counterpart to finish the swap, or to return them:\n\npublic fun swap<T: key + store, U: key + store>(\n    obj1: Escrow<T>,\n    obj2: Escrow<U>,\n) {\n    let Escrow {\n        id: id1,\n        sender: sender1,\n        recipient: recipient1,\n        exchange_key: exchange_key1,\n        escrowed_key: escrowed_key1,\n        escrowed: escrowed1,\n    } = obj1;\n\n    let Escrow {\n        id: id2,\n        sender: sender2,\n        recipient: recipient2,\n        exchange_key: exchange_key2,\n        escrowed_key: escrowed_key2,\n        escrowed: escrowed2,\n    } = obj2;\n\n    object::delete(id1);\n    object::delete(id2);\n\n    // Make sure the sender and recipient match each other\n    assert!(sender1 == recipient2, EMismatchedSenderRecipient);\n    assert!(sender2 == recipient1, EMismatchedSenderRecipient);\n\n    // Make sure the objects match each other and haven't been modified\n    // (they remain locked).\n    assert!(escrowed_key1 == exchange_key2, EMismatchedExchangeObject);\n    assert!(escrowed_key2 == exchange_key1, EMismatchedExchangeObject);\n\n    // Do the actual swap\n    transfer::public_transfer(escrowed1, recipient1);\n    transfer::public_transfer(escrowed2, recipient2);\n}\n\n\nThe swap function checks that senders and recipients match and that each party wants the object that the other party is offering, by comparing their respective key IDs. If the custodian tried to match together two unrelated escrow requests to swap, the transaction would not succeed.\n\nShared objects​\n\nCode Sample\n\nThe protocol in the shared object case is less symmetric, but still starts with the first party locking the object they want to swap.\n\nThe second party can then view the object that was locked, and if they decide they want to swap with it, they indicate their interest by creating a swap request:\n\npublic fun create<T: key + store>(\n    escrowed: T,\n    exchange_key: ID,\n    recipient: address,\n    ctx: &mut TxContext\n) {\n    let escrow = Escrow {\n        id: object::new(ctx),\n        sender: tx_context::sender(ctx),\n        recipient,\n        exchange_key,\n        escrowed,\n    };\n\n    transfer::public_share_object(escrow);\n}\n\n\nThis time the create request accepts the object being escrowed directly (not locked), and creates a shared Escrow object. The request remembers the address that sent it (who is allowed to reclaim the object if the swap hasn't already happened), and the intended recipient, who is then expected to continue the swap by providing the object they initially locked:\n\npublic fun swap<T: key + store, U: key + store>(\n    escrow: Escrow<T>,\n    key: Key,\n    locked: Locked<U>,\n    ctx: &TxContext,\n): T {\n    let Escrow {\n        id,\n        sender,\n        recipient,\n        exchange_key,\n        escrowed,\n    } = escrow;\n\n    assert!(recipient == tx_context::sender(ctx), EMismatchedSenderRecipient);\n    assert!(exchange_key == object::id(&key), EMismatchedExchangeObject);\n\n    // Do the actual swap\n    transfer::public_transfer(lock::unlock(locked, key), sender);\n    object::delete(id);\n\n    escrowed\n}\n\n\nEven though the Escrow object is a shared object that is accessible by anyone, the Move interface ensures that only the original sender and the intended recipient can successfully interact with it. swap checks that the locked object matches the object that was requested when the Escrow was created (again, by comparing key IDs) and assumes that the intended recipient wants the escrowed object (if they did not, they would not have called swap).\n\nAssuming all checks pass, the object held in Escrow is extracted, its wrapper is deleted and it is returned to the first party. The locked object offered by the first party is also unlocked and sent to the second party, completing the swap.\n\nComparison​\n\nThis topic explores two ways to implement a swap between two objects. In both cases there is a point at which one party has made a request and the other has not responded. At this point, both parties may want to access the Escrow object: One to cancel the swap, and the other to complete it.\n\nIn one case, the protocol uses only owned objects but requires a custodian to act as an intermediary. This has the advantage of avoiding the costs and latencies of consensus altogether, but involves more steps and requires trusting a third party for liveness.\n\nIn the other case, the object is custodied on chain in a shared object. This requires consensus but involves fewer steps, and no third party.\n\nEdit this page\nPrevious\nSui 101\nNext\nCreate Coins and Tokens\nExample: Escrow\nLocked<T> and Key\nOwned objects\nShared objects\nComparison\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/advanced/move-2024-migration",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nMigrating to GraphQL\nMigrating to Move 2024\nAsset Tokenization\nCustom Indexer\nOn-Chain Randomness\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesAdvanced TopicsMigrating to Move 2024\nMigrating to Move 2024\n\nNew features for Move are becoming available in 2024, a part of the aptly titled \"Move 2024\" edition. Many of these changes are enhancements to the source language, affecting the compiler without requiring any changes to the binary representation published on chain.\n\nThe primary goal of these changes is to make Move easier to write, and hopefully easier to read. The relatively few breaking changes introduced to the source language are to better position Move to handle future advancements.\n\nExisting code will continue to compile, even with the addition of these new features. And because these features are opt-in, you can write your packages with the new features, even if your dependencies do not. Opting to take advantage of the new features in your current modules, however, does introduce some breaking changes.\n\nThis document highlights some new features to try out and shows how to migrate your existing modules to use Move 2024.\n\nINFO\n\nPlease, provide any feedback or report any issues you encounter via GitHub, Discord, or Telegram.\n\nHow to migrate​\n\nTo migrate a project to Move 2024 Beta:\n\nDelete your existing Move.lock file (if one exists) to make sure you're using the newest sui-framework version.\nPerform one of the following:\nRun sui move migrate in the root of your Move project. See Automatic migration.\nAlternatively, update your Move.toml file's [package] entry to include edition = \"2024.beta\". If you do this, you might receive a number of new errors related to the breaking changes.\nAutomatic migration​\n\nMove 2024 includes an automatic migration script that you can use by calling sui move migrate in the root of your Move project. Upon running, your console prompts you for which Move edition to use. If you select 2024.beta, the script invokes the compiler and attempts to automatically update your code to avoid the breaking changes the update introduces (including marking structs as public, mutable variables with the mut keyword, avoiding restricted keywords, swapping friends for public(package), and even updating paths to global paths in many cases).\n\nAfter this is done, your console displays a diff of the changes the script intends to make. If you accept the changes, the script updates your code and your Move.toml file automatically. You are now using Move 2024 Beta.\n\nUpdate IDE support​\n\nUse the new VSCode Move extension to get support for Move 2024 features. The new extension has a number of improvements over the original move-analyzer extension, but if you would like to keep using the original one, be sure to rebuild and reinstall the move-analyzer binary to get 2024 support:\n\ncargo install --git https://github.com/MystenLabs/sui.git move-analyzer\n\n\nSee the getting started guide on Move IDEs and plugins for more information.\n\nNew features​\n\nHere is a brief overview of some of the new features in Move 2024.\n\nMethod syntax​\n\nYou can call certain functions now as methods using the . syntax. For example, the following call\n\nvector::push_back(&mut v, coin::value(&c));\n\n\ncan now be written as\n\nv.push_back(c.value());\n\n\nWhere the receiver of the method (v and c in this example) is automatically borrowed if necessary (as &mut v and &c respectively).\n\nYou can call any function defined in the same module as the receiver's type as a method if it takes the receiver as its first argument.\n\nFor functions defined outside the module, you can declare methods using public use fun and use fun.\n\nIndex syntax​\n\nWith method syntax, you can annotate certain functions as being #[syntax(index)] methods. You then call these methods using v[i]-style calls.\n\nFor example,\n\n*&mut v[i] = v[j];\n\n\nresolves to\n\n*vector::borrow_mut(&mut v, i) = *vector::borrow(&v, j);\n\npublic(package)​\n\nfriend declarations, and the associated public(friend) visibility modifiers, are deprecated. In their place is the public(package) visibility modifier, which allows calling functions only within the same package where they are defined.\n\nPositional fields​\n\nYou can now define structs with positional fields, which are accessed by zero-based index. For example,\n\npublic struct Pair(u64, u64) has copy, drop, store;\n\n\nthen to access each field,\n\npublic fun sum(p: &Pair): u64 {\n  p.0 + p.1\n}\n\n\nAnd as this example shows, you can now declare abilities after the struct field list.\n\nNested use and standard library defaults​\n\nYou can now nest use aliases for more conciseness.\n\nuse sui::{balance, coin::{Self, Coin}};\n\n\nAdditionally, the following use declarations are now automatically included in every module:\n\nuse std::vector;\nuse std::option::{Self, Option};\nuse sui::object::{Self, ID, UID};\nuse sui::transfer;\nuse sui::tx_context::{Self, TxContext};\n\nAutomatic referencing in equality​\n\nEquality operations, == and !=, now automatically borrow if one side is a reference and the other is not. For example,\n\nfun check(x: u64, r: &u64): bool {\n  x == r\n}\n\n\nis equivalent to\n\nfun check(x: u64, r: &u64): bool {\n  &x == r\n}\n\n\nThis automatic borrowing can occur on either side of == and !=.\n\nLoop labels​\n\nWhen nesting loops, it can be convenient to break to the outer loop. For example,\n\nlet mut i = 0;\nlet mut j = 0;\nlet mut terminate_loop = false;\nwhile (i < 10) {\n    while (j < 10) {\n        if (haystack(i, j) == needle) {\n            terminate_loop = true;\n            break;\n        };\n        j = j + 1;\n    };\n    if (terminate_loop) break;\n    i = i + 1;\n}\n\n\nNow, you can directly name the outer loop (outer in this case) and break it all at once:\n\nlet mut i = 0;\nlet mut j = 0;\n'outer: while (i < 10) {\n    while (j < 10) {\n        if (haystack(i, j) == needle) break'outer;\n        j = j + 1;\n    };\n    i = i + 1;\n}\n\nbreak with value​\n\nIt's now possible to break with a value from a loop. For example,\n\nlet mut i = 0;\nlet x: u64 = loop {\n    if (v[i] > 10) break i;\n    i = i + 1;\n};\n\n\nYou can achieve this with labels, as well. For example,\n\nlet mut i = 0;\nlet mut j = 0;\nlet item = 'outer: loop {\n    while (j < 10) {\n        let item = haystack(i, j);\n        if (item == needle) break'outer option::some(item);\n        j = j + 1;\n    };\n    i = i + 1;\n    if (i == 10) break option::none();\n};\n\nBreaking changes​\n\nBreaking changes are, unfortunately, a growing pain in Move 2024. We anticipate these changes to be minimally invasive and have provided a migration script to automate them in most cases. In addition, these changes pave the way for new features still to come in Move 2024.\n\nDatatype visibility requirements​\n\nCurrently, all structs in Move are, by convention, public: any other module or package can import them and refer to them by type. To make this clearer, Move 2024 requires that all structs be declared with the public keyword. For example,\n\n// legacy code\nstruct S { x: u64 }\n\n// Move 2024 code\npublic struct S { x: u64 }\n\n\nAny non-public struct produces an error at this time, though the Move team is working on new visibility options for future releases.\n\nMutability requirements​\n\nPreviously, all variables in Move were implicitly mutable. For example,\n\nfun f(s: S, y: u64): u64 {\n    let a = 0;\n    let S { x } = s;\n    a = 1;\n    x = 10;\n    y = 5;\n    x + y\n}\n\n\nNow, you must declare mutable variables explicitly:\n\nfun f(s: S, mut y: u64): u64 {\n    let mut a = 0;\n    let S { mut x } = 5;\n    a = 1;\n    x = 10;\n    y = 5;\n    x + y\n}\n\n\nThe compiler now produces an error if you attempt to reassign or borrow a variable mutably without this explicit declaration.\n\nRemoving friends and public(friend)​\n\nFriends and the public(friend) visibilities were introduced early in Move's development, predating even the package system. As indicated in the public(package) section, public(package) deprecates public(friend) in Move 2024.\n\nThe following declaration now produces an error:\n\nmodule pkg::m {\n    friend pkg::a;\n    public(friend) fun f() { ... }\n}\n\nmodule pkg::a {\n    fun calls_f() { ... pkg::m::f() ... }\n}\n\n\nInstead, if you want your function to be visible only in the package, write:\n\nmodule pkg::m {\n    public(package) fun f() { ... }\n}\n\nmodule pkg::a {\n    // this now works directly\n    fun calls_f() { ... pkg::m::f() ... }\n}\n\nNew keywords​\n\nLooking toward the future, Move 2024 Beta adds the following keywords to the language: enum, for, match, mut, and type. The compiler, unfortunately, now produces parsing errors when it finds these in other positions. This is a necessary change as the language matures. If you perform automatic migration, the migration tool renames these as enum and so on, rewriting the code to use these escaped forms.\n\nRevised paths and namespaces​\n\nMove 2024 revises how paths and namespaces work compared to legacy Move, toward easing enum aliasing in the future. Consider the following snippet from a test annotation in the sui_system library:\n\nuse sui_system::sui_system;\n...\n#[expected_failure(abort_code = sui_system::validator_set::EInvalidCap)]\n\n\nLegacy Move would always treat a three-part name as an address(sui_system), module(validator_set), and module member (EInvalidCap). Move 2024 respects scope for use, so sui_system in the attribute resolves to the module, producing a name resolution error overall.\n\nTo avoid cases where this is the intended behavior, Move 2024 introduces a prefix operation for global qualification. To use, you can rewrite this annotation as:\n\nuse sui_system::sui_system;\n...\n#[expected_failure(abort_code = ::sui_system::validator_set::EInvalidCap)]\n                             // ^ note `::` here\n\n\nThe migration script attempts to remediate naming errors using global qualification when possible.\n\nFollow along​\n\nThe beta release of Move 2024 comes with some powerful new features in addition to the breaking changes described here. There are also more on the horizon. Join the Sui developer newsletter to learn about new, exciting features coming to Move this year, including syntactic macros, enums with pattern matching, and other user-defined syntax extensions.\n\nalpha and beta guidance​\nbeta (specified via edition = \"2024.beta\") is the recommended edition. It includes all the new features mentioned above and all breaking changes. While there is the risk of breaking changes or bugs in beta, you should feel comfortable using it in your projects. As new features are added and tested, they will be included in the beta edition. The beta edition will end after all features for the year have been added and finalized.\nalpha (specified via edition = \"2024.alpha\") will get new features and changes as they are developed. Breaking changes to features in alpha should be expected. As such, take caution when usingalpha in your projects.\nEdit this page\nPrevious\nMigrating to GraphQL\nNext\nAsset Tokenization\nHow to migrate\nAutomatic migration\nUpdate IDE support\nNew features\nMethod syntax\nIndex syntax\npublic(package)\nPositional fields\nNested use and standard library defaults\nAutomatic referencing in equality\nLoop labels\nbreak with value\nBreaking changes\nDatatype visibility requirements\nMutability requirements\nRemoving friends and public(friend)\nNew keywords\nRevised paths and namespaces\nFollow along\nalpha and beta guidance\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Gas in Sui | Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/gas-in-sui",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsGas in Sui\nGas in Sui\n\nA Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates. Specifically, Sui Gas Pricing is such that any transaction pays the following gas fees:\n\ntotal_gas_fees = computation_units * reference_gas_price + storage_units * storage_price\n\nWhile computation and storage fees are separate, they are conceptually similar in that they each translate computation or storage into SUI terms by multiplying computation or storage units by the relevant price.\n\nFinally, Sui Storage mechanics provide storage fee rebates whenever a transaction deletes previously stored objects. Hence, the net fees that a user pays equals gas fees minus the rebates associated with data deletion:\n\nnet_gas_fees = computation_gas_fee + storage_gas_fee - storage_rebate\n\nThe information on net gas fees displays in a Sui network explorer for each transaction block:\n\n The Gas Fees section for a transaction block displayed on a Sui network explorer\n\nGas prices​\n\nThe reference gas price translates the real-time cost of executing a transaction into SUI units and the validator set updates it at each epoch boundary. Similarly, the storage price translates the long-term cost of storing data on chain into SUI units and updates infrequently; often remaining constant for various consecutive epochs. During regular network operations, all Sui users can expect to pay the reference gas price and storage price for computation and storage, respectively.\n\nGas units​\n\nGas units include both\n\nComputation units\nStorage units\nComputation units​\n\nDifferent Sui transactions require varying amounts of computational time for processing and execution. Sui translates these varying operational loads into transaction fees by measuring each transaction in terms of computation units. In general, more complex transactions require more computation units.\n\nImportantly, though, Sui computation gas schedule is built coarsely with a bucketing approach. Two relatively similar transactions translate into the exact same amount of computation units if they are in the same bucket, whereas two relatively different transactions translate into different amounts of computation units if they fall in separate buckets. The smallest bucket maps into 1,000 computation units, meaning that all transactions that fall into the smallest bucket cost 1,000 computation units. The largest bucket maps into 5,000,000 computation units; if a transaction requires more computation units, it aborts.\n\nUsing coarse bucketing accomplishes two important goals:\n\nFrees you from optimizing your smart contracts to deliver marginal gains in gas costs via \"gas golfing\" — instead, you can focus on step-function improvements in your products and services.\nGives you the freedom to adjust per-instruction gas costs and experiment with new gas metering schemes without creating significant development disruption. This can happen frequently, so it's important that you do not rely on per-instruction gas costs remaining stable over time.\nBucket Lower Threshold\tBucket Upper Threshold\tComputation Units\n0\t1,000\t1,000\n1,001\t5,000\t5,000\n5,001\t10,000\t10,000\n10,001\t20,000\t20,000\n20,001\t50,000\t50,000\n50,001\t200,000\t200,000\n200,001\t1,000,000\t1,000,000\n1,000,001\t5,000,000\t5,000,000\n5,000,001\tInfinity\ttransaction will abort\nStorage units​\n\nSimilarly, Sui transactions vary depending on the amount of new data written into on-chain storage. The variable storage units capture these differences by mapping the amount of bytes held in storage into storage units. The current Sui schedule is linear and maps each byte into 100 storage units. So, for example, a transaction that stores 25 bytes costs 2,500 storage units, while a transaction that stores 75 bytes costs 7,500 units.\n\nImportantly, in the Sui Storage Fund model users pay up front for the cost of storing data in perpetuity but can also get a partial rebate on previously stored data, if that data is deleted. Hence, the amount of storage fees that you pay can be split into a rebateable and non-rebateable amount. Initially, the rebateable amount equals 99% of the storage fees, while the non-rebateable amount equals the remaining 1%.\n\nGas budgets​\n\nYou must submit all transactions need together with a gas budget. This provides a cap to the amount of gas fees you pay, especially because sometimes it might be hard to perfectly forecast how much a transaction costs before you submit it to the Sui network.\n\nThe gas budget for a Sui transaction is defined in SUI units and transactions are successfully executed if:\n\ngas_budget >= max{computation_fees,total_gas_fees}\n\nIf the gas budget does not fulfill this condition, then the transaction fails and a portion of the gas budget is charged. In cases where the gas_budget is insufficient for covering computation_fees, then the entirety of the gas_budget is charged. In cases where gas_budget is sufficient for covering computation_fees but not the total_gas_fees, then a portion of the gas_budget corresponding to computation_fees and the fees associated with mutating the transaction's input objects are charged.\n\nUltimately, a successful transaction requires the end user to pay the transaction's total_gas_fees. However, since it is challenging to perfectly forecast computation time before the transaction is processed, the gas_budget condition also requires the gas_budget to be at least as large as the transaction's computation_fees in case the transaction aborts. In some cases -- especially in the presence of high storage rebates, and, thus negative net storage fees -- the gas budget might be higher than the total gas fees you pay.\n\nImportantly, the minimum gas budget is 2,000 MIST (.000002 SUI). This ensures validators are compensated with at least 2,000 MIST even if the gas budget is incorrectly specified and the transaction aborts. Additionally, this protects the Sui network from being spammed with a large number of transactions with minimal gas budgets. The maximum gas budget is 50 billion MIST or 50 SUI. This protects the network against overflow of internal multiplications and gas limits for denial of service attacks.\n\nAs mentioned previously, the storage rebate currently equals 99% of the originally paid storage fees. Because the gas budget applies to the totality of gas fees, it is often the case that a transaction only goes through if the gas budget is considerably higher than the net gas fees that a user ultimately pays.\n\nGas budget examples​\n\nThe following table provides some examples of gas accounting on the Sui network. Within the first two and last two rows, computation units are the same because transactions fall within the same bucket. However, the last two transactions are more complex than the first two and thus fall in a higher bucket. Finally, in the last transaction the storage rebate is large enough to fully offset the transaction gas fees and actually pays the user back a positive amount of SUI.\n\nThese examples showcase the importance of the gas budget. The minimum gas budget is the smallest amount a transaction can specify to successfully execute. Importantly, when there is a storage rebate, the minimum gas budget is larger than the amount of net gas fees a user ultimately pays — this is especially stark in the last example where the user receives a positive amount back for executing the transaction. This is because the minimum gas budget must be higher than a transaction's computation fees.\n\n\tReference Gas Price\tComputation Units\tStorage Price\tStorage Units\tStorage Rebate\tMinimum Gas Budget\tNet Gas Fees\nSimple transaction storing 10 bytes\t1,000 MIST\t1,000\t75 MIST\t1,000\t0 MIST\t1,075,000 MIST\t1,075,000 MIST\nSimple transaction storing 10 bytes and deleting data\t500 MIST\t1,000\t75 MIST\t1,000\t100,000 MIST\t500,000 MIST\t475,000 MIST\nComplex transaction storing 120 bytes\t1,000 MIST\t5,000\t200 MIST\t12,000\t0 MIST\t7,400,000 MIST\t7,400,000 MIST\nComplex transaction storing 120 bytes and deleting data\t500 MIST\t5,000\t200 MIST\t12,000\t5,000,000 MIST\t2,500,000 MIST\t-100,000 MIST\nEdit this page\nPrevious\nSui Gas Pricing\nNext\nResearch Papers\nGas prices\nGas units\nComputation units\nStorage units\nGas budgets\nGas budget examples\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Protocol Upgrades | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture/protocol-upgrades",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui ArchitectureProtocol Upgrades\n\nThe Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. This functionality is added in the form of new code which is released to validator operators as part of our regular software releases. The Sui protocol, however, requires that all Sui validators agree about the results of executing each transaction.\n\nThis poses the following challenge: How do we release code that changes transaction execution, given that it is not possible to ensure that all operators upgrade their software at the same instant? Further, how do we ensure that all Sui transaction history can be replayed even after functionality has changed?\n\nTo solve this problem, Sui uses a process called protocol upgrades.\n\nProtocol upgrade process\n\nAn outline of the process used for protocol upgrades includes the following steps:\n\nA Sui developer codes the new feature, but restricts access to the feature using a \"feature flag\" - a boolean config variable that is initially set to false.\nThe value of the feature flag is retrieved from a struct called ProtocolConfig.\nThe developer creates a new version of the ProtocolConfig struct where the new feature flag is set to true.\nA new release of the Sui validator software is built and released to validator and Full node operators.\nWhen the validator process starts up, it continues to use the previous version of ProtocolConfig (in which the flag is false). This way, all validators continue behaving identically regardless of whether they have the new software or not.\nAs validators are upgraded, they signal to the rest of the validator committee that they are prepared to switch to the new version of the configuration (in which the flag is enabled).\nIf enough validators vote to switch to the new protocol version, then the new version takes effect at the beginning of the next epoch.\nThe new feature now comes into effect.\n\nFull nodes follow a similar process, however, they do not participate in voting. Instead, they follow the actions that validators recorded.\n\nWhen validators switch to a new protocol version, they do so by recording the new version number in the special end-of-epoch transaction. Full nodes execute this transaction as they are replaying the chain history, and are thus able to switch to the new protocol version at the right time.\n\nFramework upgrades\n\nNot all new Sui functionality comes in the form of changes to the validator code. There are also changes to the Sui framework. For instance, Sui developers periodically add new native functions to the framework to expose new functionality to smart contracts. The process for framework updates is similar to protocol upgrades.\n\nInstead of using feature flags, however, Sui objects are used to coordinate framework changes. The Sui framework is a special object with id 0x2. The Move source code for the framework is built into the validator binary.\n\nIf the validator notices that its built-in framework is different from the framework in object 0x2, it signals to the other validators that it would like to upgrade the framework to a new version. Just as with changes to ProtocolConfig, if enough validators agree to perform the upgrade, the new framework object is written at the end of the current epoch. Then, transactions that are executed in the new epoch use the new version of the framework.\n\nEdit this page\nPrevious\nSui Indexer\nNext\nSui Tokenomics\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Gas Pricing | Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/gas-pricing",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsSui Gas Pricing\nSui Gas Pricing\n\nThe Sui gas-pricing mechanism achieves three outcomes: delivering low, predictable transaction fees, incentivizing validators to optimize their transaction processing operations, and preventing denial of service attacks.\n\nThis enables you to focus on using the Sui network to provide the best user experience without needing to forecast the current market price of gas fees. Since validators agree on a network-wide reference price at the start of each epoch, you can use the reference price as a credible anchor when submitting transactions. Moreover, the price setting mechanism rewards good validator behavior, thus aligning incentives between SUI token holders, the network's operators (validators), and its users.\n\nA unique feature of the Sui gas price mechanism is that users pay separate fees for transaction execution and for storing the data associated with each transaction. The gas fees associated with an arbitrary transaction \n𝜏\nτ equal:\n\n𝐺\n𝑎\n𝑠\n𝐹\n𝑒\n𝑒\n𝑠\n[\n𝜏\n]\n \n=\n \n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑈\n𝑛\n𝑖\n𝑡\n𝑠\n[\n𝜏\n]\n×\n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\n[\n𝜏\n]\n \n+\n \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑈\n𝑛\n𝑖\n𝑡\n𝑠\n[\n𝜏\n]\n×\n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nGasFees[τ] = ComputationUnits[τ]×ComputationPrice[τ] + StorageUnits[τ]×StoragePrice\n\nThe gas functions \n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑈\n𝑛\n𝑖\n𝑡\n𝑠\n[\n𝜏\n]\nComputationUnits[τ] and \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑈\n𝑛\n𝑖\n𝑡\n𝑠\n[\n𝜏\n]\nStorageUnits[τ] measure the amount of computation and storage resources, respectively, required to process and store the data associated with \n𝜏\nτ. The gas prices \n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\n[\n𝜏\n]\nComputationPrice[τ] and \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nStoragePrice translate the cost of computation and storage, respectively, into SUI units. The decoupling between gas units and gas prices is useful since SUI market price will fluctuate over time in accordance with supply and demand.\n\nComputation gas prices​\n\nThe computation gas price \n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\n[\n𝜏\n]\nComputationPrice[τ] captures the cost of one unit of computation in SUI units. This price is set at the transaction level and submitted by the user as the transaction's gas price. Conceptually, it is useful to think about this gas price in two parts:\n\n𝐶\n𝑜\n𝑚\n𝑝\n𝑢\n𝑡\n𝑎\n𝑡\n𝑖\n𝑜\n𝑛\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\n[\n𝜏\n]\n \n=\n \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\n \n+\n \n𝑇\n𝑖\n𝑝\n[\n𝜏\n]\nComputationPrice[τ] = ReferencePrice + Tip[τ]\n\nOn the Sui network, a single \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice exists throughout each epoch, with Sui validators updating the \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice at each epoch boundary. Hence, in practice, when a user submits a gas price above the \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice, it is useful to think of the difference as a tip paid to the network in order to get higher priority. During moments of regular network operations, users are not expected to pay tips and the vast majority of transactions have gas prices equal to \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice.\n\nMore generally, the Sui gas price mechanism makes the \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice a credible anchor for you to reference when submitting transactions to the network. Providing reasonable confidence that transactions submitted with gas prices at or close to the reference price are executed in a timely manner. This is achieved through three core steps:\n\nGas price survey: All validators are surveyed at the start of each epoch, and every validator submits their reservation price. That is, each validator states the minimum gas price at which they are willing to process transactions. The protocol orders these quotes and chooses the 2/3 percentile by stake as the reference price. The gas price survey goal is to set a reference price under which a quorum of validators are willing to promptly process transactions.\nTallying rule: Throughout the epoch, validators obtain signals over the operations of other validators. Each validator uses these signals to build a (subjective) evaluation over the performance of every other validator. Specifically, each validator constructs a multiplier for the stake rewards of every other validator such that validators who behave well receive boosted rewards, and validators who do not receive reduced rewards. The tallying rule goal is to create a community-enforced mechanism for encouraging validators to honor the reference gas price.\nIncentivized stake reward distribution rule: At the end of the epoch, the distribution of stake rewards across validators is adjusted using information from the tallying rule. Specifically, a global multiplier is built for every validator using the median value (weighted by stake) out of the set of individual multipliers constructed during the tallying rule. All else equal, validators that operated performantly receive their regular stake rewards, whereas validators who did not operate performantly at the reference gas price receive slashed rewards. Since stake rewards are influenced by the amount of stake each validator owns, validators are encouraged to obtain more stake by lowering gas fees and pricing out inefficient validators. This benefits Sui end users since the stake reward distribution rule incentivizes validators to deliver a more cost-efficient network.\n\nIn sum, the gas price mechanism has two main forces: the tallying rule incentivizes validators to honor the quotes submitted during the gas survey, while the distribution rule incentivizes validators to submit low reservations prices. The interaction of these two forces delivers a mechanism encouraging validators to set a low network-level reference gas price - but not too low, because they face penalties if they cannot honor their quotes. In other words, the gas price mechanism encourages a healthy competition for fair prices.\n\nStorage gas prices​\n\nThe storage gas price \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nStoragePrice captures the costs of covering one unit of storage in perpetuity, in SUI units. This price is set through governance proposals and is updated infrequently. The goal is to ensure Sui users pay for their use of on-chain data storage by depositing these fees into the storage fund and then redistributing these fees to future validators. In contrast to the computation gas price, storage prices are fixed and common for all transactions both within an epoch and across epochs until the storage price is updated.\n\nThe \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nStoragePrice is set exogenously through the governance proposal with the goal of targeting the off-chain dollar cost of data storage. In the long run, as the costs of storage fall due to technological improvements and the dollar price of the SUI token evolves, governance proposals will update the price in order to reflect the new dollar target price.\n\nGas prices as a coordination mechanism​\n\nOverall, when you submit transactions with computation gas prices at or close to the current epoch \n𝑅\n𝑒\n𝑓\n𝑒\n𝑟\n𝑒\n𝑛\n𝑐\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nReferencePrice and storage gas prices at the targeted \n𝑆\n𝑡\n𝑜\n𝑟\n𝑎\n𝑔\n𝑒\n𝑃\n𝑟\n𝑖\n𝑐\n𝑒\nStoragePrice, you have the best user experience. The Sui gas price mechanism provides you with credible reference prices for submitting your transactions. By incentivizing validators to elicit their true reservation prices and honor these quotes, you can credibly assume your transactions are processed in a timely manner.\n\nAfter Sui enables horizontal scaling, validators can add more workers as demand for on-chain activity scales. This increases their costs linearly at the same pace of network activity and lets them process more transactions at the same low gas prices. In cases of extreme network congestion where validators cannot scale fast enough, the tip presence provides a market-based congestion pricing mechanism that discourages further demand spikes by increasing the cost of transacting on the Sui platform.\n\nIn the long run, the Sui gas price mechanism creates incentives for validators to optimize their hardware and operations. Validators that invest in becoming more efficient are able to honor lower gas prices and obtain a stake reward boost. Sui validators are thus encouraged to innovate and improve the experience of end users.\n\nEdit this page\nPrevious\nStorage Fund\nNext\nGas in Sui\nComputation gas prices\nStorage gas prices\nGas prices as a coordination mechanism\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/storage-fund",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsStorage Fund\nStorage Fund\n\nSui includes an efficient and sustainable economic mechanism for financing data storage, which is important given the ability of Sui to store arbitrarily large amounts of on-chain data.\n\nFinancially, on-chain data storage introduces a severe inter-temporal challenge: validators who process and write data into storage today might differ from the future validators needing to store that data. If users paid fees for computation power only at write, then future users would need to subsidize past users for their storage and pay disproportionately high fees. This negative network externality can become highly taxing for Sui in the future if left unaddressed.\n\nSui economic design includes a storage fund that redistributes storage fees from past transactions to future validators. When users transact on Sui, they pay fees upfront for both computation and storage. The storage fees are deposited into a storage fund used to adjust the share of future stake rewards distributed to validators relative to the users that stake SUI with them. This design provides future Sui validators with viable business models.\n\nStorage fund rewards​\n\nThe Sui delegated proof-of-stake (PoS) mechanism calculates total stake as the sum of user stake plus the SUI tokens deposited in the storage fund. Hence, the storage fund receives a proportional share of the overall stake rewards depending on its size relative to total stake. The majority of these stake rewards – a share \n𝛾\nγ – are paid out to current validators to compensate for storage costs, while the remaining \n(\n1\n−\n𝛾\n)\n(1−γ) rewards are used to reinvest in the fund. In other words, stake rewards accruing to the storage fees submitted by past transactions are paid out to current validators to compensate them for data storage costs. When on-chain storage requirements are high, validators receive substantial additional rewards to compensate for their storage costs. Vice versa when storage requirements are low.\n\nMore specifically, the storage fund has three key features:\n\nThe storage fund is funded by past transactions and functions as a tool for shifting gas fees across different epochs. This ensures that future validators are compensated for their storage costs by the past users who created those storage requirements in the first place.\nThe storage fund pays out only the returns on its capital and does not distribute its principal. That is, in practice, it is as if validators were able to borrow the storage fund’s SUI as additional stake and keep the majority of stake rewards (a \n𝛾\nγ%). But note that validators do not receive funds directly from the storage fund. This guarantees the fund never loses its capitalization and can survive indefinitely. This feature is further buttressed by the \n(\n1\n−\n𝛾\n)\n(1−γ)% of stake rewards reinvested in the fund.\nThe storage fund includes a deletion option. If you delete data, you get a partial refund of the storage fees paid originally. Storage fees exist to pay for storage throughout the data lifecycle. There is no reason to keep charging for storage after deletion of the data, so these fees are rebated.\nINFO\n\nThe deletion option should not be confused with deleting past transactions. Activity on Sui is finalized at each epoch boundary and past transactions are immutable and can never be reversed. The type of data that can be deleted is, for example, data corresponding to objects that are no longer live, such as NFT metadata, tickets that have been redeemed, auctions that have concluded, and so on.\n\nStorage fund mechanics​\n\nThe storage fund size is fixed throughout each epoch, with its size changing at the epoch boundary according to the net inflows accumulated throughout the epoch. Inflows and outflows correspond to:\n\nInflows from the storage fees paid for transactions executed during the current epoch.\nInflows from reinvestments of the fund’s returns into new principal. Specifically, the share \n(\n1\n−\n𝛾\n)\n(1−γ) of stake rewards accrued to the storage fund that is not paid out to validators.\nOutflows from storage fee rebates paid to users who delete the data associated with past transactions.\n\nThe key property of the rebate function is that it limits storage fund outflows to be always less than the original storage flow, at the individual transaction level. This mechanism guarantees that the storage fund is never depleted and that its size moves in line with the amount of data held in storage.\n\nStorage fund incentives​\n\nThe storage fund introduces various desirable incentives into the Sui economy:\n\nIts mechanics incentivize users to delete data and obtain a rebate on their storage fees when the cost of storing such data exceeds the value obtained from maintaining that data on-chain. This introduces a useful market-based mechanism where users free storage when it becomes uneconomical for them to keep it.\nIt creates deflationary pressure over the SUI token in that increased activity leads to larger storage requirements and to more SUI removed from circulation.\nIt is capital efficient in that it is economically equivalent to a rent model where users pay for storage through a pay-per-period model.\nEdit this page\nPrevious\nSUI Bridging\nNext\nSui Gas Pricing\nStorage fund rewards\nStorage fund mechanics\nStorage fund incentives\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/sui-bridging",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsSUI Bridging\nSUI Bridging\n\nBridging is the process of moving tokens from one blockchain to another. When you use a bridge to move tokens between blockchains that are incompatible, the tokens are \"wrapped\" by the bridge, which means that they get converted to a derivative token for the target blockchain. You can transfer tokens in from other blockchains to SUI, or transfer SUI tokens out to other blockchains.\n\nSui supports bridging through Wormhole Connect and Wormhole Portal Bridge.\n\nWormhole Connect​\n\nUse to bridge tokens from any Wormhole supported chain into Sui and get dropped off with extra Sui to pay gas fees. Developers can also embed the Connect Token Bridge directly into their own websites and dApps.\n\nWormhole Connect asset support​\n\nInitially, Wormhole Connect supports only lock-and-mint bridging for ETH, WETH, USDC, MATIC, WMATIC, BNB, WBNB, AVAX, WAVAX, FTM, WFTM, CELO, GLMR, WGLRM, AND SOL across Ethereum, Polygon, BSC, Avalanche, Celo, Moonbeam, Solana and Sui. This means that any native token bridged through Wormhole Connect and the underlying Wormhole Token Bridge are received as a Wormhole-minted token on the destination chain. In some cases, Wormhole-minted tokens are the canonical representation on the chain. See the Wormhole token list on GitHub. Some Wormhole-minted tokens support swapping on the destination chain's DEX(s) for whichever assets you need.\n\nWormhole Connect automatic relay​\n\nOn EVM-based chains and Sui, Wormhole Connect lets you bridge assets while having to pay gas only on the source chain. The automatic relaying feature pays gas on behalf of users on the destination chain.\n\nWormhole Connect gas drop-off​\n\nThe gas drop-off feature enables users to pay an additional fee on the source chain to request a small amount of native gas on the destination chain. For example, a user bridging USDC from Ethereum to Sui can pay a fee denominated in USDC from their sending wallet to receive some native SUI in their receiving wallet. This is in addition to the USDC they are bridging over. Gas drop-off is currently supported on EVM-based chains and Sui.\n\nTo learn more about Wormhole Connect, see their FAQ page.\n\nWormhole Portal Bridge​\n\nThe Wormhole powered Portal Bridge supports bridging any asset from any of the 22 supported Wormhole chains.\n\nToken address list​\n\nThe following table lists the address associated with each token type. You can confirm the legitimacy of tokens when you bridge them by confirming that the address used matches the address for the token type.\n\nToken\tAddress\nCELO\t0xa198f3be41cda8c07b3bf3fee02263526e535d682499806979a111e88a5a8d0f\nWMATIC\t0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676\nWBNB\t0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f\nWETH\t0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5\nUSDC\t0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf\nUSDT\t0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c\nWBTC\t0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881\nWAVAX\t0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766\nWFTM\t0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396\nWGLMR\t0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75\nWSOL\t0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8\nUSDCsol\t0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037\nEdit this page\nPrevious\nSUI Coin\nNext\nStorage Fund\nWormhole Connect\nWormhole Connect asset support\nWormhole Connect automatic relay\nWormhole Connect gas drop-off\nWormhole Portal Bridge\nToken address list\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Staking and Unstaking | Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/staking-unstaking",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsStaking and Unstaking\nStaking and Unstaking\n\nSui uses a Delegated-Proof-of-Stake (DPoS) system to secure and operate the network, meaning that the voting power of a validator in the network is determined by the amount of stake delegated to them by SUI token holders. The more stake delegated to a validator, the more voting power they have. In exchange for processing transactions and performing consensus, validators earn rewards based on the amount of gas fees collected. These rewards are then shared among stakers as staking rewards.\n\nStaking​\n\nYou stake your SUI tokens by sending a transaction to the network that calls the staking function implemented as part of the system Move package. This transaction wraps the SUI tokens in a self-custodial stake object. This stake object contains information including the validator staking pool ID and the activation epoch of the stake. With the introduction of SIP-6, you can participate in liquid staking protocols using your staked objects.\n\nSui-compatible crypto wallets typically have functionality to initiate staking and unstaking from your Sui address. See the respective documentation for these tools to begin staking your SUI.\n\nUnstaking​\n\nSimilar to staking, a user withdraws stake from a validator by sending a transaction that calls the unstaking function in the system Move package. This transaction unwraps the stake object, and sends both the principal and the accumulated rewards to the user as SUI tokens. You accrue rewards only during epochs where the stake is active for the entire epoch. The rewards withdrawn from the validator's rewards pool are calculated based on the activation epoch and unstaking epoch of the stake.\n\nChoosing a validator for staking​\n\nWhen you stake on Sui, you have to choose a specific validator you would like to stake with. The choice of validator can potentially impact the amount of staking rewards you receive. The factors determining this amount include, but are not limited to:\n\nValidator commission rate: a validator can choose to set a non-zero commission rate specifying the percentage of staking rewards they are taking from the stakers. For example, if a validator has the commission rate of 10%, then 10% of every staker's staking rewards is given to the validator. Understand that a validator can choose its commission at a future moment in time without prior notice.\nValidator performance: a validator with bad performance might be punished according to the tallying rule. Punished validators do not receive any staking rewards for the epoch during which they are punished, and you also do not receive that epoch's rewards when you withdraw your stake from that validator.\n\nSui-compatible crypto wallets and explorers typically provide validator information such as commission and APY. See the respective documentation for these tools for information on how to retrieve this data.\n\nEdit this page\nPrevious\nValidators and Staking Pools\nNext\nSUI Coin\nStaking\nUnstaking\nChoosing a validator for staking\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/sui-coin",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsSUI Coin\nSUI Coin\n\nThe native asset on Sui is called SUI. The coin uses the capitalized version of SUI to distinguish the coin from the Sui network.\n\nThe total supply of SUI is capped at 10,000,000,000 (ten billion coins). A share of SUI total supply became liquid at Mainnet launch, with the remaining coins vesting over the coming years, or distributed as future stake reward subsidies.\n\nThe SUI coin serves four purposes on the Sui network:\n\nYou can stake SUI to participate in the proof-of-stake mechanism.\nSUI is the asset denomination needed to pay the gas fees required to execute and store transactions or other operations on the Sui network.\nYou can use SUI as a versatile and liquid asset for various applications, including the standard features of money - a unit of account, a medium of exchange, or a store of value - and more complex functionality smart contracts enable, interoperability, and composability across the Sui ecosystem.\nSUI coins play an important role in governance by acting as a right to participate in on-chain voting on issues such as protocol upgrades.\n\nThere is a finite supply of SUI. The balance must support all economic activities to scale as more and more people migrate to the Sui platform. In addition, the presence of a storage fund creates important monetary dynamics, in that higher on-chain data requirements translate into a larger storage fund, reducing the amount of SUI in circulation.\n\nEdit this page\nPrevious\nStaking and Unstaking\nNext\nSUI Bridging\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/proof-of-stake",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsProof of Stake\nProof of Stake\n\nThe Sui platform relies on delegated proof-of-stake (DPoS) to determine the set of validators that process transactions.\n\nSUI token staking​\n\nWithin each epoch, a fixed set of validators process operations, each with a specific amount of stake from SUI token holders. A validator's share of total stake is relevant in that it determines each validator's share of voting power for processing transactions. Staking SUI implies the SUI tokens are locked for the entire epoch. SUI token holders are free to withdraw their SUI or to change their selected validator when the epoch changes.\n\nEconomic model​\n\nThis section covers how the different components of the Sui economy interact with each other to introduce the Sui DPoS system. For reference, see the Staking and Tokenomics diagram in the Sui Tokenomics overview.\n\nThe Sui economic model works as follows:\n\nAt the beginning of each epoch, three important events happen:\n\nSUI holders stake (some) of their tokens to validators and a new committee is formed.\nThe reference gas prices are set as described in Sui Gas Pricing.\nThe storage fund size is adjusted using the net inflow of the previous epoch.\n\nFollowing these actions, the protocol computes the total amount of stake as the sum of staked SUI plus the storage fund. Call the share of user stake \n𝛼\nα.\n\nDuring each epoch: Users submit transactions to the Sui platform and validators process them. For each transaction, users pay the associated computation and storage gas fees. In cases where users delete previous transaction data, users obtain a partial rebate of their storage fees. Validators observe the behavior of other validators and evaluate each other's performance.\n\nAt the end of each epoch: The protocol distributes stake rewards to participants of the DPoS mechanism. This occurs through two main steps:\n\nThe total amount of stake rewards is calculated as the sum of computation fees accrued throughout the epoch plus the epoch’s stake reward subsidies. The latter component is temporary in that it will only exist in the network's first years and disappear in the long run as the amount of SUI in circulation reaches its total supply.\nThe total amount of stake rewards is distributed across various entities. Importantly, remember that the storage fund is taken into account in the calculation of the epoch total stake. However, the storage fund is not owned by any entities in the way that staked SUI is. Instead, the Sui economic model distributes the stake rewards accruing to the storage fund – a share \n(\n1\n−\n𝛼\n)\n(1−α) of the total stake rewards – to validators in order to compensate them for their storage costs. Of these rewards, a share \n𝛾\nγ is paid out to validators while the remaining \n(\n1\n−\n𝛾\n)\n(1−γ) is used to reinvest in capital of the fund. Finally, let \n𝛽\n𝑣\nβ\nv\n\t​\n\n represent the share of stake managed by a validator \n𝑣\nv that is owned by itself while \n(\n1\n−\n𝛽\n𝑣\n)\n(1−β\nv\n\t​\n\n) represents the share owned by third-party stakers. Validators keep the full rewards accruing to their own stake but keep only a commission \n𝛿\n𝑣\nδ\nv\n\t​\n\non SUI tokens staked by users as a fee for managing that stake. The split of stake rewards for the user staking pool staking at validator \n𝑣\nv and for the validator itself equal:\n𝑈\n𝑠\n𝑒\n𝑟\n𝑆\n𝑡\n𝑎\n𝑘\n𝑒\n𝑅\n𝑒\n𝑤\n𝑎\n𝑟\n𝑑\n𝑠\n𝑣\n \n=\n[\n𝛼\n(\n1\n−\n𝛿\n𝑣\n)\n(\n1\n−\n𝛽\n𝑣\n)\n]\n𝜇\n𝑣\n𝜎\n𝑣\n×\n𝑆\n𝑡\n𝑎\n𝑘\n𝑒\n𝑅\n𝑒\n𝑤\n𝑎\n𝑟\n𝑑\n𝑠\nUserStakeRewards\nv\n\t​\n\n =[α(1−δ\nv\n\t​\n\n)(1−β\nv\n\t​\n\n)]μ\nv\n\t​\n\nσ\nv\n\t​\n\n×StakeRewards\n𝑉\n𝑎\n𝑙\n𝑖\n𝑑\n𝑎\n𝑡\n𝑜\n𝑟\n𝑅\n𝑒\n𝑤\n𝑎\n𝑟\n𝑑\n𝑠\n𝑣\n \n=\n \n[\n𝛼\n(\n𝛽\n𝑣\n+\n𝛿\n𝑣\n(\n1\n−\n𝛽\n𝑣\n)\n)\n𝜇\n𝑣\n𝜎\n𝑣\n+\n(\n1\n−\n𝛼\n)\n𝛾\n𝑁\n]\n×\n𝑆\n𝑡\n𝑎\n𝑘\n𝑒\n𝑅\n𝑒\n𝑤\n𝑎\n𝑟\n𝑑\n𝑠\nValidatorRewards\nv\n\t​\n\n = [α(β\nv\n\t​\n\n+δ\nv\n\t​\n\n(1−β\nv\n\t​\n\n))μ\nv\n\t​\n\nσ\nv\n\t​\n\n+(1−α)\nN\nγ\n\t​\n\n]×StakeRewards\n\nThe \n𝜇\n𝑣\nμ\nv\n\t​\n\n variable captures the output of the tallying rule computed as part of the gas price mechanism and corresponds to \n𝜇\n𝑣\n≥\n1\nμ\nv\n\t​\n\n≥1 for performant validators and \n𝜇\n𝑣\n<\n1\nμ\nv\n\t​\n\n<1 for non-performant validators. This variable ensures that validators have \"skin in the game\" and are incentivized to operate Sui efficiently. The \n𝜎\n𝑣\nσ\nv\n\t​\n\n parameter captures each validator's share of total stake.\n\nConsequently, validators with more stake earn more stake rewards and the joint \n𝜇\n𝑣\n𝜎\n𝑣\nμ\nv\n\t​\n\nσ\nv\n\t​\n\n term incentivizes validators to increase their share of stake while also operating the network performantly. In the long-run, this incentive encourages users to shift the stake distribution towards the network's most efficient validators, delivering a cost-efficient and decentralized network.\n\nFinally, the storage fund rewards accrue to all \n𝑁\nN validators equally (since all validators face a similar burden of holding data in storage). The small amount of stake rewards that is not distributed out to either users or validators, namely the share \n(\n1\n−\n𝛼\n)\n(\n1\n−\n𝛾\n)\n(1−α)(1−γ) of stake rewards, gets reinvested in the storage fund.\n\nOn net, this design encourages validators to operate with low gas price quotes, but not too low or they receive slashed stake rewards. Consequently, the Sui gas price mechanism and DPoS system encourages a healthy competition for fair prices where validators set low gas fees while operating with viable business models.\n\nSui incentives​\n\nThe Sui economic model bestows Sui users with an important monitoring role. On the one hand, users want their transactions processed as quickly and efficiently as possible. User clients, such as wallets, encourage this by prioritizing communication with the most responsive validators. Such efficient operations are compensated with boosted rewards relative to less responsive validators. On the other hand, SUI token stakers receive the same boosted or penalized rewards as their selected validator. An unresponsive validator is thus doubly exposed to Sui incentives: they lose directly through slashed rewards and indirectly through reduced user stake in future epochs as stakers move their tokens to more responsive validators.\n\nEdit this page\nPrevious\nSui Tokenomics\nNext\nValidators and Staking Pools\nSUI token staking\nEconomic model\nSui incentives\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics/validators-staking",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomicsValidators and Staking Pools\nValidators and Staking Pools\n\nEach Sui validator maintains its own staking pool to track the amount of stake and to compound staking rewards. Validator pools operate together with a time series of exchange rates that are computed at each epoch boundary. These exchange rates determine the amount of SUI tokens that each past SUI staker can withdraw in the future. Importantly, the exchange rates increase as more rewards are deposited into a staking pool and the longer an amount of SUI is deposited in a staking pool, the more rewards it will accrue.\n\nWhen SUI is deposited to the staking pool in epoch E, those SUI are converted into liquidity tokens at the epoch E exchange rate. As the staking pool earns rewards, the exchange rate appreciates. At epoch E', those liquidity tokens are worth more and translate into more SUI. The only difference between Sui staking pools and typical liquidity pools is that in Sui the liquidity tokens do not exist. Rather, the global exchange rate table is used to track the accounting. Because all SUI tokens in the staking pool are treated the same, regardless of whether they were originally deposited as new stake or as stake rewards, all SUI tokens immediately count as stake and thus compound rewards immediately.\n\nThe staking pool is implemented in a system-level smart contract (staking_pool.move) and is part of the Sui framework.\n\nValidator pool exchange rate​\n\nThe exchange rate for each validator pool is calculated at each epoch boundary as follows:\n\nExchange Rate at E+1 = ( 1 + ( Third-Party Staker Rewards at E / Third-Party Stake at E )) ( Exchange Rate at E )\n\nThe distinction between third-party owned vs validator-owned rewards and stake is relevant in that validators earn commissions on the staking pool's tokens but third-party stakers do not. This accounting enables Sui to keep track of the rewards accrued by both validators and third-party token holders using a single global exchange rate table.\n\nValidator staking pool requirements​\n\nThere are minimum staking requirements a validator must satisfy to become active and to stay in the active validator set.\n\nMore precisely:\n\nA validator candidate must accrue at least 30M SUI of stake before they can request to join the validator set.\nIf an active validator’s stake falls below 20M SUI, they have seven epochs of grace period to gain back the stake before being removed from the validator set.\nIf an active validator’s stake falls below 15M SUI, they are removed from the validator set at the end of the current epoch boundary. Sui uses 24-hour epochs.\nEdit this page\nPrevious\nProof of Stake\nNext\nStaking and Unstaking\nValidator pool exchange rate\nValidator staking pool requirements\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "zkLogin | Sui Documentation",
      "url": "https://docs.sui.io/concepts/cryptography/zklogin",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nTransaction Authentication\nzkLogin\nCheckpoint Verification\nSui Architecture\nTokenomics\nResearch Papers\nCryptographyzkLogin\nzkLogin\n\nzkLogin is a Sui primitive that provides the ability for you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.\n\nzkLogin is designed with the following goals in mind:\n\nStreamlined onboarding: zkLogin enables you to transact on Sui using the familiar OAuth login flow, eliminating the friction of handling cryptographic keys or remembering mnemonics.\nSelf-custody: A zkLogin transaction requires user approval via the standard OAuth login process--the OAuth provider cannot transact on the user's behalf.\nSecurity: zkLogin is a two-factor authentication scheme; sending a transaction requires both a credential from a recent OAuth login and a salt not managed by the OAuth provider. An attacker who compromises an OAuth account cannot transact from the user's corresponding Sui address unless they separately compromise the salt.\nPrivacy: Zero-knowledge proofs prevent third parties from linking a Sui address with its corresponding OAuth identifier.\nOptional verified identity: A user can opt in to verify the OAuth identifier that was used to derive a particular Sui address. This serves as the foundation for a verifiable on-chain identity layer.\nAccessibility: zkLogin is one of several native Sui signature schemes thanks to Sui's cryptography agility. It integrates with other Sui primitives, like sponsored transactions and multisig.\nRigorousness: The code for zkLogin has been independently audited by two firms specializing in zero knowledge. The public zkLogin ceremony for creating the common reference string attracted contributions from more than 100 participants.\n\nAre you a builder who wants to integrate zkLogin into your application or wallet? Dive into the zkLogin Integration Guide.\n\nIf you want to understand how zkLogin works, including how the zero-knowledge proof is generated, and how Sui verifies a zkLogin transaction, see this section.\n\nIf you are curious about the security model and the privacy considerations of zkLogin, visit this page.\n\nMore questions? See the FAQ section.\n\nOpenID providers​\n\nThe following table lists the OpenID providers that can support zkLogin or are currently being reviewed to determine whether they can support zkLogin.\n\nProvider\tCan support?\tDevnet\tTestnet\tMainnet\nFacebook\tYes\tYes\tYes\tYes\nGoogle\tYes\tYes\tYes\tYes\nTwitch\tYes\tYes\tYes\tYes\nSlack\tYes\tYes\tNo\tNo\nKakao\tYes\tYes\tNo\tNo\nApple\tYes\tYes\tYes\tYes\nRedBull\tUnder review\tNo\tNo\tNo\nMicrosoft\tUnder review\tNo\tNo\tNo\nAWS (Tenant)\tUnder review\tNo\tNo\tNo\nAmazon\tUnder review\tNo\tNo\tNo\nWeChat\tUnder review\tNo\tNo\tNo\nAuth0\tUnder review\tNo\tNo\tNo\nOkta\tUnder review\tNo\tNo\tNo\nHow zkLogin works​\n\nIn rough sketches, the zkLogin protocol relies on the following:\n\nA JWT is a signed payload from OAuth providers, including a user-defined field named nonce. zkLogin leverages the OpenID Connect OAuth flow by defining the nonce as a public key and an expiry epoch.\nThe wallet stores an ephemeral KeyPair, where the ephemeral public key is defined in the nonce. The ephemeral private key signs transactions for a brief session, eliminating the need for user memorization. The Groth16 zero-knowledge proof is generated based on the JWT, concealing privacy-sensitive fields.\nA transaction is submitted on-chain with the ephemeral signature and the ZK proof. Sui authorities execute the transaction after verifying the ephemeral signature and the proof.\nInstead of deriving the Sui address based on a public key, the zkLogin address is derived from sub (that uniquely identifies the user per provider), iss (identifies the provider), aud (identifies the application) and user_salt (a value that unlinks the OAuth identifier with the on-chain address).\nThe complete zkLogin flow​\n\n(Step 0) We use Groth16 for our protocol's zkSNARK instantiation, requiring a singular generation of a structured common reference string (CRS) linked to the circuit. A ceremony is conducted to generate the CRS, which is used to produce the proving key in the ZK Proving Service, the verifying key in Sui Authority. See the Ceremony section for more details.\n\n(Step 1-3) The user begins by logging into an OpenID Provider (OP) to obtain a JWT containing a defined nonce. In particular, the user generates an ephemeral KeyPair (eph_sk, eph_pk) and embed eph_pk, along with expiry times (max_epoch) and randomness (jwt_randomness), into the nonce (see definition). After the user completes the OAuth login flow, an JWT can be found in the redirect URL in the application.\n\n(Step 4-5) The application frontend then sends the JWT to a salt service. The salt service returns the unique user_salt based on iss, aud, sub upon validation of the JWT.\n\n(Step 6-7) The user sends the ZK proving service the JWT, user salt, ephemeral public key, jwt randomness, key claim name (i.e. sub). The proving service generates a Zero-Knowledge Proof that takes these as private inputs and does the following: (a) Checks the nonce is derived correctly as defined (b) Checks that key claim value matches the corresponding field in the JWT, (c) Verifies the RSA signature from OP on the JWT, and (d) the address is consistent with the key claim value and user salt.\n\n(Step 8): The application computes the user address based on iss, aud, sub, aud. This step can be done independently as long as the application has a valid JWT.\n\n(Step 9-10) A transaction is signed using the ephemeral private key to generate an ephemeral signature. Finally, the user submits the transaction along with the ephemeral signature, ZK proof and other inputs to Sui.\n\n(After Step 10) After submitted on chain, Sui Authorities verify the ZK proof against the provider JWKs from storage (agreed upon in consensus) and also the ephemeral signature.\n\nEntities​\n\nApplication frontend: This describes the wallet or frontend application that supports zkLogin. This frontend is responsible for storing the ephemeral private key, directing users to complete the OAuth login flow, creating and signing a zkLogin transaction.\n\nSalt Backup Service: This is a backend service responsible for returning a salt per unique user. See integration guide for other strategies to maintain salt.\n\nZK Proving Service: This is a backend service responsible for generating ZK proofs based on JWT, JWT randomness, user salt and max epoch. This proof is submitted on-chain along with the ephemeral signature for a zkLogin transaction.\n\nAddress definition​\n\nThe address is computed on the following inputs:\n\nThe address flag: zk_login_flag = 0x05 for zkLogin address. This serves as a domain separator as a signature scheme defined in crypto agility.\n\nkc_name_F = hashBytesToField(kc_name, maxKCNameLen): Name of the key claim, e.g., sub. The sequence of bytes is mapped to a field element in BN254 using hashBytesToField (defined below).\n\nkc_value_F = hashBytesToField(kc_value, maxKCValueLen): The value of the key claim mapped using hashBytesToField.\n\naud_F = hashBytesToField(aud, maxAudValueLen): The relying party (RP) identifier. See definition.\n\niss: The OpenID Provider (OP) identifier. See definition.\n\nuser_salt: A value introduced to unlink the OAuth identifier with the on-chain address.\n\nFinally, we derive zk_login_address = Blake2b_256(zk_login_flag, iss_L, iss, addr_seed) where addr_seed = Poseidon_BN254(kc_name_F, kc_value_F, aud_F, Poseidon_BN254(user_salt).\n\nTerminology and notations​\n\nSee below for all relevant OpenID terminology defined in spec and how they are used in zkLogin, along with definitions for protocol details.\n\nOpenID provider (OP)​\n\nOAuth 2.0 authorization server that is capable of authenticating the end-user and providing claims to an RP about the authentication event and the end-user. This is identified in the iss field in JWT payload. Check the table of available OPs for the entities zkLogin currently supports.\n\nRelying party (RP) or client​\n\nOAuth 2.0 client application requiring end-user authentication and claims from an OpenID provider. This is assigned by OP when the developer creates the application. This is identified in the aud field in JWT payload. This refers to any zkLogin enabled wallet or application.\n\nSubject identifier (sub)​\n\nLocally unique and never reassigned identifier within the issuer for the end user, which the RP is intended to consume. Sui uses this as the key claim to derive user address.\n\nJSON Web Key (JWK)​\n\nA JSON data structure that represents a set of public keys for an OP. A public endpoint (as in https://www.googleapis.com/oauth2/v3/certs) can be queried to retrieve the valid public keys corresponding to kid for the provider. Upon matching with the kid in the header of a JWT, the JWT can be verified against the payload and its corresponding JWK. In Sui, all authorities call the JWK endpoints independently, and update the latest view of JWKs for all supported providers during protocol upgrades. The correctness of JWKs is guaranteed by the quorum (2f+1) of validator stake.\n\nJSON Web Token (JWT)​\n\nJWT is in the redirect URI to RP after the user completes the OAuth login flow (as in https://redirect.com?id_token=$JWT_TOKEN). The JWT contains a header, payload, and a signature. The signature is an RSA signature verified against jwt_message = header + . + payload and its JWK identified by kid. The payload contains a JSON of many claims that is a name-value pair. See below for the specific claims that are relevant to the zkLogin protocol.\n\nHeader\n\nName\tExample Value\tUsage\nalg\tRS256\tzkLogin only supports RS256 (RSA + SHA-256).\nkid\tc3afe7a9bda46bae6ef97e46c95cda48912e5979\tIdentifies the JWK that should be used to verify the JWT.\ntyp\tJWT\tzkLogin only supports JWT.\n\nPayload\n\nName\tExample Value\tUsage\niss\thttps://accounts.google.com\tA unique identifier assigned to the OAuth provider.\naud\t575519200000-msop9ep45u2uo98hapqmngv8d8000000.apps.googleusercontent.com\tA unique identifier assigned to the relying party by the OAuth provider.\nnonce\thTPpgF7XAKbW37rEUS6pEVZqmoI\tA value set by the relying party. The zkLogin enabled wallet is required to set this to the hash of ephemeral public key, an expiry time and a randomness.\nsub\t110463452167303000000\tA unique identifier assigned to the user.\n\nFor a zkLogin transaction, the iat and exp claims (timestamp) are not used. Instead, the nonce specifies expiry times.\n\nKey claim​\n\nThe claim used to derive a users' address is termed the \"key claim\", such as sub or email. Naturally, it's ideal to use claims that are fixed once and never changed again. zkLogin currently supports sub as the key claim because OpenID spec mandates that providers do not change this identifier. In the future, this can be extended to use email, username, and so on.\n\nNotations​\n(eph_sk, eph_pk): Ephemeral key pair refers to the private and public key pair used to produce ephemeral signatures. The signing mechanism is the same as traditional transaction signing, but it is ephemeral because it is only stored for a short session and can be refreshed upon new OAuth sessions. The ephemeral public key is used to compute nonce.\nnonce: An application-defined field embedded in the JWT payload, computed as the hash of the ephemeral public key, JWT randomness, and the maximum epoch (Sui's defined expiry epoch). Specifically, a zkLogin compatible nonce is required to passed in as nonce = ToBase64URL(Poseidon_BN254([ext_eph_pk_bigint / 2^128, ext_eph_pk_bigint % 2^128, max_epoch, jwt_randomness]).to_bytes()[len - 20..]) where ext_eph_pk_bigint is the BigInt representation of ext_eph_pk.\next_eph_pk: The byte representation of an ephemeral public key (flag || eph_pk). Size varies depending on the choice of the signature scheme (denoted by the flag, defined in Signatures).\nuser_salt: A value introduced to unlink the OAuth identifier with the on-chain address.\nmax_epoch: The epoch at which the JWT expires. This is u64 used in Sui.\nkc_name: The key claim name, e.g. sub.\nkc_value: The key claim value, e.g. 110463452167303000000.\nhashBytesToField(str, maxLen): Hashes the ASCII string to a field element using the Poseidon hash.\nCeremony​\n\nTo preserve privacy of the OAuth artifacts, a zero-knowledge proof of possession of the artifacts is provided. zkLogin employs the Groth16 zkSNARK to instantiate the zero-knowledge proofs, as it is the most efficient general-purpose zkSNARK in terms of proof size and verification efficiency.\n\nHowever, Groth16 needs a computation-specific common reference string (CRS) to be setup by a trusted party. With zkLogin expected to ensure the safe-keeping of high value transactions and the integrity of critical smart contracts, we cannot base the security of the system on the honesty of a single entity. Hence, to generate the CRS for the zkLogin circuit, it is vital to run a protocol which bases its security on the assumed honesty of a small fraction of a large number of parties.\n\nWhat is the ceremony?​\n\nThe Sui zkLogin ceremony is essentially a cryptographic multi-party computation (MPC) performed by a diverse group of participants to generate this CRS. We follow the MPC protocol MMORPG described by Bowe, Gabizon and Miers. The protocol roughly proceeds in 2 phases. The first phase results in a series of powers of a secret quantity tau in the exponent of an elliptic curve element. Since this phase is circuit-agnostic, we adopted the result of the existing community contributed perpetual powers of tau. Our ceremony was the second phase, which is specific to the zkLogin circuit.\n\nThe MMORPG protocol is a sequential protocol, which allows an indefinite number of parties to participate in sequence, without the need of any prior synchronization or ordering. Each party needs to download the output of the previous party, generate entropy of its own and then layer it on top of the received result, producing its own contribution, which is then relayed to the next party. The protocol guarantees security, if at least one of the participants follows the protocol faithfully, generates strong entropy and discards it reliably.\n\nHow was the ceremony performed?​\n\nWe sent invitations to 100+ people with diverse backgrounds and affiliations: Sui validators, cryptographers, web3 experts, world-renowned academicians, and business leaders. We planned the ceremony to take place on the dates September 12-18, 2023, but allowed participants to join when they wanted with no fixed slots.\n\nSince the MPC is sequential, each contributor needed to wait till the previous contributor finished in order to receive the previous contribution, follow the MPC steps and produce their own contribution. Due to this structure, we provisioned a queue where participants waited, while those who joined before them finished. To authenticate participants, we sent a unique activation code to each of them. The activation code was the secret key of a signing key pair, which had a dual purpose: it allowed the coordination server to associate the participant's email with the contribution, and to verify the contribution with the corresponding public key.\n\nParticipants had two options to contribute: through a browser or a docker. The browser option was more user-friendly for contributors to participate as everything happens in the browser. The Docker option required Docker setup but is more transparent—the Dockerfile and contributor source code are open-sourced and the whole process is verifiable. Moreover, the browser option utilizes snarkjs while the Docker option utilizes Kobi's implementation. This provided software variety and contributors could choose to contribute by whichever method they trust. In addition, participants could generate entropy via entering random text or making random cursor movements.\n\nThe zkLogin circuit and the ceremony client code were made open source and the links were made available to the participants to review before the ceremony. In addition, we also posted these developer docs and an audit report on the circuit from zkSecurity. We adopted challenge #0081 (resulting from 80 community contributions) from perpetual powers of tau in phase 1, which is circuit agnostic. We applied the output of the Drand random beacon at epoch #3298000 to remove bias. For phase 2, our ceremony had 111 contributions, 82 from browser and 29 from docker. Finally, we applied the output of the Drand random beacon at epoch #3320606 to remove bias from contributions. All intermediate files can be reproduced following instructions here for phase 1 and here for phase 2.\n\nFinalization​\n\nThe final CRS along with the transcript of contribution of every participant is available in a public repository. Contributors received both the hash of the previous contribution they were working on and the resulting hash after their contribution, displayed on-screen and sent via email. They can compare these hashes with the transcripts publicly available on the ceremony site. In addition, anyone is able to check that the hashes are computed correctly and each contribution is properly incorporated in the finalized parameters.\n\nEventually, the final CRS was used to generate the proving key and verifying key. The proving key is used to generate zero knowledge proof for zkLogin, stored with the ZK proving service. The verifying key was deployed as part of the validator software (protocol version 25 in release 1.10.1) that is used to verify the zkLogin transaction on Sui.\n\nSecurity and privacy​\n\nThe following sections walk through all zkLogin artifacts, their security assumptions, and the consequences of loss or exposure.\n\nJWT​\n\nThe JWT's validity is scoped on the client ID (aud) to prevent phishing attacks. The same origin policy for the proof prevents the JWT obtained for a malicious application from being used for zkLogin. The JWT for the client ID is sent directly to the application frontend through the redirect URL. A leaked JWT for the specific client ID can compromise user privacy, as these tokens frequently hold sensitive information like usernames and emails. Furthermore, if a backend salt server is responsible for user salt management, the JWT could potentially be exploited to retrieve the user's salt, which introduces additional risks.\n\nHowever, a JWT leak does not mean loss of funds as long as the corresponding ephemeral private key is safe.\n\nUser salt​\n\nThe user salt is required to get access to the zkLogin wallet. This value is essential for both ZK proof generation and zkLogin address derivation.\n\nThe leak of user salt does not mean loss of funds, but it enables the attacker to associate the user's subject identifier (i.e. sub) with the Sui address. This can be problematic depending on whether pairwise or public subject identifiers are in use. In particular, there is no problem if pairwise IDs are used (e.g., Facebook) as the subject identifier is unique per RP. However, with public reusable IDs (e.g., Google and Twitch), the globally unique sub value can be used to identify users.\n\nEphemeral private key​\n\nThe ephemeral private key's lifespan is tied to the maximum epoch specified in nonce for creating a valid ZK proof. Should it be misplaced, a new ephemeral private key can be generated for transaction signing, accompanied by a freshly generated ZK proof using a new nonce. However, if the ephemeral private key is compromised, acquiring the user salt and the valid ZK proof would be necessary to move funds.\n\nProof​\n\nObtaining the proof itself cannot create a valid zkLogin transaction because an ephemeral signature over the transaction is also needed.\n\nPrivacy​\n\nBy default, there is no linking between the OAuth subject identifier (i.e. sub) and a Sui address. This is the purpose of the user salt. The JWT is not published on-chain by default. The revealed values include iss, aud and kid so that the public input hash can be computed, any sensitive fields such as sub are used as private inputs when generating the proof.\n\nThe ZK proving service and the salt service (if maintained) can link the user identity since the user salt and JWT are known, but the two services are stateless by design.\n\nIn the future, the user can opt in to verify their OAuth identity associated with an Sui address on-chain.\n\nFAQ​\nWhat providers is zkLogin compatible with?​\n\nzkLogin can support providers that work with OpenID Connect built on top of the OAuth 2.0 framework. This is a subset of OAuth 2.0 compatible providers. See latest table for all enabled providers. Other compatible providers will be enabled via protocol upgrades in the future.\n\nHow is a zkLogin Wallet different from a traditional private key wallet?​\n\nTraditional private key wallets demand users to consistently recall mnemonics and passphrases, necessitating secure storage to prevent fund loss from private key compromise.\n\nOn the other hand, a zkLogin wallet only requires an ephemeral private key storage with session expiry and the OAuth login flow with expiry. Forgetting an ephemeral key does not result in loss of funds, because a user can always sign in again to generate a new ephemeral key and a new ZK proof.\n\nHow is zkLogin different from MPC or Multisig wallets?​\n\nMulti-Party Computation (MPC) and Multisig wallets rely on multiple keys or distributing multiple key shares and then defining a threshold value for accepting a signature.\n\nzkLogin does not split any individual private keys, but ephemeral private keys are registered using a fresh nonce when the user authenticates with the OAuth provider. The primary advantage of zkLogin is that the user does not need to manage any persistent private key anywhere, not even with any private keys management techniques like MPC or Multisig.\n\nYou can think of zkLogin as a 2FA scheme for an address, where the first part is user's OAuth account and the second is the user's salt.\n\nFurthermore, because Sui native supports Multisig wallets, one can always include one or more zkLogin signers inside a Multisig wallet for additional security, such as using the zkLogin part as 2FA in k-of-N settings.\n\nIf my OAuth account is compromised, what happens to my zkLogin address?​\n\nBecause zkLogin is a 2FA system, an attacker that has compromised your OAuth account cannot access your zkLogin address unless they have separately compromised your salt.\n\nIf I lose access to my OAuth account, do I lose access to my zkLogin address?​\n\nYes. You must be able to log into your OAuth account and produce a current JWT in order to use zkLogin.\n\nDoes losing my OAuth credential mean the loss of funds in the zkLogin wallet?​\n\nA forgotten OAuth credential can typically be recovered by resetting the password in that provider. In the unfortunate event where user's OAuth credentials get compromised, an adversary will still require to obtain user_salt, but also learn which wallet is used in order to take over that account. Note that modern user_salt providers may have additional 2FA security measures in place to prevent provision of user's salt even to entities that present a valid, non-expired JWT.\n\nIt's also important to highlight that due to the fact that zkLogin addresses do not expose any information about the user's identity or wallet used, targeted attacks by just monitoring the blockchain are more difficult. Finally, on the unfortunate event where one loses access to their OAuth account permanently, access to that wallet is lost. But if recovery from a lost OAuth account is desired, a good suggestion for wallet providers is to support the native Sui Multisig functionality and add a backup method. Note that it's even possible to have a Multisig wallet that all signers are using zkLogin, i.e. an 1-of-2 Multisig zkLogin wallet where the first part is Google and the second Facebook OAuth, respectively.\n\nCan I convert or merge a traditional private key wallet into a zkLogin one, or vice versa?​\n\nNo. The zkLogin wallet address is derived differently compared to a private key address.\n\nWill my zkLogin address ever change?​\n\nzkLogin address is derived from sub, iss, aud and user_salt.\n\nThe address will not change if the user logs in to the same wallet with the same OAuth provider, since sub, iss, aud and user_salt (see definitions) will remain unchanged in the JWT, even though the JWT itself may look different every time the user logs in.\n\nHowever, if the user logs in with different OAuth providers, your address will change because the iss and aud are defined distinctly per provider.\n\nIn addition, each wallet or application maintains its own user_salt, so logging with the same provider for different wallets may also result in different addresses.\n\nSee more on address definition.\n\nCan I have multiple addresses with the same OAuth provider?​\n\nYes, this is possible by using a different wallet provider or different user_salt for each account. This is useful for separating funds between different accounts.\n\nIs a zkLogin Wallet custodial?​\n\nA zkLogin wallet is a non-custodial or unhosted wallet.\n\nA custodial or hosted wallet is where a third party (the custodian) controls the private keys on behalf of a wallet user. No such third-party exists for zkLogin wallets.\n\nInstead, a zkLogin wallet can be viewed as a 2-out-of-2 Multisig where the two credentials are the user's OAuth credentials (maintained by the user) and the salt. In other words, neither the OAuth provider, the wallet vendor, the ZK proving service or the salt service provider is a custodian.\n\nGenerating a ZK proof is expensive, is a new proof required to be generated for every transaction?​\n\nNo. Proof generation is only required when ephemeral KeyPair expires. Since the nonce is defined by the ephemeral public key (eph_pk) and expiry (max_epoch), the ZK proof is valid until what the expiry is committed to nonce in the JWT. The ZK proof can be cached and the same ephemeral key can be used to sign transactions till it expires.\n\nDoes zkLogin work on mobile?​\n\nzkLogin is a Sui native primitive and not a feature of a particular application or wallet. It can be used by any Sui developer, including on mobile.\n\nIs account recovery possible if the user loses the OAuth credentials?​\n\nYes, the user can follow the OAuth providers' recovery flow. The ephemeral private key can be refreshed and after completing a new OAuth login flow, the user can obtain new ZK proof and sign transactions with the refreshed key.\n\nWhat are some assumptions for the zkLogin circuit?​\n\nDue to the way Groth16 works, we impose length restrictions on several fields in the JWT. Some of the fields that are length-restricted include aud, iss, the JWT's header and payload. For example, zkLogin can currently only work with aud values of up to length 120 (this value is not yet final). In general, we tried to make sure that the restrictions are as generous as possible. We have decided on these values after looking at as many JWTs that we could get our hands on.\n\nHow is zkLogin different from other solutions that support social login?​\n\nWhile providing social login with Web2 credentials for Web3 wallet is not a new concept, the existing solutions have one or more of the trust assumptions:\n\nTrust a different network or parties to verify Web2 credentials other than the Blockchain itself, usually involving a JWK oracle posted on-chain by a trusted party.\nTrust some parties to manage a persistent private key, whether it uses MPC, threshold cryptography or secure enclaves.\nRelying on smart contracts (account abstraction) to verify the JWT on chain with revealing privacy fields, or to verify ZK proofs on-chain which can be expensive.\n\nSome of the existing deployed solutions rely on some of these assumptions. Web3Auth and DAuth social login requires deployment of custom OAuth verifiers to Web3auth Auth Network nodes to verify the JWT. Magic Wallet and Privy also require custom OAuth identity issuer and verifiers to adopt the DID standard. All of the solutions still require persistent private keys management, either with trusted parties like AWS via delegation, Shamir Secret Sharing or MPC.\n\nThe key differentiators that zkLogin brings to Sui are:\n\nNative Support in Sui: Unlike other solutions that are blockchain agnostic, zkLogin is deployed just for Sui. This means a zkLogin transaction can be combined with Multisig and sponsored transactions seamlessly.\n\nSelf-Custodial without additional trust: We leverage the nonce field in JWT to commit to ephemeral public key, so no persistent private key management is required with any trusted parties. In addition, the JWK itself is an oracle agreed upon by the quorum of stakes by the validators with trusting any source of authority.\n\nFull privacy: Nothing is required to submit on-chain except the ZK proof and the ephemeral signature.\n\nCompatible with Existing Identity Providers: zkLogin is compatible with providers that adopt OpenID Connect. No need to trust any intermediate identity issuers or verifiers other than the OAuth providers themselves.\n\nHow to verify a zkLogin signature off chain?​\n\nThe following options support a zkLogin signature over either transaction data or personal message using the JWK state on Sui and current epoch.\n\nUse Sui Typescript SDK. This initializes a GraphQL client and calls the endpoint under the hood.\n\nUse the GraphQL endpoint directly: https://sui-[network].mystenlabs.com/graphql, changing [network] to the appropriate value. See the GraphQL documentation for more details. This is recommended if you do not plan to run any servers or handle any JWK rotations.\n\nUse the Sui Keytool CLI. This is recommended for debug usage.\n\n$SUI_BINARY keytool zk-login-sig-verify --sig $ZKLOGIN_SIG --bytes $BYTES --intent-scope 3 --network devnet --curr-epoch 3\n\n\nUse a self-hosted server endpoint and call this endpoint, as described in zklogin-verifier. This provides logic flexibility.\n\nCan I use zkLogin inside a multisig wallet?​\n\nYes. See the Multisig Guide for more details.\n\nRelated links​\nzkLogin Implementation Guide\nzkLogin Example\nEdit this page\nPrevious\nIntent Signing\nNext\nCheckpoint Verification\nOpenID providers\nHow zkLogin works\nThe complete zkLogin flow\nEntities\nAddress definition\nTerminology and notations\nOpenID provider (OP)\nRelying party (RP) or client\nSubject identifier (sub)\nJSON Web Key (JWK)\nJSON Web Token (JWT)\nKey claim\nNotations\nCeremony\nWhat is the ceremony?\nHow was the ceremony performed?\nFinalization\nSecurity and privacy\nJWT\nUser salt\nEphemeral private key\nProof\nPrivacy\nFAQ\nWhat providers is zkLogin compatible with?\nHow is a zkLogin Wallet different from a traditional private key wallet?\nHow is zkLogin different from MPC or Multisig wallets?\nIf my OAuth account is compromised, what happens to my zkLogin address?\nIf I lose access to my OAuth account, do I lose access to my zkLogin address?\nDoes losing my OAuth credential mean the loss of funds in the zkLogin wallet?\nCan I convert or merge a traditional private key wallet into a zkLogin one, or vice versa?\nWill my zkLogin address ever change?\nCan I have multiple addresses with the same OAuth provider?\nIs a zkLogin Wallet custodial?\nGenerating a ZK proof is expensive, is a new proof required to be generated for every transaction?\nDoes zkLogin work on mobile?\nIs account recovery possible if the user loses the OAuth credentials?\nWhat are some assumptions for the zkLogin circuit?\nHow is zkLogin different from other solutions that support social login?\nHow to verify a zkLogin signature off chain?\nCan I use zkLogin inside a multisig wallet?\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Gas Smashing | Sui Documentation",
      "url": "https://docs.sui.io/concepts/transactions/gas-smashing",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nTransactions\nProgrammable Transaction Blocks\nSponsored Transactions\nGas Smashing\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersTransactionsGas Smashing\nGas Smashing\n\nEvery transaction on Sui has a gas fee associated with its execution that must be paid to successfully execute the transaction. Gas smashing enables you to pay for this gas fee using multiple coins instead of just one. This mechanism is especially helpful in scenarios where you might have a number of coins with smaller denominations, or if you simply want to minimize the number of SUI coins under your account. Gas smashing is generally a useful tool for coin management, especially when coupled with the GasCoin programmable transaction block (PTB) argument.\n\nSmashing gas​\n\nGas smashing happens automatically in a transaction if you provide multiple coins to pay for the gas fee. When Sui executes a transaction, Sui combines, or \"smashes\", all of the coins you provide to pay for the gas into a single coin. The smashing occurs regardless of coin amounts or the gas budget provided with the transaction (as long as it is within the minimum and maximum gas budgets). Sui deducts the gas fee from the single coin regardless of the execution status of the transaction. In particular, this means that even if the transaction fails to execute for some reason (such as an execution error) the coins that you provided as gas coins remain smashed after the transaction's execution.\n\nGas smashing is an efficient way to perform coin management, and to combine many smaller coins into one single coin that you can use to not only pay for gas fees, but also for other operations in the transaction that smashes the coins. In particular, you can use gas smashing to combine multiple coins to pay for the gas fee of the PTB, and then that same PTB can withdraw from the GasCoin. A special argument is available in PTBs that references the coin used to pay gas after Sui deducts the gas fee from it, which you can use to transfer the remaining SUI to another address. Because gas smashing happens automatically in a transaction if you provide multiple gas coins, you can combine multiple coins as part of other transactions to perform coin management in parallel with non-coin-management specific transactions.\n\nSui has a maximum of 256 coins that you can smash in a single PTB - the transaction is not processed if the number of gas coins exceeds this amount. Additionally, when you smash gas coins, Sui deletes all but the first coin. Because of this, there is often a storage rebate associated with the deletion of these coins. As with other storage rebates, you can't use the resulting refund to pay for the gas fee of the transaction (and isn't credited to the coin until after the execution of the transaction), but it might result in a refund after the execution of the transaction. This refund, along with the remaining balance after the transaction's gas fee, resides in the first gas coin you provide in the transaction after execution.\n\nRunning out of gas with a refund​\n\nBecause coins are smashed regardless of the execution status, storage rebates can lead to seemingly odd cases where a transaction can both run out of gas and end up with a negative gas and storage fee (you get a refund from the transaction). As an example of how this might happen, take a transaction T that has a gas budget of 5000, and you provide coins C1, C2, C3, C4, C5 with values of 1000, 2000, 3000, 4000, and 5000 to pay for gas. If the storage rebate for a coin object is 2000, and the gas fee for T execution is more than the provided gas budget of 5000 (so, T runs out of gas), this results in an execution status of OutOfGas. The C1 coin has a balance of 1000 + 2000 + 3000 + 4000 + 5000 - 5000 + 2000 * 4 = 15000 - 5000 + 8000 = 18000 and T ends up with a negative gas and storage fee (a refund) of 3000.\n\nEdit this page\nPrevious\nSponsored Transactions\nNext\nCryptography\nSmashing gas\nRunning out of gas with a refund\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/cryptography/transaction-auth",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nTransaction Authentication\nKeys and Addresses\nSignatures\nMultisig\nOffline Signing\nIntent Signing\nzkLogin\nCheckpoint Verification\nSui Architecture\nTokenomics\nResearch Papers\nCryptographyTransaction Authentication\nTransaction Authentication\n\nTransaction authentication features on Sui provide security against unauthorized access to on-chain data.\n\nKeys and Addresses​\n\nSui adheres to widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 (and its variation, SLIP-0010), BIP-44, and BIP-39, to facilitate key management for users. At present, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig for signed transactions.\n\nGo to Keys and Addresses.\n\nSignatures​\n\nCryptographic agility is core to Sui. The system supports multiple cryptography algorithms and primitives and can switch between them rapidly. With Sui, you can choose the right cryptography solution for your system and implement the latest algorithms as they become available.\n\nGo to Signatures.\n\nMultisig​\n\nSui supports multi-signature (multisig) transactions, which require multiple keys for authorization rather than a single, one-key signature.\n\nGo to Multisig.\n\nOffline Signing​\n\nSui supports offline signing, which is signing transactions using a device not connected to a Sui network, or in a wallet implemented in a different programming language without relying on the Sui key store.\n\nGo to Offline Signing.\n\nIntent Signing​\n\nIn Sui, an intent is a compact struct that serves as the domain separator for a message that a signature commits to. The data that the signature commits to is an intent message. All signatures in Sui must commit to an intent message, instead of the message itself.\n\nGo to Intent Signing.\n\nEdit this page\nPrevious\nCryptography\nNext\nKeys and Addresses\nKeys and Addresses\nSignatures\nMultisig\nOffline Signing\nIntent Signing\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/cryptography/system/checkpoint-verification",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nTransaction Authentication\nzkLogin\nCheckpoint Verification\nSui Architecture\nTokenomics\nResearch Papers\nCryptographyCheckpoint Verification\nCheckpoint Verification\n\nOn the Sui network, checkpoints define the history of the blockchain. They are quite similar to the concept of blocks used by traditional blockchains like Bitcoin or Ethereum. The Sui blockchain, however, forms checkpoints after transaction execution has already happened to provide a certified history of the chain, instead of being formed before execution.\n\nCheckpoints contain:\n\nThe cryptographic hash of the previous checkpoint.\nA list of all the transaction digests (and the corresponding transaction effects digests) that are included in the checkpoint.\nA set of signatures from a quorum (more than 2/3rds) of the validators that formed the committee at the time the checkpoint was created.\n\nBoth validators and Full nodes consume checkpoints to remain synchronized with the network.\n\nCheckpoint verification​\n\nFor Full nodes and validators to trust a checkpoint, they must first verify it. Verification ensures that the checkpoint is a true checkpoint that the Sui validator committee created.\n\nCheckpoint verification requires two interdependent pieces:\n\nAssuming that the Full node (or other client) has the public keys of the validator committee that created the checkpoint, it can check the signatures on the checkpoint for validity.\n\nCheckpoints are signed by the aggregated BLS signatures of a quorum of the committee. If the signatures are valid, the client now knows that the checkpoint was created by the validator committee, and not by some other party.\n\nBy validating checkpoints, the client can determine the make-up of the committee, because the final checkpoint of each epoch contains the validator committee (including the public keys) of the next epoch.\n\nThese pieces seem to create a circular dependency issue. The client needs to know the committee to verify checkpoints, which in turn allows it to learn what the committee is for each epoch. To solve this problem, the process is bootstrapped by starting from the genesis checkpoint, which is the earliest checkpoint in a Sui network. The genesis checkpoint contains the initial validator committee, which allows a client to verify all checkpoints in the history by using the following process:\n\nThe client obtains the genesis checkpoint from some trusted source.\nThe client loads the initial committee from the genesis checkpoint.\nThe client uses the state sync network or Sui archive to obtain the next checkpoint.\nThe client verifies the signatures on the checkpoint using the current committee's public keys, and verifies that the checkpoint's previous checkpoint hash is equal to the hash of the previous checkpoint that the client validated.\nIf the checkpoint is invalid, an error is raised.\nOtherwise, the client checks if the checkpoint is the last one of the current epoch.\nIf so, load the next committee from it, and use that committee as the current committee.\nIf not, return to step 3 and continue.\n\nThis allows the client to eventually verify all checkpoints up to the present time.\n\nWhat do checkpoints commit to?​\n\nAfter a client verifies a checkpoint, what can it do with that information?\n\nAs mentioned earlier, a checkpoint contains a list of transactions so a Full node, for instance, can begin fetching and executing those transactions. Because the transactions are identified by their digest (a cryptographic hash), the client can be sure that the transactions it executes have not been altered.\n\nAdditionally, the checkpoint contains the effects digests of each transaction. The effects digest is the cryptographic hash of the TransactionEffects, which is itself a structure that lists all of the inputs and outputs of a transaction. It includes the digests of all objects that were written by the transaction. This allows a Full node to verify that it has obtained the same execution results as those that the validators attested to when signing the checkpoint.\n\nBy executing checkpoints, and verifying transaction outputs, a Full node can build up the entire state of the Sui network (that is, the collection of objects in the network) and trust that every byte of every object is correct.\n\nEdit this page\nPrevious\nzkLogin\nNext\nSui Architecture\nCheckpoint verification\nWhat do checkpoints commit to?\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/contribute/contribution-process",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui Environment Setup\nDocs Contribution\nContribute to Sui Repositories\nSubmit a SIP\nLocalize Sui Documentation\nCode of Conduct\nStyle Guide\nContribute\nContribute to Sui Documentation\n\nAs open source software, Sui depends on community contributions. This page covers the process for contributing to Sui's documentation.\n\nTo make changes to the documentation, you can fork and clone the Sui repository to your local machine and make changes from your preferred IDE of choice, or by the web interface on GitHub. This guide covers both scenarios.\n\nStyle guide compliance​\n\nAll changes to the documentation must follow the style guide, as well as the review process and information on the editors throughout the process. Do not be offended by the number of change requests your docs PR might receive. This is not a reflection on your writing abilities, but an effort to keep a consistent tone across the documentation set. Depending on reviewer and workload, some reviews are more thorough than others. After your PR merges, your content might be changed at a later date to align better with Sui writing standards.\n\nTo create more engaging content, be sure to follow these rules in particular:\n\nAlways prefer active voice.\nPresent tense verbs are almost always the right choice.\nBe concise. Use only the words strictly necessary to convey an idea.\nSet up local environment​\n\nCloning the documentation locally is recommended when you are creating larger, more significant changes to the docs. See Sui Environment Setup for instructions on forking the Sui repository, if necessary. The documentation is in the docs/content directory.\n\nIf you are using the recommended Visual Studio Code IDE, install Prettier to ensure that your formatting is consistent.\nAfter you make all your changes, stage all files with changes (git add . to add all modified files), create a local commit (git commit -m “message”), and then push all your changes to your forked repository (git push).\nTo view your changes via localhost, enter pnpm install into a terminal at the docs/site directory to install dependencies, then pnpm start to view the changes on localhost:3000 to ensure that the website works as intended. You might need to install the pnpm package manager if you don't already have it.\nFor beginners​\n\nEditing the documentation via the GitHub web interface is recommended if you are not familiar with working in an IDE, or for smaller changes and fixes.\n\nAdd New Page\n\nNavigate to the docs/content directory, then navigate to the appropriate subdirectory and click the Add file button in the top-right. Select create new file to create a new file and edit it directly on GitHub's web interface.\n\nChange Existing Page\n\nTo change an existing page, navigate to the file you want to edit, click on the pencil icon in the top-right, and edit your changes there.\n\nReview process​\n\nWhen you are finished creating your changes in your own fork or using the web interface, submit a PR to the Sui repository. When you do so, you can view the deployment on Vercel and double-check that everything behaves the way you intend. For every unique commit in a PR, Vercel generates a new preview. A reviewer then takes responsibility for providing clear and actionable feedback to your PR. As the owner of the PR, it is your responsibility to modify your PR to address the feedback that has been provided to you by the reviewer. Keep in mind that you may receive feedback from multiple reviewers. After a reviewer has approved your PR, it is merged into main and your contributions are made public.\n\nEdit this page\nPrevious\nGlossary\nNext\nSui Environment Setup\nStyle guide compliance\nSet up local environment\nFor beginners\nReview process\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/sui-glossary",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nGlossary\nGlossary\n\nFind terms used in Sui defined below.\n\nCausal history​\n\nCausal history is the relationship between an object in Sui and its direct predecessors and successors. This history is essential to the causal order Sui uses to process transactions. In contrast, other blockchains read the entire state of their world for each transaction, introducing latency.\n\nCausal order​\n\nCausal order is a representation of the relationship between transactions and the objects they produce, laid out as dependencies. Validators cannot execute a transaction dependent on objects created by a prior transaction that has not finished. Rather than total order, Sui uses causal order (a partial order).\n\nCertificate​\n\nA certificate is the mechanism proving a transaction was approved or certified. Validators vote on transactions, and aggregators collect a Byzantine-resistant-majority of these votes into a certificate and broadcasts it to all Sui validators, thereby ensuring finality.\n\nEpoch​\n\nOperation of the Sui network is temporally partitioned into non-overlapping, fixed-duration epochs. During a particular epoch, the set of validators participating in the network is fixed.\n\nEquivocation​\n\nEquivocation in blockchains is the malicious action of dishonest actors giving conflicting information for the same message, such as inconsistent or duplicate voting.\n\nEventual consistency​\n\nEventual consistency is the consensus model employed by Sui; if one honest validator certifies the transaction, all of the other honest validators will too eventually.\n\nFinality​\n\nFinality is the assurance a transaction will not be revoked. This stage is considered closure for an exchange or other blockchain transaction.\n\nGas​\n\nGas refers to the computational effort required for executing operations on the Sui network. In Sui, gas is paid with the network's native currency SUI. The cost of executing a transaction in SUI units is referred to as the transaction fee.\n\nGenesis​\n\nGenesis is the initial act of creating accounts and gas objects for a Sui network. Sui provides a genesis command that allows users to create and inspect the genesis object setting up the network for operation.\n\nMulti-writer objects​\n\nMulti-writer objects are objects that are owned by more than one address. Transactions affecting multi-writer objects require consensus in Sui. This contrasts with transactions affecting only single-writer objects, which require only a confirmation of the owner's address contents.\n\nObject​\n\nThe basic unit of storage in Sui is object. In contrast to many other blockchains, where storage is centered around address and each address contains a key-value store, Sui's storage is centered around objects. Sui objects have one of the following primary states:\n\nImmutable - the object cannot be modified.\nMutable - the object can be changed.\n\nFurther, mutable objects are divided into these categories:\n\nOwned - the object can be modified only by its owner.\nShared - the object can be modified by anyone.\n\nImmutable objects do not need this distinction because they have no owner.\n\nProof-of-stake​\n\nProof-of-stake is a blockchain consensus mechanism where the voting weights of validators or validators is proportional to a bonded amount of the network's native currency (called their stake in the network). This mitigates Sybil attacks by forcing bad actors to gain a large stake in the blockchain first.\n\nSingle-writer objects​\n\nSingle-writer objects are owned by one address. In Sui, transactions affecting only single-writer objects owned by the same address may proceed with only a verification of the sender's address, greatly speeding transaction times. These are simple transactions. See Single-Writer Apps for example applications of this simple transaction model.\n\nSmart contract​\n\nA smart contract is an agreement based upon the protocol for conducting transactions in a blockchain. In Sui, smart contracts are written in the Move programming language.\n\nSui​\n\nSui refers to the Sui blockchain, and the Sui open source project as a whole.\n\nSUI​\n\nSUI is the native token to the Sui network.\n\nTotal order​\n\nTotal order refers to the ordered presentation of the history of all transactions processed by a traditional blockchain up to a given time. This is maintained by many blockchain systems, as the only way to process transactions. In contrast, Sui uses a causal (partial) order wherever possible and safe.\n\nTransaction​\n\nA transaction in Sui is a change to the blockchain. This may be a simple transaction affecting only single-writer, single-address objects, such as minting an NFT or transferring an NFT or another token. These transactions may bypass the consensus protocol in Sui.\n\nMore complex transactions affecting objects that are shared or owned by multiple addresses, such as asset management and other DeFi use cases, go through the Narwhal and Bullshark DAG-based mempool and efficient Byzantine Fault Tolerant (BFT) consensus.\n\nTransfer​\n\nA transfer is switching the owner address of a token to a new one via command in Sui. This is accomplished via the Sui CLI client command line interface. It is one of the more common of many commands available in the CLI client.\n\nValidator​\n\nA validator in Sui plays a passive role analogous to the more active role of validators and minors in other blockchains. In Sui, validators do not continuously participate in the consensus protocol but are called into action only when receiving a transaction or certificate.\n\nEdit this page\nPrevious\nvoting_power\nNext\nDocs Contribution\nCausal history\nCausal order\nCertificate\nEpoch\nEquivocation\nEventual consistency\nFinality\nGas\nGenesis\nMulti-writer objects\nObject\nProof-of-stake\nSingle-writer objects\nSmart contract\nSui\nSUI\nTotal order\nTransaction\nTransfer\nValidator\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/framework",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nDeepbook\nMove Stdlib\nSui Framework\nSui System\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nMoveFramework\nSui Framework\n\nThe documentation in this section is created from the Rust cargo doc process. The process builds the content from comments in the source code.\n\nFramework documentation​\n\nThe child pages to this topic describe the module members for the following libraries:\n\n🗃️ Deepbook\n🗃️ Move Stdlib\n🗃️ Sui Framework\n🗃️ Sui System\nSource code​\n\nYou can find the source code for these Move modules in the crates/sui-framework/packages directory in the sui repository on GitHub. As previously mentioned, the comments included in the code provide context for the logic defined.\n\nCrate documentation​\n\nYou can review the raw cargo doc output of the following documentation in the sui repository. The .md files are located in the crates/sui-framework/docs directory. Online, they are located at https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/docs.\n\nBuild documentation locally​\n\nThe most recent documentation is always available in the main branch of the sui repository. You shouldn't need to build the documentation locally, but if the need arises you can:\n\nOpen a terminal or console to the sui/crates/sui-framework directory.\nRun cargo doc --workspace --exclude \"sui-benchmark\" --no-deps.\nThe docs are built to crates/sui-framework/docs into their respective subdirectories.\nINFO\n\nIf the cargo doc process does not work as expected, try running cargo clean before attempting again.\n\nEdit this page\nPrevious\nMove References\nNext\nDeepbook\nFramework documentation\nSource code\nCrate documentation\nBuild documentation locally\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-move",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nMove\nMove References\n\nMove is an open source language for writing safe packages to manipulate on-chain objects (sometimes referred to as \"smart contracts\"). Move is a platform-agnostic language to enable common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. Move is adaptable to meet the needs of the blockchain the code operates on, see Move on Sui to review enhancements made to Move for optimization on the Sui blockchain.\n\nSui Framework: Provides cargo doc-generated content for core Sui modules.\nThe Move Book: A definitive guide for learning the Move language on Sui.\nThe Move Reference: Architecture and syntax reference for the Move language.\nEdit this page\nPrevious\nRust SDK\nNext\nSui Framework\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/rust-sdk",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui SDKsRust SDK\nRust SDK\n\nThe Sui Rust SDK crate is in the crates\\sui-sdk directory of the Sui repository.\n\nThis crate provides the Sui Rust SDK, containing APIs to interact with the Sui network. Auto-generated documentation for this crate is here.\n\nGetting started​\n\nAdd the sui-sdk dependency as following:\n\nsui-sdk = { git = \"https://github.com/mystenlabs/sui\", package = \"sui-sdk\"}\ntokio = { version = \"1.2\", features = [\"full\"] }\nanyhow = \"1.0\"\n\n\nThe main building block for the Sui Rust SDK is the SuiClientBuilder, which provides a simple and straightforward way of connecting to a Sui network and having access to the different available APIs.\n\nIn the following example, the application connects to the Sui testnet and devnet networks and prints out their respective RPC API versions.\n\nuse sui_sdk::SuiClientBuilder;\n\n#[tokio::main]\nasync fn main() -> Result<(), anyhow::Error> {\n    // Sui testnet -- https://fullnode.testnet.sui.io:443\n    let sui_testnet = SuiClientBuilder::default().build_testnet().await?;\n    println!(\"Sui testnet version: {}\", sui_testnet.api_version());\n\n     // Sui devnet -- https://fullnode.devnet.sui.io:443\n    let sui_devnet = SuiClientBuilder::default().build_devnet().await?;\n    println!(\"Sui devnet version: {}\", sui_devnet.api_version());\n\n    Ok(())\n}\n\n\nDocumentation for sui-sdk crate​\n\nGitHub Pages hosts the generated documentation for all Rust crates in the Sui repository.\n\nBuilding documentation locally​\n\nYou can also build the documentation locally. To do so,\n\nClone the sui repo locally. Open a Terminal or Console and go to the sui/crates/sui-sdk directory.\n\nRun cargo doc to build the documentation into the sui/target directory. Take note of location of the generated file from the last line of the output, for example Generated /Users/foo/sui/target/doc/sui_sdk/index.html.\n\nUse a web browser, like Chrome, to open the .../target/doc/sui_sdk/index.html file at the location your console reported in the previous step.\n\nRust SDK examples​\n\nThe examples folder provides both basic and advanced examples.\n\nThere are serveral files ending in _api.rs which provide code examples of the corresponding APIs and their methods. These showcase how to use the Sui Rust SDK, and can be run against the Sui testnet. Below are instructions on the prerequisites and how to run these examples.\n\nPrerequisites​\n\nUnless otherwise specified, most of these examples assume Rust and cargo are installed, and that there is an available internet connection. The examples connect to the Sui testnet (https://fullnode.testnet.sui.io:443) and execute different APIs using the active address from the local wallet. If there is no local wallet, it will create one, generate two addresses, set one of them to be active, and it will request 1 SUI from the testnet faucet for the active address.\n\nRunning the existing examples​\n\nIn the root folder of the sui repository (or in the sui-sdk crate folder), you can individually run examples using the command cargo run --example filename (without .rs extension). For example:\n\ncargo run --example sui_client -- this one requires a local Sui network running (see [here](#Connecting to Sui Network )). If you do not have a local Sui network running, please skip this example.\ncargo run --example coin_read_api\ncargo run --example event_api -- note that this will subscribe to a stream and thus the program will not terminate unless forced (Ctrl+C)\ncargo run --example governance_api\ncargo run --example read_api\ncargo run --example programmable_transactions_api\ncargo run --example sign_tx_guide\nBasic Examples​\nConnecting to Sui Network​\n\nThe SuiClientBuilder struct provides a connection to the JSON-RPC server that you use for all read-only operations. The default URLs to connect to the Sui network are:\n\nLocal: http://127.0.0.1:9000\nDevnet: https://fullnode.devnet.sui.io:443\nTestnet: https://fullnode.testnet.sui.io:443\nMainnet: https://fullnode.mainnet.sui.io:443\n\nFor all available servers, see here.\n\nFor running a local Sui network, please follow this guide for installing Sui and this guide for starting the local Sui network.\n\nuse sui_sdk::SuiClientBuilder;\n\n#[tokio::main]\nasync fn main() -> Result<(), anyhow::Error> {\n    let sui = SuiClientBuilder::default()\n        .build(\"http://127.0.0.1:9000\") // local network address\n        .await?;\n    println!(\"Sui local network version: {}\", sui.api_version());\n\n    // local Sui network, like the above one but using the dedicated function\n    let sui_local = SuiClientBuilder::default().build_localnet().await?;\n    println!(\"Sui local network version: {}\", sui_local.api_version());\n\n    // Sui devnet -- https://fullnode.devnet.sui.io:443\n    let sui_devnet = SuiClientBuilder::default().build_devnet().await?;\n    println!(\"Sui devnet version: {}\", sui_devnet.api_version());\n\n    // Sui testnet -- https://fullnode.testnet.sui.io:443\n    let sui_testnet = SuiClientBuilder::default().build_testnet().await?;\n    println!(\"Sui testnet version: {}\", sui_testnet.api_version());\n\n    Ok(())\n}\n\nRead the total coin balance for each coin type owned by this address​\nuse std::str::FromStr;\nuse sui_sdk::types::base_types::SuiAddress;\nuse sui_sdk::{ SuiClientBuilder};\n#[tokio::main]\nasync fn main() -> Result<(), anyhow::Error> {\n\n   let sui_local = SuiClientBuilder::default().build_localnet().await?;\n   println!(\"Sui local network version: {}\", sui_local.api_version());\n\n   let active_address = SuiAddress::from_str(\"<YOUR SUI ADDRESS>\")?; // change to your Sui address\n   \n   let total_balance = sui_local\n      .coin_read_api()\n      .get_all_balances(active_address)\n      .await?;\n   println!(\"The balances for all coins owned by address: {active_address} are {}\", total_balance);\n   Ok(())\n}\n\nAdvanced examples​\n\nSee the programmable transactions example.\n\nGames examples​\nTic Tac Toe quick start​\n\nPrepare the environment\n\nInstall sui binary following the Sui installation docs.\nConnect to Sui Devnet.\nMake sure you have two addresses with gas by using the new-address command to create new addresses:\nsui client new-address ed25519\n\nYou must specify the key scheme, one of ed25519 or secp256k1 or secp256r1. You can skip this step if you are going to play with a friend. :)\nRequest Sui tokens for all addresses that will be used to join the game.\n\nPublish the move contract\n\nDownload the Sui source code.\nPublish the games package using the Sui client:\nsui client publish --path /path-to-sui-source-code/sui_programmability/examples/games --gas-budget 10000\n\nRecord the package object ID.\n\nCreate a new tic-tac-toe game\n\nRun the following command in the Sui source code directory to start a new game, replacing the game package objects ID with the one you recorded:\ncargo run --example tic-tac-toe -- --game-package-id <<games package object ID>> new-game\n\nThis will create a game for the first two addresses in your keystore by default. If you want to specify the identity of each player, use the following command and replace the variables with the actual player's addresses:\ncargo run --example tic-tac-toe -- --game-package-id <<games package object ID>> new-game --player-x <<player X address>> --player-o <<player O address>>\n\nCopy the game ID and pass it to your friend to join the game.\n\nJoining the game\n\nRun the following command in the Sui source code directory to join the game, replacing the game ID and address accordingly:\n\ncargo run --example tic-tac-toe -- --game-package-id <<games package object ID>> join-game --my-identity <<address>> --game-id <<game ID>>\n\nLicense​\n\nSPDX-License-Identifier: Apache-2.0\n\nEdit this page\nPrevious\nSui and Community SDKs\nNext\nMove References\nGetting started\nDocumentation for sui-sdk crate\nBuilding documentation locally\nRust SDK examples\nPrerequisites\nRunning the existing examples\nBasic Examples\nAdvanced examples\nGames examples\nTic Tac Toe quick start\nLicense\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/cli/validator",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Validator CLI\nSui Validator CLI\n\nThe Sui CLI validator command provides command-level access to validator features of the Sui network.\n\nCommands​\n\nTyping sui validator --help into your terminal or console displays the following information on available commands.\n\nUsage: sui validator [OPTIONS] [COMMAND]\n\nCommands:\n  make-validator-info          \t \n  become-candidate             \t \n  join-committee               \t \n  leave-committee              \t \n  display-metadata             \t \n  update-metadata              \t \n  update-gas-price              \tUpdate gas price that is used to calculate Reference Gas Price\n  report-validator              \tReport or un-report a validator\n  serialize-payload-pop         \tSerialize the payload that is used to generate Proof of Possession. This is useful to take the payload offline for an Authority protocol\n                                    \tkeypair to sign\n  display-gas-price-update-raw-txn  Print out the serialized data of a transaction that sets the gas price quote for a validator\n  help                          \tPrint this message or the help of the given subcommand(s)\n\nOptions:\n  \t--client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one will be created if missing)\n  \t--json                \tReturn command outputs in json format\n  -y, --yes                \t \n  -h, --help                \tPrint help\n\nExamples​\n\nThe following examples demonstrate some of the most often used commands.\n\nUpdate gas price for next epoch​\n$ sui validator  update-gas-price 500\n\n\nToggle output\n\nSet gas price for the next epoch​\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\n$ sui validator request_set_gas_price --args 0x5 \\\"42\\\" --gas-budget GAS-BUDGET-AMOUNT>\n\nDisplay the validator information​\n$ sui validator display-metadata 0x3...de5\n\n\nToggle output\n\nReport a bad / non-performant validator​\n$ sui validator report-validator  0xf...3d9\n\n\nToggle output\n\nHelp​\n\nEach command has its own help section. For example sui validator report-validator --help will display the following prompt:\n\n$ sui validator report-validator --help\nReport or un-report a validator\n\nUsage: sui validator report-validator [OPTIONS] <reportee-address>\n\nArguments:\n  <reportee-address>  The Sui Address of the validator is being reported or un-reported\n\nOptions:\n  \t--operation-cap-id <operation-cap-id>  Optional when sender is reporter validator itself and it holds the Cap object. Required when sender is not the reporter validator itself.\n                                         \tValidator's OperationCap ID can be found by using the `display-metadata` subcommand\n  \t--undo-report <undo-report>        \tIf true, undo an existing report [possible values: true, false]\n  \t--gas-budget <gas-budget>          \tGas budget for this transaction\n  \t--json                             \tReturn command outputs in json format\n  -h, --help                             \tPrint help\n\nEdit this page\nPrevious\nSui Move CLI\nNext\nSui and Community SDKs\nCommands\nExamples\nUpdate gas price for next epoch\nSet gas price for the next epoch\nDisplay the validator information\nReport a bad / non-performant validator\nHelp\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-sdks",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui SDKs\nSui and Community SDKs\n\nSui provides developer kits that act as wrappers for the Sui API. The Sui community broadens the code coverage with its own set of developer kits targeting the Sui blockchain.\n\nSui SDKs​\ndApp Kit\n\nA web frontend SDK that interacts with the Sui API. It is available as an NPM package.\n\nRust SDK\n\nSDK configuration and examples of using the Sui API with Rust, using the sui-sdk crate.\n\nRust SDK Auto-generated Docs\n\nAuto-generated documentation for the sui-sdk crate in the Sui repository.\n\nTypeScript SDK\n\nTypeScript SDK for integrating Sui in your TS dApps.\n\nCommunity SDKs​\nINFO\n\nWhile the community projects are expertly developed, their maintenance and community support vary. You might want to research a project's history and support level before committing to using its utilities.\n\ndApp Kit (Vue)\n\nSui dApp Kit for the Vue framework.\n\nDart SDK\n\nA cross-platform Sui SDK for mobile, web, and desktop.\n\nGo SDK\n\nSDK for developing for Sui using Golang.\n\nKotlin SDK\n\nKsui is a collection of Kotlin Multiplatform JSON-RPC wrapper and crypto utilities for interacting with a Sui Full node.\n\nPython SDK\n\npysui is a Python client for developing on the Sui blockchain.\n\nSwift SDK\n\nSuiKit is a Swift SDK natively designed for developing on the Sui blockchain.\n\nEdit this page\nPrevious\nSui Validator CLI\nNext\nRust SDK\nSui SDKs\nCommunity SDKs\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Move CLI | Sui Documentation",
      "url": "https://docs.sui.io/references/cli/move",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Move CLI\nSui Move CLI\n\nThe Sui CLI move command provides several commands for working with Move source code. A typical usage of sui move is to compile and test the Move code, or to generate a new Move project by using sui move new project_name, which creates the needed directories and the Move.toml file.\n\nCheck Sui CLI installation​\n\nBefore you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:\n\nsui --version\n\n\nIf the terminal or console responds with a version number, you already have the Sui CLI installed.\n\nIf the command is not found, follow the instructions in Install Sui to get the Sui CLI on your system.\n\nCommands​\n\nTyping sui move --help into your terminal or console displays the following information on available commands.\n\nUsage: sui move [OPTIONS] <COMMAND>\n\nCommands:\n  build\n  coverage \tInspect test coverage for this package. A previous test run with the `--coverage` flag must have previously been run\n  disassemble\n  new      \tCreate a new Move package with name `name` at `path`. If `path` is not provided the package will be created in the directory `name`\n  prove    \tRun the Move Prover on the package at `path`. If no path is provided defaults to current directory. Use `.. prove .. -- <options>` to pass on options to the\n               \tprover\n  test     \tRun Move unit tests in this package\n  help     \tPrint this message or the help of the given subcommand(s)\n\nOptions:\n  -p, --path <PACKAGE_PATH>                 \tPath to a package which the command should be run with respect to\n  -d, --dev                                 \tCompile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if this flag is set. This flag is useful for\n                                            \tdevelopment of packages that expose named addresses that are not set to a specific value\n  \t--test                                \tCompile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used along with any code in the 'tests' directory\n  \t--doc                                 \tGenerate documentation for packages\n  \t--abi                                 \tGenerate ABIs for packages\n  \t--install-dir <INSTALL_DIR>           \tInstallation directory for compiled artifacts. Defaults to current directory\n  \t--force                               \tForce recompilation of all packages\n  \t--fetch-deps-only                     \tOnly fetch dependency repos to MOVE_HOME\n  \t--skip-fetch-latest-git-deps          \tSkip fetching latest git dependencies\n  \t--default-move-flavor <DEFAULT_FLAVOR>\tDefault flavor for move compilation, if not specified in the package's config\n  \t--default-move-edition <DEFAULT_EDITION>  Default edition for move compilation, if not specified in the package's config\n  \t--dependencies-are-root               \tIf set, dependency packages are treated as root packages. Notably, this will remove warning suppression in dependency packages\n  -h, --help                                \tPrint help\n  -V, --version                             \tPrint version\n\nExamples​\n\nThe following examples demonstrate some of the most often used commands.\n\nCreate a new Move project​\n\nTo create a new Move project that automatically adds the necessary dependencies in a Move.toml file, run sui move new [<PROJECT-NAME>].\n\n$ sui move new smart_contract_test\n$ ls -l smart_contract_test\nMove.toml\nSources\n\n# display the contents of Move.toml file\n$ cat smart_contract_test/Move.toml\n[package]\nname = \"smart_contract_test\"\nversion = \"0.0.1\"\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n[addresses]\nsmart_contract_test = \"0x0\"\n\nBuild a Move project​\n\nUse sui move build at the root of your Move project to build the package.\n\n$ sui move build\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING smart_contract_test\n\nRun tests in a Move project​\n\nUse sui move test to run the tests in a Move package.\n\n$ sui move test\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING smart_contract_test\nRunning Move unit tests\nTest result: OK. Total tests: 0; passed: 0; failed: 0\n\nGet test coverage for a module​\nCAUTION\n\nThis command currently only works on debug builds of the CLI. Please build the CLI from source to use it.\n\nThis example uses first_package Move package.\n\nTo get the a summary of the test coverage, you must first run the sui move test --coverage command, and then the sui move coverage summary --test to get a summary of the test coverage in the example project.\n\n$ sui move test --coverage\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING first_package\nRunning Move unit tests\n[ PASS    ] 0x0::example::test_module_init\n[ PASS    ] 0x0::example::test_sword_transactions\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\n$ sui move coverage summary --test\n+-------------------------+\n| Move Coverage Summary   |\n+-------------------------+\nModule 0000000000000000000000000000000000000000000000000000000000000000::example\n>>> % Module coverage: 92.81\n+-------------------------+\n| % Move Coverage: 92.81  |\n+-------------------------+\n\nHelp​\n\nEach command has its own help section. For example sui move build –help displays the following prompt:\n\n$ sui move build --help\nUsage: sui move build [OPTIONS]\n\nOptions:\n  -p, --path <PACKAGE_PATH>                 \tPath to a package which the command should be run with respect to\n  \t--with-unpublished-dependencies       \tInclude the contents of packages in dependencies that haven't been published (only relevant when dumping bytecode as base64)\n  -d, --dev                                 \tCompile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if this flag is set. This flag is useful for development\n                                            \tof packages that expose named addresses that are not set to a specific value\n  \t--dump-bytecode-as-base64             \tWhether we are printing in base64\n  \t--generate-struct-layouts             \tIf true, generate struct layout schemas for all struct types passed into `entry` functions declared by modules in this package These layout\n                                            \tschemas can be consumed by clients (e.g., the TypeScript SDK) to enable serialization/deserialization of transaction arguments and events\n  \t--test                                \tCompile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used along with any code in the 'tests' directory\n  \t--doc                                 \tGenerate documentation for packages\n  \t--lint                                \tIf `true`, enable linters\n  \t--abi                                 \tGenerate ABIs for packages\n  \t--install-dir <INSTALL_DIR>           \tInstallation directory for compiled artifacts. Defaults to current directory\n  \t--force                               \tForce recompilation of all packages\n  \t--fetch-deps-only                     \tOnly fetch dependency repos to MOVE_HOME\n  \t--skip-fetch-latest-git-deps          \tSkip fetching latest git dependencies\n  \t--default-move-flavor <DEFAULT_FLAVOR>\tDefault flavor for move compilation, if not specified in the package's config\n  \t--default-move-edition <DEFAULT_EDITION>  Default edition for move compilation, if not specified in the package's config\n  \t--dependencies-are-root               \tIf set, dependency packages are treated as root packages. Notably, this will remove warning suppression in dependency packages\n  -h, --help                                \tPrint help\n\nEdit this page\nPrevious\nSui Keytool CLI\nNext\nSui Validator CLI\nCheck Sui CLI installation\nCommands\nExamples\nCreate a new Move project\nBuild a Move project\nRun tests in a Move project\nGet test coverage for a module\nHelp\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/cli/keytool",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Keytool CLI\nSui Keytool CLI\n\nThe Sui CLI keytool command provides several command-level access for the management and generation of addresses, as well as working with private keys, signatures, or zkLogin. For example, a user could export a private key from the Sui Wallet and import it into the local Sui CLI wallet using the sui keytool import [...] command.\n\nCheck Sui CLI installation​\n\nBefore you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:\n\nsui --version\n\n\nIf the terminal or console responds with a version number, you already have the Sui CLI installed.\n\nIf the command is not found, follow the instructions in Install Sui to get the Sui CLI on your system.\n\nCommands​\nUsage: sui keytool [OPTIONS] <COMMAND>\n\nCommands:\n  convert                           \tConvert private key from legacy formats (e.g. Hex or Base64) to Bech32 encoded 33 byte `flag || private key` begins with `suiprivkey`\n  decode-or-verify-tx                   Given a Base64 encoded transaction bytes, decode its components. If a signature is provided, verify the signature against the transaction \n  \t\t\t\t\t\t\t\t\t\t\tand output the result.\n  decode-multi-sig                  \tGiven a Base64 encoded MultiSig signature, decode its components. If tx_bytes is passed in, verify the multisig\n  generate                          \tGenerate a new keypair with key scheme flag {ed25519 | secp256k1 | secp256r1} with optional derivation path, default to\n                                        \tm/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0 for secp256k1 or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 |\n                                        \tword15 | word18 | word21 | word24} default to word12 if not specified\n  import                            \tAdd a new key to sui.keystore using either the input mnemonic phrase or a private key (from the Wallet), the key scheme flag {ed25519 |\n                                        \tsecp256k1 | secp256r1} and an optional derivation path, default to m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0 for secp256k1\n                                        \tor m/74'/784'/0'/0/0 for secp256r1. Supports mnemonic phrase of word length 12, 15, 18`, 21, 24\n  list                              \tList all keys by its Sui address, Base64 encoded public key, key scheme name in sui.keystore\n  load-keypair                      \tThis reads the content at the provided file path. The accepted format can be [enum SuiKeyPair] (Base64 encoded of 33-byte `flag ||\n                                        \tprivkey`) or `type AuthorityKeyPair` (Base64 encoded `privkey`). This prints out the account keypair as Base64 encoded `flag ||\n                                        \tprivkey`, the network keypair, worker keypair, protocol keypair as Base64 encoded `privkey`\n  multi-sig-address                 \tTo MultiSig Sui Address. Pass in a list of all public keys `flag || pk` in Base64. See `keytool list` for example public keys\n  multi-sig-combine-partial-sig     \tProvides a list of participating signatures (`flag || sig || pk` encoded in Base64), threshold, a list of all public keys and a list of\n                                        \ttheir weights that define the MultiSig address. Returns a valid MultiSig signature and its sender address. The result can be used as\n                                        \tsignature field for `sui client execute-signed-tx`. The sum of weights of all signatures must be >= the threshold\n  multi-sig-combine-partial-sig-legacy\n  show                              \tRead the content at the provided file path. The accepted format can be [enum SuiKeyPair] (Base64 encoded of 33-byte `flag || privkey`)\n                                        \tor `type AuthorityKeyPair` (Base64 encoded `privkey`). It prints its Base64 encoded public key and the key scheme flag\n  sign                              \tCreate signature using the private key for for the given address in sui keystore. Any signature commits to a [struct IntentMessage]\n                                        \tconsisting of the Base64 encoded of the BCS serialized transaction bytes itself and its intent. If intent is absent, default will be\n                                        \tused\n  sign-kms                          \tCreates a signature by leveraging AWS KMS. Pass in a key-id to leverage Amazon KMS to sign a message and the base64 pubkey. Generate\n                                        \tPubKey from pem using MystenLabs/base64pemkey Any signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the\n                                        \tBCS serialized transaction bytes itself and its intent. If intent is absent, default will be used\n  unpack                            \tThis takes [enum SuiKeyPair] of Base64 encoded of 33-byte `flag || privkey`). It outputs the keypair into a file at the current\n                                        \tdirectory where the address is the filename, and prints out its Sui address, Base64 encoded public key, the key scheme, and the key\n                                        \tscheme flag\n  zk-login-sign-and-execute-tx      \tGiven the max_epoch, generate an OAuth url, ask user to paste the redirect with id_token, call salt server, then call the prover\n                                        \tserver, create a test transaction, use the ephemeral key to sign and execute it by assembling to a serialized zkLogin signature\n  zk-login-enter-token              \tA workaround to the above command because sometimes token pasting does not work. All the inputs required here are printed from the\n                                        \tcommand above\n  zk-login-sig-verify               \tGiven a zkLogin signature, parse it if valid. If tx_bytes provided, it verifies the zkLogin signature based on provider and its latest\n                                        \tJWK fetched. Example request: sui keytool zk-login-sig-verify --sig $SERIALIZED_ZKLOGIN_SIG --tx-bytes $TX_BYTES --provider Google\n                                        \t--curr-epoch 10\n  help                              \tPrint this message or the help of the given subcommand(s)\n\nOptions:\n  \t--keystore-path <KEYSTORE_PATH>\n  \t--json                       \tReturn command outputs in json format\n  -h, --help                       \tPrint help\n\nJSON output​\n\nAppend the --json flag to commands to format responses in JSON instead of the more human friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the --json flag is useful.\n\nExamples​\n\nThe following examples demonstrate some of the most often used commands.\n\nList the key pairs in the local wallet​\n\nUse the sui keytool list command to output all the Sui addresses that exist in the ~/.sui/sui_config/sui.keystore file in a readable format.\n\n$ sui keytool list\n╭────────────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭─────────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ suiAddress  \t│  0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235  │ │\n│ │ publicBase64Key │  AHsXwcxaWNaNtCIIszwu7V2G6HO8aNM1598w/8y0zI5q                    \t   │ │\n│ │ keyScheme   \t│  ed25519                                                         \t   │ │\n│ │ flag        \t│  0                                                               \t   │ │\n│ │ peerId      \t│  7b17c1cc5a58d68db42208b33c2eed5d86e873bc68d335e7df30ffccb4cc8e6a    │ │\n│ ╰─────────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭─────────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ suiAddress  \t│  0x514692f08249c3e9957799ce29074695840422564bff85e424b56de462913e0d  │ │\n│ │ publicBase64Key │  AKJCGi8R8TslhYdO2OHIjI6rbr+to1eR+vlOjigLY6SX                    \t   │ │\n│ │ keyScheme   \t│  ed25519                                                         \t   │ │\n│ │ flag        \t│  0                                                               \t   │ │\n│ │ peerId      \t│  a2421a2f11f13b2585874ed8e1c88c8eab6ebfada35791faf94e8e280b63a497\t   │ │\n│ ╰─────────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰────────────────────────────────────────────────────────────────────────────────────────────╯\n\nGenerate a new key pair and store it in a file​\n\nTo generate a new key pair with the ed25519 scheme, use the sui keytool generate ed25519 command. For other schemes, see sui keytool generate –help. The key pair file is saved to the current directory with its filename being the address. The content of the file is a Base64 encoded string of 33-byte flag || privkey.\n\n$ sui keytool generate ed25519\n╭─────────────────┬───────────────────────────────────────────────────────────────────────────────────╮\n│ suiAddress  \t  │  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25           \t  │\n│ publicBase64Key │  AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                                 \t  │\n│ keyScheme   \t  │  ed25519                                                                      \t  │\n│ flag        \t  │  0                                                                            \t  │\n│ mnemonic    \t  │  cushion price ability recall payment embody kid media rude mosquito chalk broom  │\n│ peerId      \t  │  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba             \t  │\n╰─────────────────┴───────────────────────────────────────────────────────────────────────────────────╯\n\nShow the key pair data from a file​\n\nUse sui keytool show [filename] to show the key pair data that is stored in a file. For example, the previous command generated a file named 0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key.\n\n$ sui keytool show 0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key\n╭─────────────────┬──────────────────────────────────────────────────────────────────────╮\n│ suiAddress  \t  │  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25  │\n│ publicBase64Key │  AC+AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                   │\n│ keyScheme   \t  │  ed25519                                                         \t │\n│ flag        \t  │  0                                                               \t │\n│ peerId      \t  │  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba\t │\n╰─────────────────┴──────────────────────────────────────────────────────────────────────╯\n\nSign a transaction​\n$ sui keytool sign --data AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA== --address 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235\n\n╭──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ suiAddress   │ 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235                                                                                           \t  │\n│ rawTxData\t   │ AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR │\n│          \t   │ 2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                                 \t  │\n│ intent   \t   │ ╭─────────┬─────╮                                                                                                                                            \t  │\n│          \t   │ │ scope   │  0  │                                                                                                                                            \t  │\n│          \t   │ │ version │  0  │                                                                                                                                            \t  │\n│          \t   │ │ app_id  │  0  │                                                                                                                                            \t  │\n│          \t   │ ╰─────────┴─────╯                                                                                                                                            \t  │\n│ rawIntentMsg │ AAAAAAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAA │\n│          \t   │ ILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                             \t  │\n│ digest   \t   │ +B8Cbr16HfOVT50DoN/QF8HB0+oznm8KAYy8Rm+TQFo=                                                                                                                 \t  │\n│ suiSignature │ ANucBEl9TIE0uv+w965DvOjlfDUll7NUtIpJgRhPc3D3y3EtZ4cvaNbm8i5pc7TNIov/qI0FhzIYf2J6PbqoNQ57F8HMWljWjbQiCLM8Lu1dhuhzvGjTNeffMP/MtMyOag==                         \t  │\n╰──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nHelp​\n\nEach command has its own help section. For example sui keytool sign –help displays the following prompt:\n\n$ sui keytool sign --help\nCreate signature using the private key for for the given address in sui keystore. Any signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the BCS serialized\ntransaction bytes itself and its intent. If intent is absent, default will be used\n\nUsage: sui keytool sign [OPTIONS] --address <ADDRESS> --data <DATA>\n\nOptions:\n  \t--address <ADDRESS>  \n  \t--data <DATA>   \t \n  \t--json           \tReturn command outputs in json format\n  \t--intent <INTENT>    \n  -h, --help           \tPrint help\n\nEdit this page\nPrevious\nSui Console CLI\nNext\nSui Move CLI\nCheck Sui CLI installation\nCommands\nJSON output\nExamples\nList the key pairs in the local wallet\nGenerate a new key pair and store it in a file\nShow the key pair data from a file\nSign a transaction\nHelp\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Client CLI | Sui Documentation",
      "url": "https://docs.sui.io/references/cli/client",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Client CLI\nSui Client CLI\n\nThe Sui CLI client command provides command-level access to interact with the Sui network. Typical uses for sui client include publishing Move smart contracts, getting the information of an object, executing transactions, or managing addresses.\n\nCheck Sui CLI installation​\n\nBefore you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:\n\nsui --version\n\n\nIf the terminal or console responds with a version number, you already have the Sui CLI installed.\n\nIf the command is not found, follow the instructions in Install Sui to get the Sui CLI on your system.\n\nCommands​\n\nThe following list itemizes all the available subcommands for the sui client command.\n\nUsage: sui client [OPTIONS] [COMMAND]\n\nCommands:\n  active-address              Default address used for commands when none specified\n  active-env                  Default environment used for commands when none specified\n  addresses                   Obtain the Addresses managed by the client\n  balance                     List the coin balance of an address\n  call                        Call Move function\n  chain-identifier            Query the chain identifier from the rpc endpoint\n  dynamic-field               Query a dynamic field by its address\n  envs                        List all Sui environments\n  execute-signed-tx           Execute a Signed Transaction. This is useful when the user prefers to sign elsewhere and use this command to execute\n  execute-combined-signed-tx  Execute a combined serialized SenderSignedData string\n  faucet                      Request gas coin from faucet. By default, it will use the active address and the active network\n  gas                         Obtain all gas objects owned by the address. An address' alias can be used instead of the address\n  merge-coin                  Merge two coin objects into one coin\n  new-address                 Generate new address and keypair with keypair scheme flag {ed25519 | secp256k1 | secp256r1} with optional derivation path, default to m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0\n                                  for secp256k1 or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 | word15 | word18 | word21 | word24} default to word12 if not specified\n  new-env                     Add new Sui environment\n  object                      Get object info\n  objects                     Obtain all objects owned by the address. It also accepts an address by its alias\n  pay                         Pay coins to recipients following specified amounts, with input coins. Length of recipients must be the same as that of amounts\n  pay-all-sui                 Pay all residual SUI coins to the recipient with input coins, after deducting the gas cost. The input coins also include the coin for gas payment, so no extra gas coin is required\n  pay-sui                     Pay SUI coins to recipients following following specified amounts, with input coins. Length of recipients must be the same as that of amounts. The input coins also include the coin for\n                                  gas payment, so no extra gas coin is required\n  publish                     Publish Move modules\n  split-coin                  Split a coin object into multiple coins\n  switch                      Switch active address and network(e.g., devnet, local rpc server)\n  tx-block                    Get the effects of executing the given transaction block\n  transfer                    Transfer object\n  transfer-sui                Transfer SUI, and pay gas with the same SUI coin object. If amount is specified, only the amount is transferred; otherwise the entire object is transferred\n  upgrade                     Upgrade Move modules\n  verify-bytecode-meter       Run the bytecode verifier on the package\n  verify-source               Verify local Move packages against on-chain packages, and optionally their dependencies\n  profile-transaction         Profile the gas usage of a transaction. Unless an output filepath is not specified, outputs a file `gas_profile_{tx_digest}_{unix_timestamp}.json` which can be opened in a flamegraph\n                                  tool such as speedscope\n  replay-transaction          Replay a given transaction to view transaction effects. Set environment variable MOVE_VM_STEP=1 to debug\n  replay-batch                Replay transactions listed in a file\n  replay-checkpoint           Replay all transactions in a range of checkpoints\n  help                        Print this message or the help of the given subcommand(s)\n\nOptions:\n      --client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one will be created if missing)\n      --json                    Return command outputs in json format\n  -y, --yes\n  -h, --help                    Print help\n\nJSON output​\n\nAppend the --json flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the --json flag is useful.\n\nExamples​\n\nThe following examples demonstrate some of the most often used commands.\n\nList available network environments​\n\nUse the sui client envs command to find the network environments set up in the CLI. The information for these environments is also stored in the client.yaml file in the Sui configuration directory (~/.sui/sui_config).\n\n╭────────┬────────────────────────────────────┬────────╮\n│ alias  │ url                                │ active │\n├────────┼────────────────────────────────────┼────────┤\n│ devnet │ https://fullnode.devnet.sui.io:443 │ *  \t   │\n╰────────┴────────────────────────────────────┴────────╯\n\nCreate network environment​\n\nUse client new-env to add details for a new network environment. This example creates an environment pointer to Sui Mainnet. Setting the alias value makes referencing the environment less prone to typographical errors. After running this command, Sui updates your client.yaml file in ~/.sui/sui_config with the new information.\n\n$ sui client new-env --alias=mainnet --rpc https://fullnode.mainnet.sui.io:443\n\nAdded new Sui env [mainnet] to config.\n\nSet current environment​\n\nUse the sui client switch command to change the current network. This example switches the current network to mainnet.\n\n$ sui client switch --env mainnet\n\nActive environment switched to [mainnet]\n\n\nIf you run sui client envs after this command, you see the asterisk in the active column on the mainnet row of the table.\n\nGet current active address​\n\nUse the sui client active-address command to reveal the current address. The CLI uses the current active address to execute address-specific CLI commands (like sui client objects) when you don't provide them with a Sui address value.\n\n$ sui client active-address\n0x514692f08249c3e9951234ce29074695840422564bff85e424b56de462913e0d\n\nGet objects owned by an address​\n\nUse sui client objects to list summary information about the objects the current active address owns. You can provide a Sui address value to the command to list objects for a particular address. This example lists objects for the current active address.\n\n$ sui client objects 0x36df11369cf00ecf0be68d6ba965b0abe2e883bc5245911e3a29ebfa0aaf6b69\n\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n| ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  │ │\n│ │ version\t   │  33363559                                                        \t  │ │\n│ │ digest \t   │  IY7/qsIJhliQL0uxwSzNYu0SMcn5AMsqQklSGngn1V0=                    \t  │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                        \t  │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0xfffe59fb6f78b1ced7f6537e69a205cc45d105270857bfd66332f9a627a38ae0  │ │\n│ │ version\t   │  33370864                                                            │ │\n│ │ digest     │  b+tKChvujbCk/UCm8L+lflyb6Vjt7beB+uz6+ahUHmM=                    \t  │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                        \t  │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n\nGet complete object information​\n\nUse sui client object <OBJECT-ID> to list object information for the ID you provide. This example displays the information for a Coin object.\n\n$ sui client object 0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f\n╭───────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ objectId  \t  │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f                                             \t  │\n│ version   \t  │  33363559                                                                                                       \t  │\n│ digest    \t  │  3FzvXJVVVcXb9H6dEXdARaY9EmxXyyNFduet3X4eYV4x                                                                   \t  │\n│ objType   \t  │  0x2::coin::Coin<0x2::sui::SUI>                                                                                 \t  │\n│ ownerType \t  │  AddressOwner                                                                                                   \t  │\n│ prevTx    \t  │  ES2RQThjRE5u8rwiUEnhcnMoLA3cHeEGYJ8Pq98tmyAc                                                                   \t  │\n│ storageRebate │  988000                                                                                                         \t  │\n│ content   \t  │ ╭───────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│           \t  │ │ dataType      \t  │  moveObject                                                                            \t    │ │\n│           \t  │ │ type          \t  │  0x2::coin::Coin<0x2::sui::SUI>                                                       \t    │ │\n│           \t  │ │ hasPublicTransfer │  true                                                                                    \t  │ │\n│           \t  │ │ fields        \t  │ ╭─────────┬───────────────────────────────────────────────────────────────────────────────╮ │ │\n│           \t  │ │               \t  │ │ balance │  530076676                                                                \t  │ │ │\n│           \t  │ │               \t  │ │ id  \t  │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │\n│           \t  │ │               \t  │ │     \t  │ │ id │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  │ │ │ │\n│           \t  │ │               \t  │ │     \t  │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │\n│           \t  │ │               \t  │ ╰─────────┴───────────────────────────────────────────────────────────────────────────────╯ │ │\n│           \t  │ ╰───────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────╯ │\n╰───────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nGet dynamic fields of an object​\n\nUse the sui client dynamic-field <DYNAMIC-FIELD-ID> command to list the details of the dynamic field with the ID you provide.\n\n$ sui client dynamic-field 0x5\n╭─────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮\n│ hasNextPage │  false                                                                                \t  │\n│ nextCursor  │  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1                   \t  │\n│ data     \t  │ ╭───────────────────────────────────────────────────────────────────────────────────────╮ │\n│         \t  │ │ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │ │\n│         \t  │ │ │ name   \t   │ ╭───────┬───────╮                                                \t  │ │ │\n│         \t  │ │ │        \t   │ │ type  │  u64  │                                                \t  │ │ │\n│         \t  │ │ │        \t   │ │ value │  2\t │                                                \t    │ │ │\n│         \t  │ │ │        \t   │ ╰───────┴───────╯                                                \t  │ │ │\n│         \t  │ │ │ bcsName\t   │  LQM2cdzDY3                                                      \t  │ │ │\n│         \t  │ │ │ type   \t   │  DynamicField                                                    \t  │ │ │\n│         \t  │ │ │ objectType │  0x3::sui_system_state_inner::SuiSystemStateInnerV2              \t  │ │ │\n│         \t  │ │ │ objectId   │  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1  │ │ │\n│         \t  │ │ │ version\t   │  112                                                             \t  │ │ │\n│         \t  │ │ │ digest \t   │  HMrm1KNKjq3GfB1cWTRdvRo8gk7auhgvoZXaVoyEHqUR                    \t  │ │ │\n│         \t  │ │ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │ │\n│         \t  │ ╰───────────────────────────────────────────────────────────────────────────────────────╯ │\n╰─────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯\n\nSend SUI or objects​\n\nIn this example, let's see how to transfer SUI or transfer an object from one address to another. First of all, there two main commands for sending SUI or transferring objects: pay and transfer. Both pay and transfer have a few sister commands: pay-sui, pay-all-sui, transfer-sui.\n\nThe differences between these commands are:\n\ncommands that end in -sui deal with Sui's native coin, and they use the input coints to pay for gas and for transferring SUI or the object.\npay- commands typically deal with coins and handle gas smashing for you, whereas transfer commands can handle the transfer of any object that has public transfer, meaning any object that has the store ability.\npay commands allow you to send coins to multiple recipients, whereas transfer commands only accept one recipient.\npay-all-sui is a special case of pay-sui that offers a way to transfer the entire balance after smashing.\ntransfer-sui is a legacy command and has been entirely superseded by pay-sui or pay-all-sui depending on whether an amount is specified or not.\n\nAssume you have two addresses:\n\n╭───────────────────┬────────────────────────────────────────────────────────────────────┬────────────────╮\n│ alias             │ address                                                            │ active address │\n├───────────────────┼────────────────────────────────────────────────────────────────────┼────────────────┤\n│ hungry-spodumene  │ 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea │ *              │\n│ eloquent-amber    │ 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 │                │\n╰───────────────────┴────────────────────────────────────────────────────────────────────┴────────────────╯\n\n\nAddress hungry-spodumene has a few coins:\n\nsui client gas hungry-spodumene\n╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮\n│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │\n├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤\n│ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 │ 200000000000       │ 200.00           │\n│ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a │ 200000000000       │ 200.00           │\n│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 200000000000       │ 200.00           │\n│ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 │ 200000000000       │ 200.00           │\n│ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 │ 200000000000       │ 200.00           │\n╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯\n\n\nYou want to send 0.5 SUI to eloquent-amber. Given that you have a few gas coins, you can use pay. If only one gas coin exists, then you need to use transfer-sui or pay-sui, or you would need to split the coin first to have another coin to use for paying gas. In this case, let's use the pay-sui command as you do not need to provide a separate gas coin to be used for the gas fees. In the command below, you set the recipient to be eloquent-amber, which coin to use to transfer SUI from, and the amount of SUI to transfer.\n\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client pay-sui --recipients eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --amounts 500000000 --gas-budget 5000000\n\n\nThe result is:\n\nTransaction Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   │\n│ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                │\n│ Gas Budget: 5000000 MIST                                                                                     │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                                    │\n│  │ Version: 2                                                                                                │\n│  │ Digest: 9MEH7kr1YkBDx7pdUPCDnVb3FtPz9UZVeWmCot5Dhxqr                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976\" │ │\n│ │ 1   Pure Arg: Type: u64, Value: \"500000000\"                                                              │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭──────────────────────╮                                                                                     │\n│ │ Commands             │                                                                                     │\n│ ├──────────────────────┤                                                                                     │\n│ │ 0  SplitCoins:       │                                                                                     │\n│ │  ┌                   │                                                                                     │\n│ │  │ Coin: GasCoin     │                                                                                     │\n│ │  │ Amounts:          │                                                                                     │\n│ │  │   Input  1        │                                                                                     │\n│ │  └                   │                                                                                     │\n│ │                      │                                                                                     │\n│ │ 1  TransferObjects:  │                                                                                     │\n│ │  ┌                   │                                                                                     │\n│ │  │ Arguments:        │                                                                                     │\n│ │  │   Result 0        │                                                                                     │\n│ │  │ Address: Input  0 │                                                                                     │\n│ │  └                   │                                                                                     │\n│ ╰──────────────────────╯                                                                                     │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    eZc/iFO3i4Y8Le92zu9q75jILs+yg0sSXd1yPV9Dta+knH99VfkSCnzNQG1KbXSvY24wexmVtiuU6NkfudbiAQ==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 0                                                                                 │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                         │\n│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 1976000 MIST                                                                     │\n│    Computation Cost: 1000000 MIST                                                                 │\n│    Storage Rebate: 978120 MIST                                                                    │\n│    Non-refundable Storage Fee: 9880 MIST                                                          │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    GThyjtRFysBgVppXDc9iduNPzB2bLteXBnJcBEYXz4vG                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n\n╭──────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                   │\n├──────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                  │\n│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    │\n│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 ) │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │\n│  │ Version: 3                                                                                    │\n│  │ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                          │\n│  └──                                                                                             │\n│ Mutated Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                  │\n│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea ) │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │\n│  │ Version: 3                                                                                    │\n│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                          │\n│  └──                                                                                             │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Balance Changes                                                                                   │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: -501997880                                                                             │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: 500000000                                                                              │\n│  └──                                                                                              │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\nCheck the gas for the sender and the recipient's coins using sui client gas <address>. The sender now has 199.49 SUI for that gas coin that was used. 0.5 SUI was transferred, and the remaining 0.01 SUI paid the gas fees.\n\nsui client gas\n╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮\n│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │\n├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤\n│ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 │ 200000000000       │ 200.00           │\n│ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a │ 200000000000       │ 200.00           │\n│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 199498002120       │ 199.49           │\n│ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 │ 200000000000       │ 200.00           │\n│ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 │ 200000000000       │ 200.00           │\n╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯\n\nsui client gas eloquent-amber\n╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮\n│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │\n├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤\n│ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 │ 500000000          │ 0.50             │\n╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯\n\n\nIf you want to transfer the whole object, you can use sui client pay-all-sui or sui client transfer-sui (without passing the amount):\n\nsui client pay-sui --recipient eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000\nor\nsui client transfer-sui --to eloquent-amber --sui-coin-object-id 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000\n\n\nThen check the gas for eloquent-amber again:\n\nsui client gas eloquent-amber\n╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮\n│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │\n├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤\n│ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 │ 500000000          │ 0.50             │\n│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 199496992240       │ 199.49           │\n╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯\n\nReplay a transaction​\n\nUse the sui client replay-transaction --tx-digest <TRANSACTION-DIGEST> to re-execute a transaction locally and show the transaction effects. This command will fetch the transaction dependencies from the fullnode specified in the client env. For transactions that happened quite far in the past, it is advised to set the client fullnode to one that has non-pruned chain data for that transaction. This will also verify that the resulting effects from the locally executed transaction match the effects of the transaction stored on-chain.\n\nYou can add additional flags --gas-info and --ptb-info to this command to see more information about the transaction.\n\n$ sui client replay-transaction --tx-digest 51MzJP2Uesvza8vXGpPCGbfLrY6UCfdvdoErN1z4oXPW\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: 51MzJP2Uesvza8vXGpPCGbfLrY6UCfdvdoErN1z4oXPW                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 237                                                                               │\n│                                                                                                   │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000006                         │\n│  │ Owner: Shared                                                                                  │\n│  │ Version: 20303014                                                                              │\n│  │ Digest: 3FyU88FpFFa2mhDFJWcabwQNdfaVaWvvnbjkfErD6AgJ                                           │\n│  └──                                                                                              │\n│                                                                                                   │\n│ Shared Objects:                                                                                   │\n│  ┌──                                                                                              │\n│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000006                         │\n│  │ Version: 20303013                                                                              │\n│  │ Digest: 7uGV3aHa9NDAWLX1UUyV1DG7wAuhfFkzSGo514wtco1C                                           │\n│  └──                                                                                              │\n│                                                                                                   │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000000                         │\n│  │ Owner: Account Address ( 0x0000000000000000000000000000000000000000000000000000000000000000 )  │\n│  │ Version: 0                                                                                     │\n│  │ Digest: 11111111111111111111111111111111                                                       │\n│  └──                                                                                              │\n│                                                                                                   │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 0                                                                                │\n│    Computation Cost: 0                                                                            │\n│    Storage Rebate: 0                                                                              │\n│    Non-refundable Storage Fee: 0                                                                  │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    EvDLzYeKbrxDNHJomgrr2zwAJ7FJDtb2uNwfbonF2uGK                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\nExecution finished successfully. Local and on-chain effects match.\n\n\nUse sui client replay-batch --path <FILEPATH> to replay several transactions listed in a newline-separated file. This will verify that all transactions local execution results match the effects on-chain.\n\nProfile a transaction​\n\nUse the sui client profile-transaction --tx-digest <TRANSACTION-DIGEST> command to re-execute a transaction locally and produce a gas profile. Similar to the replay command, this command fetches the transaction dependencies from the Full node specified in the client environment that are needed to execute the transaction. During the local execution of the transaction, this command records all the Move function invocations and the gas cost breakdown for each invocation.\n\nTo enable the profiler, you must either install or build the Sui Client binary locally with the --features gas-profiler flag.\n\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch <BRANCH-NAME> --features gas-profiler sui\n\n\nThe command outputs a profile to the current working directory in the format gas_profile_{tx_digest}_{unix_timestamp}.json. You can include the optional flag --profile-output </PATH/OUTPUT.json> to write the profile to /PATH/OUTPUT_{tx_digest}_{unix_timestamp}.json instead. Use speedscope to inspect the profile.\n\nTo install speedscope run\n\nnpm install -g speedscope\n\n\nTo open a profile in speedscope run\n\nspeedscope <PATH/PROFILE-OUTPUT-FILE>\n\n\nWhen looking at the profile in speedscope, there are three different views available from the top left menu: Timer Order, Left Heavy, and Sandwich. In each view, each bar's vertical width corresponds to the percentage of gas consumption incurred by the function, and you can hover your mouse over a bar or click a bar to see the computation units accrued by the function invocation. The transaction's total computation units, along with the storage computation units, are multiplied by the gas price to determine the gas cost of the transaction based on a tier system.\n\nTime Order shows the callstack of function invocations from left to right in the order of invocation, while Left Heavy combines repeated sequences of nested invocations into a single combined call stack. Left Heavy displays these sequences from left to right by total incurred gas consumption per combined call stack. This is useful when there have been hundreds of repeated calls to the same function to quickly observe the total gas consumption over all calls to that function. In both these views, you can click the top section and drag to zoom in and out over different sections of the profile.\n\nSandwich view shows a list of discrete values that correspond to gas consumption per function, with Total showing gas cost incurred in all the functions called by the function, and Self showing the gas cost done by only the given function.\n\nObserving a transaction's gas consumption provides useful insight of expected gas cost usage of a smart contract. When developing a smart contract, you can run a local network and publish the package to the local network. Then create a transaction that calls your published smart contract, and finally run the profiler on the transaction to see a breakdown of the gas cost.\n\nPublish a Move package​\n\nOne of the main uses of the sui client command is to publish smart contracts on the Sui network. This example switches the current environment to the Devnet network, then builds, tests, and publishes one of the existing Move examples available in the Sui repository: sui/examples/move\n\nThis example also makes use of sui move commands. To learn more about those commands, see Sui Move CLI.\n\nOpen a terminal or console to the root of your local Sui repository and navigate to the move_tutorial example.\ncd examples/move\ncd first_package\n\nSwitch to the Devnet network. This command uses an alias, so the devnet value might be different for you, depending on the alias name set in your configuration (use sui client envs for a list of your defined networks and their aliases).\nsui client switch --env devnet\n\nUse sui move build to build the package. You must run this command at the same level as the package manifest file (Move.toml). The console responds with the status of the build.\nsui move build\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING first_package\n\nUse sui move test to run the unit tests. The console responds with updates of its progress.\nsui move test\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING first_package\nRunning Move unit tests\n[ PASS    ] 0x0::example::test_module_init\n[ PASS    ] 0x0::example::test_sword_transactions\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\nUse the sui client verify-bytecode-meter to check if the module passes the bytecode meter. The console responds with the maximum allowed values, as well as the amount the package uses.\n$ sui client verify-bytecode-meter\nRunning bytecode verifier for 1 modules\n╭──────────────────────────────────╮\n│ Module will pass metering check! │\n├────────┬────────────┬────────────┤\n│        │ Module     │ Function   │\n│ Max    │ 16000000   │ 16000000   │\n│ Used   │ 4565       │ 4565       │\n╰────────┴────────────┴────────────╯\n\nUse sui client gas to verify that the active address has a gas coin for paying gas. In the case of this example, the console responds with the information that the address is coinless.\n$ sui client gas\nNo gas coins are owned by this address\n\nIf you need coins, use sui client faucet (not available for Mainnet). For more information on getting gas tokens, see Get Sui Tokens.\n$ sui client faucet\n\nUse sui client gas to verify the current active address received the coins.\n$ sui client gas\n╭────────────────────────────────────────────────────────────────────┬─────────────╮\n│ gasCoinId                                                      \t   │ gasBalance  │\n├────────────────────────────────────────────────────────────────────┼─────────────┤\n│ 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8 │ 10000000000 │\n╰────────────────────────────────────────────────────────────────────┴─────────────╯\n\nUse sui client publish to publish the package, being sure to set an appropriate value for the gas-budget flag. The console responds with the details of the publish. You can use sui client object <OBJECT-ID> to check the details of any of the objects from the process.\n$ sui client publish --gas-budget 100000000 .\n Transaction Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   │\n│ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                │\n│ Gas Budget: 5000000000 MIST                                                                                  │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                                    │\n│  │ Version: 2                                                                                                │\n│  │ Digest: GZQwvpxLeTciVboEWeC8EZ2KYYU9o6XoBtW6LrA5Si1h                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea\" │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │\n│ │ Commands                                                                │                                  │\n│ ├─────────────────────────────────────────────────────────────────────────┤                                  │\n│ │ 0  Publish:                                                             │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Dependencies:                                                        │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │\n│ │  └                                                                      │                                  │\n│ │                                                                         │                                  │\n│ │ 1  TransferObjects:                                                     │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Arguments:                                                           │                                  │\n│ │  │   Result 0                                                           │                                  │\n│ │  │ Address: Input  0                                                    │                                  │\n│ │  └                                                                      │                                  │\n│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    x437h/JxDAba2zkx4a2kEfz6iaXQ08T7+inyP5YkbmlSB5K7IYasM6onckjYDB19FNM1ZNqXm1z13VyTmDHXCw==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 0                                                                                 │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                           │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ ID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                           │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ ID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                         │\n│  │ Owner: Immutable                                                                               │\n│  │ Version: 1                                                                                     │\n│  │ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ Version: 3                                                                                     │\n│  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 9978800                                                                          │\n│    Computation Cost: 1000000                                                                      │\n│    Storage Rebate: 978120                                                                         │\n│    Non-refundable Storage Fee: 9880                                                               │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    891Qjq6qDZ6SzAJiAg3CEaHobXrpDL5bAy2o45ZJPTuB                                                   │\n│    ESHcS3y3VCuaCVmWkKDx3EXX3icfPtj4bHhk86gaGWdo                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n╭────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                     │\n├────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                   │\n│  ┌──                                                                                               │\n│  │ ObjectID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                    │\n│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │\n│  │ ObjectType: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da::example::Forge  │\n│  │ Version: 3                                                                                      │\n│  │ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                            │\n│  └──                                                                                               │\n│  ┌──                                                                                               │\n│  │ ObjectID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                    │\n│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │\n│  │ ObjectType: 0x2::package::UpgradeCap                                                            │\n│  │ Version: 3                                                                                      │\n│  │ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                            │\n│  └──                                                                                               │\n│ Mutated Objects:                                                                                   │\n│  ┌──                                                                                               │\n│  │ ObjectID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                    │\n│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                      │\n│  │ Version: 3                                                                                      │\n│  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                            │\n│  └──                                                                                               │\n│ Published Objects:                                                                                 │\n│  ┌──                                                                                               │\n│  │ PackageID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                   │\n│  │ Version: 1                                                                                      │\n│  │ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                            │\n│  │ Modules: example                                                                                │\n│  └──                                                                                               │\n╰────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Balance Changes                                                                                   │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: -10000680                                                                              │\n│  └──                                                                                              │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nHelp​\n\nEach command has its own help section. For example, sui client call --help displays the following prompt:\n\nCall Move function\n\nUsage: sui client call [OPTIONS] --package <PACKAGE> --module <MODULE> --function <FUNCTION> --gas-budget <GAS_BUDGET>\n\nOptions:\n  \t--package <PACKAGE>           \tObject ID of the package, which contains the module\n  \t--module <MODULE>             \tThe name of the module in the package\n  \t--function <FUNCTION>         \tFunction name in module\n  \t--type-args <TYPE_ARGS>...    \tType arguments to the generic function being called. All must be specified, or the call will fail\n  \t--args <ARGS>...              \tSimplified ordered args like in the function syntax ObjectIDs, Addresses must be hex strings\n  \t--gas <GAS>                   \tID of the gas object for gas payment, in 20 bytes Hex string If not provided, a gas object with at least gas_budget value will be selected\n  \t--gas-budget <GAS_BUDGET>     \tGas budget for this call\n  \t--serialize-unsigned-transaction  Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction data (TransactionData) using base64 encoding, and print out\n                                    \tthe string <TX_BYTES>. The string can be used to execute transaction with `sui client execute-signed-tx --tx-bytes <TX_BYTES>`.\n  \t--serialize-signed-transaction\tInstead of executing the transaction, serialize the bcs bytes of the signed transaction data (SenderSignedData) using base64 encoding, and print out the\n                                    \tstring <SIGNED_TX_BYTES>. The string can be used to execute transaction with `sui client execute-combined-signed-tx --signed-tx-bytes <SIGNED_TX_BYTES>`.\n  \t--json                        \tReturn command outputs in json format\n  -h, --help                        \tPrint help\n\nEdit this page\nPrevious\nSui CLI\nNext\nSui Client PTB CLI\nCheck Sui CLI installation\nCommands\nJSON output\nExamples\nList available network environments\nCreate network environment\nSet current environment\nGet current active address\nGet objects owned by an address\nGet complete object information\nGet dynamic fields of an object\nSend SUI or objects\nReplay a transaction\nProfile a transaction\nPublish a Move package\nHelp\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Console CLI | Sui Documentation",
      "url": "https://docs.sui.io/references/cli/console",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Console CLI\nSui Console CLI\n\nThe Sui CLI console command provides command-level access to interact with the Sui network by wrapping the Sui Client CLI command in a shell-like functionality. This command spins up a new process and provides the user an environment for running all the available Sui Client CLI commands. In addition, it also offers command history support.\n\nCheck Sui CLI installation​\n\nBefore you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:\n\nsui --version\n\n\nIf the terminal or console responds with a version number, you already have the Sui CLI installed.\n\nIf the command is not found, follow the instructions in Install Sui to get the Sui CLI on your system.\n\nCommands​\n\nFor all available commands, consult the Sui Client CLI docs. To start the Sui Console, type sui console, which displays some information similar to the following:\n\n🚀 ~ % sui console\n   _____       _    ______                       __\n  / ___/__  __(_)  / ____/___  ____  _________  / /__\n  \\__ \\/ / / / /  / /   / __ \\/ __ \\/ ___/ __ \\/ / _ \\\n ___/ / /_/ / /  / /___/ /_/ / / / (__  ) /_/ / /  __/\n/____/\\__,_/_/   \\____/\\____/_/ /_/____/\\____/_/\\___/\n--- Sui Console 1.14.0 ---\n\nManaged addresses : 2\nActive address: 0x3...235\nKeystore Type : File\nKeystore Path : Some(\"/Users/user/.sui/sui_config/sui.keystore\")\nActive environment : testnet\nRPC URL: https://fullnode.testnet.sui.io:443\n[warn] Client/Server api version mismatch, client api version : 1.14.0, server api version : 1.13.0\nConnecting to Sui full node. API version 1.13.0\n\nAvailable RPC methods: [\"sui_devInspectTransactionBlock\", \"sui_dryRunTransactionBlock\", \"sui_executeTransactionBlock\", \n\"sui_getChainIdentifier\", \"sui_getCheckpoint\", \"sui_getCheckpoints\", \"sui_getEvents\", \"sui_getLatestCheckpointSequenceNumber\", \n\"sui_getLoadedChildObjects\", \"sui_getMoveFunctionArgTypes\", \"sui_getNormalizedMoveFunction\", \"sui_getNormalizedMoveModule\", \n\"sui_getNormalizedMoveModulesByPackage\", \"sui_getNormalizedMoveStruct\", \"sui_getObject\", \"sui_getProtocolConfig\", \n\"sui_getTotalTransactionBlocks\", \"sui_getTransactionBlock\", \"sui_multiGetObjects\", \"sui_multiGetTransactionBlocks\", \n\"sui_tryGetPastObject\", \"sui_tryMultiGetPastObjects\", \"suix_getAllBalances\", \"suix_getAllCoins\", \"suix_getBalance\", \n\"suix_getCoinMetadata\", \"suix_getCoins\", \"suix_getCommitteeInfo\", \"suix_getDynamicFieldObject\", \"suix_getDynamicFields\", \n\"suix_getLatestSuiSystemState\", \"suix_getOwnedObjects\", \"suix_getReferenceGasPrice\", \"suix_getStakes\", \"suix_getStakesByIds\", \n\"suix_getTotalSupply\", \"suix_getValidatorsApy\", \"suix_queryEvents\", \"suix_queryTransactionBlocks\", \"suix_resolveNameServiceAddress\", \n\"suix_resolveNameServiceNames\", \"suix_subscribeEvent\", \"suix_subscribeTransaction\", \"unsafe_batchTransaction\", \"unsafe_mergeCoins\", \n\"unsafe_moveCall\", \"unsafe_pay\", \"unsafe_payAllSui\", \"unsafe_paySui\", \"unsafe_publish\", \"unsafe_requestAddStake\", \n\"unsafe_requestWithdrawStake\", \"unsafe_splitCoin\", \"unsafe_splitCoinEqual\", \"unsafe_transferObject\", \"unsafe_transferSui\"]\n\nWelcome to the Sui interactive console.\n\nsui>-$\n\n\nEdit this page\nPrevious\nSui Client PTB CLI\nNext\nSui Keytool CLI\nCheck Sui CLI installation\nCommands\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Client PTB CLI | Sui Documentation",
      "url": "https://docs.sui.io/references/cli/ptb",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLISui Client PTB CLI\nSui Client PTB CLI\n\nThe client ptb command allows you to specify the transactions for execution in a programmable transaction block (PTB) directly from your CLI or through bash scripts.\n\nCommands​\n\nThe following list itemizes all the available args for the sui client ptb command. Use the --help for a long help version that includes some examples on how to use this command.\n\nBuild, preview, and execute programmable transaction blocks. Depending on your shell, you might have to use quotes around arrays or other passed values. Use --help to see examples for how to use the core functionality of this\ncommand.\n\nUsage: sui client ptb [OPTIONS]\n\nOptions:\n      --assign <NAME> <VALUE>\n          Assign a value to a variable name to use later in the PTB.\n           If only a name is supplied, the result of the last transaction is bound to that name.\n           If a name and value are supplied, then the name is bound to that value.\n\n          Examples:\n           --assign MYVAR 100\n           --assign X [100,5000]\n           --split-coins gas [1000, 5000, 75000]\n           --assign new_coins # bound new_coins to the result of previous transaction\n\n      --dry-run\n          Perform a dry run of the PTB instead of executing it.\n\n      --gas-coin <ID>\n          The object ID of the gas coin to use. If not specified, it will try to use the first gas coin that it finds that has at least the requested gas-budget balance.\n\n      --gas-budget <MIST>\n          An optional gas budget for this PTB (in MIST). If gas budget is not provided, the tool will first perform a dry run to estimate the gas cost, and then it will execute the transaction. Please note that this incurs a small\n          cost in performance due to the additional dry run call.\n\n      --make-move-vec <TYPE> <[VALUES]>\n          Given n-values of the same type, it constructs a vector. For non objects or an empty vector, the type tag must be specified.\n\n          Examples:\n           --make-move-vec <u64> []\n           --make-move-vec <u64> [1, 2, 3, 4]\n           --make-move-vec <std::option::Option<u64>> [none,none]\n           --make-move-vec <sui::coin::Coin<sui::sui::SUI>> [gas]\n\n      --merge-coins <INTO_COIN> <[COIN OBJECTS]>\n          Merge N coins into the provided coin.\n\n          Examples:\n           --merge-coins @coin_object_id [@coin_obj_id1, @coin_obj_id2]\n\n      --move-call <PACKAGE::MODULE::FUNCTION> <TYPE> <FUNCTION_ARGS>\n          Make a move call to a function.\n\n          Examples:\n           --move-call std::option::is_none <u64> none\n           --assign a none\n           --move-call std::option::is_none <u64> a\n\n      --split-coins <COIN> <[AMOUNT]>\n          Split the coin into N coins as per the given array of amounts.\n\n          Examples:\n           --split-coins gas [1000, 5000, 75000]\n           --assign new_coins # bounds the result of split-coins command to variable new_coins\n           --split-coins @coin_object_id [100]\n\n      --transfer-objects <[OBJECTS]> <TO>\n          Transfer objects to the specified address.\n\n          Examples:\n           --transfer-objects [obj1, obj2, obj3] @address\n\n           --split-coins gas [1000, 5000, 75000]\n           --assign new_coins # bound new_coins to result of split-coins to use next\n           --transfer-objects [new_coins.0, new_coins.1, new_coins.2] @to_address\n\n      --publish <MOVE_PACKAGE_PATH>\n          Publish the Move package. It takes as input the folder where the package exists.\n\n          Examples:\n           --move-call sui::tx_context::sender\n           --assign sender\n           --publish \".\"\n           --assign upgrade_cap\n           --transfer-objects sender \"[upgrade_cap]\"\n\n      --upgrade <MOVE_PACKAGE_PATH>\n          Upgrade the move package. It takes as input the folder where the package exists.\n\n      --preview\n          Preview the list of PTB transactions instead of executing them.\n\n      --serialize-unsigned-transaction\n          Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction data using base64 encoding.\n\n      --serialize-signed-transaction\n          Instead of executing the transaction, serialize the bcs bytes of the signed transaction data using base64 encoding.\n\n      --summary\n          Show only a short summary (digest, execution status, gas cost). Do not use this flag when you need all the transaction data and the execution effects.\n\n      --warn-shadows\n          Enable shadow warning when the same variable name is declared multiple times. Off by default.\n\n      --json\n          Return command outputs in json format.\n\n  -h, --help\n          Print help (see a summary with '-h')\n\nDesign philosophy and concepts​\n\nThe main philosophy behind the CLI PTB support is to enable a user to build and execute a PTB from the command line. Bash scripts can be used to construct and execute the PTB just as you would do from the command line, providing great flexibility when it comes to automating different tasks.\n\nBesides using existing traditional PTB related concepts, we introduce a few new and important concepts for this command.\n\nWARNING\n\nAll the following examples were tested using a bash shell environment and your experience may vary depending on how your shell interprets the input values (e.g., zsh requires to pass values in brackets by adding quotes around it: \"[]\"; bash accepts them without quotes).\n\nTypes​\n\nSometimes, CLI PTBs require that you specify the type of a value or variable. For instance, in the following example you must provide the <u64> type when calling the 0x1::option::is_none function.\n\nsui client ptb \\\n--assign my_variable none \\\n--move-call 0x1::option::is_none \"<u64>\" my_variable \\\n--gas-budget 50000000\n\n\nTo pass in multiple types, delimit them with a comma:\n\n...\n--move-call package::module::function \"<u64,u8,u256>\" \\\n...\n\nStrings​\n\nCLI PTBs support string literals as inputs, which will be encoded as pure values that can be used as inputs to vector<u8>, std::ascii::String and std::string::String parameters. The following example previews a transaction block that passes the string \"Hello, world\" to a function m::f in a package $PKG (its ID is held in an environment variable).\n\nsui client ptb --move-call \"$PKG::m::f\" '\"Hello, world\"' --gas-budget 10000000 --preview\n\nWARNING\n\nDouble-quoted string literals tend to also be valid syntax for shells (like bash), so when inputting PTBs on the command-line, remember to wrap the entire string in single-quotes so that its double-quotes are interpreted literally, as in the previous example.\n\nAddresses and Object IDs​\n\nYou can pass literal addresses and objects IDs by prefixing them with '@'. This is needed to distinguish a hexadecimal value from an address in some situations.\n\nFor addresses that are in your local wallet, you can use their alias instead (passing them without '@', for example, --transfer-objects my_alias).\n\nHere are some examples for transfer-objects and gas-coin:\n\nsui client ptb --transfer-objects [ARRAY_OF_OBJECTS] @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 --gas-coin @0x00002819ee07a66e53800495ccf5eeade8a02054a2e0827546c70e4b226f0495\n\nAssign​\n\nUse the --assign argument to bind values to variables. There are two ways you can use it:\n\nassign a value to a variable\nassign a variable to the result of the previous command\n\nLet's look at the first case where you assign a value to a variable. You want to check if some variable's value is none. Call the 0x1::option::is_none function from the Move standard library, and pass in the variable name:\n\nsui client ptb \\\n--assign my_variable none \\\n--move-call 0x1::option::is_none \"<u64>\" my_variable \\\n--gas-budget 50000000\n\nTIP\n\nCLI PTB uses name resolution for common packages like sui, std, deepbook, so you can use them directly instead of their addresses: 0x2, 0x1, or 0xdee9.\n\nIn the second case, if a previous command outputs some result, you can bound it to a variable for later access. Let's see an example where you want a new coin with 1000 MIST, which you can achieve by using the split-coins command. After you do that, you want to transfer the new coin to another address. Without the --assign argument, you couldn't instruct the CLI to transfer that new coin object as you would not have a way to refer to it.\n\nsui client ptb \\\n--split-coins gas [1000] \\\n--assign coin \\\n--transfer-objects [coin] @recipient_address \\\n--gas-budget 50000000\n\nTIP\n\nIf you build a complex PTB, use the --preview flag to display the PTB transaction list instead of executing it.\n\nExamples​\n\nThe following examples demonstrate how to use the client ptb command.\n\nTIP\n\nWhen a PTB is executed, the output contains all the relevant information (transaction data, gas cost, effects, object changes, and so on). Use --summary to get a short summary when you do not need all the data. For complex PTBs, you can use --preview to display the PTB transaction list instead of executing it.\n\nMove call​\n\nWhen needing to execute a Move call, use the --move-call transaction to call a specific function from a package. The CLI PTB supports name resolution for common packages like sui, std, deepbook, so you can use both 0x1::option::is_none as well as std::option::is_none for passing the function name.\n\n--assign A none\n--move-call std::option::is_none \"<u64>\" A\n\n\nTo call a specific function from a specific package, you can use the following call:\n\n--move-call PACKAGE_ADDR::MODULE::FUNCTION \"<TYPE>\" FUNC_ARG1 FUNC_ARG2 ...\n\nPublish​\n\nPublishing a package is one of the most important commands you need when working with Sui. While the CLI has a standalone publish command, PTBs also support publishing and upgrading packages. One main difference is that with sui client ptb, you must explicitly transfer the UpgradeCap object that is returned when creating a package, or destroy it with a call to make_immutable. Here is an example on how to publish a Move project on chain using the sui client ptb command. It makes a call to the sui::tx_context::sender to acquire the sender and assigns the result of that call to the sender variable, and then calls the publish command. The result of publish is bounded to upgrade_cap variable, and then this object is transferred to the sender.\n\nsui client ptb \\\n--move-call sui::tx_context::sender \\\n--assign sender \\\n--publish \".\" \\\n--assign upgrade_cap \\\n--transfer-objects [upgrade_cap] sender \\\n--gas-budget 100000000\n\nSplit, destroy, and merge coins​\n\nThe following example showcases how to split a gas coin into multiple coins, make a move call to destroy one or more of the new coins, and finally merge the coins that were not destroyed back into the gas coin. It also showcases how to use framework name resolution (for example, sui::coin instead of 0x2::coin) and how to refer to different values in an array using the . syntax.\n\n# Split off from gas\n--split-coins gas [0,1,2,3]\n--assign coins\n--move-call sui::coin::destroy_zero<sui::sui::SUI> coins.0\n# Can further split a split coin (and through variable bindings/result accesses)\n--split-coins coins.1 [0,0]\n--assign zcoins\n# Destroy both new coins\n--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.0\n--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.1\n# Can merge the split coins back\n--merge-coins gas [coins.1, coins.2, coins.3]\n--gas-budget 10000000\n\nTransfer objects​\n\nThis example creates three new coins from gas and transfers them to a different address.\n\n--assign to_address @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 \\\n--split-coins gas [1,2,3] \\\n--assign s \\\n--transfer-objects [s.0, s.1, s.2] to_address \\\n--gas-budget 10000000\n\nINFO\n\nYou can also pass an alias (without the '@') instead of an address.\n\nReserved words​\n\nYou cannot use the following words for variable names:\n\naddress\nbool\nvector\nsome\nnone\ngas\nu8\nu16\nu32\nu64\nu128\nu256\nJSON output​\n\nAppend the --json flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the --json flag is useful.\n\nEdit this page\nPrevious\nSui Client CLI\nNext\nSui Console CLI\nCommands\nDesign philosophy and concepts\nTypes\nStrings\nAddresses and Object IDs\nAssign\nExamples\nMove call\nPublish\nSplit, destroy, and merge coins\nTransfer objects\nReserved words\nJSON output\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/cli",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui CLI\nSui CLI\n\nSui provides a command line interface (CLI) tool to interact with the Sui network, its features, and the Move programming language. The complete suite of tools is called the Sui CLI, with commands grouped together by feature. Each group of commands is commonly referred to by its top-level command: Sui Client CLI, Sui Console CLI, Sui Keytool CLI, Sui Move CLI, and Sui Validator CLI.\n\nCheck Sui CLI installation​\n\nBefore you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:\n\nsui --version\n\n\nIf the terminal or console responds with a version number, you already have the Sui CLI installed.\n\nIf the command is not found, follow the instructions in Install Sui to get the Sui CLI on your system.\n\nUpdate CLI​\n\nTo get the latest version of the CLI, you can run the following command from a terminal or console. Be sure to replace <BRANCH-NAME> with main, devnet, testnet, or mainnet to get the desired version. For more information on the branches available, see Sui Environment Setup.\n\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch <BRANCH-NAME> --features gas-profiler sui\n\nINFO\n\nThe --features gas-profiler flag is necessary only if you want to run gas profiles for transactions.\n\nSui CLI commands​\n\nThere are a number of top-level commands available, but the five most useful to users are the following. Use the help flag for the commands that are not documented yet. For example, sui validator --help.\n\nSui Client CLI: Use the sui client commands to interact with the Sui network.\nSui Client PTB CLI: Use the sui client ptb command to build and execute PTBs.\nSui Console CLI: Use sui console to open an interactive console with the currently active network.\nSui Keytool CLI: Use the sui keytool commands to access cryptography utilities.\nSui Move CLI: Use the sui move commands to work with the Move programming language.\nSui Validator CLI: Use the sui validator commands to access tools useful for Sui validators.\nEdit this page\nPrevious\nRPC Best Practices\nNext\nSui Client CLI\nCheck Sui CLI installation\nUpdate CLI\nSui CLI commands\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui API Reference | Sui Documentation | Sui Documentation",
      "url": "https://docs.sui.io/sui-api-ref",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nRPC: https://fullnode.mainnet.sui.io:443\nMainnet\nRPC: https://fullnode.mainnet.sui.io:443\nCoin Query API\nsuix_getAllBalances\nsuix_getAllCoins\nsuix_getBalance\nsuix_getCoinMetadata\nsuix_getCoins\nsuix_getTotalSupply\nExtended API\nsuix_getDynamicFieldObject\nsuix_getDynamicFields\nsuix_getOwnedObjects\nsuix_queryEvents\nsuix_queryTransactionBlocks\nsuix_resolveNameServiceAddress\nsuix_resolveNameServiceNames\nsuix_subscribeEvent\nsuix_subscribeTransaction\nGovernance Read API\nsuix_getCommitteeInfo\nsuix_getLatestSuiSystemState\nsuix_getReferenceGasPrice\nsuix_getStakes\nsuix_getStakesByIds\nsuix_getValidatorsApy\nMove Utils\nsui_getMoveFunctionArgTypes\nsui_getNormalizedMoveFunction\nsui_getNormalizedMoveModule\nsui_getNormalizedMoveModulesByPackage\nsui_getNormalizedMoveStruct\nRead API\nsui_getChainIdentifier\nsui_getCheckpoint\nsui_getCheckpoints\nsui_getEvents\nsui_getLatestCheckpointSequenceNumber\nsui_getLoadedChildObjects\nsui_getObject\nsui_getProtocolConfig\nsui_getTotalTransactionBlocks\nsui_getTransactionBlock\nsui_multiGetObjects\nsui_multiGetTransactionBlocks\nsui_tryGetPastObject\nsui_tryMultiGetPastObjects\nTransaction Builder API\nunsafe_batchTransaction\nunsafe_mergeCoins\nunsafe_moveCall\nunsafe_pay\nunsafe_payAllSui\nunsafe_paySui\nunsafe_publish\nunsafe_requestAddStake\nunsafe_requestWithdrawStake\nunsafe_splitCoin\nunsafe_splitCoinEqual\nunsafe_transferObject\nunsafe_transferSui\nWrite API\nsui_devInspectTransactionBlock\nsui_dryRunTransactionBlock\nsui_executeTransactionBlock\nSui JSON-RPC Reference - Version: 1.24.1\n\nSui JSON-RPC API for interaction with Sui Full node. Make RPC calls using https://fullnode.NETWORK.sui.io:443, where NETWORK is the network you want to use (testnet, devnet, mainnet). By default, local networks use port 9000.\n\nCoin Query API\nsuix_getAllBalances\n\nReturn the total coin balance for all coin type, owned by the address owner.\n\nParameters\n\nName<Type>\nRequired\nDescription\nowner< SuiAddress >\nYes\nThe owner's Sui address\n\nResult\n\nVec<Balance><[ Balance ]>\n\nExample\n\nGets all balances for the address in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getAllBalances\",\n  \"params\": [\n    \"0x94f1a597b4e8f709a396f7f6b1482bdcd65a673d111e49286c527fab7c2d0961\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"coinType\": \"0x2::sui::SUI\",\n      \"coinObjectCount\": 15,\n      \"totalBalance\": \"3000000000\",\n      \"lockedBalance\": {}\n    }\n  ],\n  \"id\": 1\n}\nsuix_getAllCoins\n\nReturn all Coin objects owned by an address.\n\nParameters\n\nName<Type>\nRequired\nDescription\nowner< SuiAddress >\nYes\nThe owner's Sui address\ncursor< ObjectID >\nNo\nOptional paging cursor\nlimit< uint >\nNo\nMaximum number of items per page\n\nResult\n\nCoinPage< Page_for_Coin_and_ObjectID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ Coin ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< ObjectID | null >\nNo\n\nExample\n\nGets all coins for the address in the request body. Begin listing the coins that are after the provided cursor value and return only the limit amount of results per page.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getAllCoins\",\n  \"params\": [\n    \"0x41f5975e3c6bd5c95f041a8493ad7e9934be26e69152d2c2e86d8a9bdbd242b3\",\n    \"0x2564cd31a71cf9833609b111436d8f0f47b7f8b9927ec3f8975a1dcbf9b25564\",\n    3\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0x91825debff541cf4e08b5c5f7296ff9840e6f0b185af93984cde8cf3870302c0\",\n        \"version\": \"103626\",\n        \"digest\": \"7dp5WtTmtGp83EXYYFMzjBJRFeSgR67AzqMETLrfgeFx\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"9WfFUVhjbbh4tWkyUse1QxzbKX952cyXScH7xJNPB2vQ\"\n      },\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0x48a53f22e2e901ea2a5bf44fdd5bb94a1d83b6efc4dd779f0890ca3b1f6ba997\",\n        \"version\": \"103626\",\n        \"digest\": \"9xLdMXezY8d1yRA2TtN6pYjapyy2EVKHWNriGPFGCFvd\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"Byq9SyV7x6fvzaf88YRA9JM8vLbVLJAqUX8pESDmKcgw\"\n      },\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0x6867fcc63161269c5c0c73b02229486bbaff319209dfb8299ced3b8609037997\",\n        \"version\": \"103626\",\n        \"digest\": \"5xexWFq6QpGHBQyC9P2cbAJXq9qm2EjzfuRM9NwS1uyG\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"CEjwHmo98nAiYhSMfKoSDvUMtfKJ6ge6Uj4wKotK4MPZ\"\n      }\n    ],\n    \"nextCursor\": \"0x861c5e055605b2bb1199faf653a8771e448930bc95a0369fad43a9870a2e5878\",\n    \"hasNextPage\": true\n  },\n  \"id\": 1\n}\nsuix_getBalance\n\nReturn the total coin balance for one coin type, owned by the address owner.\n\nParameters\n\nName<Type>\nRequired\nDescription\nowner< SuiAddress >\nYes\nThe owner's Sui address\ncoin_type< string >\nNo\nOptional type names for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC), default to 0x2::sui::SUI if not specified.\n\nResult\n\nBalance< Balance >\n\nParameter\nRequired\nDescription\ncoinObjectCount< uint >\nYes\ncoinType< string >\nYes\nlockedBalance< BigInt_for_uint128 >\nYes\ntotalBalance< BigInt_for_uint128 >\nYes\n\nExample\n\nGets the balance of the specified type of coin for the address in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getBalance\",\n  \"params\": [\n    \"0x51ceab2edc89f74730e683ebee65578cb3bc9237ba6fca019438a9737cf156ae\",\n    \"0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"coinType\": \"0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC\",\n    \"coinObjectCount\": 15,\n    \"totalBalance\": \"15\",\n    \"lockedBalance\": {}\n  },\n  \"id\": 1\n}\nsuix_getCoinMetadata\n\nReturn metadata(e.g., symbol, decimals) for a coin\n\nParameters\n\nName<Type>\nRequired\nDescription\ncoin_type< string >\nYes\nType name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC)\n\nResult\n\nSuiCoinMetadata< SuiCoinMetadata >\n\nParameter\nRequired\nDescription\ndecimals< uint8 >\nYes\nNumber of decimal places the coin uses.\ndescription< string >\nYes\nDescription of the token\niconUrl< [string,null] >\nNo\nURL for the token logo\nid< ObjectID | null >\nNo\nObject id for the CoinMetadata object\nname< string >\nYes\nName for the token\nsymbol< string >\nYes\nSymbol for the token\n\nExample\n\nGets the metadata for the coin type in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getCoinMetadata\",\n  \"params\": [\n    \"0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"decimals\": 9,\n    \"name\": \"Usdc\",\n    \"symbol\": \"USDC\",\n    \"description\": \"Stable coin.\",\n    \"iconUrl\": null,\n    \"id\": \"0x6d907beaa3a49db57bdfdb3557e6d405cbf01c293a53e01457d65e92b5d8dd68\"\n  },\n  \"id\": 1\n}\nsuix_getCoins\n\nReturn all Coin<coin_type> objects owned by an address.\n\nParameters\n\nName<Type>\nRequired\nDescription\nowner< SuiAddress >\nYes\nThe owner's Sui address\ncoin_type< string >\nNo\nOptional type name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC), default to 0x2::sui::SUI if not specified.\ncursor< ObjectID >\nNo\nOptional paging cursor\nlimit< uint >\nNo\nMaximum number of items per page\n\nResult\n\nCoinPage< Page_for_Coin_and_ObjectID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ Coin ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< ObjectID | null >\nNo\n\nExample\n\nGets all SUI coins owned by the address provided. Return a paginated list of limit results per page. Similar to suix_getAllCoins, but provides a way to filter by coin type.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getCoins\",\n  \"params\": [\n    \"0xd62ca040aba24f862a763851c54908cd2a0ee7d709c11b93d4a2083747b76856\",\n    \"0x2::sui::SUI\",\n    \"0xe5c651321915b06c81838c2e370109b554a448a78d3a56220f798398dde66eab\",\n    3\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0xa5a8e30db5a798a7354340b6ea78a66f50921841ab5359ec7a3dc01f282420ae\",\n        \"version\": \"103626\",\n        \"digest\": \"tw5DzJTfdxTn4f3rekFrhN7dQTUezBgsEhycDobTBLb\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"HSein75AFXgdsnbABWLQ5mvjFmPFWrBFi9CMVsNn7gJr\"\n      },\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0x47dfa99496428c65b2054ad7db1872b87ff05b1047bb5e3adf5257cceb08ecb4\",\n        \"version\": \"103626\",\n        \"digest\": \"AfgFe7ZfjJ5dWV6VAy2LbtvBFhcABkvdvwEjLrRcFqtr\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"5WHnm9jUZEtDvSvsj7HBrP5BoxA3UY6R57qqumXJXboV\"\n      },\n      {\n        \"coinType\": \"0x2::sui::SUI\",\n        \"coinObjectId\": \"0xd4f062dbcfc3bf73f5861945592222ff7b090ac21c8a3cf840abdc5b743da778\",\n        \"version\": \"103626\",\n        \"digest\": \"9er6jxigfuQEKsn9gtPV2oW1zGQRcFtKNijHVe88GUJD\",\n        \"balance\": \"200000000\",\n        \"previousTransaction\": \"H3gwoKE2FSLx3BwvNTTKqCsNHmg6ARzm345icHhXUAEW\"\n      }\n    ],\n    \"nextCursor\": \"0xd4f062dbcfc3bf73f5861945592222ff7b090ac21c8a3cf840abdc5b743da778\",\n    \"hasNextPage\": true\n  },\n  \"id\": 1\n}\nsuix_getTotalSupply\n\nReturn total supply for a coin\n\nParameters\n\nName<Type>\nRequired\nDescription\ncoin_type< string >\nYes\nType name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC)\n\nResult\n\nSupply< Supply >\n\nParameter\nRequired\nDescription\nvalue< BigInt_for_uint64 >\nYes\n\nExample\n\nGets total supply for the type of coin provided.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getTotalSupply\",\n  \"params\": [\n    \"0x0a52124e2d53af3bef7959609efa51761ad155441a1b73bdaeecce7c56488b13::acoin::ACOIN\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"value\": \"12023692\"\n  },\n  \"id\": 1\n}\nExtended API\nsuix_getDynamicFieldObject\n\nReturn the dynamic field object information for a specified object\n\nParameters\n\nName<Type>\nRequired\nDescription\nparent_object_id< ObjectID >\nYes\nThe ID of the queried parent object\nname< DynamicFieldName >\nYes\nThe Name of the dynamic field\n\nResult\n\nSuiObjectResponse< SuiObjectResponse >\n\nParameter\nRequired\nDescription\ndata< ObjectData | null >\nNo\nerror< ObjectResponseError | null >\nNo\n\nExample\n\nGets the information for the dynamic field the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getDynamicFieldObject\",\n  \"params\": [\n    \"0xc8359b6b5e3bfeab524e5edaad3a204b4053745b2d45d1f00cd8d24e5b697607\",\n    {\n      \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n      \"value\": \"some_value\"\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": {\n      \"objectId\": \"0xc8359b6b5e3bfeab524e5edaad3a204b4053745b2d45d1f00cd8d24e5b697607\",\n      \"version\": \"1\",\n      \"digest\": \"2VivvkBoFVwEg8oXq3tK9r3d3ybvMACtk9QwpFnkM6v2\",\n      \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n      \"owner\": {\n        \"AddressOwner\": \"0xc055d5c23e2f6c69e6aacf5b4664b570cb20d4feace07fc863a2eef286c3e95e\"\n      },\n      \"previousTransaction\": \"FJjAr8fdpuQvVZgd9VswXxz9jZcFGEAgKgdi8d6zXE3S\",\n      \"storageRebate\": \"100\",\n      \"content\": {\n        \"dataType\": \"moveObject\",\n        \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n        \"hasPublicTransfer\": true,\n        \"fields\": {}\n      }\n    }\n  },\n  \"id\": 1\n}\nsuix_getDynamicFields\n\nReturn the list of dynamic field objects owned by an object.\n\nParameters\n\nName<Type>\nRequired\nDescription\nparent_object_id< ObjectID >\nYes\nThe ID of the parent object\ncursor< ObjectID >\nNo\nAn optional paging cursor. If provided, the query will start from the next item after the specified cursor. Default to start from the first item if not specified.\nlimit< uint >\nNo\nMaximum item returned per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified.\n\nResult\n\nDynamicFieldPage< Page_for_DynamicFieldInfo_and_ObjectID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ DynamicFieldInfo ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< ObjectID | null >\nNo\n\nExample\n\nGets dynamic fields for the object the request provides in a paginated list of limit dynamic field results per page. The default limit is 50.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getDynamicFields\",\n  \"params\": [\n    \"0xe15bb8de6dadd21835dfe44f4973139c15f93ddea0f8c3da994d9ead562ce76e\",\n    \"0xa9334aeacc435c70ab9635e47a277d8f8dd9d87765d1aadec2db8cc24c312542\",\n    3\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"name\": {\n          \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n          \"value\": \"some_value\"\n        },\n        \"bcsName\": \"2F1KQ3miNpBx1RzoRr1MVYMraK7RV\",\n        \"type\": \"DynamicField\",\n        \"objectType\": \"test\",\n        \"objectId\": \"0x36fdef6a382da344930c73d1298b0e9644b85ea6f7a348f4a7bd1a9ab069eb7f\",\n        \"version\": 1,\n        \"digest\": \"7hWCQjKfZf7oNLpSrhFJZEmYnpmSPzVLwJfFuHmMD9ct\"\n      },\n      {\n        \"name\": {\n          \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n          \"value\": \"some_value\"\n        },\n        \"bcsName\": \"2F1KQ3miNpBx1RzoRr1MVYMraK7RV\",\n        \"type\": \"DynamicField\",\n        \"objectType\": \"test\",\n        \"objectId\": \"0xfe41671856fd3450dc5574abd53c793c9f22d8a72d5550df8d2d64a9155d126c\",\n        \"version\": 1,\n        \"digest\": \"CxuC9uMcWLk8oMg7QGaJSqUE4hwP6cMUQ94ipiN53jr3\"\n      },\n      {\n        \"name\": {\n          \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestField\",\n          \"value\": \"some_value\"\n        },\n        \"bcsName\": \"2F1KQ3miNpBx1RzoRr1MVYMraK7RV\",\n        \"type\": \"DynamicField\",\n        \"objectType\": \"test\",\n        \"objectId\": \"0x1edb2df5ea5d55c96a611371d22799d268270cd4bb4d4f520fe9bbf0cf1cebe3\",\n        \"version\": 1,\n        \"digest\": \"HJxTwLy4oE1Aoy3PocGfL9oHystQiyssHfmyE8YaPrw4\"\n      }\n    ],\n    \"nextCursor\": \"0x8a25d8876ea3c60e345ac3861444136b4a1b0b37a91692359a98496738a58c17\",\n    \"hasNextPage\": true\n  },\n  \"id\": 1\n}\nsuix_getOwnedObjects\n\nReturn the list of objects owned by an address. Note that if the address owns more than QUERY_MAX_RESULT_LIMIT objects, the pagination is not accurate, because previous page may have been updated when the next page is fetched. Please use suix_queryObjects if this is a concern.\n\nParameters\n\nName<Type>\nRequired\nDescription\naddress< SuiAddress >\nYes\nThe owner's Sui address\nquery< ObjectResponseQuery >\nNo\nThe objects query criteria.\ncursor< ObjectID >\nNo\nAn optional paging cursor. If provided, the query will start from the next item after the specified cursor. Default to start from the first item if not specified.\nlimit< uint >\nNo\nMax number of items returned per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified.\n\nResult\n\nObjectsPage< Page_for_SuiObjectResponse_and_ObjectID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ SuiObjectResponse ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< ObjectID | null >\nNo\n\nExample\n\nReturns all the objects the address provided in the request owns and that match the filter. By default, only the digest value is returned, but the request returns additional information by setting the relevant keys to true. A cursor value is also provided, so the list of results begin after that value.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getOwnedObjects\",\n  \"params\": [\n    \"0xa69bb635dcee0f33643b4729ae81730d55e5e26860fac6839ce2d7ed7e6f29d2\",\n    {\n      \"filter\": {\n        \"MatchAll\": [\n          {\n            \"StructType\": \"0x2::coin::Coin<0x2::sui::SUI>\"\n          },\n          {\n            \"AddressOwner\": \"0xa69bb635dcee0f33643b4729ae81730d55e5e26860fac6839ce2d7ed7e6f29d2\"\n          },\n          {\n            \"Version\": \"13488\"\n          }\n        ]\n      },\n      \"options\": {\n        \"showType\": true,\n        \"showOwner\": true,\n        \"showPreviousTransaction\": true,\n        \"showDisplay\": false,\n        \"showContent\": false,\n        \"showBcs\": false,\n        \"showStorageRebate\": false\n      }\n    },\n    \"0x76a1b4c23f2d9a9b6f0d8b2c17beace292b72aea16d6fb49b7d1ae51f33b01ed\",\n    3\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"data\": {\n          \"objectId\": \"0x3d6255ff8223c12b0fd985c49d5777a0d65ad3d707164b2a378eee639ebc2690\",\n          \"version\": \"13488\",\n          \"digest\": \"A6v9pFTLH3PkDSvEGgVjW1JhL7CtcUQKwGmgXK8SQNsc\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"owner\": {\n            \"AddressOwner\": \"0xa69bb635dcee0f33643b4729ae81730d55e5e26860fac6839ce2d7ed7e6f29d2\"\n          },\n          \"previousTransaction\": \"AZiaEnge9YnawyLosmuxd8grpoiYasfpvBEjSLFUmJ8m\",\n          \"storageRebate\": \"100\"\n        }\n      },\n      {\n        \"data\": {\n          \"objectId\": \"0x1a6e30f43933bbf40f5f5b6ce1f44957337dcb28f32e0355326f8c7d932bd54d\",\n          \"version\": \"13488\",\n          \"digest\": \"Fn1HG7LyUcLDps6bhYQkPWXpeUXgisznxRJ2qvn7Q1JN\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"owner\": {\n            \"AddressOwner\": \"0xa69bb635dcee0f33643b4729ae81730d55e5e26860fac6839ce2d7ed7e6f29d2\"\n          },\n          \"previousTransaction\": \"5EZjpdpApGGb48UZtuRgXuTRDBgkFDYaiNUtUNg7788k\",\n          \"storageRebate\": \"100\"\n        }\n      },\n      {\n        \"data\": {\n          \"objectId\": \"0x28628a24386298faa98850887f64da841b87279efd098d59a66a3d9adc87cce8\",\n          \"version\": \"13488\",\n          \"digest\": \"39aXGAwHaY3CiqWwLiBZ7JRaGSvnpvPbHxMSJAwAUY5i\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"owner\": {\n            \"AddressOwner\": \"0xa69bb635dcee0f33643b4729ae81730d55e5e26860fac6839ce2d7ed7e6f29d2\"\n          },\n          \"previousTransaction\": \"CnBDiCrxWcJCCU1LHoda6XwwRaCSRfva8HZzfmR3p8Ag\",\n          \"storageRebate\": \"100\"\n        }\n      }\n    ],\n    \"nextCursor\": \"0x28628a24386298faa98850887f64da841b87279efd098d59a66a3d9adc87cce8\",\n    \"hasNextPage\": true\n  },\n  \"id\": 1\n}\nsuix_queryEvents\n\nReturn list of events for a specified query criteria.\n\nParameters\n\nName<Type>\nRequired\nDescription\nquery< EventFilter >\nYes\nThe event query criteria. See Event filter documentation for examples.\ncursor< EventID >\nNo\nOptional paging cursor\nlimit< uint >\nNo\nMaximum number of items per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified.\ndescending_order< Boolean >\nNo\nQuery result ordering, default to false (ascending order), oldest record first.\n\nResult\n\nEventPage< Page_for_Event_and_EventID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ Event ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< EventID | null >\nNo\n\nExample\n\nReturns the events for a specified query criteria.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_queryEvents\",\n  \"params\": [\n    {\n      \"MoveModule\": {\n        \"package\": \"0x30651d6e8f93e0fb79b4bc65a512beb5b9f3378423de90ed03b694cecf443c72\",\n        \"module\": \"test\"\n      }\n    },\n    {\n      \"txDigest\": \"Nb5kW8n655ApSBA19d2K8UVFGtMnJHa1mJQRH1h5N9L\",\n      \"eventSeq\": \"1\"\n    },\n    100,\n    false\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"id\": {\n          \"txDigest\": \"8WecQq8Qd79MmrHRXYudNG7e6vjWC9HtGAT4XZFyyWRM\",\n          \"eventSeq\": \"1\"\n        },\n        \"packageId\": \"0x28f9c59f430eaba84b8bee9b43a30f9cc83fa395759ca37c6e1ffc179184e98a\",\n        \"transactionModule\": \"test\",\n        \"sender\": \"0xc5db76052ab656e5f81853d0cf701cdbc8ebf27ab513fc6ef8c344406c78da3d\",\n        \"type\": \"0x3::test::Test<0x3::test::Test>\",\n        \"parsedJson\": \"some_value\",\n        \"bcs\": \"\"\n      },\n      {\n        \"id\": {\n          \"txDigest\": \"CNLhn3qWzHhfmmLQTdinbFDd2DuXFPN9z77UUqsC4Z4A\",\n          \"eventSeq\": \"1\"\n        },\n        \"packageId\": \"0x28f9c59f430eaba84b8bee9b43a30f9cc83fa395759ca37c6e1ffc179184e98a\",\n        \"transactionModule\": \"test\",\n        \"sender\": \"0x5ad3a5fcc295dc8803c15989a62d33ee859014cfd5e91c13a481370240e39246\",\n        \"type\": \"0x3::test::Test<0x3::test::Test>\",\n        \"parsedJson\": \"some_value\",\n        \"bcs\": \"\"\n      },\n      {\n        \"id\": {\n          \"txDigest\": \"FEhceVx5a6mkeZH8dPxthQkEEPkWfjWN3w1e6uTB5rFm\",\n          \"eventSeq\": \"1\"\n        },\n        \"packageId\": \"0x28f9c59f430eaba84b8bee9b43a30f9cc83fa395759ca37c6e1ffc179184e98a\",\n        \"transactionModule\": \"test\",\n        \"sender\": \"0x4c329a203fb9f0a8158aaab9b2a90044b26e14cc7fee4100fdcabda6d15c63c4\",\n        \"type\": \"0x3::test::Test<0x3::test::Test>\",\n        \"parsedJson\": \"some_value\",\n        \"bcs\": \"\"\n      },\n      {\n        \"id\": {\n          \"txDigest\": \"Nb5kW8n655ApSBA19d2K8UVFGtMnJHa1mJQRH1h5N9L\",\n          \"eventSeq\": \"1\"\n        },\n        \"packageId\": \"0x28f9c59f430eaba84b8bee9b43a30f9cc83fa395759ca37c6e1ffc179184e98a\",\n        \"transactionModule\": \"test\",\n        \"sender\": \"0xb49c45ae23f2b936495cd38b1a4b04010295baa75ac72e548aeecf2ce8b4e885\",\n        \"type\": \"0x3::test::Test<0x3::test::Test>\",\n        \"parsedJson\": \"some_value\",\n        \"bcs\": \"\"\n      }\n    ],\n    \"nextCursor\": {\n      \"txDigest\": \"Nb5kW8n655ApSBA19d2K8UVFGtMnJHa1mJQRH1h5N9L\",\n      \"eventSeq\": \"1\"\n    },\n    \"hasNextPage\": false\n  },\n  \"id\": 1\n}\nsuix_queryTransactionBlocks\n\nReturn list of transactions for a specified query criteria.\n\nParameters\n\nName<Type>\nRequired\nDescription\nquery< TransactionBlockResponseQuery >\nYes\nThe transaction query criteria.\ncursor< TransactionDigest >\nNo\nAn optional paging cursor. If provided, the query will start from the next item after the specified cursor. Default to start from the first item if not specified.\nlimit< uint >\nNo\nMaximum item returned per page, default to QUERY_MAX_RESULT_LIMIT if not specified.\ndescending_order< Boolean >\nNo\nQuery result ordering, default to false (ascending order), oldest record first.\n\nResult\n\nTransactionBlocksPage< Page_for_TransactionBlockResponse_and_TransactionDigest >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ TransactionBlockResponse ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< TransactionDigest | null >\nNo\n\nExample\n\nReturns the transaction digest for specified query criteria.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_queryTransactionBlocks\",\n  \"params\": [\n    {\n      \"filter\": {\n        \"InputObject\": \"0x93633829fcba6d6e0ccb13d3dbfe7614b81ea76b255e5d435032cd8595f37eb8\"\n      },\n      \"options\": null\n    },\n    \"HxidAfFfyr4kXSiWeVq1J6Tk526YUVDoSUY5PSnS4tEJ\",\n    100,\n    false\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"digest\": \"GUPcK4cmRmgsTFr52ab9f6fnzNVg3Lz6hF2aXFcsRzaD\"\n      },\n      {\n        \"digest\": \"B2iV1SVbBjgTKfbJKPQrvTT6F3kNdekFuBwY9tQcAxV2\"\n      },\n      {\n        \"digest\": \"8QrPa4x9iNG5r2zQfmeH8pJoVjjtq9AGzp8rp2fxi8Sk\"\n      },\n      {\n        \"digest\": \"3nek86HEjXZ7K3EtrAcBG4wMrCS21gqr8BqwwC6M6P7F\"\n      }\n    ],\n    \"nextCursor\": \"3nek86HEjXZ7K3EtrAcBG4wMrCS21gqr8BqwwC6M6P7F\",\n    \"hasNextPage\": false\n  },\n  \"id\": 1\n}\nsuix_resolveNameServiceAddress\n\nReturn the resolved address given resolver and name\n\nParameters\n\nName<Type>\nRequired\nDescription\nname< string >\nYes\nThe name to resolve\n\nResult\n\nSuiAddress< SuiAddress >\n\nExample\n\nReturns the resolved address for the name the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_resolveNameServiceAddress\",\n  \"params\": [\n    \"example.sui\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": \"0x70f2d83f980fe0996a92d351d6749a0a0b47998aaf3d11da24c49e014d4ccb1d\",\n  \"id\": 1\n}\nsuix_resolveNameServiceNames\n\nReturn the resolved names given address, if multiple names are resolved, the first one is the primary name.\n\nParameters\n\nName<Type>\nRequired\nDescription\naddress< SuiAddress >\nYes\nThe address to resolve\ncursor< ObjectID >\nNo\nlimit< uint >\nNo\n\nResult\n\nPage<String,ObjectID>< Page_for_String_and_ObjectID >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ string ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< ObjectID | null >\nNo\n\nExample\n\nReturns the SuiNS name for the address the request provides. Currently, the API returns only the first name in cases where there are multiple. Future support will use the cursor ID and limit values in the request to control pagination of the response for addresses with multiple names.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_resolveNameServiceNames\",\n  \"params\": [\n    \"0xb01f2f3f227a90090e6777f19aa10fd9e64e29dd4e8da119481d1a7c3c050dc5\",\n    \"0x7d0cd09d3cc1679290f1df2803b32b76ba0395dbb635e3fb7390f04e6567f739\",\n    3\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      \"example.sui\"\n    ],\n    \"nextCursor\": \"0x7d0cd09d3cc1679290f1df2803b32b76ba0395dbb635e3fb7390f04e6567f739\",\n    \"hasNextPage\": false\n  },\n  \"id\": 1\n}\nsuix_subscribeEvent\n\nSubscribe to a stream of Sui event\n\nParameters\n\nName<Type>\nRequired\nDescription\nfilter< EventFilter >\nYes\nThe filter criteria of the event stream. See Event filter documentation for examples.\n\nResult\n\nSuiEvent< Event >\n\nParameter\nRequired\nDescription\nbcs< Base58 >\nYes\nBase 58 encoded bcs bytes of the move event\nid< EventID >\nYes\nSequential event ID, ie (transaction seq number, event seq number). 1) Serves as a unique event ID for each fullnode 2) Also serves to sequence events for the purposes of pagination and querying. A higher id is an event seen later by that fullnode. This ID is the \"cursor\" for event querying.\npackageId< ObjectID >\nYes\nMove package where this event was emitted.\nparsedJson< >\nYes\nParsed json value of the event\nsender< SuiAddress >\nYes\nSender's Sui address.\ntimestampMs< BigInt_for_uint64 | null >\nNo\nUTC timestamp in milliseconds since epoch (1/1/1970)\ntransactionModule< string >\nYes\nMove module where this event was emitted.\ntype< string >\nYes\nMove event type.\nsuix_subscribeTransaction\n\nSubscribe to a stream of Sui transaction effects\n\nParameters\n\nName<Type>\nRequired\nDescription\nfilter< TransactionFilter >\nYes\n\nResult\n\nSuiTransactionBlockEffects< TransactionBlockEffects >\n\nGovernance Read API\nsuix_getCommitteeInfo\n\nReturn the committee information for the asked epoch.\n\nParameters\n\nName<Type>\nRequired\nDescription\nepoch< BigInt_for_uint64 >\nNo\nThe epoch of interest. If None, default to the latest epoch\n\nResult\n\nSuiCommittee< CommitteeInfo >\n\nRPC representation of the [Committee] type.\n\nParameter\nRequired\nDescription\nepoch< BigInt_for_uint64 >\nYes\nvalidators<[ AuthorityPublicKeyBytes, BigInt_for_uint64 ]>\nYes\n\nExample\n\nGets committee information for epoch 5000.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getCommitteeInfo\",\n  \"params\": [\n    \"5000\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"epoch\": \"5000\",\n    \"validators\": [\n      [\n        \"jc/20VUECmVvSBmxMRG1LFdGqGunLzlfuv4uw4R9HoFA5iSnUf32tfIFC8cgXPnTAATJCwx0Cv/TJs5nPMKyOi0k1T4q/rKG38Zo/UBgCJ1tKxe3md02+Q0zLlSnozjU\",\n        \"2500\"\n      ],\n      [\n        \"mfJe9h+AMrkUY2RgmCxcxvE07x3a52ZX8sv+wev8jQlzdAgN9vzw3Li8Sw2OCvXYDrv/K0xZn1T0LWMS38MUJ2B4wcw0fru+xRmL4lhRPzhrkw0CwnSagD4jMJVevRoQ\",\n        \"2500\"\n      ],\n      [\n        \"rd7vlNiYyI5A297/kcXxBfnPLHR/tvK8N+wD1ske2y4aV4z1RL6LCTHiXyQ9WbDDDZihbOO6HWzx1/UEJpkusK2zE0sFW+gUDS218l+wDYP45CIr8B/WrJOh/0152ljy\",\n        \"2500\"\n      ],\n      [\n        \"s/1e+1yHJAOkrRPxGZUTYG0jNUqEUkmuoVdWTCP/PBXGyeZSty10DoysuTy8wGhrDsDMDBx2C/tCtDZRn8WoBUt2UzqXqfI5h9CX75ax8lJrsgc/oQp3GZQXcjR+8nT0\",\n        \"2500\"\n      ]\n    ]\n  },\n  \"id\": 1\n}\nsuix_getLatestSuiSystemState\n\nReturn the latest SUI system state object on-chain.\n\nParameters\n\nNone\n\nResult\n\nSuiSystemStateSummary< SuiSystemStateSummary >\n\nThis is the JSON-RPC type for the SUI system state object. It flattens all fields to make them top-level fields such that it as minimum dependencies to the internal data structures of the SUI system state type.\n\nParameter\nRequired\nDescription\nactiveValidators<[ SuiValidatorSummary ]>\nYes\nThe list of active validators in the current epoch.\natRiskValidators<[ SuiAddress, BigInt_for_uint64 ]>\nYes\nMap storing the number of epochs for which each validator has been below the low stake threshold.\nepoch< BigInt_for_uint64 >\nYes\nThe current epoch ID, starting from 0.\nepochDurationMs< BigInt_for_uint64 >\nYes\nThe duration of an epoch, in milliseconds.\nepochStartTimestampMs< BigInt_for_uint64 >\nYes\nUnix timestamp of the current epoch start\ninactivePoolsId< ObjectID >\nYes\nID of the object that maps from a staking pool ID to the inactive validator that has that pool as its staking pool.\ninactivePoolsSize< BigInt_for_uint64 >\nYes\nNumber of inactive staking pools.\nmaxValidatorCount< BigInt_for_uint64 >\nYes\nMaximum number of active validators at any moment. We do not allow the number of validators in any epoch to go above this.\nminValidatorJoiningStake< BigInt_for_uint64 >\nYes\nLower-bound on the amount of stake required to become a validator.\npendingActiveValidatorsId< ObjectID >\nYes\nID of the object that contains the list of new validators that will join at the end of the epoch.\npendingActiveValidatorsSize< BigInt_for_uint64 >\nYes\nNumber of new validators that will join at the end of the epoch.\npendingRemovals<[ BigInt_for_uint64 ]>\nYes\nRemoval requests from the validators. Each element is an index pointing to active_validators.\nprotocolVersion< BigInt_for_uint64 >\nYes\nThe current protocol version, starting from 1.\nreferenceGasPrice< BigInt_for_uint64 >\nYes\nThe reference gas price for the current epoch.\nsafeMode< Boolean >\nYes\nWhether the system is running in a downgraded safe mode due to a non-recoverable bug. This is set whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode. It can be reset once we are able to successfully execute advance_epoch.\nsafeModeComputationRewards< BigInt_for_uint64 >\nYes\nAmount of computation rewards accumulated (and not yet distributed) during safe mode.\nsafeModeNonRefundableStorageFee< BigInt_for_uint64 >\nYes\nAmount of non-refundable storage fee accumulated during safe mode.\nsafeModeStorageRebates< BigInt_for_uint64 >\nYes\nAmount of storage rebates accumulated (and not yet burned) during safe mode.\nsafeModeStorageRewards< BigInt_for_uint64 >\nYes\nAmount of storage rewards accumulated (and not yet distributed) during safe mode.\nstakeSubsidyBalance< BigInt_for_uint64 >\nYes\nBalance of SUI set aside for stake subsidies that will be drawn down over time.\nstakeSubsidyCurrentDistributionAmount< BigInt_for_uint64 >\nYes\nThe amount of stake subsidy to be drawn down per epoch. This amount decays and decreases over time.\nstakeSubsidyDecreaseRate< uint16 >\nYes\nThe rate at which the distribution amount decays at the end of each period. Expressed in basis points.\nstakeSubsidyDistributionCounter< BigInt_for_uint64 >\nYes\nThis counter may be different from the current epoch number if in some epochs we decide to skip the subsidy.\nstakeSubsidyPeriodLength< BigInt_for_uint64 >\nYes\nNumber of distributions to occur before the distribution amount decays.\nstakeSubsidyStartEpoch< BigInt_for_uint64 >\nYes\nThe starting epoch in which stake subsidies start being paid out\nstakingPoolMappingsId< ObjectID >\nYes\nID of the object that maps from staking pool's ID to the sui address of a validator.\nstakingPoolMappingsSize< BigInt_for_uint64 >\nYes\nNumber of staking pool mappings.\nstorageFundNonRefundableBalance< BigInt_for_uint64 >\nYes\nThe non-refundable portion of the storage fund coming from storage reinvestment, non-refundable storage rebates and any leftover staking rewards.\nstorageFundTotalObjectStorageRebates< BigInt_for_uint64 >\nYes\nThe storage rebates of all the objects on-chain stored in the storage fund.\nsystemStateVersion< BigInt_for_uint64 >\nYes\nThe current version of the system state data structure type.\ntotalStake< BigInt_for_uint64 >\nYes\nTotal amount of stake from all active validators at the beginning of the epoch.\nvalidatorCandidatesId< ObjectID >\nYes\nID of the object that stores preactive validators, mapping their addresses to their Validator structs.\nvalidatorCandidatesSize< BigInt_for_uint64 >\nYes\nNumber of preactive validators.\nvalidatorLowStakeGracePeriod< BigInt_for_uint64 >\nYes\nA validator can have stake below validator_low_stake_threshold for this many epochs before being kicked out.\nvalidatorLowStakeThreshold< BigInt_for_uint64 >\nYes\nValidators with stake amount below validator_low_stake_threshold are considered to have low stake and will be escorted out of the validator set after being below this threshold for more than validator_low_stake_grace_period number of epochs.\nvalidatorReportRecords<[ SuiAddress, array ]>\nYes\nA map storing the records of validator reporting each other.\nvalidatorVeryLowStakeThreshold< BigInt_for_uint64 >\nYes\nValidators with stake below validator_very_low_stake_threshold will be removed immediately at epoch change, no grace period.\n\nExample\n\nGets objects owned by the address in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getLatestSuiSystemState\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": \"some_system_state\",\n  \"id\": 1\n}\nsuix_getReferenceGasPrice\n\nReturn the reference gas price for the network\n\nParameters\n\nNone\n\nResult\n\nBigInt<u64>< BigInt_for_uint64 >\n\nExample\n\nGets reference gas price information for the network.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getReferenceGasPrice\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": 1000,\n  \"id\": 1\n}\nsuix_getStakes\n\nReturn all [DelegatedStake].\n\nParameters\n\nName<Type>\nRequired\nDescription\nowner< SuiAddress >\nYes\n\nResult\n\nVec<DelegatedStake><[ DelegatedStake ]>\n\nExample\n\nReturns the staking information for the address the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getStakes\",\n  \"params\": [\n    \"0xb5387b29a731d26d98108d7abc4902107d7d6a8e0f8fea6fda5488462e58724c\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"validatorAddress\": \"0x034462b6064a08845e2ae2942fe7c4ee816d754eb2eed23e6c6bb32c89fe1f21\",\n      \"stakingPool\": \"0xab588374445e72e0402aea014b295610579963ee67e81398729f87d81d62f399\",\n      \"stakes\": [\n        {\n          \"stakedSuiId\": \"0xc041b0f8d0938923ea7e3917608ee62df4376710024f81dd33ab6833482ee803\",\n          \"stakeRequestEpoch\": \"62\",\n          \"stakeActiveEpoch\": \"63\",\n          \"principal\": \"200000000000\",\n          \"status\": \"Active\",\n          \"estimatedReward\": \"520000000\"\n        },\n        {\n          \"stakedSuiId\": \"0x4e779a48e6ef635c7f856df4905022458bfbd22bbb46f892c42d9ec0ae4de93e\",\n          \"stakeRequestEpoch\": \"142\",\n          \"stakeActiveEpoch\": \"143\",\n          \"principal\": \"200000000000\",\n          \"status\": \"Pending\"\n        }\n      ]\n    },\n    {\n      \"validatorAddress\": \"0x02c75973a51c17180798237326a58694a2cf5cd6fa76ed1d18f05f15e3507525\",\n      \"stakingPool\": \"0x2ddec4fb83621d55952d9172fcfcb72feae238b3186a7bb26a1ab2c982a0a9b4\",\n      \"stakes\": [\n        {\n          \"stakedSuiId\": \"0x82aa70f5a010fffc60f20194ef0f597474e8ceaf9ee4582d3a233101e322a22c\",\n          \"stakeRequestEpoch\": \"244\",\n          \"stakeActiveEpoch\": \"245\",\n          \"principal\": \"200000000000\",\n          \"status\": \"Unstaked\"\n        }\n      ]\n    }\n  ],\n  \"id\": 1\n}\nsuix_getStakesByIds\n\nReturn one or more [DelegatedStake]. If a Stake was withdrawn its status will be Unstaked.\n\nParameters\n\nName<Type>\nRequired\nDescription\nstaked_sui_ids<[ ObjectID ]>\nYes\n\nResult\n\nVec<DelegatedStake><[ DelegatedStake ]>\n\nExample\n\nReturns the staking information for the address the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getStakesByIds\",\n  \"params\": [\n    [\n      \"0xb2a5bea2e681ea5af4e59bd1abb0bb4fcb2747866ff92885a3c21a7703f56472\",\n      \"0x1c198308aa0c71b771ada6b96c16fc9c0fa754b3c61936f77fcfdaa213c2f7b4\"\n    ]\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"validatorAddress\": \"0xfb1b51ef9f3ed66000c0e45697dbee0954790a7b5c15ad7354f23b968be8bb06\",\n    \"stakingPool\": \"0x03d47b901cb7b3177a791cd29bb5304037fea6ced287081357950315a8842c38\",\n    \"stakes\": [\n      {\n        \"stakedSuiId\": \"0xb2a5bea2e681ea5af4e59bd1abb0bb4fcb2747866ff92885a3c21a7703f56472\",\n        \"stakeRequestEpoch\": \"62\",\n        \"stakeActiveEpoch\": \"63\",\n        \"principal\": \"200000000000\",\n        \"status\": \"Active\",\n        \"estimatedReward\": \"520000000\"\n      },\n      {\n        \"stakedSuiId\": \"0x1c198308aa0c71b771ada6b96c16fc9c0fa754b3c61936f77fcfdaa213c2f7b4\",\n        \"stakeRequestEpoch\": \"244\",\n        \"stakeActiveEpoch\": \"245\",\n        \"principal\": \"200000000000\",\n        \"status\": \"Unstaked\"\n      }\n    ]\n  },\n  \"id\": 1\n}\nsuix_getValidatorsApy\n\nReturn the validator APY\n\nParameters\n\nNone\n\nResult\n\nValidatorApys< ValidatorApys >\n\nParameter\nRequired\nDescription\napys<[ ValidatorApy ]>\nYes\nepoch< BigInt_for_uint64 >\nYes\n\nExample\n\nGets the APY for all validators.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"suix_getValidatorsApy\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"apys\": [\n      {\n        \"address\": \"0xb7d1cb695b9491893f88a5ae1b9d4f235b3c7e00acf5386662fa062483ba507b\",\n        \"apy\": 0.06\n      },\n      {\n        \"address\": \"0x1e9e3039750f0a270f2e12441ad7f611a5f7fd0b2c4326c56b1fec231d73038d\",\n        \"apy\": 0.02\n      },\n      {\n        \"address\": \"0xba0f0885b97982f5fcac3ec6f5c8cae16743671832358f25bfacde706e528df4\",\n        \"apy\": 0.05\n      }\n    ],\n    \"epoch\": \"420\"\n  },\n  \"id\": 1\n}\nMove Utils\nsui_getMoveFunctionArgTypes\n\nReturn the argument types of a Move function, based on normalized Type.\n\nParameters\n\nName<Type>\nRequired\nDescription\npackage< ObjectID >\nYes\nmodule< string >\nYes\nfunction< string >\nYes\n\nResult\n\nVec<MoveFunctionArgType><[ MoveFunctionArgType ]>\n\nExample\n\nReturns the argument types for the package and function the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getMoveFunctionArgTypes\",\n  \"params\": [\n    \"0x007efb0f94f1e64d2e8090c619a39299d87ee8070b5f56bb10bafa0e2261d819\",\n    \"suifrens\",\n    \"mint\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"Object\": \"ByMutableReference\"\n    },\n    \"Pure\",\n    \"Pure\",\n    {\n      \"Object\": \"ByValue\"\n    },\n    {\n      \"Object\": \"ByImmutableReference\"\n    },\n    {\n      \"Object\": \"ByValue\"\n    },\n    {\n      \"Object\": \"ByMutableReference\"\n    }\n  ],\n  \"id\": 1\n}\nsui_getNormalizedMoveFunction\n\nReturn a structured representation of Move function\n\nParameters\n\nName<Type>\nRequired\nDescription\npackage< ObjectID >\nYes\nmodule_name< string >\nYes\nfunction_name< string >\nYes\n\nResult\n\nSuiMoveNormalizedFunction< SuiMoveNormalizedFunction >\n\nParameter\nRequired\nDescription\nisEntry< Boolean >\nYes\nparameters<[ SuiMoveNormalizedType ]>\nYes\nreturn<[ SuiMoveNormalizedType ]>\nYes\ntypeParameters<[ SuiMoveAbilitySet ]>\nYes\nvisibility< SuiMoveVisibility >\nYes\n\nExample\n\nReturns the structured representation of the function the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getNormalizedMoveFunction\",\n  \"params\": [\n    \"0xb2582f82ab308bf9c96dfb22ec7345db1b5f14fdb2b9538efb160d31842e3a17\",\n    \"moduleName\",\n    \"functionName\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"visibility\": \"Public\",\n    \"isEntry\": false,\n    \"typeParameters\": [\n      {\n        \"abilities\": [\n          \"Store\",\n          \"Key\"\n        ]\n      }\n    ],\n    \"parameters\": [\n      \"U64\"\n    ],\n    \"return\": [\n      \"U64\"\n    ]\n  },\n  \"id\": 1\n}\nsui_getNormalizedMoveModule\n\nReturn a structured representation of Move module\n\nParameters\n\nName<Type>\nRequired\nDescription\npackage< ObjectID >\nYes\nmodule_name< string >\nYes\n\nResult\n\nSuiMoveNormalizedModule< SuiMoveNormalizedModule >\n\nParameter\nRequired\nDescription\naddress< string >\nYes\nexposedFunctions< SuiMoveNormalizedFunction >\nYes\nfileFormatVersion< uint32 >\nYes\nfriends<[ SuiMoveModuleId ]>\nYes\nname< string >\nYes\nstructs< SuiMoveNormalizedStruct >\nYes\n\nExample\n\nGets a structured representation of the Move module for the package in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getNormalizedMoveModule\",\n  \"params\": [\n    \"0x16dc6797cf787c839a07edc03e633842109123618df6438d21a48040e6bb568c\",\n    \"module\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"fileFormatVersion\": 6,\n    \"address\": \"0x43cc4c24010dafad05b12619b275649741cc9060d87664c26a3f9a509228c21b\",\n    \"name\": \"module\",\n    \"friends\": [],\n    \"structs\": {},\n    \"exposedFunctions\": {}\n  },\n  \"id\": 1\n}\nsui_getNormalizedMoveModulesByPackage\n\nReturn structured representations of all modules in the given package\n\nParameters\n\nName<Type>\nRequired\nDescription\npackage< ObjectID >\nYes\n\nResult\n\nBTreeMap<String,SuiMoveNormalizedModule>< SuiMoveNormalizedModule >\n\nExample\n\nGets structured representations of all the modules for the package in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getNormalizedMoveModulesByPackage\",\n  \"params\": [\n    \"0xece356d10d89e75f565b0934851ba8d5bc59462a46078b90f1f508a1e4fd4eed\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"fileFormatVersion\": 6,\n    \"address\": \"0xafc13246bd847c60448160e0358cac4a11345594d02890c986dbf328d28d21ac\",\n    \"name\": \"module\",\n    \"friends\": [],\n    \"structs\": {},\n    \"exposedFunctions\": {}\n  },\n  \"id\": 1\n}\nsui_getNormalizedMoveStruct\n\nReturn a structured representation of Move struct\n\nParameters\n\nName<Type>\nRequired\nDescription\npackage< ObjectID >\nYes\nmodule_name< string >\nYes\nstruct_name< string >\nYes\n\nResult\n\nSuiMoveNormalizedStruct< SuiMoveNormalizedStruct >\n\nParameter\nRequired\nDescription\nabilities< SuiMoveAbilitySet >\nYes\nfields<[ SuiMoveNormalizedField ]>\nYes\ntypeParameters<[ SuiMoveStructTypeParameter ]>\nYes\n\nExample\n\nGets a structured representation of the struct in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getNormalizedMoveStruct\",\n  \"params\": [\n    \"0x46c25c211cb35c05d801c769b78770474957b37379c527753c5c8ab783f697e7\",\n    \"module\",\n    \"StructName\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"abilities\": {\n      \"abilities\": [\n        \"Store\",\n        \"Key\"\n      ]\n    },\n    \"typeParameters\": [],\n    \"fields\": []\n  },\n  \"id\": 1\n}\nRead API\nsui_getChainIdentifier\n\nReturn the first four bytes of the chain's genesis checkpoint digest.\n\nParameters\n\nNone\n\nResult\n\nString< string >\n\nExample\n\nGets the identifier for the chain receiving the POST.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getChainIdentifier\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": \"4c78adac\",\n  \"id\": 1\n}\nsui_getCheckpoint\n\nReturn a checkpoint\n\nParameters\n\nName<Type>\nRequired\nDescription\nid< CheckpointId >\nYes\nCheckpoint identifier, can use either checkpoint digest, or checkpoint sequence number as input.\n\nResult\n\nCheckpoint< Checkpoint >\n\nParameter\nRequired\nDescription\ncheckpointCommitments<[ CheckpointCommitment ]>\nYes\nCommitments to checkpoint state\ndigest< CheckpointDigest >\nYes\nCheckpoint digest\nendOfEpochData< EndOfEpochData | null >\nNo\nPresent only on the final checkpoint of the epoch.\nepoch< BigInt_for_uint64 >\nYes\nCheckpoint's epoch ID\nepochRollingGasCostSummary< GasCostSummary >\nYes\nThe running total gas costs of all transactions included in the current epoch so far until this checkpoint.\nnetworkTotalTransactions< BigInt_for_uint64 >\nYes\nTotal number of transactions committed since genesis, including those in this checkpoint.\npreviousDigest< CheckpointDigest | null >\nNo\nDigest of the previous checkpoint\nsequenceNumber< BigInt_for_uint64 >\nYes\nCheckpoint sequence number\ntimestampMs< BigInt_for_uint64 >\nYes\nTimestamp of the checkpoint - number of milliseconds from the Unix epoch Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent checkpoints can have same timestamp if they originate from the same underlining consensus commit\ntransactions<[ TransactionDigest ]>\nYes\nTransaction digests\nvalidatorSignature< Base64 >\nYes\nValidator Signature\n\nExample\n\nGets checkpoint information for the checkpoint ID in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getCheckpoint\",\n  \"params\": [\n    \"1000\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"epoch\": \"5000\",\n    \"sequenceNumber\": \"1000\",\n    \"digest\": \"G6Dtzr1ZSfHFhotGsTE3cLENa7L1ooe1BBvknAUsARbV\",\n    \"networkTotalTransactions\": \"792385\",\n    \"previousDigest\": \"6tBy8RXZKrdrB4XkMQn7J3MNG4fQCo9XcRduFFvYrL5Z\",\n    \"epochRollingGasCostSummary\": {\n      \"computationCost\": \"0\",\n      \"storageCost\": \"0\",\n      \"storageRebate\": \"0\",\n      \"nonRefundableStorageFee\": \"0\"\n    },\n    \"timestampMs\": \"1676911928\",\n    \"transactions\": [\n      \"mN8YNBgVR3wB7vfXmjVgDRF4oqxVRRjzmJ6U4mzbq77\"\n    ],\n    \"checkpointCommitments\": [],\n    \"validatorSignature\": \"wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n  },\n  \"id\": 1\n}\nsui_getCheckpoints\n\nReturn paginated list of checkpoints\n\nParameters\n\nName<Type>\nRequired\nDescription\ncursor< BigInt_for_uint64 >\nNo\nAn optional paging cursor. If provided, the query will start from the next item after the specified cursor. Default to start from the first item if not specified.\nlimit< uint >\nNo\nMaximum item returned per page, default to [QUERY_MAX_RESULT_LIMIT_CHECKPOINTS] if not specified.\ndescending_order< Boolean >\nYes\nQuery result ordering, default to false (ascending order), oldest record first.\n\nResult\n\nCheckpointPage< Page_for_Checkpoint_and_BigInt_for_uint64 >\n\nnext_cursor points to the last item in the page; Reading with next_cursor will start from the next item after next_cursor if next_cursor is Some, otherwise it will start from the first item.\n\nParameter\nRequired\nDescription\ndata<[ Checkpoint ]>\nYes\nhasNextPage< Boolean >\nYes\nnextCursor< BigInt_for_uint64 | null >\nNo\n\nExample\n\nGets a paginated list in descending order of all checkpoints starting at the provided cursor. Each page of results has a maximum number of checkpoints set by the provided limit.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getCheckpoints\",\n  \"params\": [\n    \"1004\",\n    4,\n    false\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"epoch\": \"5000\",\n        \"sequenceNumber\": \"1005\",\n        \"digest\": \"9zA7Q9Ka1ykvYjSQGhQCdCf32FZkcWNWx7L22JczXGsk\",\n        \"networkTotalTransactions\": \"792385\",\n        \"previousDigest\": \"8BLFxLTjWZ2KqaGc3FjR1o9aL6kbyYrmhuNfJLU1ehYt\",\n        \"epochRollingGasCostSummary\": {\n          \"computationCost\": \"0\",\n          \"storageCost\": \"0\",\n          \"storageRebate\": \"0\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"timestampMs\": \"1676911928\",\n        \"transactions\": [\n          \"7RudGLkQDBNJyqrptkrNU66Zd3pvq8MHVAHYz9WpBm59\"\n        ],\n        \"checkpointCommitments\": [],\n        \"validatorSignature\": \"wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      },\n      {\n        \"epoch\": \"5000\",\n        \"sequenceNumber\": \"1006\",\n        \"digest\": \"FAUWHyWacmb4Vg4QGi9a6gqeVb7ixAZiL73FaGd6WpoV\",\n        \"networkTotalTransactions\": \"792385\",\n        \"previousDigest\": \"6Pn25cieaE62AT6BwCeBoca13AGZuneucaaTGqt3gNCo\",\n        \"epochRollingGasCostSummary\": {\n          \"computationCost\": \"0\",\n          \"storageCost\": \"0\",\n          \"storageRebate\": \"0\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"timestampMs\": \"1676911928\",\n        \"transactions\": [\n          \"7r7tmP5hzgrusiN6cucFwfTveqDb7K75tMJ7oNCyoDmy\"\n        ],\n        \"checkpointCommitments\": [],\n        \"validatorSignature\": \"wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      },\n      {\n        \"epoch\": \"5000\",\n        \"sequenceNumber\": \"1007\",\n        \"digest\": \"B3mzC6gy87SomUQwPsmVY7mtwkZLxfm5WwNi3kKyEb3x\",\n        \"networkTotalTransactions\": \"792385\",\n        \"previousDigest\": \"CnHTfdUJr1UUqwXkYUhbQjXeM16xR33UR62jE72toCis\",\n        \"epochRollingGasCostSummary\": {\n          \"computationCost\": \"0\",\n          \"storageCost\": \"0\",\n          \"storageRebate\": \"0\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"timestampMs\": \"1676911928\",\n        \"transactions\": [\n          \"Gb1UDqhmKMzMJ5FL37kBqCcuy4TtBL2ay3qec8tEUBLj\"\n        ],\n        \"checkpointCommitments\": [],\n        \"validatorSignature\": \"wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      },\n      {\n        \"epoch\": \"5000\",\n        \"sequenceNumber\": \"1008\",\n        \"digest\": \"HunuJWKu7azBfS47rJTq9FHTMvUDNVo2SK4hQeh5brXp\",\n        \"networkTotalTransactions\": \"792385\",\n        \"previousDigest\": \"38fLUfuigyzLPEDrsmRhcQmhKtbEUohuFBP9NDcWBmFz\",\n        \"epochRollingGasCostSummary\": {\n          \"computationCost\": \"0\",\n          \"storageCost\": \"0\",\n          \"storageRebate\": \"0\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"timestampMs\": \"1676911928\",\n        \"transactions\": [\n          \"GWTS9QR7mjNz9fBWGkk4JZU3mrzMXrmj74uS59Cd5und\"\n        ],\n        \"checkpointCommitments\": [],\n        \"validatorSignature\": \"wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      }\n    ],\n    \"nextCursor\": \"1008\",\n    \"hasNextPage\": true\n  },\n  \"id\": 1\n}\nsui_getEvents\n\nReturn transaction events.\n\nParameters\n\nName<Type>\nRequired\nDescription\ntransaction_digest< TransactionDigest >\nYes\nThe event query criteria.\n\nResult\n\nVec<SuiEvent><[ Event ]>\n\nExample\n\nReturns the events the transaction in the request emits.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getEvents\",\n  \"params\": [\n    \"11a72GCQ5hGNpWGh2QhQkkusTEGS6EDqifJqxr7nSYX\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": [\n      {\n        \"id\": {\n          \"txDigest\": \"11a72GCQ5hGNpWGh2QhQkkusTEGS6EDqifJqxr7nSYX\",\n          \"eventSeq\": \"0\"\n        },\n        \"packageId\": \"0xc54ab30a3d9adc07c1429c4d6bbecaf9457c9af77a91f631760853934d383634\",\n        \"transactionModule\": \"test_module\",\n        \"sender\": \"0xbcf7c32655009a61f1de0eae420a2e4ae1bb772ab2dd5d5a7dfa949c0ef06908\",\n        \"type\": \"0x0000000000000000000000000000000000000000000000000000000000000009::test::TestEvent\",\n        \"parsedJson\": {\n          \"test\": \"example value\"\n        },\n        \"bcs\": \"\"\n      }\n    ],\n    \"nextCursor\": {\n      \"txDigest\": \"11a72GCQ5hGNpWGh2QhQkkusTEGS6EDqifJqxr7nSYX\",\n      \"eventSeq\": \"5\"\n    },\n    \"hasNextPage\": false\n  },\n  \"id\": 1\n}\nsui_getLatestCheckpointSequenceNumber\n\nReturn the sequence number of the latest checkpoint that has been executed\n\nParameters\n\nNone\n\nResult\n\nBigInt<u64>< BigInt_for_uint64 >\n\nExample\n\nGets the sequence number for the latest checkpoint.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getLatestCheckpointSequenceNumber\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": \"507021\",\n  \"id\": 1\n}\nsui_getLoadedChildObjects\n\nParameters\n\nName<Type>\nRequired\nDescription\ndigest< TransactionDigest >\nYes\n\nResult\n\nSuiLoadedChildObjectsResponse< LoadedChildObjectsResponse >\n\nParameter\nRequired\nDescription\nloadedChildObjects<[ LoadedChildObject ]>\nYes\n\nExample\n\nGets loaded child objects associated with the transaction the request provides.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getLoadedChildObjects\",\n  \"params\": [\n    \"6hpz6Qxv6t5VkNT5rcBKQS2Jootr6WHuSuRMLmmN13Jg\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"loadedChildObjects\": [\n      {\n        \"objectId\": \"0xb6a23efeb7298cf0a8d0b837b78749c2cfc711c42036cc6b76211639f3606a53\",\n        \"sequenceNumber\": \"2462820\"\n      },\n      {\n        \"objectId\": \"0xf61f3a566963b3eac49fe3bb57d304a454ed2f4859b44f4e49180047d5fa0a82\",\n        \"sequenceNumber\": \"2462820\"\n      },\n      {\n        \"objectId\": \"0xd55c32b09995a0ae1eedfee9c7b1354e805ed10ee3d0800105867da4655eca6d\",\n        \"sequenceNumber\": \"2164186\"\n      },\n      {\n        \"objectId\": \"0x258bfd1ad92af329a07781ee71e60065e00f2de961630d3505f8905a0f4d42c6\",\n        \"sequenceNumber\": \"3350147\"\n      },\n      {\n        \"objectId\": \"0xa78a6ba2b28f68a3299ec3417bbabc6717dcc95b9e341bc3aba1654bdbad707d\",\n        \"sequenceNumber\": \"3560717\"\n      },\n      {\n        \"objectId\": \"0xcd773bd6309363447ef3fe58a960de92aa9377b3482580ee8d5bdc5b824808df\",\n        \"sequenceNumber\": \"3560717\"\n      }\n    ]\n  },\n  \"id\": 1\n}\nsui_getObject\n\nReturn the object information for a specified object\n\nParameters\n\nName<Type>\nRequired\nDescription\nobject_id< ObjectID >\nYes\nThe ID of the queried object\noptions< ObjectDataOptions >\nNo\nOptions for specifying the content to be returned\n\nResult\n\nSuiObjectResponse< SuiObjectResponse >\n\nParameter\nRequired\nDescription\ndata< ObjectData | null >\nNo\nerror< ObjectResponseError | null >\nNo\n\nExample\n\nGets Object data for the ID in the request.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getObject\",\n  \"params\": [\n    \"0x53e4567ccafa5f36ce84c80aa8bc9be64e0d5ae796884274aef3005ae6733809\",\n    {\n      \"showType\": true,\n      \"showOwner\": true,\n      \"showPreviousTransaction\": true,\n      \"showDisplay\": false,\n      \"showContent\": true,\n      \"showBcs\": false,\n      \"showStorageRebate\": true\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"data\": {\n      \"objectId\": \"0x53e4567ccafa5f36ce84c80aa8bc9be64e0d5ae796884274aef3005ae6733809\",\n      \"version\": \"1\",\n      \"digest\": \"33K5ZXJ3RyubvYaHuEnQ1QXmmbhgtrFwp199dnEbL4n7\",\n      \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n      \"owner\": {\n        \"AddressOwner\": \"0xc8ec1d5b84dd6289e193b9f88de4a994358c9f856135236c3e75a925e1c77ac3\"\n      },\n      \"previousTransaction\": \"5PLgmQye6rraDYqpV3npV6H1cUXoJZgJh1dPCyRa3WCv\",\n      \"storageRebate\": \"100\",\n      \"content\": {\n        \"dataType\": \"moveObject\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"hasPublicTransfer\": true,\n        \"fields\": {\n          \"balance\": \"100000000\",\n          \"id\": {\n            \"id\": \"0x53e4567ccafa5f36ce84c80aa8bc9be64e0d5ae796884274aef3005ae6733809\"\n          }\n        }\n      }\n    }\n  },\n  \"id\": 1\n}\nsui_getProtocolConfig\n\nReturn the protocol config table for the given version number. If the version number is not specified, If none is specified, the node uses the version of the latest epoch it has processed.\n\nParameters\n\nName<Type>\nRequired\nDescription\nversion< BigInt_for_uint64 >\nNo\nAn optional protocol version specifier. If omitted, the latest protocol config table for the node will be returned.\n\nResult\n\nProtocolConfigResponse< ProtocolConfig >\n\nParameter\nRequired\nDescription\nattributes< Boolean >\nYes\nfeatureFlags< Boolean >\nYes\nmaxSupportedProtocolVersion< ProtocolVersion >\nYes\nminSupportedProtocolVersion< ProtocolVersion >\nYes\nprotocolVersion< ProtocolVersion >\nYes\n\nExample\n\nReturns the protocol config for the given protocol version. If none is specified, the node uses the version of the latest epoch it has processed\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getProtocolConfig\",\n  \"params\": [\n    6\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"minSupportedProtocolVersion\": \"1\",\n    \"maxSupportedProtocolVersion\": \"44\",\n    \"protocolVersion\": \"6\",\n    \"featureFlags\": {\n      \"accept_zklogin_in_multisig\": false,\n      \"advance_epoch_start_time_in_safe_mode\": true,\n      \"advance_to_highest_supported_protocol_version\": false,\n      \"allow_receiving_object_id\": false,\n      \"ban_entry_init\": false,\n      \"commit_root_state_digest\": false,\n      \"consensus_order_end_of_epoch_last\": true,\n      \"disable_invariant_violation_check_in_swap_loc\": false,\n      \"disallow_adding_abilities_on_upgrade\": false,\n      \"disallow_change_struct_type_params_on_upgrade\": false,\n      \"enable_coin_deny_list\": false,\n      \"enable_effects_v2\": false,\n      \"enable_group_ops_native_function_msm\": false,\n      \"enable_group_ops_native_functions\": false,\n      \"enable_jwk_consensus_updates\": false,\n      \"enable_poseidon\": false,\n      \"end_of_epoch_transaction_supported\": false,\n      \"hardened_otw_check\": false,\n      \"include_consensus_digest_in_prologue\": false,\n      \"loaded_child_object_format\": false,\n      \"loaded_child_object_format_type\": false,\n      \"loaded_child_objects_fixed\": true,\n      \"missing_type_is_compatibility_error\": true,\n      \"narwhal_certificate_v2\": false,\n      \"narwhal_new_leader_election_schedule\": false,\n      \"narwhal_versioned_metadata\": false,\n      \"no_extraneous_module_bytes\": false,\n      \"package_digest_hash_module\": false,\n      \"package_upgrades\": true,\n      \"random_beacon\": false,\n      \"receive_objects\": false,\n      \"recompute_has_public_transfer_in_execution\": false,\n      \"reject_mutable_random_on_entry_functions\": false,\n      \"scoring_decision_with_validity_cutoff\": true,\n      \"shared_object_deletion\": false,\n      \"simple_conservation_checks\": false,\n      \"simplified_unwrap_then_delete\": false,\n      \"throughput_aware_consensus_submission\": false,\n      \"txn_base_cost_as_multiplier\": false,\n      \"upgraded_multisig_supported\": false,\n      \"verify_legacy_zklogin_address\": false,\n      \"zklogin_auth\": false\n    },\n    \"attributes\": {\n      \"address_from_bytes_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"address_from_u256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"address_to_u256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"base_tx_cost_fixed\": {\n        \"u64\": \"2000\"\n      },\n      \"base_tx_cost_per_byte\": {\n        \"u64\": \"0\"\n      },\n      \"binary_address_identifiers\": null,\n      \"binary_constant_pool\": null,\n      \"binary_field_handles\": null,\n      \"binary_field_instantiations\": null,\n      \"binary_friend_decls\": null,\n      \"binary_function_defs\": null,\n      \"binary_function_handles\": null,\n      \"binary_function_instantiations\": null,\n      \"binary_identifiers\": null,\n      \"binary_module_handles\": null,\n      \"binary_signatures\": null,\n      \"binary_struct_def_instantiations\": null,\n      \"binary_struct_defs\": null,\n      \"binary_struct_handles\": null,\n      \"bls12381_bls12381_min_pk_verify_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"bls12381_bls12381_min_pk_verify_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"bls12381_bls12381_min_pk_verify_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"bls12381_bls12381_min_sig_verify_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"bls12381_bls12381_min_sig_verify_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"bls12381_bls12381_min_sig_verify_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"buffer_stake_for_protocol_upgrade_bps\": {\n        \"u64\": \"5000\"\n      },\n      \"check_zklogin_id_cost_base\": null,\n      \"check_zklogin_issuer_cost_base\": null,\n      \"consensus_bad_nodes_stake_threshold\": null,\n      \"consensus_max_transaction_size_bytes\": null,\n      \"consensus_max_transactions_in_block_bytes\": null,\n      \"crypto_invalid_arguments_cost\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_add_child_object_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_add_child_object_struct_tag_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"dynamic_field_add_child_object_type_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"dynamic_field_add_child_object_value_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"dynamic_field_borrow_child_object_child_ref_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"dynamic_field_borrow_child_object_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_borrow_child_object_type_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"dynamic_field_has_child_object_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_has_child_object_with_ty_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_has_child_object_with_ty_type_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_has_child_object_with_ty_type_tag_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_hash_type_and_key_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_hash_type_and_key_type_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_hash_type_and_key_type_tag_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_hash_type_and_key_value_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_remove_child_object_child_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"dynamic_field_remove_child_object_cost_base\": {\n        \"u64\": \"100\"\n      },\n      \"dynamic_field_remove_child_object_type_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_decompress_pubkey_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_k1_ecrecover_keccak256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_k1_ecrecover_keccak256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_ecrecover_keccak256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_ecrecover_sha256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_k1_ecrecover_sha256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_ecrecover_sha256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_secp256k1_verify_keccak256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_k1_secp256k1_verify_keccak256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_secp256k1_verify_keccak256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_secp256k1_verify_sha256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_k1_secp256k1_verify_sha256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_k1_secp256k1_verify_sha256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_ecrecover_keccak256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_r1_ecrecover_keccak256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_ecrecover_keccak256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_ecrecover_sha256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_r1_ecrecover_sha256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_ecrecover_sha256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_secp256r1_verify_keccak256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_r1_secp256r1_verify_keccak256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_secp256r1_verify_keccak256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_secp256r1_verify_sha256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ecdsa_r1_secp256r1_verify_sha256_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecdsa_r1_secp256r1_verify_sha256_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecvrf_ecvrf_verify_alpha_string_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ecvrf_ecvrf_verify_alpha_string_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"ecvrf_ecvrf_verify_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ed25519_ed25519_verify_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"ed25519_ed25519_verify_msg_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"ed25519_ed25519_verify_msg_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"event_emit_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"event_emit_output_cost_per_byte\": {\n        \"u64\": \"10\"\n      },\n      \"event_emit_tag_size_derivation_cost_per_byte\": {\n        \"u64\": \"5\"\n      },\n      \"event_emit_value_size_derivation_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"execution_version\": null,\n      \"gas_model_version\": {\n        \"u64\": \"5\"\n      },\n      \"gas_rounding_step\": null,\n      \"groth16_prepare_verifying_key_bls12381_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"groth16_prepare_verifying_key_bn254_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"groth16_verify_groth16_proof_internal_bls12381_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"groth16_verify_groth16_proof_internal_bls12381_cost_per_public_input\": {\n        \"u64\": \"2\"\n      },\n      \"groth16_verify_groth16_proof_internal_bn254_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"groth16_verify_groth16_proof_internal_bn254_cost_per_public_input\": {\n        \"u64\": \"2\"\n      },\n      \"groth16_verify_groth16_proof_internal_public_input_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"group_ops_bls12381_decode_g1_cost\": null,\n      \"group_ops_bls12381_decode_g2_cost\": null,\n      \"group_ops_bls12381_decode_gt_cost\": null,\n      \"group_ops_bls12381_decode_scalar_cost\": null,\n      \"group_ops_bls12381_g1_add_cost\": null,\n      \"group_ops_bls12381_g1_div_cost\": null,\n      \"group_ops_bls12381_g1_hash_to_base_cost\": null,\n      \"group_ops_bls12381_g1_hash_to_cost_per_byte\": null,\n      \"group_ops_bls12381_g1_msm_base_cost\": null,\n      \"group_ops_bls12381_g1_msm_base_cost_per_input\": null,\n      \"group_ops_bls12381_g1_mul_cost\": null,\n      \"group_ops_bls12381_g1_sub_cost\": null,\n      \"group_ops_bls12381_g2_add_cost\": null,\n      \"group_ops_bls12381_g2_div_cost\": null,\n      \"group_ops_bls12381_g2_hash_to_base_cost\": null,\n      \"group_ops_bls12381_g2_hash_to_cost_per_byte\": null,\n      \"group_ops_bls12381_g2_msm_base_cost\": null,\n      \"group_ops_bls12381_g2_msm_base_cost_per_input\": null,\n      \"group_ops_bls12381_g2_mul_cost\": null,\n      \"group_ops_bls12381_g2_sub_cost\": null,\n      \"group_ops_bls12381_gt_add_cost\": null,\n      \"group_ops_bls12381_gt_div_cost\": null,\n      \"group_ops_bls12381_gt_mul_cost\": null,\n      \"group_ops_bls12381_gt_sub_cost\": null,\n      \"group_ops_bls12381_msm_max_len\": null,\n      \"group_ops_bls12381_pairing_cost\": null,\n      \"group_ops_bls12381_scalar_add_cost\": null,\n      \"group_ops_bls12381_scalar_div_cost\": null,\n      \"group_ops_bls12381_scalar_mul_cost\": null,\n      \"group_ops_bls12381_scalar_sub_cost\": null,\n      \"hash_blake2b256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"hash_blake2b256_data_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"hash_blake2b256_data_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"hash_keccak256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"hash_keccak256_data_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"hash_keccak256_data_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"hmac_hmac_sha3_256_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"hmac_hmac_sha3_256_input_cost_per_block\": {\n        \"u64\": \"2\"\n      },\n      \"hmac_hmac_sha3_256_input_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"max_accumulated_txn_cost_per_object_in_checkpoint\": null,\n      \"max_age_of_jwk_in_epochs\": null,\n      \"max_arguments\": {\n        \"u32\": \"512\"\n      },\n      \"max_back_edges_per_function\": {\n        \"u64\": \"10000\"\n      },\n      \"max_back_edges_per_module\": {\n        \"u64\": \"10000\"\n      },\n      \"max_basic_blocks\": {\n        \"u64\": \"1024\"\n      },\n      \"max_checkpoint_size_bytes\": {\n        \"u64\": \"31457280\"\n      },\n      \"max_dependency_depth\": {\n        \"u64\": \"100\"\n      },\n      \"max_event_emit_size\": {\n        \"u64\": \"256000\"\n      },\n      \"max_event_emit_size_total\": null,\n      \"max_fields_in_struct\": {\n        \"u64\": \"32\"\n      },\n      \"max_function_definitions\": {\n        \"u64\": \"1000\"\n      },\n      \"max_function_parameters\": {\n        \"u64\": \"128\"\n      },\n      \"max_gas_computation_bucket\": {\n        \"u64\": \"5000000\"\n      },\n      \"max_gas_payment_objects\": {\n        \"u32\": \"256\"\n      },\n      \"max_gas_price\": {\n        \"u64\": \"100000\"\n      },\n      \"max_generic_instantiation_length\": {\n        \"u64\": \"32\"\n      },\n      \"max_input_objects\": {\n        \"u64\": \"2048\"\n      },\n      \"max_jwk_votes_per_validator_per_epoch\": null,\n      \"max_loop_depth\": {\n        \"u64\": \"5\"\n      },\n      \"max_meter_ticks_per_module\": {\n        \"u64\": \"6000000\"\n      },\n      \"max_meter_ticks_per_package\": null,\n      \"max_modules_in_publish\": {\n        \"u32\": \"128\"\n      },\n      \"max_move_identifier_len\": null,\n      \"max_move_object_size\": {\n        \"u64\": \"256000\"\n      },\n      \"max_move_package_size\": {\n        \"u64\": \"102400\"\n      },\n      \"max_move_value_depth\": null,\n      \"max_move_vector_len\": {\n        \"u64\": \"262144\"\n      },\n      \"max_num_deleted_move_object_ids\": {\n        \"u64\": \"2048\"\n      },\n      \"max_num_deleted_move_object_ids_system_tx\": {\n        \"u64\": \"32768\"\n      },\n      \"max_num_event_emit\": {\n        \"u64\": \"256\"\n      },\n      \"max_num_new_move_object_ids\": {\n        \"u64\": \"2048\"\n      },\n      \"max_num_new_move_object_ids_system_tx\": {\n        \"u64\": \"32768\"\n      },\n      \"max_num_transferred_move_object_ids\": {\n        \"u64\": \"2048\"\n      },\n      \"max_num_transferred_move_object_ids_system_tx\": {\n        \"u64\": \"32768\"\n      },\n      \"max_package_dependencies\": null,\n      \"max_programmable_tx_commands\": {\n        \"u32\": \"1024\"\n      },\n      \"max_publish_or_upgrade_per_ptb\": null,\n      \"max_pure_argument_size\": {\n        \"u32\": \"16384\"\n      },\n      \"max_push_size\": {\n        \"u64\": \"10000\"\n      },\n      \"max_serialized_tx_effects_size_bytes\": {\n        \"u64\": \"524288\"\n      },\n      \"max_serialized_tx_effects_size_bytes_system_tx\": {\n        \"u64\": \"8388608\"\n      },\n      \"max_size_written_objects\": {\n        \"u64\": \"5000000\"\n      },\n      \"max_size_written_objects_system_tx\": {\n        \"u64\": \"50000000\"\n      },\n      \"max_struct_definitions\": {\n        \"u64\": \"200\"\n      },\n      \"max_transactions_per_checkpoint\": {\n        \"u64\": \"10000\"\n      },\n      \"max_tx_gas\": {\n        \"u64\": \"50000000000\"\n      },\n      \"max_tx_size_bytes\": {\n        \"u64\": \"131072\"\n      },\n      \"max_type_argument_depth\": {\n        \"u32\": \"16\"\n      },\n      \"max_type_arguments\": {\n        \"u32\": \"16\"\n      },\n      \"max_type_nodes\": {\n        \"u64\": \"256\"\n      },\n      \"max_value_stack_size\": {\n        \"u64\": \"1024\"\n      },\n      \"max_verifier_meter_ticks_per_function\": {\n        \"u64\": \"6000000\"\n      },\n      \"move_binary_format_version\": {\n        \"u32\": \"6\"\n      },\n      \"obj_access_cost_delete_per_byte\": {\n        \"u64\": \"40\"\n      },\n      \"obj_access_cost_mutate_per_byte\": {\n        \"u64\": \"40\"\n      },\n      \"obj_access_cost_read_per_byte\": {\n        \"u64\": \"15\"\n      },\n      \"obj_access_cost_verify_per_byte\": {\n        \"u64\": \"200\"\n      },\n      \"obj_data_cost_refundable\": {\n        \"u64\": \"100\"\n      },\n      \"obj_metadata_cost_non_refundable\": {\n        \"u64\": \"50\"\n      },\n      \"object_borrow_uid_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"object_delete_impl_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"object_record_new_uid_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"object_runtime_max_num_cached_objects\": {\n        \"u64\": \"1000\"\n      },\n      \"object_runtime_max_num_cached_objects_system_tx\": {\n        \"u64\": \"16000\"\n      },\n      \"object_runtime_max_num_store_entries\": {\n        \"u64\": \"1000\"\n      },\n      \"object_runtime_max_num_store_entries_system_tx\": {\n        \"u64\": \"16000\"\n      },\n      \"package_publish_cost_fixed\": {\n        \"u64\": \"1000\"\n      },\n      \"package_publish_cost_per_byte\": {\n        \"u64\": \"80\"\n      },\n      \"poseidon_bn254_cost_base\": null,\n      \"poseidon_bn254_cost_per_block\": null,\n      \"random_beacon_dkg_timeout_round\": null,\n      \"random_beacon_reduction_allowed_delta\": null,\n      \"random_beacon_reduction_lower_bound\": null,\n      \"reward_slashing_rate\": {\n        \"u64\": \"10000\"\n      },\n      \"scoring_decision_cutoff_value\": {\n        \"f64\": \"2.5\"\n      },\n      \"scoring_decision_mad_divisor\": {\n        \"f64\": \"2.3\"\n      },\n      \"storage_fund_reinvest_rate\": {\n        \"u64\": \"500\"\n      },\n      \"storage_gas_price\": {\n        \"u64\": \"76\"\n      },\n      \"storage_rebate_rate\": {\n        \"u64\": \"9900\"\n      },\n      \"transfer_freeze_object_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"transfer_receive_object_cost_base\": null,\n      \"transfer_share_object_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"transfer_transfer_internal_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"tx_context_derive_id_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"types_is_one_time_witness_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"types_is_one_time_witness_type_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"types_is_one_time_witness_type_tag_cost_per_byte\": {\n        \"u64\": \"2\"\n      },\n      \"validator_validate_metadata_cost_base\": {\n        \"u64\": \"52\"\n      },\n      \"validator_validate_metadata_data_cost_per_byte\": {\n        \"u64\": \"2\"\n      }\n    }\n  },\n  \"id\": 1\n}\nsui_getTotalTransactionBlocks\n\nReturn the total number of transaction blocks known to the server.\n\nParameters\n\nNone\n\nResult\n\nBigInt<u64>< BigInt_for_uint64 >\n\nExample\n\nGets total number of transactions on the network.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getTotalTransactionBlocks\",\n  \"params\": []\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": \"2451485\",\n  \"id\": 1\n}\nsui_getTransactionBlock\n\nReturn the transaction response object.\n\nParameters\n\nName<Type>\nRequired\nDescription\ndigest< TransactionDigest >\nYes\nThe digest of the queried transaction\noptions< TransactionBlockResponseOptions >\nNo\nOptions for specifying the content to be returned\n\nResult\n\nSuiTransactionBlockResponse< TransactionBlockResponse >\n\nParameter\nRequired\nDescription\nbalanceChanges< BalanceChange [array,null] >\nNo\ncheckpoint< BigInt_for_uint64 | null >\nNo\nThe checkpoint number when this transaction was included and hence finalized. This is only returned in the read api, not in the transaction execution api.\nconfirmedLocalExecution< [boolean,null] >\nNo\ndigest< TransactionDigest >\nYes\neffects< TransactionBlockEffects | null >\nNo\nerrors<[ string ]>\nNo\nevents< Event [array,null] >\nNo\nobjectChanges< ObjectChange [array,null] >\nNo\nrawEffects<[ string ]>\nNo\nrawTransaction< Base64 >\nNo\nBCS encoded [SenderSignedData] that includes input object references returns empty array if show_raw_transaction is false\ntimestampMs< BigInt_for_uint64 | null >\nNo\ntransaction< TransactionBlock | null >\nNo\nTransaction input data\n\nExample\n\nReturns the transaction response object for specified transaction digest.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getTransactionBlock\",\n  \"params\": [\n    \"Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF\",\n    {\n      \"showInput\": true,\n      \"showRawInput\": false,\n      \"showEffects\": true,\n      \"showEvents\": true,\n      \"showObjectChanges\": false,\n      \"showBalanceChanges\": false,\n      \"showRawEffects\": false\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"digest\": \"Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF\",\n    \"transaction\": {\n      \"data\": {\n        \"messageVersion\": \"v1\",\n        \"transaction\": {\n          \"kind\": \"ProgrammableTransaction\",\n          \"inputs\": [\n            {\n              \"type\": \"pure\",\n              \"valueType\": \"address\",\n              \"value\": \"0x8196d048b7a6d04c8edc89579d86fd3fc90c52f9a14c6b812b94fe613c5bcebb\"\n            },\n            {\n              \"type\": \"object\",\n              \"objectType\": \"immOrOwnedObject\",\n              \"objectId\": \"0x5eeb1d449e2516166d57d71fdeb154d0dc9ecdb7b30057d0a932684cac352cdc\",\n              \"version\": \"2\",\n              \"digest\": \"GK4NxEKSrK88XkPNeuBqtJYPmU9yMTWMD7K9TdU4ybKN\"\n            }\n          ],\n          \"transactions\": [\n            {\n              \"TransferObjects\": [\n                [\n                  {\n                    \"Input\": 1\n                  }\n                ],\n                {\n                  \"Input\": 0\n                }\n              ]\n            }\n          ]\n        },\n        \"sender\": \"0x82179c57d5895babfb655cd62e8e886a53334b5e7be9be658eb759cc35e3fc66\",\n        \"gasData\": {\n          \"payment\": [\n            {\n              \"objectId\": \"0x1a3e898029d024eec1d44c6af5e2facded84d03b5373514f16e3d66e00081051\",\n              \"version\": 2,\n              \"digest\": \"7nDZ5J4VyvYGUbX2f6mQdhkr3RFrb3vZqui1ogoyApD9\"\n            }\n          ],\n          \"owner\": \"0x82179c57d5895babfb655cd62e8e886a53334b5e7be9be658eb759cc35e3fc66\",\n          \"price\": \"10\",\n          \"budget\": \"100000\"\n        }\n      },\n      \"txSignatures\": [\n        \"AMU7cJTEsJ5WoVlKZ2zsVuGMk9linDuNqLV9eGIIrqarP2x4R9riuvmmMgXfdxMm7jTzYxbHrsDNMwlxpTbbFghtCxWrqsEEHAdxoMDwblU5hyWJ8H3zFvk20E2fO5bzHA==\"\n      ]\n    },\n    \"rawTransaction\": \"AQAAAAAAAgAggZbQSLem0EyO3IlXnYb9P8kMUvmhTGuBK5T+YTxbzrsBAF7rHUSeJRYWbVfXH96xVNDcns23swBX0KkyaEysNSzcAgAAAAAAAAAg43+UGkUe+CCaD7+/G1SbK7Jrjq7giJUUbfJ7w88mEMEBAQEBAQABAACCF5xX1Ylbq/tlXNYujohqUzNLXnvpvmWOt1nMNeP8ZgEaPomAKdAk7sHUTGr14vrN7YTQO1NzUU8W49ZuAAgQUQIAAAAAAAAAIGS7c6HtWLLBiwy/N3eS4gbmuA1NXupk4ucFY7FYkCbEghecV9WJW6v7ZVzWLo6IalMzS1576b5ljrdZzDXj/GYKAAAAAAAAAKCGAQAAAAAAAAFhAMU7cJTEsJ5WoVlKZ2zsVuGMk9linDuNqLV9eGIIrqarP2x4R9riuvmmMgXfdxMm7jTzYxbHrsDNMwlxpTbbFghtCxWrqsEEHAdxoMDwblU5hyWJ8H3zFvk20E2fO5bzHA==\",\n    \"effects\": {\n      \"messageVersion\": \"v1\",\n      \"status\": {\n        \"status\": \"success\"\n      },\n      \"executedEpoch\": \"0\",\n      \"gasUsed\": {\n        \"computationCost\": \"100\",\n        \"storageCost\": \"100\",\n        \"storageRebate\": \"10\",\n        \"nonRefundableStorageFee\": \"0\"\n      },\n      \"transactionDigest\": \"6AyFnAuKAKCqm1cD94EyGzBqJCDDJ716ojjmsKF2rqoi\",\n      \"mutated\": [\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x82179c57d5895babfb655cd62e8e886a53334b5e7be9be658eb759cc35e3fc66\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x1a3e898029d024eec1d44c6af5e2facded84d03b5373514f16e3d66e00081051\",\n            \"version\": 2,\n            \"digest\": \"7nDZ5J4VyvYGUbX2f6mQdhkr3RFrb3vZqui1ogoyApD9\"\n          }\n        },\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x8196d048b7a6d04c8edc89579d86fd3fc90c52f9a14c6b812b94fe613c5bcebb\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x5eeb1d449e2516166d57d71fdeb154d0dc9ecdb7b30057d0a932684cac352cdc\",\n            \"version\": 2,\n            \"digest\": \"GK4NxEKSrK88XkPNeuBqtJYPmU9yMTWMD7K9TdU4ybKN\"\n          }\n        }\n      ],\n      \"gasObject\": {\n        \"owner\": {\n          \"ObjectOwner\": \"0x82179c57d5895babfb655cd62e8e886a53334b5e7be9be658eb759cc35e3fc66\"\n        },\n        \"reference\": {\n          \"objectId\": \"0x1a3e898029d024eec1d44c6af5e2facded84d03b5373514f16e3d66e00081051\",\n          \"version\": 2,\n          \"digest\": \"7nDZ5J4VyvYGUbX2f6mQdhkr3RFrb3vZqui1ogoyApD9\"\n        }\n      },\n      \"eventsDigest\": \"9BQobwxQvJ1JxSXNn8v8htZPTu8FEzJJGgcD4kgLUuMd\"\n    },\n    \"objectChanges\": [\n      {\n        \"type\": \"transferred\",\n        \"sender\": \"0x82179c57d5895babfb655cd62e8e886a53334b5e7be9be658eb759cc35e3fc66\",\n        \"recipient\": {\n          \"AddressOwner\": \"0x8196d048b7a6d04c8edc89579d86fd3fc90c52f9a14c6b812b94fe613c5bcebb\"\n        },\n        \"objectType\": \"0x2::example::Object\",\n        \"objectId\": \"0x5eeb1d449e2516166d57d71fdeb154d0dc9ecdb7b30057d0a932684cac352cdc\",\n        \"version\": \"2\",\n        \"digest\": \"64UQ3a7m1mjWuzgyGoH8RnMyPGDN4XYTC9dS4qiSfdK4\"\n      }\n    ]\n  },\n  \"id\": 1\n}\nsui_multiGetObjects\n\nReturn the object data for a list of objects\n\nParameters\n\nName<Type>\nRequired\nDescription\nobject_ids<[ ObjectID ]>\nYes\nThe IDs of the queried objects\noptions< ObjectDataOptions >\nNo\nOptions for specifying the content to be returned\n\nResult\n\nVec<SuiObjectResponse><[ SuiObjectResponse ]>\n\nExample\n\nGets objects by IDs.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_multiGetObjects\",\n  \"params\": [\n    [\n      \"0xb61439368cd75ebe63d633af32ffb4a022d18b95b4eaa9fd3b22b43f6b2c8e92\",\n      \"0x6ea7bed8f6c3d80f2a595c2305e12dd6d07c3fbbd3ebef7dbcc7b02346cdf056\",\n      \"0x75da5e934f672d3da3e003d989075efaecc79b5cd5df0df2a168259b7115a41c\",\n      \"0x38554a9ff7b4f6b59f9426c321c8013afed093481dd4ef1267c67a8e9a0d074f\",\n      \"0xe74d1b250d5df2cb5170782a8a438fbf681eded4d1e0a2cd7dfb27e784493fb1\"\n    ],\n    {\n      \"showType\": true,\n      \"showOwner\": true,\n      \"showPreviousTransaction\": true,\n      \"showDisplay\": false,\n      \"showContent\": true,\n      \"showBcs\": false,\n      \"showStorageRebate\": true\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"data\": {\n        \"objectId\": \"0xb61439368cd75ebe63d633af32ffb4a022d18b95b4eaa9fd3b22b43f6b2c8e92\",\n        \"version\": \"1\",\n        \"digest\": \"6D2MGzZN1DnALrbg6y9nQWwuipCa6fJERLXAwNGuGtKQ\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0x090bd6d16522a6fd4fa83ec70a5f197ad656da104dde1de9880be827a1a753e5\"\n        },\n        \"previousTransaction\": \"CQN1aMpZRYrVHByFfPFceCXzv5kT7bNM4Uzoe2jbZvM\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"100000000\",\n            \"id\": {\n              \"id\": \"0xb61439368cd75ebe63d633af32ffb4a022d18b95b4eaa9fd3b22b43f6b2c8e92\"\n            }\n          }\n        }\n      }\n    },\n    {\n      \"data\": {\n        \"objectId\": \"0x6ea7bed8f6c3d80f2a595c2305e12dd6d07c3fbbd3ebef7dbcc7b02346cdf056\",\n        \"version\": \"1\",\n        \"digest\": \"HCvnds5SSF8Tn2kANyZDeAJuKa7bY6mf1ykzD8nQY42b\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0x74452cc61f316af5d5d7c02b94b02324268500a65bf5fdccb50582333b61721e\"\n        },\n        \"previousTransaction\": \"86PvfkkGKweeE3TRmQDL9azrkyU9yqiVcRpWMNsqcWTK\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"100000000\",\n            \"id\": {\n              \"id\": \"0x6ea7bed8f6c3d80f2a595c2305e12dd6d07c3fbbd3ebef7dbcc7b02346cdf056\"\n            }\n          }\n        }\n      }\n    },\n    {\n      \"data\": {\n        \"objectId\": \"0x75da5e934f672d3da3e003d989075efaecc79b5cd5df0df2a168259b7115a41c\",\n        \"version\": \"1\",\n        \"digest\": \"7AVTCGjWUFNAZYmcxtKQvAWbyzbFVn9cbr1fMvngbs9S\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0xcc0a372b6fd0026e0c63043492ce4d0c19a63e7f360c51d035a6470f09c8d237\"\n        },\n        \"previousTransaction\": \"2YMeG7z6fPbqT6Sk7K4DQ7qqd2zBC1zAn2SuEXq4wJgY\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"100000000\",\n            \"id\": {\n              \"id\": \"0x75da5e934f672d3da3e003d989075efaecc79b5cd5df0df2a168259b7115a41c\"\n            }\n          }\n        }\n      }\n    },\n    {\n      \"data\": {\n        \"objectId\": \"0x38554a9ff7b4f6b59f9426c321c8013afed093481dd4ef1267c67a8e9a0d074f\",\n        \"version\": \"1\",\n        \"digest\": \"DumsSGokTELtJXW54HKCRLjFKBeHkaySUZ86DDo8QwvR\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0x90fddb42cd928f74b986c6f539a734f3d7c9a75a9cb227ec315724962ee4193c\"\n        },\n        \"previousTransaction\": \"ARhjuTpfA6H8EM8bpBuJ5vFGALmMrMcbSZDiTTF8nxCp\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"100000000\",\n            \"id\": {\n              \"id\": \"0x38554a9ff7b4f6b59f9426c321c8013afed093481dd4ef1267c67a8e9a0d074f\"\n            }\n          }\n        }\n      }\n    },\n    {\n      \"data\": {\n        \"objectId\": \"0xe74d1b250d5df2cb5170782a8a438fbf681eded4d1e0a2cd7dfb27e784493fb1\",\n        \"version\": \"1\",\n        \"digest\": \"94nQ4Tz4nyqcVJmbLMUShkucx3eVfhLXGTCR4d1KP6gL\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0xdccde7893a3ac5c67cd2c4e27540b52ee828096b2aa5fe50a7effd8c23976147\"\n        },\n        \"previousTransaction\": \"3rqeFGm86S2ZKWXPF2HHP8zdpRRqb7WZLDkquE2KHetA\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"100000000\",\n            \"id\": {\n              \"id\": \"0xe74d1b250d5df2cb5170782a8a438fbf681eded4d1e0a2cd7dfb27e784493fb1\"\n            }\n          }\n        }\n      }\n    }\n  ],\n  \"id\": 1\n}\nsui_multiGetTransactionBlocks\n\nReturns an ordered list of transaction responses The method will throw an error if the input contains any duplicate or the input size exceeds QUERY_MAX_RESULT_LIMIT\n\nParameters\n\nName<Type>\nRequired\nDescription\ndigests<[ TransactionDigest ]>\nYes\nA list of transaction digests.\noptions< TransactionBlockResponseOptions >\nNo\nConfig options to control which fields to fetch\n\nResult\n\nVec<SuiTransactionBlockResponse><[ TransactionBlockResponse ]>\n\nExample\n\nReturns the transaction data for specified digest.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_multiGetTransactionBlocks\",\n  \"params\": [\n    [\n      \"61GhydW9kTXNU6LXktceLKM5svzLcDwW1eRU2UdQ9wov\",\n      \"4TU9wToRuiYvPZZAtMzq3gfQEBuv91Nt5pkgWbVL8mR9\",\n      \"HiWguwCqK3mWzhv5Qefb6pfhKdocWZo7gbToHED5Pzp7\"\n    ],\n    {\n      \"showInput\": true,\n      \"showRawInput\": false,\n      \"showEffects\": true,\n      \"showEvents\": true,\n      \"showObjectChanges\": false,\n      \"showBalanceChanges\": false,\n      \"showRawEffects\": false\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"digest\": \"61GhydW9kTXNU6LXktceLKM5svzLcDwW1eRU2UdQ9wov\",\n      \"transaction\": {\n        \"data\": {\n          \"messageVersion\": \"v1\",\n          \"transaction\": {\n            \"kind\": \"ProgrammableTransaction\",\n            \"inputs\": [\n              {\n                \"type\": \"pure\",\n                \"valueType\": \"address\",\n                \"value\": \"0x0ad2c31e8c3681aa4f7d35488cf6bf1135d2fc8703690e085797c3e4f846a282\"\n              },\n              {\n                \"type\": \"object\",\n                \"objectType\": \"immOrOwnedObject\",\n                \"objectId\": \"0x754946e181e00f4341a53b5e895ef8ec3c73d2378a0a11825e232fac1a70e20e\",\n                \"version\": \"2\",\n                \"digest\": \"21hjAvY5LZAy2dc72b3nPgJTsbmtRYaTfqMn2a2sdnkB\"\n              }\n            ],\n            \"transactions\": [\n              {\n                \"TransferObjects\": [\n                  [\n                    {\n                      \"Input\": 1\n                    }\n                  ],\n                  {\n                    \"Input\": 0\n                  }\n                ]\n              }\n            ]\n          },\n          \"sender\": \"0x0a3f57ac1ee741463bc97744050f1af4d570d8b8d0f203b67d09cd82fdb21e13\",\n          \"gasData\": {\n            \"payment\": [\n              {\n                \"objectId\": \"0x146fb1303bd60eb4bea9bd453e50690b423241f0e2e9beabd601bbdabf2828ee\",\n                \"version\": 2,\n                \"digest\": \"BYX5uiUfQkTJrNSnH3mj8Cs8mz1ppQKWBXi4y3Xi6y8D\"\n              }\n            ],\n            \"owner\": \"0x0a3f57ac1ee741463bc97744050f1af4d570d8b8d0f203b67d09cd82fdb21e13\",\n            \"price\": \"10\",\n            \"budget\": \"100000\"\n          }\n        },\n        \"txSignatures\": [\n          \"AFj3Uat/4CHwGMzZZgO6PXosHI9nErbfC8uFgiuvowKZKdMd1UVHez5YjNabMgZ98bC+I9C2Hud4/EjoXsamYAI34HWK6fGd/e11nJeO7UMQFVm4jiZjwDYb8XNiqcCJOQ==\"\n        ]\n      },\n      \"rawTransaction\": \"AQAAAAAAAgAgCtLDHow2gapPfTVIjPa/ETXS/IcDaQ4IV5fD5PhGooIBAHVJRuGB4A9DQaU7Xole+Ow8c9I3igoRgl4jL6wacOIOAgAAAAAAAAAgDwm8uJB3PRHBq9cXZ7H2eoBAJneIID85dyL8J2rqpzwBAQEBAQABAAAKP1esHudBRjvJd0QFDxr01XDYuNDyA7Z9Cc2C/bIeEwEUb7EwO9YOtL6pvUU+UGkLQjJB8OLpvqvWAbvavygo7gIAAAAAAAAAIJyn5CJ6Yc/4Uf75+2oIrkRMlvmBAnXWr5c8DQItueIaCj9XrB7nQUY7yXdEBQ8a9NVw2LjQ8gO2fQnNgv2yHhMKAAAAAAAAAKCGAQAAAAAAAAFhAFj3Uat/4CHwGMzZZgO6PXosHI9nErbfC8uFgiuvowKZKdMd1UVHez5YjNabMgZ98bC+I9C2Hud4/EjoXsamYAI34HWK6fGd/e11nJeO7UMQFVm4jiZjwDYb8XNiqcCJOQ==\",\n      \"effects\": {\n        \"messageVersion\": \"v1\",\n        \"status\": {\n          \"status\": \"success\"\n        },\n        \"executedEpoch\": \"0\",\n        \"gasUsed\": {\n          \"computationCost\": \"100\",\n          \"storageCost\": \"100\",\n          \"storageRebate\": \"10\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"transactionDigest\": \"CVLsRJgJKde8RVNLtkZCBGWxEmCninDQaBb5V4tz9sZ8\",\n        \"mutated\": [\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0x0a3f57ac1ee741463bc97744050f1af4d570d8b8d0f203b67d09cd82fdb21e13\"\n            },\n            \"reference\": {\n              \"objectId\": \"0x146fb1303bd60eb4bea9bd453e50690b423241f0e2e9beabd601bbdabf2828ee\",\n              \"version\": 2,\n              \"digest\": \"BYX5uiUfQkTJrNSnH3mj8Cs8mz1ppQKWBXi4y3Xi6y8D\"\n            }\n          },\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0x0ad2c31e8c3681aa4f7d35488cf6bf1135d2fc8703690e085797c3e4f846a282\"\n            },\n            \"reference\": {\n              \"objectId\": \"0x754946e181e00f4341a53b5e895ef8ec3c73d2378a0a11825e232fac1a70e20e\",\n              \"version\": 2,\n              \"digest\": \"21hjAvY5LZAy2dc72b3nPgJTsbmtRYaTfqMn2a2sdnkB\"\n            }\n          }\n        ],\n        \"gasObject\": {\n          \"owner\": {\n            \"ObjectOwner\": \"0x0a3f57ac1ee741463bc97744050f1af4d570d8b8d0f203b67d09cd82fdb21e13\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x146fb1303bd60eb4bea9bd453e50690b423241f0e2e9beabd601bbdabf2828ee\",\n            \"version\": 2,\n            \"digest\": \"BYX5uiUfQkTJrNSnH3mj8Cs8mz1ppQKWBXi4y3Xi6y8D\"\n          }\n        },\n        \"eventsDigest\": \"Hwdei4TM2C5h2gpRiUQfS8roKsKgTUzx883qTuy7ASdt\"\n      },\n      \"objectChanges\": [\n        {\n          \"type\": \"transferred\",\n          \"sender\": \"0x0a3f57ac1ee741463bc97744050f1af4d570d8b8d0f203b67d09cd82fdb21e13\",\n          \"recipient\": {\n            \"AddressOwner\": \"0x0ad2c31e8c3681aa4f7d35488cf6bf1135d2fc8703690e085797c3e4f846a282\"\n          },\n          \"objectType\": \"0x2::example::Object\",\n          \"objectId\": \"0x754946e181e00f4341a53b5e895ef8ec3c73d2378a0a11825e232fac1a70e20e\",\n          \"version\": \"2\",\n          \"digest\": \"zbXdxaWUbmKnKQfLLwiCVYe2nQyreC7JoKHrk8vY9aA\"\n        }\n      ]\n    },\n    {\n      \"digest\": \"4TU9wToRuiYvPZZAtMzq3gfQEBuv91Nt5pkgWbVL8mR9\",\n      \"transaction\": {\n        \"data\": {\n          \"messageVersion\": \"v1\",\n          \"transaction\": {\n            \"kind\": \"ProgrammableTransaction\",\n            \"inputs\": [\n              {\n                \"type\": \"pure\",\n                \"valueType\": \"address\",\n                \"value\": \"0x2e84e81f871c47c3149e27b12500da884afdf5c30b19c017a0d10388c28ddd59\"\n              },\n              {\n                \"type\": \"object\",\n                \"objectType\": \"immOrOwnedObject\",\n                \"objectId\": \"0x77a58e206acd19639c875a4fbecf3342b825c8384300ac7e3badc820a75b5742\",\n                \"version\": \"2\",\n                \"digest\": \"6ozDx8La5rgu5zSoxaMseRjcX169ZBEjSyQeD2RGoa44\"\n              }\n            ],\n            \"transactions\": [\n              {\n                \"TransferObjects\": [\n                  [\n                    {\n                      \"Input\": 1\n                    }\n                  ],\n                  {\n                    \"Input\": 0\n                  }\n                ]\n              }\n            ]\n          },\n          \"sender\": \"0x028d636e74862991ed521dcc9c6cb7ab860b449e3f4f7b8520b582325bcda4f6\",\n          \"gasData\": {\n            \"payment\": [\n              {\n                \"objectId\": \"0x24b920aa9b005093b820df24ef8b43715499f4fff4e056c0cd5cd8024b4b39a7\",\n                \"version\": 2,\n                \"digest\": \"J9ifwZ2hbL5Tg7fbbta3CXybtaabdaN8BmKudP7R8sBU\"\n              }\n            ],\n            \"owner\": \"0x028d636e74862991ed521dcc9c6cb7ab860b449e3f4f7b8520b582325bcda4f6\",\n            \"price\": \"10\",\n            \"budget\": \"100000\"\n          }\n        },\n        \"txSignatures\": [\n          \"ABBKl/c5PQ8vYVTfmqIhpmKaw5h87g3803RmvzBsvCs+7W4+X7UaGhrNMuHa1mgxEIaujlBa/b6tPZaZxuhfmwWhtxyxD8zwVSmWjSVhhtf+UKhpW2mTgOA1Wn2xxsedmg==\"\n        ]\n      },\n      \"rawTransaction\": \"AQAAAAAAAgAgLoToH4ccR8MUniexJQDaiEr99cMLGcAXoNEDiMKN3VkBAHeljiBqzRljnIdaT77PM0K4Jcg4QwCsfjutyCCnW1dCAgAAAAAAAAAgVlPau21sld3X01pC0x86m+u7aD22booGcGhVRnLhN7UBAQEBAQABAAACjWNudIYpke1SHcycbLerhgtEnj9Pe4UgtYIyW82k9gEkuSCqmwBQk7gg3yTvi0NxVJn0//TgVsDNXNgCS0s5pwIAAAAAAAAAIP7ScTSwc9qGOEVBETllGTeeiIyDq68OYAUEeeRW/wE/Ao1jbnSGKZHtUh3MnGy3q4YLRJ4/T3uFILWCMlvNpPYKAAAAAAAAAKCGAQAAAAAAAAFhABBKl/c5PQ8vYVTfmqIhpmKaw5h87g3803RmvzBsvCs+7W4+X7UaGhrNMuHa1mgxEIaujlBa/b6tPZaZxuhfmwWhtxyxD8zwVSmWjSVhhtf+UKhpW2mTgOA1Wn2xxsedmg==\",\n      \"effects\": {\n        \"messageVersion\": \"v1\",\n        \"status\": {\n          \"status\": \"success\"\n        },\n        \"executedEpoch\": \"0\",\n        \"gasUsed\": {\n          \"computationCost\": \"100\",\n          \"storageCost\": \"100\",\n          \"storageRebate\": \"10\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"transactionDigest\": \"6gAPDZyrAYmnm5zGDhc3LF3Ae2PT6ABP6xSC1dfRRoXp\",\n        \"mutated\": [\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0x028d636e74862991ed521dcc9c6cb7ab860b449e3f4f7b8520b582325bcda4f6\"\n            },\n            \"reference\": {\n              \"objectId\": \"0x24b920aa9b005093b820df24ef8b43715499f4fff4e056c0cd5cd8024b4b39a7\",\n              \"version\": 2,\n              \"digest\": \"J9ifwZ2hbL5Tg7fbbta3CXybtaabdaN8BmKudP7R8sBU\"\n            }\n          },\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0x2e84e81f871c47c3149e27b12500da884afdf5c30b19c017a0d10388c28ddd59\"\n            },\n            \"reference\": {\n              \"objectId\": \"0x77a58e206acd19639c875a4fbecf3342b825c8384300ac7e3badc820a75b5742\",\n              \"version\": 2,\n              \"digest\": \"6ozDx8La5rgu5zSoxaMseRjcX169ZBEjSyQeD2RGoa44\"\n            }\n          }\n        ],\n        \"gasObject\": {\n          \"owner\": {\n            \"ObjectOwner\": \"0x028d636e74862991ed521dcc9c6cb7ab860b449e3f4f7b8520b582325bcda4f6\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x24b920aa9b005093b820df24ef8b43715499f4fff4e056c0cd5cd8024b4b39a7\",\n            \"version\": 2,\n            \"digest\": \"J9ifwZ2hbL5Tg7fbbta3CXybtaabdaN8BmKudP7R8sBU\"\n          }\n        },\n        \"eventsDigest\": \"8ju2GtaGc2UB3vFu9Pmjwze8LcUh37izem5NsGcstgtx\"\n      },\n      \"objectChanges\": [\n        {\n          \"type\": \"transferred\",\n          \"sender\": \"0x028d636e74862991ed521dcc9c6cb7ab860b449e3f4f7b8520b582325bcda4f6\",\n          \"recipient\": {\n            \"AddressOwner\": \"0x2e84e81f871c47c3149e27b12500da884afdf5c30b19c017a0d10388c28ddd59\"\n          },\n          \"objectType\": \"0x2::example::Object\",\n          \"objectId\": \"0x77a58e206acd19639c875a4fbecf3342b825c8384300ac7e3badc820a75b5742\",\n          \"version\": \"2\",\n          \"digest\": \"kLukTF3HAHvTW17s8ZHtVKZyWf4bSJb7SjZ5HuNeELk\"\n        }\n      ]\n    },\n    {\n      \"digest\": \"HiWguwCqK3mWzhv5Qefb6pfhKdocWZo7gbToHED5Pzp7\",\n      \"transaction\": {\n        \"data\": {\n          \"messageVersion\": \"v1\",\n          \"transaction\": {\n            \"kind\": \"ProgrammableTransaction\",\n            \"inputs\": [\n              {\n                \"type\": \"pure\",\n                \"valueType\": \"address\",\n                \"value\": \"0xdcc85bada4a729d650f7762226432129780927838b06db0346808ffb0676099d\"\n              },\n              {\n                \"type\": \"object\",\n                \"objectType\": \"immOrOwnedObject\",\n                \"objectId\": \"0xe0408b31759f57b69c52e09410a66f9a23c34be9913b6697a5e83e02e2a0fc74\",\n                \"version\": \"2\",\n                \"digest\": \"GP1ZYjdAR42yCiTAvnQgqPtc5bG9i7BzetfWeAo6ewgN\"\n              }\n            ],\n            \"transactions\": [\n              {\n                \"TransferObjects\": [\n                  [\n                    {\n                      \"Input\": 1\n                    }\n                  ],\n                  {\n                    \"Input\": 0\n                  }\n                ]\n              }\n            ]\n          },\n          \"sender\": \"0xb30fdd73db52c4eb06754bdb50fec3ea0e19a7851f2383d764fcb3d6eb7f8c82\",\n          \"gasData\": {\n            \"payment\": [\n              {\n                \"objectId\": \"0x7057ba0901e4d9b1e04de75ea2699a4413215612581eba57ebe7e594b809ccce\",\n                \"version\": 2,\n                \"digest\": \"Gtv38WbTUCw2KoAv9S5db8oTXn8ZdgkX7gGCrfU3Zvms\"\n              }\n            ],\n            \"owner\": \"0xb30fdd73db52c4eb06754bdb50fec3ea0e19a7851f2383d764fcb3d6eb7f8c82\",\n            \"price\": \"10\",\n            \"budget\": \"100000\"\n          }\n        },\n        \"txSignatures\": [\n          \"APXV3tMi3dDUyb0PGKcI4/2kDw7W++XWyRWZTLK4jZKo/V0qseed7rngZsrNg6fgmXIbJlHBxvzK50I4K208TwnWnfBR88qs+c/GcHXhsNtHEECK8vIjfFKQvXV+9IXwAw==\"\n        ]\n      },\n      \"rawTransaction\": \"AQAAAAAAAgAg3MhbraSnKdZQ93YiJkMhKXgJJ4OLBtsDRoCP+wZ2CZ0BAOBAizF1n1e2nFLglBCmb5ojw0vpkTtml6XoPgLioPx0AgAAAAAAAAAg5IK3WMI5kDnbvt1dskOF6TTWgrL9ZzRGkavQ78dxlBsBAQEBAQABAACzD91z21LE6wZ1S9tQ/sPqDhmnhR8jg9dk/LPW63+MggFwV7oJAeTZseBN516iaZpEEyFWElgeulfr5+WUuAnMzgIAAAAAAAAAIOwr5NrG/2lF1Js+zAQ9BJYR9s/RC8pNUX6UUq1Uhtaesw/dc9tSxOsGdUvbUP7D6g4Zp4UfI4PXZPyz1ut/jIIKAAAAAAAAAKCGAQAAAAAAAAFhAPXV3tMi3dDUyb0PGKcI4/2kDw7W++XWyRWZTLK4jZKo/V0qseed7rngZsrNg6fgmXIbJlHBxvzK50I4K208TwnWnfBR88qs+c/GcHXhsNtHEECK8vIjfFKQvXV+9IXwAw==\",\n      \"effects\": {\n        \"messageVersion\": \"v1\",\n        \"status\": {\n          \"status\": \"success\"\n        },\n        \"executedEpoch\": \"0\",\n        \"gasUsed\": {\n          \"computationCost\": \"100\",\n          \"storageCost\": \"100\",\n          \"storageRebate\": \"10\",\n          \"nonRefundableStorageFee\": \"0\"\n        },\n        \"transactionDigest\": \"F2iA4tJuSYJhXArnKAhrUJVAvNdTuvA8VMj9zXj6PNDe\",\n        \"mutated\": [\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0xb30fdd73db52c4eb06754bdb50fec3ea0e19a7851f2383d764fcb3d6eb7f8c82\"\n            },\n            \"reference\": {\n              \"objectId\": \"0x7057ba0901e4d9b1e04de75ea2699a4413215612581eba57ebe7e594b809ccce\",\n              \"version\": 2,\n              \"digest\": \"Gtv38WbTUCw2KoAv9S5db8oTXn8ZdgkX7gGCrfU3Zvms\"\n            }\n          },\n          {\n            \"owner\": {\n              \"AddressOwner\": \"0xdcc85bada4a729d650f7762226432129780927838b06db0346808ffb0676099d\"\n            },\n            \"reference\": {\n              \"objectId\": \"0xe0408b31759f57b69c52e09410a66f9a23c34be9913b6697a5e83e02e2a0fc74\",\n              \"version\": 2,\n              \"digest\": \"GP1ZYjdAR42yCiTAvnQgqPtc5bG9i7BzetfWeAo6ewgN\"\n            }\n          }\n        ],\n        \"gasObject\": {\n          \"owner\": {\n            \"ObjectOwner\": \"0xb30fdd73db52c4eb06754bdb50fec3ea0e19a7851f2383d764fcb3d6eb7f8c82\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x7057ba0901e4d9b1e04de75ea2699a4413215612581eba57ebe7e594b809ccce\",\n            \"version\": 2,\n            \"digest\": \"Gtv38WbTUCw2KoAv9S5db8oTXn8ZdgkX7gGCrfU3Zvms\"\n          }\n        },\n        \"eventsDigest\": \"HQh9RPyW3hh7X3GYRXPvAQ2k7VmYWKKrZ5cMcvPypu3v\"\n      },\n      \"objectChanges\": [\n        {\n          \"type\": \"transferred\",\n          \"sender\": \"0xb30fdd73db52c4eb06754bdb50fec3ea0e19a7851f2383d764fcb3d6eb7f8c82\",\n          \"recipient\": {\n            \"AddressOwner\": \"0xdcc85bada4a729d650f7762226432129780927838b06db0346808ffb0676099d\"\n          },\n          \"objectType\": \"0x2::example::Object\",\n          \"objectId\": \"0xe0408b31759f57b69c52e09410a66f9a23c34be9913b6697a5e83e02e2a0fc74\",\n          \"version\": \"2\",\n          \"digest\": \"Azr7oPHAo6LZ9iPfHYjguY2BoVTZ9zwVArvUEJSwXKWW\"\n        }\n      ]\n    }\n  ],\n  \"id\": 1\n}\nsui_tryGetPastObject\n\nNote there is no software-level guarantee/SLA that objects with past versions can be retrieved by this API, even if the object and version exists/existed. The result may vary across nodes depending on their pruning policies. Return the object information for a specified version\n\nParameters\n\nName<Type>\nRequired\nDescription\nobject_id< ObjectID >\nYes\nThe ID of the queried object\nversion< SequenceNumber >\nYes\nThe version of the queried object. If None, default to the latest known version\noptions< ObjectDataOptions >\nNo\nOptions for specifying the content to be returned\n\nResult\n\nSuiPastObjectResponse< ObjectRead >\n\nExample\n\nGets Past Object data.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_tryGetPastObject\",\n  \"params\": [\n    \"0x11af4b844ff94b3fbef6e36b518da3ad4c5856fa686464524a876b463d129760\",\n    4,\n    {\n      \"showType\": true,\n      \"showOwner\": true,\n      \"showPreviousTransaction\": true,\n      \"showDisplay\": false,\n      \"showContent\": true,\n      \"showBcs\": false,\n      \"showStorageRebate\": true\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"status\": \"VersionFound\",\n    \"details\": {\n      \"objectId\": \"0x11af4b844ff94b3fbef6e36b518da3ad4c5856fa686464524a876b463d129760\",\n      \"version\": \"4\",\n      \"digest\": \"5VPAwDXy3BL72ehFc7gSJoz27ahMd6spUg5YwYc4ibcv\",\n      \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n      \"owner\": {\n        \"AddressOwner\": \"0x3568c40e814d9d5396d23087a0fd641e91e0e00df6c012cded9ef9ba5e5bf042\"\n      },\n      \"previousTransaction\": \"5jQByoouHBwaico5pQB73GdbzerC2StjTiHh5garBjiV\",\n      \"storageRebate\": \"100\",\n      \"content\": {\n        \"dataType\": \"moveObject\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"hasPublicTransfer\": true,\n        \"fields\": {\n          \"balance\": \"10000\",\n          \"id\": {\n            \"id\": \"0x11af4b844ff94b3fbef6e36b518da3ad4c5856fa686464524a876b463d129760\"\n          }\n        }\n      }\n    }\n  },\n  \"id\": 1\n}\nsui_tryMultiGetPastObjects\n\nNote there is no software-level guarantee/SLA that objects with past versions can be retrieved by this API, even if the object and version exists/existed. The result may vary across nodes depending on their pruning policies. Return the object information for a specified version\n\nParameters\n\nName<Type>\nRequired\nDescription\npast_objects<[ GetPastObjectRequest ]>\nYes\nA vector of object and versions to be queried\noptions< ObjectDataOptions >\nNo\nOptions for specifying the content to be returned\n\nResult\n\nVec<SuiPastObjectResponse><[ ObjectRead ]>\n\nExample\n\nGets Past Object data for a vector of objects.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_tryMultiGetPastObjects\",\n  \"params\": [\n    [\n      {\n        \"objectId\": \"0x5056aa3325512c8af40b9f5fd7065c83ded900657eac70a7979c2541646fa449\",\n        \"version\": \"4\"\n      },\n      {\n        \"objectId\": \"0xe81109dc075f537067726d63dd5287100e177404a969989215da2abfbfc098cf\",\n        \"version\": \"12\"\n      }\n    ],\n    {\n      \"showType\": true,\n      \"showOwner\": true,\n      \"showPreviousTransaction\": true,\n      \"showDisplay\": false,\n      \"showContent\": true,\n      \"showBcs\": false,\n      \"showStorageRebate\": true\n    }\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": [\n    {\n      \"status\": \"VersionFound\",\n      \"details\": {\n        \"objectId\": \"0x5056aa3325512c8af40b9f5fd7065c83ded900657eac70a7979c2541646fa449\",\n        \"version\": \"4\",\n        \"digest\": \"F34PCnEHm5GAP5ksDKPSdRMKz49JiqrvLUTZsiojqJS2\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0xfde53941b2a08a8bf752c20979842732ac019f52835282744318d6d84f3c52b3\"\n        },\n        \"previousTransaction\": \"EMLrFqmDkZtFvidxKy1T8bwAiHnUiLqramE58kSUcAf8\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"10000\",\n            \"id\": {\n              \"id\": \"0x5056aa3325512c8af40b9f5fd7065c83ded900657eac70a7979c2541646fa449\"\n            }\n          }\n        }\n      }\n    },\n    {\n      \"status\": \"VersionFound\",\n      \"details\": {\n        \"objectId\": \"0xe81109dc075f537067726d63dd5287100e177404a969989215da2abfbfc098cf\",\n        \"version\": \"12\",\n        \"digest\": \"FvrqyqH5yA85sziA2NoPGJ8N23kmTxeXQh4HyJAbB7c2\",\n        \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n        \"owner\": {\n          \"AddressOwner\": \"0x13090a95287cde98d711fc27217b81e08d494bdb70c3b42f0fe27be8eb500568\"\n        },\n        \"previousTransaction\": \"6XEirxRenmgbeg4tviP43bAKsosqgySXwoBxGEWQVTii\",\n        \"storageRebate\": \"100\",\n        \"content\": {\n          \"dataType\": \"moveObject\",\n          \"type\": \"0x2::coin::Coin<0x2::sui::SUI>\",\n          \"hasPublicTransfer\": true,\n          \"fields\": {\n            \"balance\": \"20000\",\n            \"id\": {\n              \"id\": \"0x5056aa3325512c8af40b9f5fd7065c83ded900657eac70a7979c2541646fa449\"\n            }\n          }\n        }\n      }\n    }\n  ],\n  \"id\": 1\n}\nTransaction Builder API\nunsafe_batchTransaction\n\nCreate an unsigned batched transaction.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\nsingle_transaction_params<[ RPCTransactionRequestParams ]>\nYes\nList of transaction request parameters\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\ntxn_builder_mode< SuiTransactionBlockBuilderMode >\nNo\nWhether this is a regular transaction or a Dev Inspect Transaction\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_mergeCoins\n\nCreate an unsigned transaction to merge multiple coins into one coin.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\nprimary_coin< ObjectID >\nYes\nThe coin object to merge into, this coin will remain after the transaction\ncoin_to_merge< ObjectID >\nYes\nThe coin object to be merged, this coin will be destroyed, the balance will be added to primary_coin\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_moveCall\n\nCreate an unsigned transaction to execute a Move call on the network, by calling the specified function in the module of a given package.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\npackage_object_id< ObjectID >\nYes\nThe Move package ID, e.g. 0x2\nmodule< string >\nYes\nThe Move module name, e.g. pay\nfunction< string >\nYes\nThe move function name, e.g. split\ntype_arguments<[ TypeTag ]>\nYes\nThe type arguments of the Move function\narguments<[ SuiJsonValue ]>\nYes\nThe arguments to be passed into the Move function, in SuiJson format\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\nexecution_mode< SuiTransactionBlockBuilderMode >\nNo\nWhether this is a Normal transaction or a Dev Inspect Transaction. Default to be SuiTransactionBlockBuilderMode::Commit when it's None.\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_pay\n\nSend Coin&lt;T> to a list of addresses, where T can be any coin type, following a list of amounts, The object specified in the gas field will be used to pay the gas fee for the transaction. The gas object can not appear in input_coins. If the gas object is not specified, the RPC server will auto-select one.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ninput_coins<[ ObjectID ]>\nYes\nThe Sui coins to be used in this transaction\nrecipients<[ SuiAddress ]>\nYes\nThe recipients' addresses, the length of this vector must be the same as amounts.\namounts<[ BigInt_for_uint64 ]>\nYes\nThe amounts to be transferred to recipients, following the same order\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_payAllSui\n\nSend all SUI coins to one recipient. This is for SUI coin only and does not require a separate gas coin object. Specifically, what pay_all_sui does are: 1. accumulate all SUI from input coins and deposit all SUI to the first input coin 2. transfer the updated first coin to the recipient and also use this first coin as gas coin object. 3. the balance of the first input coin after tx is sum(input_coins) - actual_gas_cost. 4. all other input coins other than the first are deleted.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ninput_coins<[ ObjectID ]>\nYes\nThe Sui coins to be used in this transaction, including the coin for gas payment.\nrecipient< SuiAddress >\nYes\nThe recipient address,\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_paySui\n\nSend SUI coins to a list of addresses, following a list of amounts. This is for SUI coin only and does not require a separate gas coin object. Specifically, what pay_sui does are: 1. debit each input_coin to create new coin following the order of amounts and assign it to the corresponding recipient. 2. accumulate all residual SUI from input coins left and deposit all SUI to the first input coin, then use the first input coin as the gas coin object. 3. the balance of the first input coin after tx is sum(input_coins) - sum(amounts) - actual_gas_cost 4. all other input coints other than the first one are deleted.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ninput_coins<[ ObjectID ]>\nYes\nThe Sui coins to be used in this transaction, including the coin for gas payment.\nrecipients<[ SuiAddress ]>\nYes\nThe recipients' addresses, the length of this vector must be the same as amounts.\namounts<[ BigInt_for_uint64 ]>\nYes\nThe amounts to be transferred to recipients, following the same order\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_publish\n\nCreate an unsigned transaction to publish a Move package.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsender< SuiAddress >\nYes\nThe transaction signer's Sui address\ncompiled_modules<[ Base64 ]>\nYes\nThe compiled bytes of a Move package\ndependencies<[ ObjectID ]>\nYes\nA list of transitive dependency addresses that this set of modules depends on.\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_requestAddStake\n\nAdd stake to a validator's staking pool using multiple coins and amount.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ncoins<[ ObjectID ]>\nYes\nCoin<SUI> object to stake\namount< BigInt_for_uint64 >\nNo\nStake amount\nvalidator< SuiAddress >\nYes\nThe validator's Sui address\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_requestWithdrawStake\n\nWithdraw stake from a validator's staking pool.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\nstaked_sui< ObjectID >\nYes\nStakedSui object ID\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_splitCoin\n\nCreate an unsigned transaction to split a coin object into multiple coins.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ncoin_object_id< ObjectID >\nYes\nThe coin object to be spilt\nsplit_amounts<[ BigInt_for_uint64 ]>\nYes\nThe amounts to split out from the coin\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_splitCoinEqual\n\nCreate an unsigned transaction to split a coin object into multiple equal-size coins.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\ncoin_object_id< ObjectID >\nYes\nThe coin object to be spilt\nsplit_count< BigInt_for_uint64 >\nYes\nThe number of coins to split into\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_transferObject\n\nCreate an unsigned transaction to transfer an object from one address to another. The object's type must allow public transfers\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\nobject_id< ObjectID >\nYes\nThe ID of the object to be transferred\ngas< ObjectID >\nNo\nGas object to be used in this transaction, node will pick one from the signer's possession if not provided\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\nrecipient< SuiAddress >\nYes\nThe recipient's Sui address\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nunsafe_transferSui\n\nCreate an unsigned transaction to send SUI coin object to a Sui address. The SUI object is also used as the gas object.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsigner< SuiAddress >\nYes\nThe transaction signer's Sui address\nsui_object_id< ObjectID >\nYes\nThe Sui coin object to be used in this transaction\ngas_budget< BigInt_for_uint64 >\nYes\nThe gas budget, the transaction will fail if the gas cost exceed the budget\nrecipient< SuiAddress >\nYes\nThe recipient's Sui address\namount< BigInt_for_uint64 >\nNo\nThe amount to be split out and transferred\n\nResult\n\nTransactionBlockBytes< TransactionBlockBytes >\n\nParameter\nRequired\nDescription\ngas<[ ObjectRef ]>\nYes\nthe gas objects to be used\ninputObjects<[ InputObjectKind ]>\nYes\nobjects to be used in this transaction\ntxBytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nWrite API\nsui_devInspectTransactionBlock\n\nRuns the transaction in dev-inspect mode. Which allows for nearly any transaction (or Move call) with any arguments. Detailed results are provided, including both the transaction effects and any return values.\n\nParameters\n\nName<Type>\nRequired\nDescription\nsender_address< SuiAddress >\nYes\ntx_bytes< Base64 >\nYes\nBCS encoded TransactionKind(as opposed to TransactionData, which include gasBudget and gasPrice)\ngas_price< BigInt_for_uint64 >\nNo\nGas is not charged, but gas usage is still calculated. Default to use reference gas price\nepoch< BigInt_for_uint64 >\nNo\nThe epoch to perform the call. Will be set from the system state object if not provided\nadditional_args< DevInspectArgs >\nNo\nAdditional arguments including gas_budget, gas_objects, gas_sponsor and skip_checks.\n\nResult\n\nDevInspectResults< DevInspectResults >\n\nThe response from processing a dev inspect transaction\n\nParameter\nRequired\nDescription\neffects< TransactionBlockEffects >\nYes\nSummary of effects that likely would be generated if the transaction is actually run. Note however, that not all dev-inspect transactions are actually usable as transactions so it might not be possible actually generate these effects from a normal transaction.\nerror< [string,null] >\nNo\nExecution error from executing the transactions\nevents<[ Event ]>\nYes\nEvents that likely would be generated if the transaction is actually run.\nrawEffects<[ string ]>\nNo\nThe raw effects of the transaction that was dev inspected.\nrawTxnData<[ string ]>\nNo\nThe raw transaction data that was dev inspected.\nresults< SuiExecutionResult [array,null] >\nNo\nExecution results (including return values) from executing the transactions\n\nExample\n\nRuns the transaction in dev-inspect mode. Which allows for nearly any transaction (or Move call) with any arguments. Detailed results are provided, including both the transaction effects and any return values.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_devInspectTransactionBlock\",\n  \"params\": [\n    \"0xd70420418b84502e506794227f897237764dde8d79a01ab2104bf742a277a2ab\",\n    \"AAACACBnxtMcbJcOVn8D72fYEaT4Q2ZbjePygvpIs+AQO6m77QEAagYVO5/EhuEB8OnicDrIZm0GrsxN3355JqNhlwxlpbECAAAAAAAAACDoQ3EipycU+/EOvBcDPFtMkZiSbdzWAw3CwdmQCAtBWAEBAQEBAAEAAC9cVD1xauQ9RT3rOxmbva8bxwMMdoL4dwPc5DEkj+3gASxDgF0Nb1QCp60Npb3sVJx83qBrxKHTOaIlIe6pM7iJAgAAAAAAAAAgnvsgc1pPauyCE27/c+aBnHN3fSsxRAWdEJYzYFOryNAvXFQ9cWrkPUU96zsZm72vG8cDDHaC+HcD3OQxJI/t4AoAAAAAAAAAoIYBAAAAAAAA\",\n    1000,\n    8888,\n    null\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"effects\": {\n      \"messageVersion\": \"v1\",\n      \"status\": {\n        \"status\": \"success\"\n      },\n      \"executedEpoch\": \"0\",\n      \"gasUsed\": {\n        \"computationCost\": \"100\",\n        \"storageCost\": \"100\",\n        \"storageRebate\": \"10\",\n        \"nonRefundableStorageFee\": \"0\"\n      },\n      \"transactionDigest\": \"76gyHCk7FRrGACRqXM7Ybj5uJLtAzgEMJ5P9CeEzxZSG\",\n      \"mutated\": [\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x2f5c543d716ae43d453deb3b199bbdaf1bc7030c7682f87703dce431248fede0\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x2c43805d0d6f5402a7ad0da5bdec549c7cdea06bc4a1d339a22521eea933b889\",\n            \"version\": 2,\n            \"digest\": \"BhbWpBeESxuRWvmvLMyb2JNUuFa6j4aG1T4WUiPgKAHm\"\n          }\n        },\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x67c6d31c6c970e567f03ef67d811a4f843665b8de3f282fa48b3e0103ba9bbed\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x6a06153b9fc486e101f0e9e2703ac8666d06aecc4ddf7e7926a361970c65a5b1\",\n            \"version\": 2,\n            \"digest\": \"GdfET1avZReDftpJNB8LSuHJ2cKUheSbEaLMzuPVXHsM\"\n          }\n        }\n      ],\n      \"gasObject\": {\n        \"owner\": {\n          \"ObjectOwner\": \"0x2f5c543d716ae43d453deb3b199bbdaf1bc7030c7682f87703dce431248fede0\"\n        },\n        \"reference\": {\n          \"objectId\": \"0x2c43805d0d6f5402a7ad0da5bdec549c7cdea06bc4a1d339a22521eea933b889\",\n          \"version\": 2,\n          \"digest\": \"BhbWpBeESxuRWvmvLMyb2JNUuFa6j4aG1T4WUiPgKAHm\"\n        }\n      },\n      \"eventsDigest\": \"6kerMphN4S5QTfd9TAhwMiFq1q9c2YwfpheBfWm85vUq\"\n    },\n    \"events\": []\n  },\n  \"id\": 1\n}\nsui_dryRunTransactionBlock\n\nReturn transaction execution effects including the gas cost summary, while the effects are not committed to the chain.\n\nParameters\n\nName<Type>\nRequired\nDescription\ntx_bytes< Base64 >\nYes\n\nResult\n\nDryRunTransactionBlockResponse< DryRunTransactionBlockResponse >\n\nParameter\nRequired\nDescription\nbalanceChanges<[ BalanceChange ]>\nYes\neffects< TransactionBlockEffects >\nYes\nevents<[ Event ]>\nYes\ninput< TransactionBlockData >\nYes\nobjectChanges<[ ObjectChange ]>\nYes\n\nExample\n\nDry runs a transaction block to get back estimated gas fees and other potential effects.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_dryRunTransactionBlock\",\n  \"params\": [\n    \"AAACACB7qR3cfnF89wjJNwYPBASHNuwz+xdG2Zml5YzVxnftgAEAT4LxyFh7mNZMAL+0bDhDvYv2zPp8ZahhOGmM0f3Kw9wCAAAAAAAAACCxDABG4pPAjOwPQHg9msS/SrtNf4IGR/2F0ZGD3ufH/wEBAQEBAAEAAGH7tbTzQqQL2/h/5KlGueONGM+P/HsAALl1F1x7apV2AejYx86GPzE9o9vZKoPvJtEouI/ma/JuDg0Jza9yfR2EAgAAAAAAAAAgzMqpegLMOpgEFnDhYJ23FOmFjJbp5GmFXxzzv9+X6GVh+7W080KkC9v4f+SpRrnjjRjPj/x7AAC5dRdce2qVdgoAAAAAAAAAoIYBAAAAAAAA\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"digest\": \"DNtx7EmGqSywGbnSC1CKoqmBFEXGvApXpRVt6bU855xP\",\n    \"transaction\": {\n      \"data\": {\n        \"messageVersion\": \"v1\",\n        \"transaction\": {\n          \"kind\": \"ProgrammableTransaction\",\n          \"inputs\": [\n            {\n              \"type\": \"pure\",\n              \"valueType\": \"address\",\n              \"value\": \"0x7ba91ddc7e717cf708c937060f04048736ec33fb1746d999a5e58cd5c677ed80\"\n            },\n            {\n              \"type\": \"object\",\n              \"objectType\": \"immOrOwnedObject\",\n              \"objectId\": \"0x4f82f1c8587b98d64c00bfb46c3843bd8bf6ccfa7c65a86138698cd1fdcac3dc\",\n              \"version\": \"2\",\n              \"digest\": \"Cv7n2YaM7Am1ssZGu4khsFkcKHnpgVhwFCSs4kLjrtLW\"\n            }\n          ],\n          \"transactions\": [\n            {\n              \"TransferObjects\": [\n                [\n                  {\n                    \"Input\": 1\n                  }\n                ],\n                {\n                  \"Input\": 0\n                }\n              ]\n            }\n          ]\n        },\n        \"sender\": \"0x61fbb5b4f342a40bdbf87fe4a946b9e38d18cf8ffc7b0000b975175c7b6a9576\",\n        \"gasData\": {\n          \"payment\": [\n            {\n              \"objectId\": \"0xe8d8c7ce863f313da3dbd92a83ef26d128b88fe66bf26e0e0d09cdaf727d1d84\",\n              \"version\": 2,\n              \"digest\": \"EnRQXe1hDGAJCFyF2ds2GmPHdvf9V6yxf24LisEsDkYt\"\n            }\n          ],\n          \"owner\": \"0x61fbb5b4f342a40bdbf87fe4a946b9e38d18cf8ffc7b0000b975175c7b6a9576\",\n          \"price\": \"10\",\n          \"budget\": \"100000\"\n        }\n      },\n      \"txSignatures\": [\n        \"AG+AHZMT7BZWQVagaGfENXyiFQ2nYRkG4XdnwqwToeJEmZ4J1IxKw0xKzTATGiUzFedY/nxKVuHikFibNlZ3wg9Dij1TvBYKLcfLNo8fq6GASb9yfo6uvuwNUBGkTf54wQ==\"\n      ]\n    },\n    \"rawTransaction\": \"AQAAAAAAAgAge6kd3H5xfPcIyTcGDwQEhzbsM/sXRtmZpeWM1cZ37YABAE+C8chYe5jWTAC/tGw4Q72L9sz6fGWoYThpjNH9ysPcAgAAAAAAAAAgsQwARuKTwIzsD0B4PZrEv0q7TX+CBkf9hdGRg97nx/8BAQEBAQABAABh+7W080KkC9v4f+SpRrnjjRjPj/x7AAC5dRdce2qVdgHo2MfOhj8xPaPb2SqD7ybRKLiP5mvybg4NCc2vcn0dhAIAAAAAAAAAIMzKqXoCzDqYBBZw4WCdtxTphYyW6eRphV8c87/fl+hlYfu1tPNCpAvb+H/kqUa5440Yz4/8ewAAuXUXXHtqlXYKAAAAAAAAAKCGAQAAAAAAAAFhAG+AHZMT7BZWQVagaGfENXyiFQ2nYRkG4XdnwqwToeJEmZ4J1IxKw0xKzTATGiUzFedY/nxKVuHikFibNlZ3wg9Dij1TvBYKLcfLNo8fq6GASb9yfo6uvuwNUBGkTf54wQ==\",\n    \"effects\": {\n      \"messageVersion\": \"v1\",\n      \"status\": {\n        \"status\": \"success\"\n      },\n      \"executedEpoch\": \"0\",\n      \"gasUsed\": {\n        \"computationCost\": \"100\",\n        \"storageCost\": \"100\",\n        \"storageRebate\": \"10\",\n        \"nonRefundableStorageFee\": \"0\"\n      },\n      \"transactionDigest\": \"8UExPV121BEfWkbymSPDYhh23rVNh3MSWtC5juJ9JGMJ\",\n      \"mutated\": [\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x61fbb5b4f342a40bdbf87fe4a946b9e38d18cf8ffc7b0000b975175c7b6a9576\"\n          },\n          \"reference\": {\n            \"objectId\": \"0xe8d8c7ce863f313da3dbd92a83ef26d128b88fe66bf26e0e0d09cdaf727d1d84\",\n            \"version\": 2,\n            \"digest\": \"EnRQXe1hDGAJCFyF2ds2GmPHdvf9V6yxf24LisEsDkYt\"\n          }\n        },\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x7ba91ddc7e717cf708c937060f04048736ec33fb1746d999a5e58cd5c677ed80\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x4f82f1c8587b98d64c00bfb46c3843bd8bf6ccfa7c65a86138698cd1fdcac3dc\",\n            \"version\": 2,\n            \"digest\": \"Cv7n2YaM7Am1ssZGu4khsFkcKHnpgVhwFCSs4kLjrtLW\"\n          }\n        }\n      ],\n      \"gasObject\": {\n        \"owner\": {\n          \"ObjectOwner\": \"0x61fbb5b4f342a40bdbf87fe4a946b9e38d18cf8ffc7b0000b975175c7b6a9576\"\n        },\n        \"reference\": {\n          \"objectId\": \"0xe8d8c7ce863f313da3dbd92a83ef26d128b88fe66bf26e0e0d09cdaf727d1d84\",\n          \"version\": 2,\n          \"digest\": \"EnRQXe1hDGAJCFyF2ds2GmPHdvf9V6yxf24LisEsDkYt\"\n        }\n      },\n      \"eventsDigest\": \"55TNn3v5vpuXjQfjqamw76P9GZD522pumo4NuT7RYeFB\"\n    },\n    \"objectChanges\": [\n      {\n        \"type\": \"transferred\",\n        \"sender\": \"0x61fbb5b4f342a40bdbf87fe4a946b9e38d18cf8ffc7b0000b975175c7b6a9576\",\n        \"recipient\": {\n          \"AddressOwner\": \"0x7ba91ddc7e717cf708c937060f04048736ec33fb1746d999a5e58cd5c677ed80\"\n        },\n        \"objectType\": \"0x2::example::Object\",\n        \"objectId\": \"0x4f82f1c8587b98d64c00bfb46c3843bd8bf6ccfa7c65a86138698cd1fdcac3dc\",\n        \"version\": \"2\",\n        \"digest\": \"B3xLC8EbyvTxy5pgiwTNUzHLa6kS7uwD6sZdErKB8F8f\"\n      }\n    ]\n  },\n  \"id\": 1\n}\nsui_executeTransactionBlock\n\nExecute the transaction and wait for results if desired. Request types: 1. WaitForEffectsCert: waits for TransactionEffectsCert and then return to client. This mode is a proxy for transaction finality. 2. WaitForLocalExecution: waits for TransactionEffectsCert and make sure the node executed the transaction locally before returning the client. The local execution makes sure this node is aware of this transaction when client fires subsequent queries. However if the node fails to execute the transaction locally in a timely manner, a bool type in the response is set to false to indicated the case. request_type is default to be WaitForEffectsCert unless options.show_events or options.show_effects is true\n\nParameters\n\nName<Type>\nRequired\nDescription\ntx_bytes< Base64 >\nYes\nBCS serialized transaction data bytes without its type tag, as base-64 encoded string.\nsignatures<[ Base64 ]>\nYes\nA list of signatures (flag || signature || pubkey bytes, as base-64 encoded string). Signature is committed to the intent message of the transaction data, as base-64 encoded string.\noptions< TransactionBlockResponseOptions >\nNo\nOptions for specifying the content to be returned\nrequest_type< ExecuteTransactionRequestType >\nNo\nThe request type, derived from SuiTransactionBlockResponseOptions if None\n\nResult\n\nSuiTransactionBlockResponse< TransactionBlockResponse >\n\nParameter\nRequired\nDescription\nbalanceChanges< BalanceChange [array,null] >\nNo\ncheckpoint< BigInt_for_uint64 | null >\nNo\nThe checkpoint number when this transaction was included and hence finalized. This is only returned in the read api, not in the transaction execution api.\nconfirmedLocalExecution< [boolean,null] >\nNo\ndigest< TransactionDigest >\nYes\neffects< TransactionBlockEffects | null >\nNo\nerrors<[ string ]>\nNo\nevents< Event [array,null] >\nNo\nobjectChanges< ObjectChange [array,null] >\nNo\nrawEffects<[ string ]>\nNo\nrawTransaction< Base64 >\nNo\nBCS encoded [SenderSignedData] that includes input object references returns empty array if show_raw_transaction is false\ntimestampMs< BigInt_for_uint64 | null >\nNo\ntransaction< TransactionBlock | null >\nNo\nTransaction input data\n\nExample\n\nExecutes a transaction with serialized signatures.\n\nRequest\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_executeTransactionBlock\",\n  \"params\": [\n    \"AAACACBqEB6aOvXIBwES+Ahkizbvv43uihqC3kbZUE6WoRCKFwEAjvdvVsOZYzousxC8qRJOXy84znOeqsu2YAaIgE4HhEgCAAAAAAAAACB9w3+ufZMpihJFwxtCBojBaGy00TVtFxgN2C6TpIPFqwEBAQEBAAEAAAS0l6kWtGVmCaf6gnoJGE1vR2gdO6dM4NejbGSysfiHAZ+Q9/hmzCnfsdpjc86U+dldylpA9OF2mRjuv5+64AvTAgAAAAAAAAAgjleHL0UiRGjh/BfIFHCJ3EMY/dQA22c2TvNQyVJnbYUEtJepFrRlZgmn+oJ6CRhNb0doHTunTODXo2xksrH4hwoAAAAAAAAAoIYBAAAAAAAA\",\n    [\n      \"AKD4XdltkCyBi1Heb4EJJ3lzuV3F4u7+CYeaE+Fd7qXpaT17yd4tHWjMf4CWq3TuXBLxTpkc2MV39P6p7eMV8QnqvbuA0Q1Bqu4RHV3JPpqmH+C527hWJGUBOZN1j9sg8w==\"\n    ],\n    {\n      \"showInput\": true,\n      \"showRawInput\": true,\n      \"showEffects\": true,\n      \"showEvents\": true,\n      \"showObjectChanges\": true,\n      \"showBalanceChanges\": true,\n      \"showRawEffects\": false\n    },\n    \"WaitForLocalExecution\"\n  ]\n}\n\nResponse\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"digest\": \"Gx7V6EteEAqSsptc1kbi1nUEMP7mhr4qV2cYS7JjzbBd\",\n    \"transaction\": {\n      \"data\": {\n        \"messageVersion\": \"v1\",\n        \"transaction\": {\n          \"kind\": \"ProgrammableTransaction\",\n          \"inputs\": [\n            {\n              \"type\": \"pure\",\n              \"valueType\": \"address\",\n              \"value\": \"0x6a101e9a3af5c8070112f808648b36efbf8dee8a1a82de46d9504e96a1108a17\"\n            },\n            {\n              \"type\": \"object\",\n              \"objectType\": \"immOrOwnedObject\",\n              \"objectId\": \"0x8ef76f56c399633a2eb310bca9124e5f2f38ce739eaacbb6600688804e078448\",\n              \"version\": \"2\",\n              \"digest\": \"9Tvs1pGrMbNv7kkr1PoKLsWamyQpaFz5UWbL2AQ1ezk2\"\n            }\n          ],\n          \"transactions\": [\n            {\n              \"TransferObjects\": [\n                [\n                  {\n                    \"Input\": 1\n                  }\n                ],\n                {\n                  \"Input\": 0\n                }\n              ]\n            }\n          ]\n        },\n        \"sender\": \"0x04b497a916b4656609a7fa827a09184d6f47681d3ba74ce0d7a36c64b2b1f887\",\n        \"gasData\": {\n          \"payment\": [\n            {\n              \"objectId\": \"0x9f90f7f866cc29dfb1da6373ce94f9d95dca5a40f4e1769918eebf9fbae00bd3\",\n              \"version\": 2,\n              \"digest\": \"AaeJbTYkUuyromsivxzkoxSkHt7pCESTyQG7xz6nbQ2G\"\n            }\n          ],\n          \"owner\": \"0x04b497a916b4656609a7fa827a09184d6f47681d3ba74ce0d7a36c64b2b1f887\",\n          \"price\": \"10\",\n          \"budget\": \"100000\"\n        }\n      },\n      \"txSignatures\": [\n        \"AKD4XdltkCyBi1Heb4EJJ3lzuV3F4u7+CYeaE+Fd7qXpaT17yd4tHWjMf4CWq3TuXBLxTpkc2MV39P6p7eMV8QnqvbuA0Q1Bqu4RHV3JPpqmH+C527hWJGUBOZN1j9sg8w==\"\n      ]\n    },\n    \"rawTransaction\": \"AQAAAAAAAgAgahAemjr1yAcBEvgIZIs277+N7ooagt5G2VBOlqEQihcBAI73b1bDmWM6LrMQvKkSTl8vOM5znqrLtmAGiIBOB4RIAgAAAAAAAAAgfcN/rn2TKYoSRcMbQgaIwWhstNE1bRcYDdguk6SDxasBAQEBAQABAAAEtJepFrRlZgmn+oJ6CRhNb0doHTunTODXo2xksrH4hwGfkPf4Zswp37HaY3POlPnZXcpaQPThdpkY7r+fuuAL0wIAAAAAAAAAII5Xhy9FIkRo4fwXyBRwidxDGP3UANtnNk7zUMlSZ22FBLSXqRa0ZWYJp/qCegkYTW9HaB07p0zg16NsZLKx+IcKAAAAAAAAAKCGAQAAAAAAAAFhAKD4XdltkCyBi1Heb4EJJ3lzuV3F4u7+CYeaE+Fd7qXpaT17yd4tHWjMf4CWq3TuXBLxTpkc2MV39P6p7eMV8QnqvbuA0Q1Bqu4RHV3JPpqmH+C527hWJGUBOZN1j9sg8w==\",\n    \"effects\": {\n      \"messageVersion\": \"v1\",\n      \"status\": {\n        \"status\": \"success\"\n      },\n      \"executedEpoch\": \"0\",\n      \"gasUsed\": {\n        \"computationCost\": \"100\",\n        \"storageCost\": \"100\",\n        \"storageRebate\": \"10\",\n        \"nonRefundableStorageFee\": \"0\"\n      },\n      \"transactionDigest\": \"9agZ3azEMgMqxrDVG8P4GddELfWag2HhimEkpjixHhGE\",\n      \"mutated\": [\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x04b497a916b4656609a7fa827a09184d6f47681d3ba74ce0d7a36c64b2b1f887\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x9f90f7f866cc29dfb1da6373ce94f9d95dca5a40f4e1769918eebf9fbae00bd3\",\n            \"version\": 2,\n            \"digest\": \"AaeJbTYkUuyromsivxzkoxSkHt7pCESTyQG7xz6nbQ2G\"\n          }\n        },\n        {\n          \"owner\": {\n            \"AddressOwner\": \"0x6a101e9a3af5c8070112f808648b36efbf8dee8a1a82de46d9504e96a1108a17\"\n          },\n          \"reference\": {\n            \"objectId\": \"0x8ef76f56c399633a2eb310bca9124e5f2f38ce739eaacbb6600688804e078448\",\n            \"version\": 2,\n            \"digest\": \"9Tvs1pGrMbNv7kkr1PoKLsWamyQpaFz5UWbL2AQ1ezk2\"\n          }\n        }\n      ],\n      \"gasObject\": {\n        \"owner\": {\n          \"ObjectOwner\": \"0x04b497a916b4656609a7fa827a09184d6f47681d3ba74ce0d7a36c64b2b1f887\"\n        },\n        \"reference\": {\n          \"objectId\": \"0x9f90f7f866cc29dfb1da6373ce94f9d95dca5a40f4e1769918eebf9fbae00bd3\",\n          \"version\": 2,\n          \"digest\": \"AaeJbTYkUuyromsivxzkoxSkHt7pCESTyQG7xz6nbQ2G\"\n        }\n      },\n      \"eventsDigest\": \"816hEv4WAW2reK9xkf11PeHiaZJrp7PQT9oGJZhdf9TN\"\n    },\n    \"objectChanges\": [\n      {\n        \"type\": \"transferred\",\n        \"sender\": \"0x04b497a916b4656609a7fa827a09184d6f47681d3ba74ce0d7a36c64b2b1f887\",\n        \"recipient\": {\n          \"AddressOwner\": \"0x6a101e9a3af5c8070112f808648b36efbf8dee8a1a82de46d9504e96a1108a17\"\n        },\n        \"objectType\": \"0x2::example::Object\",\n        \"objectId\": \"0x8ef76f56c399633a2eb310bca9124e5f2f38ce739eaacbb6600688804e078448\",\n        \"version\": \"2\",\n        \"digest\": \"7PsBHpUW6yfGNov2WrbVafLjgT9nYziQ3gVDbRq6zTbF\"\n      }\n    ]\n  },\n  \"id\": 1\n}\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-api/rpc-best-practices",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui RPCRPC Best Practices\nRPC Best Practices\n\nThis topic provides some best practices for configuring your RPC settings to ensure a reliable infrastructure for your projects and services built on Sui.\n\nCAUTION\n\nUse dedicated nodes/shared services rather than public endpoints for production apps. The public endpoints maintained by Mysten Labs (fullnode.<NETWORK>.sui.io:443) are rate-limited, and support only 100 requests per 30 seconds. Do not use public endpoints in production applications with high traffic volume.\n\nYou can either run your own Full nodes, or outsource this to a professional infrastructure provider (preferred for apps that have high traffic). You can find a list of reliable RPC endpoint providers for Sui on the Sui Dev Portal using the Node Service tag.\n\nRPC provisioning guidance​\n\nConsider the following when working with a provider:\n\nSLA and 24-hour support: Choose a provider that offers a SLA that meets your needs and 24-hour support.\nOnboarding call: Always do an onboarding call with the provider you select to ensure they can provide service that meets your needs. If you have a high-traffic event, such as an NFT mint coming up, notify your RPC provider with the expected traffic increase at least 48 hours in advance.\nRedundancy: It is important for high-traffic and time-sensitive apps, like NFT marketplaces and DeFi protocols, to ensure they don't rely on just one provider for RPCs. Many projects default to just using a single provider, but that's extremely risky and you should use other providers to provide redundancy.\nTraffic estimate: You should have a good idea about the amount and type of traffic you expect, and you should communicate that information in advance with your RPC provider. During high-traffic events (such as NFT mints), request increased capacity from your RPC provider in advance. Bot mitigation - As Sui matures, a lot of bots will emerge on the network. Sui dApp builders should think about bot mitigation at the infrastructure level. This depends heavily on use cases. For NFT minting, bots are undesirable. However, for certain DeFi use cases, bots are necessary. Think about the implications and prepare your infrastructure accordingly.\nProvisioning notice: Make RPC provisioning requests at least one week in advance. This gives operators and providers advance notice so they can arrange for the configure hardware/servers as necessary. If there’s a sudden, unexpected demand, please reach out to us so we can help set you up with providers that have capacity for urgent situations.\nEdit this page\nPrevious\nUnchangedSharedObject\nNext\nSui CLI\nRPC provisioning guidance\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "GraphQL for Sui RPC | Sui Documentation",
      "url": "https://docs.sui.io/references/sui-graphql",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nApi\nDirectives\nMutations\nQueries\nTypes\nDirectives\nEnums\nInputs\nInterfaces\nObjects\nScalars\nUnions\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui RPCGraphQL\nGraphQL for Sui RPC\n\nGraphQL for the Sui RPC is a public service that enables interacting with the Sui network.\n\nTo get started with GraphQL for the Sui RPC, check out the Getting Started guide. If you'd like to learn more about the concepts used in the GraphQL service, check out the GraphQL for Sui RPC concepts page.\n\nKey Types​\n\nAll GraphQL API elements are accessible via the left sidebar, the following are good starting points to explore from.\n\n\"Queries\" lists all top-level queries for reading the chain state, from reading details about addresses and objects to dryRunTransactionBlock, which has an execution-like interface but does not modify the chain.\n\"Mutations\" lists operations that can modify chain state, like executeTransactionBlock.\nObject is the type representing all on-chain objects (Move values and packages).\nAddress corresponds to account addresses (derived from the public keys of signatures that sign transactions) and can be used to query the objects owned by these accounts and the transactions they have signed or been affected by.\nOwner represents any entity that can own a MoveObject to handle cases where it is not known whether the owner is an Object or an Address (for example, from the perspective of a Move object looking at its owner).\nRelated links​\nGraphQL migration: Migrating to GraphQL guides you through migrating Sui RPC projects from JSON-RPC to GraphQL.\nGraphQL quick-start: Querying Sui RPC with GraphQL gets you started using GraphQL to query the Sui RPC for on-chain data.\nGraphQL concepts: GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.\nEdit this page\nPrevious\nSui RPC\nNext\ninclude\nKey Types\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/standards/wallet-standard",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nWallet Standard\nWallet Standard\n\nBrowser extension wallets built for Sui are defined using the Wallet Standard. This is a cross-chain standard that defines how wallets can automatically be discovered and interacted with from dApps.\n\nIf you are building a wallet, we publish a helper library @mysten/wallet-standard which provides types and utilities that make it simple to get started.\n\nCreating a wallet interface​\n\nYou need to create a class that represents your wallet. You can use the Wallet interface from @mysten/wallet-standard to help ensure your class adheres to the standard.\n\nimport { SUI_DEVNET_CHAIN, Wallet } from '@mysten/wallet-standard';\n\nclass YourWallet implements Wallet {\n\tget version() {\n\t\t// Return the version of the Wallet Standard this implements (in this case, 1.0.0).\n\t\treturn '1.0.0';\n\t}\n\tget name() {\n\t\treturn 'Wallet Name';\n\t}\n\tget icon() {\n\t\treturn 'some-icon-data-url';\n\t}\n\t// Return the Sui chains that your wallet supports.\n\tget chains() {\n\t\treturn [SUI_DEVNET_CHAIN];\n\t}\n}\n\nImplementing features​\n\nFeatures are standard methods consumers can use to interact with a wallet. To be listed in the Sui wallet adapter, you must implement the following features in your wallet:\n\nstandard:connect - Used to initiate a connection to the wallet.\nstandard:events - Used to listen for changes that happen within the wallet, such as accounts being added or removed.\nsui:signPersonalMessage - Used to prompt the user to sign a personal message, and return the message signature back to the dApp. This can be used to verify the user’s public key.\nsui:signTransactionBlock - Used to prompt the user to sign a transaction block, and return the serialized transaction block and signature back to the dApp. This method does not submit the transaction block for execution.\nsui:signAndExecuteTransactionBlock - Used to prompt the user to sign a transaction, then submit it for execution to the blockchain.\n\nYou can implement these features in your wallet class under the features property:\n\nimport {\n  ConnectFeature,\n  ConnectMethod,\n  EventsFeature,\n  EventsOnMethod,\n  SuiFeatures,\n  SuiSignPersonalMessageMethod,\n  SuiSignTransactionBlockMethod,\n  SuiSignAndExecuteTransactionBlockMethod\n} from \"@mysten/wallet-standard\";\n\nclass YourWallet implements Wallet {\n\t/* ... existing code from above ... */\n\n  get features(): ConnectFeature & EventsFeature & SuiFeatures {\n    return {\n      \"standard:connect\": {\n        version: \"1.0.0\",\n        connect: this.#connect,\n      },\n      \"standard:events\": {\n        version: \"1.0.0\",\n        on: this.#on,\n      },\n\t\t\t\"sui:signPersonalMessage\": {\n        version: \"1.0.0\",\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n      \"sui:signTransactionBlock\": {\n        version: \"1.0.0\",\n        signTransactionBlock: this.#signTransactionBlock,\n      },\n      \"sui:signAndExecuteTransactionBlock\": {\n        version: \"1.0.0\",\n        signAndExecuteTransactionBlock: this.#signAndExecuteTransactionBlock,\n      },\n    };\n  },\n\n  #on: EventsOnMethod = () => {\n    // Your wallet's events on implementation.\n  };\n\n  #connect: ConnectMethod = () => {\n    // Your wallet's connect implementation\n  };\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = () => {\n    // Your wallet's signTransaction implementation\n  };\n\n  #signTransactionBlock: SuiSignTransactionBlockMethod = () => {\n    // Your wallet's signTransaction implementation\n  };\n\n  #signAndExecuteTransactionBlock: SuiSignAndExecuteTransactionBlockMethod = () => {\n    // Your wallet's signAndExecuteTransaction implementation\n  };\n}\n\nExposing accounts​\n\nThe last requirement of the wallet interface is to expose an accounts interface. This should expose all of the accounts that a connected dApp has access to. It can be empty prior to initiating a connection through the standard:connect feature.\n\nThe accounts can use the ReadonlyWalletAccount class to easily construct an account matching the required interface.\n\nimport { ReadonlyWalletAccount } from '@mysten/wallet-standard';\n\nclass YourWallet implements Wallet {\n\tget accounts() {\n\t\t// Assuming we already have some internal representation of accounts:\n\t\treturn someWalletAccounts.map(\n\t\t\t(walletAccount) =>\n\t\t\t\t// Return\n\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\taddress: walletAccount.suiAddress,\n\t\t\t\t\tpublicKey: walletAccount.pubkey,\n\t\t\t\t\t// The Sui chains that your wallet supports.\n\t\t\t\t\tchains: [SUI_DEVNET_CHAIN],\n\t\t\t\t\t// The features that this account supports. This can be a subset of the wallet's supported features.\n\t\t\t\t\t// These features must exist on the wallet as well.\n\t\t\t\t\tfeatures: [\n\t\t\t\t\t\t'sui:signPersonalMessage',\n\t\t\t\t\t\t'sui:signTransactionBlock',\n\t\t\t\t\t\t'sui:signAndExecuteTransactionBlock',\n\t\t\t\t\t],\n\t\t\t\t}),\n\t\t);\n\t}\n}\n\nRegistering in the window​\n\nOnce you have a compatible interface for your wallet, you register it using the registerWallet function.\n\nimport { registerWallet } from '@mysten/wallet-standard';\n\nregisterWallet(new YourWallet());\n\nEdit this page\nPrevious\nSui Object Display\nCreating a wallet interface\nImplementing features\nExposing accounts\nRegistering in the window\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/standards/display",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nSui Object Display\nSui Object Display\n\nThe Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type. With it, you can substitute data for an object into a template string. The standard doesn’t limit the fields you can set. You can use the {property} syntax to access all object properties, and then insert them as a part of the template string.\n\nUse a Publisher object that you own to set sui::display for a type. For more information about Publisher objects, see Publisher topic in Sui Move by Example.\n\nIn Sui Move, Display<T> represents an object that specifies a set of named templates for the type T. For example, for a type 0x2::capy::Capy the display syntax is: Display<0x2::capy::Capy>.\n\nSui Full nodes process all objects of the type T by matching the Display definition, and return the processed result when you query an object with the { showDisplay: true } setting in the query.\n\nDisplay properties​\n\nThe basic set of properties suggested includes:\n\nname - A name for the object. The name is displayed when users view the object.\ndescription - A description for the object. The description is displayed when users view the object.\nlink - A link to the object to use in an application.\nimage_url - A URL or a blob with the image for the object.\nthumbnail_url - A URL to a smaller image to use in wallets, explorers, and other products as a preview.\nproject_url - A link to a website associated with the object or creator.\ncreator - A string that indicates the object creator.\nAn example Sui Hero module​\n\nThe following code sample demonstrates how the Display for an example Hero module varies based on the name, id, and image_url properties of the type Hero. The following represents the template the init function defines:\n\n{\n    \"name\": \"{name}\",\n    \"link\": \"https://sui-heroes.io/hero/{id}\",\n    \"image_url\": \"ipfs://{image_url}\",\n    \"description\": \"A true Hero of the Sui ecosystem!\",\n    \"project_url\": \"https://sui-heroes.io\",\n    \"creator\": \"Unknown Sui Fan\"\n}\n\n/// Example of an unlimited \"Sui Hero\" collection - anyone can\n/// mint their Hero. Shows how to initialize the `Publisher` and how\n/// to use it to get the `Display<Hero>` object - a way to describe a\n/// type for the ecosystem.\nmodule examples::my_hero {\n    use sui::tx_context::{sender};\n    use std::string::{utf8, String};\n\n    // The creator bundle: these two packages often go together.\n    use sui::package;\n    use sui::display;\n\n    /// The Hero - an outstanding collection of digital art.\n    public struct Hero has key, store {\n        id: UID,\n        name: String,\n        image_url: String,\n    }\n\n    /// One-Time-Witness for the module.\n    public struct MY_HERO has drop {}\n\n    /// In the module initializer one claims the `Publisher` object\n    /// to then create a `Display`. The `Display` is initialized with\n    /// a set of fields (but can be modified later) and published via\n    /// the `update_version` call.\n    ///\n    /// Keys and values are set in the initializer but could also be\n    /// set after publishing if a `Publisher` object was created.\n    fun init(otw: MY_HERO, ctx: &mut TxContext) {\n        let keys = vector[\n            utf8(b\"name\"),\n            utf8(b\"link\"),\n            utf8(b\"image_url\"),\n            utf8(b\"description\"),\n            utf8(b\"project_url\"),\n            utf8(b\"creator\"),\n        ];\n\n        let values = vector[\n            // For `name` one can use the `Hero.name` property\n            utf8(b\"{name}\"),\n            // For `link` one can build a URL using an `id` property\n            utf8(b\"https://sui-heroes.io/hero/{id}\"),\n            // For `image_url` use an IPFS template + `image_url` property.\n            utf8(b\"ipfs://{image_url}\"),\n            // Description is static for all `Hero` objects.\n            utf8(b\"A true Hero of the Sui ecosystem!\"),\n            // Project URL is usually static\n            utf8(b\"https://sui-heroes.io\"),\n            // Creator field can be any\n            utf8(b\"Unknown Sui Fan\")\n        ];\n\n        // Claim the `Publisher` for the package!\n        let publisher = package::claim(otw, ctx);\n\n        // Get a new `Display` object for the `Hero` type.\n        let mut display = display::new_with_fields<Hero>(\n            &publisher, keys, values, ctx\n        );\n\n        // Commit first version of `Display` to apply changes.\n        display::update_version(&mut display);\n\n        transfer::public_transfer(publisher, sender(ctx));\n        transfer::public_transfer(display, sender(ctx));\n    }\n\n    /// Anyone can mint their `Hero`!\n    public fun mint(name: String, image_url: String, ctx: &mut TxContext): Hero {\n        let id = object::new(ctx);\n        Hero { id, name, image_url }\n    }\n}\n\nWork with Object Display​\n\nThe display::new<T> call creates a Display, either in a custom function or module initializer, or as part of a programmable transaction. The following code sample demonstrates how to create a Display:\n\nmodule sui::display {\n    /// Get a new Display object for the `T`.\n    /// Publisher must be the publisher of the T, `from_package`\n    /// check is performed.\n    public fun new<T>(pub: &Publisher): Display<T> { /* ... */ }\n}\n\n\nAfter you create the Display, you can modify it. The following code sample demonstrates how to modify a Display:\n\nmodule sui::display {\n    /// Sets multiple fields at once\n    public fun add_multiple(\n        self: &mut Display,\n        keys: vector<String>,\n        values: vector<String>\n    ) { /* ... */ }\n\n    /// Edit a single field\n    public fun edit(self: &mut Display, key: String, value: String) { /* ... */ }\n\n    /// Remove a key from Display\n    public fun remove(self: &mut Display, key: String ) { /* ... */ }\n}\n\n\nNext, the update_version call applies the changes and sets the Display for the T by emitting an event. Full nodes receive the event and use the data in the event to retrieve a template for the type.\n\nThe following code sample demonstrates how to use the update_version call:\n\nmodule sui::display {\n    /// Update the version of Display and emit an event\n    public fun update_version(self: &mut Display) { /* ... */ }\n}\n\nSui utility objects​\n\nIn Sui, utility objects enable authorization for capabilities. Almost all modules have features that can be accessed only with the required capability. Generic modules allow one capability per application, such as a marketplace. Some capabilities mark ownership of a shared object on-chain, or access the shared data from another account. With capabilities, it is important to provide a meaningful description of objects to facilitate user interface implementation. This helps avoid accidentally transferring the wrong object when objects are similar. It also provides a user-friendly description of items that users see.\n\nThe following example demonstrates how to create a capy capability:\n\nmodule capy::utility {\n   /// A capability which grants Capy Manager permission to add\n   /// new genes and manage the Capy Market\n   struct CapyManagerCap has key, store {\n    id: UID }\n}\n\nTypical objects with data duplication​\n\nA common case with in-game items is to have a large number of similar objects grouped by some criteria. It is important to optimize their size and the cost to mint and update them. Typically, a game uses a single source image or URL per group or item criteria. Storing the source image inside of every object is not optimal. In some cases, users mint in-game items when a game allows them or when they purchase an in-game item. To enable this, some IPFS/Arweave metadata must be created and stored in advance. This requires additional logic that is usually not related to the in-game properties of the item.\n\nThe following example demonstrates how to create a Capy:\n\nmodule capy::capy_items {\n   /// A wearable Capy item. For some items there can be an\n   /// unlimited supply. And items with the same name are identical.\n   struct CapyItem has key, store {\n        id: UID,\n        name: String\n   }\n}\n\nUnique objects with dynamic representation​\n\nSui Capys use dynamic image generation. When a Capy is born, its attributes determine the Capy’s appearance, such as color or pattern. When a user puts an item on a Capy, the Capy’s appearance changes. When users put multiple items on a Capy, there’s a chance of a bonus for a combination of items.\n\nTo implement this, the Capys game API service refreshes the image in response to a user-initiated change. The URL for a Capy is a template with the capy.id. But storing the full URL - as well as other fields in the Capy object due to their diverse population - also leads to users paying for excess storage and increased gas fees.\n\nThe following example demonstrates how to implement dynamic image generation:\n\nmodule capy::capy {\n   /// A Capy - very diverse object with different combination\n   /// of genes. Created dynamically + for images a dynamic SVG\n   /// generation is used.\n   struct Capy has key, store {\n    id: UID,\n    genes: vector<u8>\n   }\n}\n\nObjects with unique static content​\n\nThis is the simplest scenario - an object represents everything itself. It is very easy to apply a metadata standard to an object of this kind, especially if the object stays immutable forever. However, if the metadata standard evolves and some ecosystem projects add new features for some properties, this object always stays in its original form and might require backward-compatible changes.\n\nmodule sui::devnet_nft {\n   /// A Collectible with a static data. URL, name, description are\n   /// set only once on a mint event\n   struct DevNetNFT has key, store {\n       id: UID,\n       name: String,\n       description: String,\n       url: Url,\n   }\n}\n\nEdit this page\nPrevious\nTrade and Swap\nNext\nWallet Standard\nDisplay properties\nAn example Sui Hero module\nWork with Object Display\nSui utility objects\nTypical objects with data duplication\nUnique objects with dynamic representation\nObjects with unique static content\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/standards/deepbook",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nDesign\nDeepBook Orders\nDeepBook Pools\nQuery The Pool\nRouting a Swap\nTrade and Swap\nSui Object Display\nWallet Standard\nDeepBook\nDeepBook\n\nAs Sui's first native liquidity layer, DeepBook provides token trading activity. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy. DeepBook operates as a decentralized and permissionless environment to support token trades.\n\nDeepBook is open for community development. You can use the Sui Improvement Proposals (SIPs) process to suggest changes to make DeepBook better.\n\nDeepBook does not include an end-user interface for token trading. Rather, it offers built-in trading functionality that can support token trades from decentralized exchanges, wallets, or other apps. You can leverage its SDK to build functionality for token trades and price queries.\n\nLiquidity support​\n\nSimilar to order books for other market places, DeepBook's central limit order book (CLOB) architecture enables you to enter market and limit orders. You can sell SUI tokens, referred to as an \"ask,\" can set your price, referred to as a limit order, or sell at the market's going rate. If you are seeking to buy SUI, referred to as a \"bid,\" you can pay the current market price or set a limit amount you're willing to pay. Limit orders only get fulfilled if the CLOB finds a match between a buyer and seller.\n\nIf you put in a limit order for 1,000 SUI, and no single seller is currently offering that quantity of tokens, DeepBook automatically pools the current asks to meet the quantity of your bid.\n\nTransparency and privacy​\n\nAs a CLOB, DeepBook works like a digital ledger, logging bids and asks in chronological order and automatically finding matches between the two sides. It takes into account user parameters on trades such as prices.\n\nThe digital ledger is open so people can view the trades and prices, giving clear proof of fairness. You can use this transparency to create metrics and dashboards to monitor trading activity.\n\nEdit this page\nPrevious\nNFT Rental Using Kiosk Apps\nNext\nDesign\nLiquidity support\nTransparency and privacy\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Kiosk | Sui Documentation",
      "url": "https://docs.sui.io/standards/kiosk",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nSui Kiosk\nSui Kiosk\n\nKiosk is a decentralized system for commerce applications on Sui. It consists of Kiosks - shared objects owned by individual parties that store assets and allow listing them for sale as well as utilize custom trading functionality - for example, an auction. While being highly decentralized, Kiosk provides a set of strong guarantees:\n\nKiosk owners retain ownership of their assets to the moment of purchase.\nCreators set custom policies - sets of rules applied to every trade (such as pay royalty fee or do some arbitrary action X).\nMarketplaces can index events the Kiosk emits and subscribe to a single feed for on-chain asset trading.\n\nPractically, Kiosk is a part of the Sui framework, and it is native to the system and available to everyone out of the box.\n\nINFO\n\nSee the Kiosk SDK documentation for examples of working with Kiosk using TypeScript.\n\nSui Kiosk owners​\n\nAnyone can create a Sui Kiosk. Ownership of a kiosk is determined by the owner of the KioskOwnerCap, a special object that grants full access to a single kiosk. As the owner, you can sell any asset with a type (T) that has a shared TransferPolicy available, or you can use a kiosk to store assets even without a shared policy. You can’t sell or transfer any assets from your kiosk that do not have an associated transfer policy available.\n\nTo sell an item, if there is an existing transfer policy for the type (T), you just add your assets to your kiosk and then list them. You specify an offer amount when you list an item. Anyone can then purchase the item for the amount of SUI specified in the listing. The associated transfer policy determines what the buyer can do with the purchased asset.\n\nA Kiosk owner can:\n\nPlace and take items\nList items for sale\nAdd and remove Extensions\nWithdraw profits from sales\nBorrow and mutate owned assets\nAccess the full set of trading tools, such as auctions, lotteries, and collection bidding\nSui Kiosk for buyers​\n\nA buyer is a party that purchases (or - more generally - receives) items from Kiosks, anyone on the network can be a Buyer (and, for example, a Kiosk Owner at the same time).\n\n** Benefits:**\n\nBuyers get access to global liquidity and can get the best offer\nBuyers can place bids on collections through their Kiosks\nMost of the actions performed in Kiosks are free (gas-less) for Buyers\n\nResponsibilities:\n\nBuyer is the party that pays the fees if they're set in the policy\nBuyer must follow the rules set by creators or a transaction won't succeed\n\nGuarantees:\n\nWhen using a custom trading logic such as an Auction, the items are guaranteed to be unchanged until the trade is complete\nSui Kiosk for marketplaces​\n\nAs a marketplace operator, you can implement Sui Kiosk to watch for offers made in a collection of kiosks and display them on a marketplace site. You can also implement a custom system using Kiosk extensions (created by the community or third-parties). For example, marketplaces can use a TransferPolicyCap to implement application-specific transfer rules.\n\nSui Kiosk for creators​\n\nAs a creator, Sui Kiosk supports strong enforcement for transfer policies and associated rules to protect assets and enforce asset ownership. Sui Kiosk gives creators more control over their creations, and puts creators and owners in control of how their works can be used.\n\nCreator is a party that creates and controls the TransferPolicy for a single type. For example, the authors of SuiFrens are the Creators of the SuiFren<Capy> type and act as creators in the Kiosk ecosystem. Creators set the policy, but they might also be the first sellers of their assets through a Kiosk.\n\nCreators can:\n\nSet any rules for trades\nSet multiple ways (\"tracks\") of rules\nEnable or disable trades at any moment with a policy\nEnforce policies (eg royalties) on all trades\nPerform a primary sale of their assets through a Kiosk\n\nAll of the above is effective immediately and globally.\n\nCreators cannot:\n\nTake or modify items stored in someone else's Kiosk\nRestrict taking items from Kiosks if the \"locking\" rule was not set in the policy\nSui Kiosk guarantees​\n\nSui Kiosk provides a set of guarantees that Sui enforces through smart contracts. These guarantees include:\n\nEvery trade in Sui Kiosk requires a TransferPolicy resolution. This gives creators control over how their assets can be traded.\nTrue Ownership, which means that only a kiosk owner can take, list, borrow, or modify the assets added to their kiosk. This is similar to how single-owner objects work on Sui.\nStrong policy enforcement, for example Royalty policies, that lets creators enable or disable policies at any time that applies to all trades on the platform for objects with that policy attached.\nChanges to a TransferPolicy apply instantly and globally.\n\nIn practice, these guarantees mean that:\n\nWhen you list an item for sale, no one can modify it or take it from the kiosk.\nWhen you define a PurchaseCap, an item remains locked and you can’t modify or take the item from the kiosk unless the trade uses or returns the PurchaseCap.\nYou can remove any rule at any time (as the owner).\nYou can disable any extension at any time (as the owner).\nThe state of an extension state is always accessible to the extension.\nAsset states in Sui Kiosk​\n\nSui Kiosk is a shared object that can store heterogeneous values, such as different sets of asset collectibles. When you add an asset to your kiosk, it has one of the following states:\n\nPLACED - an item placed in the kiosk using the kiosk::place function. The Kiosk Owner can withdraw it and use it directly, borrow it (mutably or immutably), or list an item for sale.\nLOCKED - an item placed in the kiosk using the kiosk::lock function. You can’t withdraw a Locked item from a kiosk, but you can borrow it mutably and list it for sale. Any item placed in a kiosk that has an associated Kiosk Lock policy have a LOCKED state.\nLISTED - an item in the kiosk that is listed for sale using the kiosk::list or kiosk::place_and_list functions. You can’t modify an item while listed, but you can borrow it immutably or delist it, which returns it to its previous state.\nLISTED EXCLUSIVELY - an item placed or locked in the kiosk by an extension that calls the kiosk::list_with_purchase_cap function. Only the kiosk owner can approve calling the function. The owner can only borrow it immutably. The extension must provide the functionality to delist / unlock the asset, or it might stay locked forever. Given that this action is explicitly performed by the Owner - it is the responsibility of the Owner to choose verified and audited extensions to use.\n\nWhen someone purchases an asset from a kiosk, the asset leaves the kiosk and ownership transfers to the buyer’s address.\n\nOpen a Sui Kiosk​\n\nTo use a Sui Kiosk, you must create one and have the KioskOwnerCap that matches the Kiosk object. You can create a new kiosk using a single transaction by calling the kiosk::default function. The function creates and shares a Kiosk, and transfers the KioskOwnerCap to your address.\n\nCreate a Sui Kiosk using programmable transaction blocks​\nlet tx = new TransactionBlock();\ntx.moveCall({\n    target: '0x2::kiosk::default'\n});\n\nCreate a Sui Kiosk using the Sui CLI​\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client call \\\n    --package 0x2 \\\n    --module kiosk \\\n    --function default \\\n    --gas-budget 1000000000\n\nCreate a Sui Kiosk with advanced options​\n\nFor more advanced use cases, when you want to choose the storage model or perform an action right away, you can use the programmable transaction block (PTB) friendly function kiosk::new. Kiosk is designed to be shared. If you choose a different storage model, such as owned, your kiosk might not function as intended or not be accessible to other users. You can make sure your Kiosk works by testing it on Sui Testnet.\n\nCreate a Sui Kiosk with advanced options using programmable transaction blocks​\nlet tx = new TransactionBlock();\nlet [kiosk, kioskOwnerCap] = tx.moveCall({\n    target: '0x2::kiosk::new'\n});\n\ntx.transferObjects([ kioskOwnerCap ], sender);\ntx.moveCall({\n    target: '0x2::transfer::public_share_object',\n    arguments: [ kiosk ],\n    typeArguments: '0x2::kiosk::Kiosk'\n})\n\nCreate a Sui Kiosk with advanced options using the SUI CLI​\n\nSui CLI does not support PTBs and transaction chaining yet. You can use the kiosk::default function instead.\n\nPlace items in and take items from your kiosk​\n\nAs a kiosk owner, you can place any assets into your Sui Kiosk. You can take any item from your kiosk that is not currently listed for sale.\n\nThere's no limitations on which assets you can place in your kiosk. However, you can’t necessarily list and trade all of the items you place in your kiosk. The TransferPolicy associated with the type for the item determines whether you can trade it. To learn more, see the Purchase items from a Kiosk section.\n\nPlace an item in your kiosk​\n\nTo place an item to the Kiosk, the owner needs to call the sui::kiosk::place function on the Kiosk object and pass the KioskOwnerCap and the Item as arguments.\n\nITEM_TYPE in the following examples represents the full type of the item.\n\nPlace an item using programmable transaction blocks​\nlet tx = new TransactionBlock();\n\nlet itemArg = tx.object('<ID>');\nlet kioskArg = tx.object('<ID>');\nlet kioskOwnerCapArg = tx.object('<ID>');\n\ntx.moveCall({\n    target: '0x2::kiosk::place',\n    arguments: [ kioskArg, kioskOwnerCapArg, itemArg ],\n    typeArguments: [ '<ITEM_TYPE>' ]\n})\n\nPlace an item using the Sui CLI​\nsui client call \\\n    --package 0x2 \\\n    --module kiosk \\\n    --function place \\\n    --args \"<KIOSK_ID>\" \"<CAP_ID>\" \"<ITEM_ID>\" \\\n    --type-args \"<ITEM_TYPE>\" \\\n    --gas-budget 1000000000\n\nTake items from a kiosk​\n\nTo take an item from a kiosk you must be the kiosk owner. As the owner, call the sui::kiosk::take function on the Kiosk object, and pass the KioskOwnerCap and ID of the item as arguments.\n\nITEM_TYPE in the following examples represents the full type of the item.\n\nTake an item from a kiosk using programmable transaction blocks​\nlet tx = new TransactionBlock();\n\nlet itemId = tx.pure.id('<ITEM_ID>');\nlet kioskArg = tx.object('<ID>');\nlet kioskOwnerCapArg = tx.object('<ID>');\n\nlet item = tx.moveCall({\n    target: '0x2::kiosk::take',\n    arguments: [ kioskArg, kioskOwnerCapArg, itemId ],\n    typeArguments: [ '<ITEM_TYPE>' ]\n});\n\nTake an item from a kiosk using the Sui CLI​\n\nThe kiosk::take function is built to be PTB friendly and returns the asset. The Sui CLI does not yet support transaction chaining.\n\nLock items in a kiosk​\n\nSome policies require that assets never get removed from a kiosk, such as for strong royalty enforcement. To support this, Sui Kiosk provides a locking mechanism. Locking is similar to placing except that you can't take a locked asset out of the kiosk.\n\nTo lock an asset in a kiosk, call the sui::kiosk::lock function. To ensure that you can later unlock the asset you must associate a TransferPolicy with the asset.\n\nINFO\n\nAfter you lock an asset, you must use list or list_with_purchase_cap functions to list it.\n\nLock an item in a kiosk​\n\nWhen you use the lock function, similar to using the place function, you specify the KioskOwnerCap and the Item as arguments. But to lock the item, you must also show the TransferPolicy.\n\n<ITEM_TYPE> in the following examples represents the full type of the asset.\n\nLock an item using programmable transaction blocks​\nconst tx = new TransactionBlock();\n\nlet kioskArg = tx.object('<ID>');\nlet kioskOwnerCapArg = tx.object('<ID>');\nlet itemArg = tx.object('<ID>');\nlet transferPolicyArg = tx.object('<ID>');\n\ntx.moveCall({\n    target: '0x2::kiosk::lock',\n    arguments: [ kioskArg, kioskOwnerCapArg, transferPolicyArg, itemArg ],\n    typeArguments: [ '<ITEM_TYPE>' ]\n});\n\nLock an item using the Sui CLI​\nsui client call \\\n    --package 0x2 \\\n    --module kiosk \\\n    --function lock \\\n    --args \"<KIOSK_ID>\" \"<CAP_ID>\" \"<TRANSFER_POLICY_ID>\" \"<ITEM_ID>\" \\\n    --type-args \"<ITEM_TYPE>\" \\\n    --gas-budget 1000000000\n\nList and delist items from a kiosk​\n\nSui Kiosk provides basic trading functionality. As a kiosk owner, you can list assets for sale, and buyers can discover and purchase them. Sui Kiosk supports listing items by default with three primary functions:\n\nkiosk::list - list an asset for sale for a fixed price\nkiosk::delist - remove an existing listing\nkiosk::purchase - purchase an asset listed for sale\n\nAnyone on the network can purchase an item listed from a Sui Kiosk. To learn more about the purchase flow, see the Purchase section. To learn more about asset states and what can be done with a listed item, see the Asset States section.\n\nList an item from a kiosk​\n\nAs a kiosk owner, you can use the kiosk::list function to list any asset you added to your kiosk. Include the item to sell and the list price as arguments. All listings on Sui are in SUI tokens. When you list an item, Sui emits a kiosk::ItemListed event that contains the Kiosk ID, Item ID, type of the Item, and the list price.\n\nList an item using programmable transaction blocks​\nlet tx = new TransactionBlock();\n\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\nlet itemId = tx.pure.id('<ID>');\nlet itemType = 'ITEM_TYPE';\nlet priceArg = tx.pure.u64('<price>'); // in MIST (1 SUI = 10^9 MIST)\n\ntx.moveCall({\n    target: '0x2::kiosk::list',\n    arguments: [ kioskArg, capArg, itemId, priceArg ],\n    typeArguments: [ itemType ]\n});\n\nList an item using the Sui CLI​\nsui client call \\\n    --package 0x2 \\\n    --module kiosk \\\n    --function list \\\n    --args \"<KIOSK_ID>\" \"<CAP_ID>\" \"<ITEM_ID>\" \"<PRICE>\" \\\n    --type-args \"ITEM_TYPE\" \\\n    --gas-budget 1000000000\n\nDelist an item​\n\nAs a kiosk owner you can use the kiosk::delist to delist any currently listed asset. Specify the item to delist as an argument.\n\nWhen you delist an item, Sui returns to the kiosk owner the gas fees charged to list the item.\n\nWhen you delist an item, Sui emits a kiosk::ItemDelisted event that contains the Kiosk ID, Item ID, and the type of the item.\n\nDelist an item using the programmable transaction blocks​\nlet tx = new TransactionBlock();\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\nlet itemId = tx.pure.id('<ID>');\nlet itemType = 'ITEM_TYPE';\n\ntx.moveCall({\n    target: '0x2::kiosk::delist',\n    arguments: [ kioskArg, capArg, itemId ],\n    typeArguments: [ itemType ]\n});\n\nDelist an item using the Sui CLI​\nsui client call \\\n    --package 0x2 \\\n    --module kiosk \\\n    --function delist \\\n    --args \"<KIOSK_ID>\" \"<CAP_ID>\" \"<ITEM_ID>\" \\\n    --type-args \"ITEM_TYPE\" \\\n    --gas-budget 1000000000\n\nPurchase an item from a kiosk​\n\nAnyone that has an address on the Sui network can purchase an item listed from a Sui Kiosk. To purchase an item, you can use the kiosk::purchase function. Specify the item to purchase and pay the list price set by the Kiosk Owner.\n\nYou can discover the items listed on the network with the kiosk::ItemListed event.\n\nWhen you use the kiosk::purchase function, it returns the purchased asset and the TransferRequest for the type associated with the asset. To complete the purchase, you must meet the terms defined in the TransferPolicy applied to the asset.\n\nBorrow an item from a kiosk​\n\nAs a kiosk owner, you can access an asset placed or locked in a kiosk without taking the asset from the kiosk. You can always borrow the asset immutably. Whether you can mutably borrow an asset depends on the state of the asset. For example, you can’t borrow a listed asset because you can’t modify it while listed. The functions available include:\n\nkiosk::borrow - returns an immutable reference to the asset\nkiosk::borrow_mut - returns a mutable reference to the asset\nkiosk::borrow_val - a PTB-friendly version of borrow_mut, which allows you to take an asset and place it back in the same transaction.\nImmutable borrow​\n\nYou can always borrow an asset from a kiosk immutably. You can use the kiosk::borrow function to borrow an asset, however, it is not possible to use references within a programmable transaction block. To access the asset you must use a published module (function).\n\nImmutably borrow an asset using Sui Move​\nmodule examples::immutable_borrow {\n    use sui::object::ID;\n    use sui::kiosk::{Self, Kiosk, KioskOwnerCap};\n\n    public fun immutable_borrow_example<T>(self: &Kiosk, cap: &KioskOwnerCap, item_id: ID): &T {\n        kiosk::borrow(self, cap, item_id)\n    }\n}\n\nMutable borrow with borrow_mut​\n\nYou can mutably borrow an asset from a kiosk if it is not listed. You can use the kiosk::borrow_mut function to mutably borrow an asset. However, it is not possible to use references within a PTB, so to access the mutably borrowed asset you must use a published module (function).\n\nMutably borrow an asset using Sui Move​\nmodule examples::mutable_borrow\n    use sui::object::ID;\n    use sui::kiosk::{Self, Kiosk, KioskOwnerCap};\n\n    public fun mutable_borrow_example<T>(\n        self: &mut Kiosk, cap: &KioskOwnerCap, item_id: ID\n    ): &mut T {\n        kiosk::borrow_mut(self, cap, item_id)\n    }\n}\n\nMutable borrow with borrow_val​\n\nYou can use the PTB-friendly kiosk::borrow_val function. It allows you to take an asset and place it back in the same transaction. To make sure the asset is placed back into the kiosk, the function \"obliges\" the caller with a “Hot Potato”.\n\nMutable borrow with borrow_val using programmable transaction blocks​\nlet tx = new TransactionBlock();\n\nlet itemType = 'ITEM_TYPE';\nlet itemId = tx.pure.id('<ITEM_ID>');\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\n\nlet [item, promise] = tx.moveCall({\n    target: '0x2::kiosk::borrow_val',\n    arguments: [ kioskArg, capArg, itemId ],\n    typeArguments: [ itemType ],\n});\n\n// freely mutate or reference the `item`\n// any calls are available as long as they take a reference\n// `returnValue` must be explicitly called\n\ntx.moveCall({\n    target: '0x2::kiosk::return_val',\n    arguments: [ kioskArg, item, promise ],\n    typeArguments: [ itemType ],\n});\n\nWithdraw proceeds from a completed sale​\n\nWhen someone purchases an item, Sui stores the proceeds from the sale in the Kiosk. As the kiosk owner, you can withdraw the proceeds at any time by calling the kiosk::withdraw function. The function is simple, but because it is PTB friendly it is not currently supported in the Sui CLI.\n\nWithdraw proceeds using programmable transaction blocks​\nlet tx = new TransactionBlock();\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\n\n// because the function uses an Option<u64> argument,\n// constructing is a bit more complex\nlet amountArg = tx.moveCall({\n    target: '0x1::option::some',\n    arguments: [ tx.pure.u64('<amount>') ],\n    typeArguments: [ 'u64' ],\n});\n\n// alternatively\nlet withdrawAllArg = tx.moveCall({\n    target: '0x1::option::none',\n    typeArguments: [ 'u64' ],\n});\n\nlet coin = tx.moveCall({\n    target: '0x2::kiosk::withdraw',\n    arguments: [ kioskArg, capArg, amountArg ],\n    typeArguments: [ 'u64' ],\n});\n\nWithdraw proceeds using the Sui CLI​\n\nDue to the function being PTB friendly, it is not currently supported in the CLI environment.\n\nEdit this page\nPrevious\nCoin/Token API comparison\nNext\nKiosk Apps\nSui Kiosk owners\nSui Kiosk for buyers\nSui Kiosk for marketplaces\nSui Kiosk for creators\nSui Kiosk guarantees\nAsset states in Sui Kiosk\nOpen a Sui Kiosk\nCreate a Sui Kiosk using programmable transaction blocks\nCreate a Sui Kiosk using the Sui CLI\nCreate a Sui Kiosk with advanced options\nCreate a Sui Kiosk with advanced options using programmable transaction blocks\nCreate a Sui Kiosk with advanced options using the SUI CLI\nPlace items in and take items from your kiosk\nPlace an item in your kiosk\nPlace an item using programmable transaction blocks\nPlace an item using the Sui CLI\nTake items from a kiosk\nTake an item from a kiosk using programmable transaction blocks\nTake an item from a kiosk using the Sui CLI\nLock items in a kiosk\nLock an item in a kiosk\nLock an item using programmable transaction blocks\nLock an item using the Sui CLI\nList and delist items from a kiosk\nList an item from a kiosk\nList an item using programmable transaction blocks\nList an item using the Sui CLI\nDelist an item\nDelist an item using the programmable transaction blocks\nDelist an item using the Sui CLI\nPurchase an item from a kiosk\nBorrow an item from a kiosk\nImmutable borrow\nImmutably borrow an asset using Sui Move\nMutable borrow with borrow_mut\nMutably borrow an asset using Sui Move\nMutable borrow with borrow_val\nMutable borrow with borrow_val using programmable transaction blocks\nWithdraw proceeds from a completed sale\nWithdraw proceeds using programmable transaction blocks\nWithdraw proceeds using the Sui CLI\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/standards/kiosk-apps",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nNFT Rental Example\nDeepBook\nSui Object Display\nWallet Standard\nKiosk Apps\nKiosk Apps\n\nKiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.\n\nThere are two types of apps:\n\nBasic apps\nPermissioned apps\nBasic apps​\n\nBasic Kiosk apps do not require Kiosk Apps API to function. They usually serve the purpose of adding custom metadata to a kiosk or wrapping/working with existing objects such as Kiosk or KioskOwnerCap. An example of an app that does not require the API is the Personal Kiosk app.\n\nUID access via the uid_mut​\n\nKiosk has an id: UID field like all objects on Sui, which allows this object to be uniquely identified and carry custom dynamic fields and dynamic object fields. The Kiosk itself is built around dynamic fields and features like place and list are built around dynamic object fields.\n\nThe uid_mut_as_owner function​\n\nKiosk can carry additional dynamic fields and dynamic object fields. The uid_mut_as_owner function allows the Kiosk owner to mutably access the UID of the Kiosk object and use it to add or remove custom fields.\n\nFunction signature:\n\nkiosk::uid_mut_as_owner(self: &mut Kiosk, cap: &KioskOwnerCap): &mut UID\n\nThe public uid getter​\n\nAnyone can read the uid of kiosks. This allows third party modules to read the fields of the kiosk if they're allowed to do so. Therefore enabling the object capability and other patterns.\n\nBasic app ideas​\n\nYou can attach custom dynamic fields to your kiosks that anyone can then read (but only you can modify), you can use this to implement basic apps. For example, a Kiosk Name app where you as the kiosk owner can set a name for the kiosk, attach it as a dynamic field, and make it readable by anyone.\n\nmodule examples::kiosk_name_ext {\n    use std::string::String;\n    use std::option::{Self, Option};\n    use sui::dynamic_field as df;\n    use sui::kiosk::{Self, Kiosk, KioskOwnerCap};\n\n    /// The dynamic field key for the Kiosk Name Extension\n    struct KioskName has copy, store, drop {}\n\n    /// Add a name to the Kiosk (in this implementation can be called only once)\n    public fun add(self: &mut Kiosk, cap: &KioskOwnerCap, name: String) {\n        let uid_mut = kiosk::uid_mut_as_owner(self, cap);\n        df::add(uid_mut, KioskName {}, name)\n    }\n\n    /// Try read the name of the Kiosk - if set - return Some(String), if not - None\n    public fun name(self: &Kiosk): Option<String> {\n        if (df::exists_(kiosk::uid(self), KioskName {})) {\n            option::some(*df::borrow(kiosk::uid(self), KioskName {}))\n        } else {\n            option::none()\n        }\n    }\n}\n\nPermissioned apps using the Kiosk Apps API​\n\nPermissioned apps use the Kiosk Apps API to perform actions in the kiosk. They usually imply interaction with a third party and provide guarantees for the storage access (preventing malicious actions from the seller).\n\nJust having access to the uid is often not enough to build an app due to the security limitations. Only the owner of a kiosk has full access to the uid, which means that an app involving a third party would require involvement from the kiosk owner in every step of the process.\n\nIn addition to limited and constrained access to storage, app permissions are also owner dependent. In the default setup, no party can place or lock items in a kiosk without its owner's consent. As a result, some cases such as collection bidding (offering X SUI for any item in a collection) requires the kiosk owner to approve the bid.\n\nkiosk_extension module​\n\nThe kiosk_extension module addresses concerns over owner bottlenecks and provides more guarantees for storage access. The module provides a set of functions that enable you to perform certain actions in the kiosk without the kiosk owner's involvement and have a guarantee that the storage of the app is not tampered with.\n\nmodule example::my_extension {\n    use sui::kiosk_extension;\n\n    // ...\n}\n\nApp lifecycle​\n\nThese are the key points in the lifecycle of a Sui Kiosk app:\n\nYou can only install an app with an explicit call in the kiosk_extension module.\nA kiosk owner can revoke permissions of an app at any time by calling the disable function.\nA kiosk owner can re-enable a disabled app at any time by calling the enable function.\nYou can only remove apps if the app storage is empty (all items are removed).\nAdding an app​\n\nFor the app to function, the kiosk owner first needs to install it. To achieve that, an app needs to implement the add function that the kiosk owner calls to request all necessary permissions.\n\nImplementing add function​\n\nThe signature of the kiosk_extension::add function requires the app witness, making it impossible to install an app without an explicit implementation. The following example shows how to implement the add function for an app that requires the place permission:\n\nmodule examples::letterbox_ext {\n    // ... dependencies\n\n    /// The expected set of permissions for extension. It requires `place`.\n    const PERMISSIONS: u128 = 1;\n\n    /// The Witness struct used to identify and authorize the extension.\n    struct Extension has drop {}\n\n    /// Install the Mallbox extension into the Kiosk.\n    public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {\n        kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)\n    }\n}\n\nApp permissions​\n\nApps can request permissions from the kiosk owner on installation. Permissions follow the all or nothing principle. If the kiosk owner adds an app, it gets all of the requested permissions; if the kiosk owner then disables an app, it loses all of its permissions.\n\nStructure​\n\nPermissions are represented as a u128 integer storing a bitmap. Each of the bits corresponds to a permission, the first bit is the least significant bit. The following table lists all permissions and their corresponding bit:\n\nBit\tDecimal\tPermission\n0000\t0\tNo permissions\n0001\t1\tApp can place\n0010\t2\tApp can place and lock\n0011\t3\tApp can place and lock\nINFO\n\nCurrently, Sui Kiosk has only two permissions: place (first bit) and lock and place (second bit). The remaining bits are reserved for future use.\n\nUsing permissions in the add function​\n\nIt's considered good practice to define a constant containing permissions of the app:\n\nmodule examples::letterbox_ext {\n    // ... dependencies\n\n    /// The expected set of permissions for the app. It requires `place`.\n    const PERMISSIONS: u128 = 1;\n\n    /// The witness struct used to identify and authorize the app.\n    struct Extension has drop {}\n\n    /// Install the Mallbox app into the kiosk and request `place` permission.\n    public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {\n        kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)\n    }\n}\n\nAccessing protected functions​\n\nIf an app requests and is granted permissions (and isn't disabled), it can access protected functions. The following example shows how to access the place function:\n\nmodule examples::letterbox_ext {\n    // ...\n\n    /// Emitted when trying to place an item without permissions.\n    const ENotEnoughPermissions: u64 = 1;\n\n    /// Place a letter into the kiosk without the `KioskOwnerCap`.\n    public fun place(kiosk: &mut Kiosk, letter: Letter, policy: &TransferPolicy<T>) {\n        assert!(kiosk_extension::can_place<Extension>(kiosk), ENotEnoughPermissions)\n\n        kiosk_extension::place(Extension {}, kiosk, letter, policy)\n    }\n}\n\n\nCurrently, two functions are available:\n\nplace<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>) - similar to place\nlock<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>) - similar to lock\nChecking permissions​\n\nUse the can_place<Ext>(kiosk: &Kiosk): bool function to check if the app has the place permission. Similarly, you can use the can_lock<Ext>(kiosk: &Kiosk): bool function to check if the app has the lock permission. Both functions make sure that the app is enabled, so you don't need to explicitly check for that.\n\nApp storage​\n\nEvery app gets its isolated storage as a bag type that only the app module can access (providing the app witness). After you install an app, it can use the storage to store its data. Ideally, the storage should be managed in a way that allows the app to be removed from the kiosk if there are no active trades or other activities happening at the moment.\n\nThe storage is always available to the app if it is installed. The owner of a kiosk can't access the storage of the app if the logic for it is not implemented.\n\nAccessing the storage​\n\nAn installed app can access the storage mutably or immutably using one of the following functions:\n\nstorage(_ext: Extension {}, kiosk: &Kiosk): Bag: returns a reference to the storage of the app. Use the function to read the storage.\nstorage_mut(_ext: Extension {}, kiosk: &mut Kiosk): &mut Bag: returns a mutable reference to the storage of the app. Use the function to read and write to the storage.\nDisabling and removing​\n\nThe kiosk owner can disable any app at any time. Doing so revokes all permissions of the app and prevents it from performing any actions in the kiosk. The kiosk owner can also re-enable the app at any time.\n\nDisabling an app does not remove it from the kiosk. An installed app has access to its storage until completely removed from the kiosk.\n\nDisabling an app​\n\nUse the disable<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap) function to disable an app. It revokes all permissions of the app and prevents it from performing any protected actions in the kiosk.\n\nExample PTB\n\nlet txb = new TransactionBuilder();\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\n\ntxb.moveCall({\n    target: '0x2::kiosk_extension::disable',\n    arguments: [ kioskArg, capArg ],\n    typeArguments: '<letter_box_package>::letterbox_ext::Extension'\n});\n\nRemoving an app​\n\nYou can remove an app only if the storage is empty. Use the remove<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap) function to facilitate removal. The function removes the app, unpacks the app storage and configuration and rebates the storage cost to the kiosk owner. Only the kiosk owner can perform this action.\n\nThe call fails if the storage is not empty.\n\nExample PTB\n\nlet txb = new TransactionBuilder();\nlet kioskArg = tx.object('<ID>');\nlet capArg = tx.object('<ID>');\n\ntxb.moveCall({\n    target: '0x2::kiosk_extension::remove',\n    arguments: [ kioskArg, capArg ],\n    typeArguments: '<letter_box_package>::letterbox_ext::Extension'\n});\n\nRelated links​\nNFT Rental: An example implementation of the Kiosk Apps standard that enables renting NFTs.\nNFT Rental repository: GitHub repo that contains the source code for the NFT Rental app.\nEdit this page\nPrevious\nSui Kiosk\nNext\nNFT Rental Using Kiosk Apps\nBasic apps\nUID access via the uid_mut\nThe uid_mut_as_owner function\nThe public uid getter\nBasic app ideas\nPermissioned apps using the Kiosk Apps API\nkiosk_extension module\nApp lifecycle\nAdding an app\nImplementing add function\nApp permissions\nStructure\nUsing permissions in the add function\nAccessing protected functions\nChecking permissions\nApp storage\nAccessing the storage\nDisabling and removing\nDisabling an app\nRemoving an app\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/standards/closed-loop-token",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nAction Request\nToken Policy\nSpending\nRules\nCoin/Token API comparison\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nClosed-Loop Token\nClosed-Loop Token\n\nUsing the Closed-Loop Token standard, you can limit the applications that can use the token and set up custom policies for transfers, spends, and conversions. The sui::token module in the Sui framework defines the standard.\n\nBackground and use cases​\n\nThe Coin standard on Sui is an example of an open-loop system - coins are free-flowing, wrappable, freely transferable and you can store them in any application. The best real world analogy would be cash - hardly regulated and can be freely used and passed.\n\nSome applications, however, require constraining the scope of the token to a specific purpose. For example, some applications might need a token that you can only use for a specific service, or that an authorized account can only use, or a token that you can block certain accounts from using. A real-world analogy would be a bank account - regulated, bank-controlled, and compliant with certain rules and policies.\n\nDifference with Coin​\n\nUnlike Coin, which has key + store abilities and thus supports wrapping and public transfers, Token has only the key ability and cannot be wrapped, stored as a dynamic field, or freely transferred (unless there's a custom policy for that). Due to this restriction, Token can only be owned by an account and can't be stored in an application (however, it can be \"spent\" - see Spending section section).\n\n// defined in `sui::coin`\nstruct Coin<phantom T> has key, store { id: UID, balance: Balance<T> }\n\n// defined in `sui::token`\nstruct Token<phantom T> has key { id: UID, balance: Balance<T> }\n\nCompliance and rules​\n\nYou can set up any rules for transfers, spends, and conversions for the tokens you create. You specify these rules per action in the TokenPolicy. Rules are custom programmable restrictions that you can use to implement any request authorization or validation logic.\n\nFor example, a policy can set a limit on a transfer - X tokens per operation; or require user verification before spending tokens; or allow spending tokens only on a specific service.\n\nYou can reuse rules across different policies and applications; and you can freely combine rules to create complex policies.\n\nPublic actions​\n\nTokens have a set of public and protected actions that you can use to manage the token. Public actions are available to everyone and don't require any authorization. They have similar APIs to coins, but operate on the Token type:\n\ntoken::keep - send a token to the transaction sender\ntoken::join - join two tokens\ntoken::split - split a token into two, specify the amount to split\ntoken::zero - create an empty (zero balance) token\ntoken::destroy_zero - destroy a token with zero balance\n\nSee Coin Token Comparison for coin and token methods comparison.\n\nProtected actions​\n\nProtected actions are ones that issue an ActionRequest - a hot-potato struct that must be resolved for the transaction to succeed. There are three main ways to resolve an ActionRequest, most common of which is via the TokenPolicy.\n\ntoken::transfer - transfer a token to a specified address\ntoken::to_coin - convert a token to a coin\ntoken::from_coin - convert a coin to a token\ntoken::spend - spend a token on a specified address\n\nThe previous methods are included in the base implementation, however it is possible to create ActionRequests for custom actions.\n\nToken policy and rules​\n\nProtected actions are disabled by default but you can enable them in a TokenPolicy. Additionally, you can set custom restrictions called rules that a specific action must satisfy for it to succeed.\n\nEdit this page\nPrevious\nCoin\nNext\nAction Request\nBackground and use cases\nDifference with Coin\nCompliance and rules\nPublic actions\nProtected actions\nToken policy and rules\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui-Related Research Papers | Sui Documentation",
      "url": "https://docs.sui.io/concepts/research-papers",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nResearch Papers\nSui-Related Research Papers\n\nThis document contains a list of research papers that are relevant to Sui and have been co-authored by at least one member of the team. Some of the ideas of these papers are currently being integrated into Sui, others are in our roadmap, and others are not in our roadmap but could be integrated in the future. Start with the Sui Smart Contract Platform white paper, which contains our latest design inspired by previous works below.\n\nFastPay: High-Performance Byzantine Fault Tolerant Settlement​\nLink: https://arxiv.org/abs/2003.11506\nPublication: ACM Conference on Advances in Financial Technologies (AFT), 2020\nRelevance: FastPay describes the core protocol at the heart of Sui.\nSummary: FastPay allows a set of distributed validators, some of which are Byzantine, to maintain a high-integrity and availability settlement system for pre-funded payments. It can be used to settle payments in a native unit of value (crypto-currency), or as a financial side-infrastructure to support retail payments in fiat currencies. This is not the protocol Sui uses, yet it proposes the basic safety mechanism that Sui extends. FastPay is based on Byzantine Consistent Broadcast as its core primitive, foregoing the expenses of full atomic commit channels (consensus). The resulting system has low-latency for both confirmation and payment finality. Remarkably, each validator can be sharded across many machines to allow unbounded horizontal scalability.\nNarwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus​\nLink: https://arxiv.org/abs/2105.11827\nPublication: EuroSys, 2022\nRelevance: The consensus system that we will likely use to support shared-objects in Sui.\nSummary: We propose separating the task of reliable transaction dissemination from transaction ordering to enable high-performance Byzantine fault-tolerant quorum-based consensus. We design and evaluate a mempool protocol, Narwhal, specializing in high-throughput reliable dissemination and storage of causal histories of transactions. Narwhal tolerates an asynchronous network and maintains high performance despite failures. Narwhal is designed to easily scale-out using multiple workers at each validator, and we demonstrate that there is no foreseeable limit to the throughput we can achieve. Composing Narwhal with a partially synchronous consensus protocol (Narwhal-HotStuff) yields significantly better throughput even in the presence of faults or intermittent loss of liveness due to asynchrony. However, loss of liveness can result in higher latency. To achieve overall good performance when faults occur we design Tusk, a zero-message overhead asynchronous consensus protocol, to work with Narwhal. We demonstrate its high performance under a variety of configurations and faults. As a summary of results, on a WAN, Narwhal-Hotstuff achieves more than 130,000 tx/sec at less than 2-sec latency compared with 1,800 tx/sec at 1-sec latency for Hotstuff. Additional workers increase throughput linearly to 600,000 tx/sec without any latency increase. Tusk achieves 160,000 tx/sec with about 3 seconds latency. Under faults, both protocols maintain high throughput, but Narwhal-HotStuff suffers from increased latency.\nZef: Low-latency, Scalable, Private Payments​\nLink: https://arxiv.org/abs/2201.05671\nPublication: Not published yet (under submission)\nRelevance: Extends the FastPay design to support objects (rather than accounts), what Sui actually uses. An additional contribution of this paper is to add strong privacy to FastPay transactions (but Sui does not plan to do this).\nSummary: We introduce Zef, the first Byzantine-Fault Tolerant (BFT) protocol to support payments in anonymous digital coins at arbitrary scale. Zef follows the communication and security model of FastPay: both protocols are asynchronous, low-latency, linearly-scalable, and powered by partially-trusted sharded validators. Zef further introduces opaque coins represented as off-chain certificates that are bound to user accounts. In order to hide the face values of coins when a payment operation consumes or creates them, Zef uses random commitments and NIZK proofs. Created coins are made unlinkable using the blind and randomizable threshold anonymous credentials of Coconut. To control storage costs associated with coin replay prevention, Zef accounts are designed so that data can be safely removed once an account is deactivated. Besides the specifications and a detailed analysis of the protocol, we are making available an open source implementation of Zef in Rust. Our extensive benchmarks on AWS confirm textbook linear scalability and demonstrate a confirmation time under one second at nominal capacity. Compared to existing anonymous payment systems based on a blockchain, this represents a latency speedup of three orders of magnitude, with no theoretical limit on throughput.\nBullshark: DAG BFT Protocols Made Practical​\nLink: https://arxiv.org/abs/2201.05677\nPublication: Not published yet (under submission)\nRelevance: Provides a partially-synchronous consensus protocol running over Narwhal. Sui may want to use it instead of Tusk.\nSummary: We present Bullshark, the first directed acyclic graph (DAG) based Byzantine Fault Tolerant (BFT) protocol that is optimized for partial synchrony. Bullshark inherits all the desired properties of its predecessor (DAG-Rider) such as optimal amortized complexity, asynchronous liveness, zero-overhead, and post-quantum safety; but at the same time Bullshark provides a practical low-latency fast-path that exploits synchronous periods. In addition, we introduce a standalone partially synchronous version of Bullshark and evaluate it against the state of the art. The resulting protocol is embarrassingly simple 20 LOC on top of a DAG-based mempool implementation) and highly efficient, achieving for example, 125k transactions per second and 2 seconds latency with 50 nodes.\nBe Aware of Your Leaders​\nLink: https://arxiv.org/abs/2110.00960\nPublication: Financial Cryptography and Data Security (FC), 2022\nRelevance: Provides a performant leader election algorithm for partially-synchronous consensus protocol (such as Bullshark). Sui may want to use it alongside Bullshark to support shared objects.\nSummary: Advances in blockchains have influenced the State-Machine-Replication (SMR) world and many state-of-the-art blockchain-SMR solutions are based on two pillars: Chaining and Leader-rotation. A predetermined round-robin mechanism used for Leader-rotation, however, has an undesirable behavior: crashed parties become designated leaders infinitely often, slowing down overall system performance. In this paper, we provide a new Leader-Aware SMR framework that, among other desirable properties, formalizes a Leader-utilization requirement that bounds the number of rounds whose leaders are faulty in crash-only executions. We introduce Carousel, a novel, reputation-based Leader-rotation solution to achieve Leader-Aware SMR. The challenge in adaptive Leader-rotation is that it cannot rely on consensus to determine a leader, since consensus itself needs a leader. Carousel uses the available on-chain information to determine a leader locally and achieves Liveness despite this difficulty. A HotStuff implementation fitted with Carousel demonstrates drastic performance improvements: it increases throughput over 2x in faultless settings and provides a 20x throughput increase and 5x latency reduction in the presence of faults.\nTwins: BFT Systems Made Robust​\nLink: https://arxiv.org/abs/2004.10617\nPublication: International Conference on Principles of Distributed Systems (OPODIS), 2021\nRelevance: Less related to Sui than the other papers, this provides a way to test implementations of consensus systems, such as Tusk and Bullshark. The paper is, however, theoretical and not on our roadmap.\nSummary: This paper presents Twins, an automated unit test generator of Byzantine attacks. Twins implements three types of Byzantine behaviors: (i) leader equivocation, (ii) double voting, and (iii) losing internal state such as forgetting 'locks' guarding voted values. To emulate interesting attacks by a Byzantine node, it instantiates twin copies of the node instead of one, giving both twins the same identities and network credentials. To the rest of the system, the twins appear indistinguishable from a single node behaving in a 'questionable' manner. Twins can systematically generate Byzantine attack scenarios at scale, execute them in a controlled manner, and examine their behavior. Twins scenarios iterate over protocol rounds and vary the communication patterns among nodes. Twins runs in a production setting within DiemBFT where it can execute 44M Twins-generated scenarios daily. Whereas the system at hand did not manifest errors, subtle safety bugs that were deliberately injected for the purpose of validating the implementation of Twins itself were exposed within minutes. Twins can prevent developers from regressing correctness when updating the codebase, introducing new features, or performing routine maintenance tasks. Twins requires only a thin wrapper over DiemBFT; we thus envision other systems using it. Building on this idea, one new attack and several known attacks against other BFT protocols were materialized as Twins scenarios. In all cases, the target protocols break within fewer than a dozen protocol rounds. Hence it is realistic for the Twins approach to expose the problems.\nSybilQuorum: Open Distributed Ledgers Through Trust Networks​\nLink: https://arxiv.org/abs/1906.12237\nPublication: Not published\nRelevance: Less related to Sui than the other papers, and the paper is in its early stages. It presents an algorithm to strengthen proof-of-Stake systems (like Sui). The paper is, however, theoretical and not on our roadmap.\nSummary: The Sybil attack plagues all peer-to-peer systems, and modern open distributed ledgers employ a number of tactics to prevent it from proof of work, or other resources such as space, stake or memory, to traditional admission control in permissioned settings. With SybilQuorum we propose an alternative approach to securing an open distributed ledger against Sybil attacks, and ensuring consensus amongst honest participants, leveraging social network based Sybil defenses. We show how nodes expressing their trust relationships through the ledger can bootstrap and operate a value system, and general transaction system, and how Sybil attacks are thwarted. We empirically evaluate our system as a secure Federated Byzantine Agreement System, and extend the theory of those systems to do so.\nEdit this page\nPrevious\nGas in Sui\nFastPay: High-Performance Byzantine Fault Tolerant Settlement\nNarwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus\nZef: Low-latency, Scalable, Private Payments\nBullshark: DAG BFT Protocols Made Practical\nBe Aware of Your Leaders\nTwins: BFT Systems Made Robust\nSybilQuorum: Open Distributed Ledgers Through Trust Networks\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Coin Standard | Sui Documentation",
      "url": "https://docs.sui.io/standards/coin",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nCoin\nCoin Standard\n\nThe Coin standard is the technical standard used for smart contracts on Sui for creating coins on the Sui blockchain. The standardization of coin creation on Sui means that wallets, exchanges, and other smart contracts can manage coins created on Sui the same as they manage SUI, without any additional processing logic.\n\nSee Sui Tokenomics to learn more about the SUI native coin and its use on the Sui network.\n\nAlthough coins on Sui follow the Coin standard, they can offer specialized abilities. For example, you can create a regulated token that allows its creator to add specific addresses to a deny list, so that the identified addresses cannot use the token as inputs to transactions.\n\nSee the coin module documentation for all available options when creating a coin-type token on Sui.\n\nFungible tokens​\n\nIn the Sui blockchain ecosystem, the Coin<T> type represents open-loop fungible tokens (see Token<T> for closed-loop tokens). Coins are denominated by their type parameter, T, which is also associated with metadata (like name, symbol, decimal precision, and so on) that applies to all instances of Coin<T>. The sui::coin module exposes an interface over Coin<T> that treats it as fungible, meaning that a unit of T held in one instance of Coin<T> is interchangeable with any other unit of T, much like how traditional fiat currencies operate.\n\nINFO\n\nThe documentation refers to fungible tokens created on Sui using the Coin standard as \"coins\". For fungible tokens created on Sui using the Closed-Loop Token standard, the documentation uses the term \"tokens\". In practice, the terms for both these objects are often interchangeable.\n\nTreasury capability​\n\nWhen you create a coin using the coin::create_currency function, the publisher of the smart contract that creates the coin receives a TreasuryCap object. The TreasuryCap object is required to mint new coins or to burn current ones. Consequently, only addresses that have access to this object are able to maintain the coin supply on the Sui network.\n\nThe TreasuryCap object is transferable, so a third party can take over the management of a coin that you create if you transfer the TreasuryCap. After transferring the capability, however, you are no longer able to mint and burn tokens yourself.\n\nRegulated coins​\n\nThe Coin standard includes the ability to create regulated coins. To create a regulated coin, you use the coin::create_regulated_currency function (which uses the coin::create_currency function itself), but which also returns a DenyCap capability. The DenyCap capability allows the bearer to maintain a list of addresses that aren't allowed to use the token.\n\nTIP\n\nThe regulated-coin-sample repository provides an example of regulated coin creation.\n\nDenyList object​\n\nThe list of addresses that aren't able to use a particular regulated coin is held within a system-created DenyList shared object. If you have access to the DenyCap, then you can use the coin::deny_list_add and coin::deny_list_remove functions to add and remove addresses. You can also use the coin::deny_list_contains function to check if an address is already on the list.\n\nCoin metadata​\n\nEach coin you create includes metadata that describes it. Typically, smart contracts freeze this object upon creation using the transfer::public_freeze_object function because the metadata for coins should almost never change. Regulated coins freeze the metadata they create automatically.\n\nRegular coins using the Coin standard include a CoinMetadata object. As mentioned previously, regulated coins build on top of the same procedure that creates regular coins, so they receive the same metadata object in addition to a RegulatedCoinMetadata object that includes deny list information.\n\nThe fields of the metadata objects include the following:\n\nCoinMetadata​\nName\tDescription\nid\tThe object ID of the metadata for the token.\ndecimals\tThe number of decimals the token uses. If you set this field to 3, then a token of value 1000 would display as 1.000.\nname\tName of the coin.\nsymbol\tSymbol for the coin. This might be the same as name, but is typically fewer than five all capital letters. For example, SUI is the symbol for the native coin on Sui but its name is also SUI.\ndescription\tA short description to describe the token.\nicon_url\tThe URL for the token's icon, used for display in wallets, explorers, and other apps.\nRegulatedCoinMetadata​\nName\tDescription\nid\tThe ID of the metadata object for the regulated token.\ncoin_metadata_object\tThe ID of the underlying metadata object (CoinMetadata) for the regulated token.\ndeny_cap_object\tThe ID of the token's DenyCap object, which is necessary to maintain the deny list entries that controls who can and cannot use the token.\nMinting and burning coins​\n\nThe coin module provides the logic for creating and destroying coins on the Sui network (as long as you own the associated TreasuryCap). These functions are the same for all coins and each requires the TreasuryCap as an input.\n\nMint​\n\nUse the coin::mint function to create new tokens. The signature for the function is:\n\npublic fun mint<T>(\n  cap: &mut coin::TreasuryCap<T>, \n  value: u64, \n  ctx: &mut tx_context::TxContext\n): coin::Coin<T>\n\n\nThe signature shows that a Coin<T> results from calling the function with a TreasuryCap, value for the coin created, and the transaction context. The function updates the total supply in TreasuryCap automatically. Upon display, the coin value respects the decimals value in the metadata. So, if you supply 1000000 as the coin value that has a decimal value of 6, the coin's value displays as 1.000000.\n\nBurn​\n\nUse the coin::burn function to destroy current tokens. The signature for the function is:\n\npublic entry fun burn<T>(\n  cap: &mut coin::TreasuryCap<T>, \n  c: coin::Coin<T>\n): u64\n\n\nThe signature shows that only the TreasuryCap and coin object you want to burn are necessary inputs, returning the amount by which the supply was decreased (value of the coin). The function does not allow you to burn more coins than are available in the supply.\n\nAdding and removing addresses to and from the deny list​\n\nThe deny list is only applicable to regulated coins. As mentioned previously, when you create a regulated coin you receive a DenyCap that authorizes the bearer to add and remove addresses from the system-created DenyList object. Any address on the list for your coin is unable to use the coin as an input to transactions.\n\nAdd address to deny list​\n\nUse the coin::deny_list_add function to add the provided address to the deny list for your coin. The signature for the function is:\n\npublic fun deny_list_add<T>(\n  deny_list: &mut deny_list::DenyList, \n  _deny_cap: &mut coin::DenyCap<T>, \n  addr: address, \n  _ctx: &mut tx_context::TxContext\n)\n\n\nWhen using this function, you provide the DenyList object (0x403), the DenyCap you receive on coin creation, the address to add to the list, and the transaction context. After using this function, the address you provide is unable to use your coin by the next epoch.\n\nRemove address from deny list​\n\nUse the coin::deny_list_remove function to remove addresses from the deny list for your coin. The signature for the function is:\n\npublic fun deny_list_remove<T>(\n  deny_list: &mut deny_list::DenyList, \n  _deny_cap: &mut coin::DenyCap<T>, \n  addr: address, \n  _ctx: &mut tx_context::TxContext\n)\n\n\nWhen using this function, you provide the DenyList object (0x403), the DenyCap you receive on coin creation, the address to remove from the list, and the transaction context. If you try to remove an address that isn't on the list, you receive an ENotFrozen error and the function aborts. After calling this function, the address you provide is able to use your coin by the next epoch.\n\nUsing an SDK​\n\nYou can use either the TypeScript or Rust SDK to manipulate the addresses held in the DenyList for your coin. The following examples are based on the regulated coin sample.\n\nTypeScript\nRust\nconst txb = new TransactionBlock();\n\ntxb.moveCall({\n    target: `0x2::coin::deny_list_add`,\n    arguments: [\n        txb.object(<SUI-DENY-LIST-OBJECT-ID>),\n        txb.object(<DENY-CAP-ID>),\n        txb.pure.address(options.address),\n    ],\n    typeArguments: [<COIN-TYPE>],\n});\n\n<SUI-DENY-LIST-OBJECT-ID> is \"0x403\"\n<DENY-CAP-ID> is the object of type DenyCap<REGULATED_COIN> we received from publishing the contract\noptions.address is the address to ban\n<COIN-TYPE> is ${PACKAGE-ID}::${MODULE-NAME}::${COIN-NAME}, which is ${PACKAGE-ID}::regulated_coin::REGULATED_COIN based on the example.\nQuery coin data​\n\nYou can use the following functions to retrieve data from coins.\n\nMetadata​\n\nUse the following functions to get the values for the respective fields on the metadata object for coins.\n\nFunction\tSignature\nget_decimals\tpublic fun get_decimals<T>(metadata: &coin::CoinMetadata<T>): u8\nget_name\tpublic fun get_name<T>(metadata: &coin::CoinMetadata<T>): string::String\nget_symbol\tpublic fun get_symbol<T>(metadata: &coin::CoinMetadata<T>): ascii::String\nget_description\tpublic fun get_description<T>(metadata: &coin::CoinMetadata<T>): string::String\nget_icon_url\tpublic fun get_icon_url<T>(metadata: &coin::CoinMetadata<T>): option::Option<url::Url>\nSupply​\n\nUse the coin::supply function to get the current supply of a given coin.\n\nCheck for address on deny list​\n\nUse the coin::deny_list_contains function to check if an address exists on the deny list for your coin. The signature of the function is:\n\npublic fun deny_list_contains<T>(\n  freezer: &deny_list::DenyList, \n  addr: address\n): bool\n\n\nThe function returns true if the address is found on the coin's list, otherwise it returns false.\n\nUpdate coin metadata​\n\nIf the CoinMetadata object was not frozen upon creation, you can use the following functions to update its values.\n\nEach function signature is similar. Replace <FUNCTION-NAME> and <ATTRIBUTE-TYPE> with the values defined in the table to get the signature of each function:\n\n\npublic entry fun <FUNCTION-NAME><T>(\n  _treasury: &coin::TreasuryCap<T>, \n  metadata: &mut coin::CoinMetadata<T>, \n  <ATTRIBUTE-TYPE>\n)\n\n\n<FUNCTION-NAME>\t<ATTRIBUTE-TYPE>\nupdate_name\tname: string::String\nupdate_symbol\tsymbol: ascii::String\nupdate_description\tdescription: string::String\nupdate_icon_url\turl: ascii::String\nINFO\n\nRegulatedCoinMetadata is frozen upon creation, so there are no functions to update its data.\n\nRelated links​\n\nCheck out the following content for more information about coins and tokens on Sui:\n\nCreate a Coin: Guide for creating coins and regulated coins in your smart contracts.\nClosed-Loop Token Standard: Details the Token standard on Sui.\ncoin module rustdoc documentation: Automated documentation output for the Sui framework coin module.\ntoken module rustdoc documentation: Automated documentation output for the Sui framework token module.\nTokenomics: Discover the Sui ecosystem and where SUI coins fit within it.\nEdit this page\nPrevious\nOverview\nNext\nClosed-Loop Token\nFungible tokens\nTreasury capability\nRegulated coins\nDenyList object\nCoin metadata\nMinting and burning coins\nMint\nBurn\nAdding and removing addresses to and from the deny list\nAdd address to deny list\nRemove address from deny list\nUsing an SDK\nQuery coin data\nMetadata\nSupply\nCheck for address on deny list\nUpdate coin metadata\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "App Developers | Sui Documentation",
      "url": "https://docs.sui.io/concepts/app-devs",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp Developers\nApp Developers\n\nThe topics in this section explore some of the concepts that are of interest to developers creating smart contracts on Sui. After becoming familiar with these concepts, be sure to check out the Guides section for instruction on how to implement these concepts in your own code.\n\nGraphQL for Sui RPC​\n\nBasics of the GraphQL service to interact with the Sui network.\n\nGo to GraphQL for Sui RPC.\n\nObject Model​\n\nThe basic unit of storage in Sui is the object. In contrast to many other blockchains where storage is centered around accounts containing key-value stores, Sui's storage is centered around objects addressable on-chain by unique IDs. The topics in this section examine the model for objects on Sui.\n\nGo to Object Model.\n\nMove Overview​\n\nMove is an open source language for writing safe packages to manipulate on-chain objects (sometimes referred to as \"smart contracts\"). Move is a platform-agnostic language to enable common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. Move is adaptable to meet the needs of the blockchain the code operates on, see Move on Sui to review enhancements made to Move for optimization on the Sui blockchain.\n\nThe topics in this section describe some of the key features and coding patterns of Move applied to the Sui network.\n\nGo to Move Overview.\n\nTransactions​\n\nTransactions define the history of activity on a blockchain. On Sui, you can develop complex programmable transaction blocks that perform several transaction commands in a single execution. You can also sponsor transactions for your smart contract users to streamline onboarding. The topics in this section explore transactions on Sui at a conceptual level.\n\nGo to Transactions.\n\nEdit this page\nPrevious\nSui Components\nNext\nGraphQL for the Sui RPC\nGraphQL for Sui RPC\nObject Model\nMove Overview\nTransactions\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Architecture | Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-architecture",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\nTokenomics\nResearch Papers\nSui Architecture\nSui Architecture\n\nSui shares some similarities with other blockchains but is unique in many ways. Use the topics in this section to understand the features that define the Sui network.\n\nUnderstand Sui Security​\n\nLearn about the mechanisms available to secure on-chain assets, and the assurances Sui provides regarding asset security. Understand Sui Security explores the overall Sui security architecture to ensure the asset types you design leverage Sui to provide a secure experience for asset holders.\n\nGo to Understand Sui Security.\n\nLife of a Transaction​\n\nLife of a Transaction details the transitions that all transactions on Sui go through from creation to finality. This topic also explores some features of the blockchain (like epochs and checkpoints) that play a role in the life of a transaction.\n\nGo to Life of a Transaction.\n\nConsensus​\n\nEvery transaction on Sui is sequenced by consensus, where validators agree to the same order of execution of the transactions, even if a minority of them are down or are malicious actors that want to harm the network and users. Sui currently uses Narwhal and Bullshark for consensus, but will transition to Mysticeti soon.\n\nGo to Consensus.\n\nSui Indexer​\n\nRunning a Sui indexer offloads data processing from your Full node and stores it in a relational database. This topic explores some of the benefits running an indexer has and points to instruction on how to run your own.\n\nGo to Sui Indexer.\n\nProtocol Upgrades​\n\nThe Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. This functionality is added in the form of new code which is released to validator operators as part of our regular software releases. The Sui protocol, however, requires that all Sui validators agree about the results of executing each transaction.\n\nGo to Protocol Upgrades.\n\nEdit this page\nPrevious\nCheckpoint Verification\nNext\nUnderstand Sui Security\nUnderstand Sui Security\nLife of a Transaction\nConsensus\nSui Indexer\nProtocol Upgrades\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "App Examples | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/app-examples",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nBlackjack\nCoin Flip\nDistributed Counter\nOracles\nPlinko\nReview Rating\nTic-Tac-Toe\nTrustless Swap\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesApp Examples\nApp Examples\n\nThe ever-growing number of examples in this section showcase packages for the Sui blockchain. Extract techniques used in these examples to apply to your own Sui projects as they are written by Sui and Move experts.\n\nCAUTION\n\nUse dedicated nodes/shared services rather than public endpoints for production apps. The public endpoints maintained by Mysten Labs (fullnode.<NETWORK>.sui.io:443) are rate-limited, and support only 100 requests per 30 seconds. Do not use public endpoints in production applications with high traffic volume.\n\nYou can either run your own Full nodes, or outsource this to a professional infrastructure provider (preferred for apps that have high traffic). You can find a list of reliable RPC endpoint providers for Sui on the Sui Dev Portal using the Node Service tag.\n\nExamples​\n\nSui is dedicated to providing a wide range of examples to guide you in proper programming techniques for the Sui blockchain. This list will continue to grow, so check back often.\n\nBlackjack: This example demonstrates the logic behind an on-chain version of the popular casino card game, Blackjack.\nCoin Flip: The Coin Flip app demonstrates on-chain randomness.\nDistributed Counter: An end-to-end example that creates a basic decentralized counter that anyone can increment, but only the object owner can reset it. The example includes Move code to create the package and leverages the Sui TypeScript SDK to provide a basic frontend.\nPlinko: This example puts the classic Plinko game on chain, demonstrating use of cryptography-based strategies to create a fair and transparent game of chance.\nTic-tac-toe: Three implementations of the classic tic-tac-toe game on the Sui network to demonstrate different approaches to user interaction.\nTrustless Swap: This example demonstrates trustless swaps on the Sui blockchain using a shared object as an escrow account.\nWeather Oracle: The Sui Weather Oracle demonstrates how to create a basic weather oracle that provides real-time weather data.\nReviews Rating: This example demonstrates implementing a reviews-rating platform for the food service industry on Sui.\nEdit this page\nPrevious\nOn-Chain Randomness\nNext\nBlackjack\nExamples\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Cryptography | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/cryptography",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nSui On-Chain Signatures Verification in Move\nGroth16\nHashing\nECVRF\nMultisig Authentication\nzkLogin Integration Guide\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesCryptography\nCryptography\n\nEffective use of cryptography keeps your smart contract transactions secure on the Sui blockchain.\n\nSignature verification​\n\nMove contracts in Sui support verifications for several on-chain signature schemes. Not all signatures supported in on-chain verification are supported as user signature verification. See Signatures for valid signature schemes for transaction authorization.\n\nGo to Sui On-Chain Signatures Verification in Move.\n\nGroth16​\n\nA zero-knowledge proof is a method by which a party, known as the prover, can confirm the truthfulness of a claim without disclosing any information about the underlying data. For instance, it's possible for the prover to demonstrate they have solved a sudoku puzzle without showing the actual solution. Groth16 is one such proof you can use in your smart contracts.\n\nGo to Groth16.\n\nHashing​\n\nA cryptographic hash function is a widely used cryptographic primitive that maps an arbitrary length input to a fixed length output, the hash value. The hash function is designed to be a one-way function, which means that it is infeasible to invert the function to find the input data from a given hash value, and to be collision resistant, which means that it is infeasible to find two different inputs that map to the same hash value. Use available hashing functions to provide security to your smart contracts.\n\nGo to Hashing.\n\nElliptic Curve Verifiable Random Function (ECVRF)​\n\nUse ECVRFs to generate a random number and provide proof that the number used a secret key for generation. The public key corresponding to the secret key verifies the proof, so you can use it as a random number generator that generates outputs that anyone can verify. Applications that need verifiable randomness on chain can also benefit from its use.\n\nGo to ECVRF.\n\nMultisig​\n\nSui allows you to mix and match key schemes in a single multisig account. For example, you can pick a single Ed25519 mnemonic-based key and two ECDSA secp256r1 keys to create a multisig account that always requires the Ed25519 key, but also one of the ECDSA secp256r1 keys to sign. You could use this structure for mobile secure enclave stored keys as two-factor authentication.\n\nGo to Multisig.\n\nRelated links​\nCryptography concepts: Before you use the guides, you might want to learn about the concepts behind the use of cryptography on Sui.\nEdit this page\nPrevious\nSimulating References\nNext\nSui On-Chain Signatures Verification in Move\nSignature verification\nGroth16\nHashing\nElliptic Curve Verifiable Random Function (ECVRF)\nMultisig\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/graphql-rpc",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedQuerying Sui RPC with GraphQL\nQuerying Sui RPC with GraphQL\n\nThe quickest way to access the GraphQL service for Sui RPC is through the online IDE that provides a complete toolbox for fetching data and executing transactions on the network. The online IDE provides features such as auto-completion (use Ctrl+Space or just start typing), built-in documentation (Book icon, top-left), multi-tabs, and more.\n\nThe online IDE is available for Mainnet and Testnet. This guide contains various queries that you can try directly in the IDE.\n\nINFO\nAny existing addresses/object IDs in these examples refer to mainnet data only.\nBoth mainnet and testnet services are rate-limited to keep network throughput optimized.\n\nFor more details about some concepts used in the examples below, please see the GraphQL concepts page, and consult the reference for full documentation on the supported schema.\n\nDiscovering the schema​\n\nGraphQL introspection exposes the schema supported by the RPC service. The IDE's \"Docs\" pane (Book icon, top-left) and Search dialog (Cmd+K on macOS or Ctrl+K on Windows and Linux) offer a way to browse introspection output interactively.\n\nThe official documentation provides an overview on introspection, and how to interact with it programmatically.\n\nFinding the reference gas price for latest epoch​\nquery {\n  epoch {\n    referenceGasPrice\n  }\n}\n\nFinding information about a specific historical epoch​\n\nThis example finds the total stake rewards, the reference gas price, the number of checkpoints and the total gas fees for epoch 100. Note that in the query, the id argument is optional, and defaults to the latest epoch.\n\nquery {\n  epoch(id: 100) # note that id is optional, and without it, latest epoch is returned\n  {\n    epochId\n    totalStakeRewards\n    referenceGasPrice\n    totalCheckpoints\n    totalGasFees\n    totalStakeSubsidies\n    storageFund {\n      totalObjectStorageRebates\n      nonRefundableBalance\n    }\n  }\n}\n\nFinding a transaction block by its digest​\n\nThis example gets a transaction block by its digest and shows information such as the gas sponsor's address, the gas price, the gas budget, and effects from executing that transaction block.\n\nquery {\n  transactionBlock(digest: \"FdKFgsQ9iRrxW6b1dh9WPGuNuaJWMXHJn1wqBQSqVqK2\") {\n    gasInput {\n      gasSponsor {\n        address\n      }\n      gasPrice\n      gasBudget\n    }\n    effects {\n      status\n      timestamp\n      checkpoint {\n        sequenceNumber\n      }\n      epoch {\n        epochId\n        referenceGasPrice\n      }\n    }\n  }\n}\n\nFinding the last ten transactions that are not a system transaction​\nquery {\n  transactionBlocks(last: 10, filter: {kind: PROGRAMMABLE_TX}) {\n    nodes {\n      digest\n      kind {\n        __typename\n      }\n    }\n  }\n}\n\nFinding all transactions that touched a given object​\n\nThis example finds all the transactions that touched (modified/transferred/deleted) a given object. This is useful for when we want to trace the flow of a Coin/StakeSui/NFT.\n\nINFO\n\nThis example uses GraphQL variables and pagination. When using the online IDE, copy the variables JSON to the \"Variables\" window, below the main editor.\n\nquery ($objectID: SuiAddress!) {\n  transactionBlocks(filter: {changedObject: $objectID}) {\n    nodes {\n      sender {\n        address\n      }\n      digest\n      effects {\n        objectChanges {\n          nodes {\n            address\n          }\n        }\n      }\n    }\n  }\n}\n\n\nVariables:\n\n{\n  \"objectID\": \"0x11c6ae8432156527fc2e12e05ac7db79f2e972510a823a4ef2e670f27ad7b52f\"\n}\n\nFiltering transaction blocks by a function​\n\nThis example finds the last ten transaction blocks that called the public_transfer function, (as a move call transaction command).\n\nINFO\n\nThis example makes usage of the filter last, which indicates that the user only wants the last ten transaction blocks known to the service.\n\n{\n  transactionBlocks(\n    last: 10,\n      filter: {\n        function: \"0x2::transfer::public_transfer\"\n      }\n  ) {\n    nodes { digest }\n  }\n}\n\nFinding transaction balance changes​\n\nThis example finds the balance changes of all the transactions where a given address called a staking-related function. This is useful when you want to get your staking or unstaking history.\n\nquery ($address: SuiAddress!) {\n  transactionBlocks(filter: {\n    function: \"0x3::sui_system::request_add_stake\"\n    signAddress: $address\n  }) {\n    nodes {\n      digest\n      effects {\n        balanceChanges {\n          nodes {\n            owner {\n              address\n            }\n            amount\n          }\n        }\n      }\n    }\n  }\n}\n\n\nVariables:\n\n{\n  \"address\": \"0xa9ad44383140a07cc9ea62d185c12c4d9ef9c6a8fd2f47e16316229815862d23\"\n}\n\nFetching a dynamic field on an object​\nINFO\n\nThis example uses aliases and fragments.\n\nquery DynamicField {\n  object(\n    address: \"0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac\"\n  ) {\n    dynamicField(\n      name: {\n        type: \"0x2::kiosk::Listing\",\n        bcs: \"NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1VhfwA\",\n      }\n    ) {\n      ...DynamicFieldSelect\n    }\n  }\n}\n\nfragment DynamicFieldSelect on DynamicField {\n  name {\n    ...MoveValueFields\n  }\n  value {\n    ...DynamicFieldValueSelection\n  }\n}\n\nfragment DynamicFieldValueSelection on DynamicFieldValue {\n  __typename\n  ... on MoveValue {\n    ...MoveValueFields\n  }\n  ... on MoveObject {\n    hasPublicTransfer\n    contents {\n      ...MoveValueFields\n    }\n  }\n}\n\nfragment MoveValueFields on MoveValue {\n  type {\n    repr\n  }\n  data\n  bcs\n}\n\nFetching all dynamic fields on an object​\n\nThis query can be used to paginate over the dynamic fields of an object. This works even when the object in question is wrapped, by using the owner query, so can be used for iterating over the elements of on-chain data structures, like Tables and Bags.\n\nINFO\n\nThis example uses fragments and variables.\n\nquery ($id: SuiAddress!) {\n  owner(address: $id) {\n    dynamicFields {\n      nodes {\n        name { ...Value }\n        value {\n          __typename\n          ... on MoveValue {\n            ...Value\n          }\n          ... on MoveObject {\n            contents {\n              ...Value\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfragment Value on MoveValue {\n  type {\n    repr\n  }\n  json\n}\n\nPaginating checkpoints forward, five at a time​\nquery ($after: String) {\n  checkpoints(first: 5, after: $after) {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      digest\n      timestamp\n    }\n  }\n}\n\n\nSets up a paginated query, starting at the genesis checkpoint, reading five checkpoints at a time, in increasing order of sequence number. The value of pageInfo.hasNextPage determines whether there is another page to be read, and the value of pageInfo.endCursor is fed back in as the cursor to read $after.\n\nINFO\n\nThis example uses GraphQL variables and pagination.\n\nPaginating checkpoints backwards, five at a time​\nquery ($before: String) {\n  checkpoints(last: 5, before: $before) {\n    pageInfo {\n      hasPreviousPage\n      startCursor\n    }\n    nodes {\n      digest\n      timestamp\n    }\n  }\n}\n\n\nSets up a paginated query, starting at the latest indexed checkpoint, reading five checkpoints at a time, in decreasing order of sequence number. The value of pageInfo.hasPreviousPage determines whether there is another page to be read, and the value of pageInfo.startCursor is fed back in as the cursor to read $before.\n\nINFO\n\nThis example uses GraphQL variables and pagination.\n\nExecuting a transaction​\n\nTransaction execution takes in two arguments, txBytes and signatures. txBytes is the serialized unsigned transaction data, which can be generated when using the Sui CLI's client call command, to call a Move function by passing the --serialize-unsigned-transaction flag. The signatures can be generated using Sui CLI's keytool command sui keytool sign. More information on Sui CLI can be found here.\n\nmutation ($tx: String!, $sigs: [String!]!) {\n  executeTransactionBlock(txBytes: $tx, signatures: $sigs) {\n    errors\n    effects {\n      status\n      epoch {\n        startTimestamp\n      }\n      gasEffects {\n        gasSummary {\n          computationCost\n        }\n      }\n    }\n  }\n}\n\n\nVariables:\n\n{\n  \"tx\": \"AAACACAZXApmrHgzTs3FGDyXWka+wmMCy2IwOdKLmTWHb5PnFQEASlCnLAw4qfzLF3unH9or5/L7YpOlReaSEWfoEwhTqpavSxAAAAAAACCUFUCOn8ljIxcG9O+CA1bzqjunqr4DLDSzSoNCkUvu2AEBAQEBAAEAALNQHmLi4jgC5MuwwmiMvZEeV5kuyh+waCS60voE7fpzAa3v/tOFuqDvQ+bjBpKTfjyL+6yIg+5eC3dKReVwghH/rksQAAAAAAAgxtZtKhXTr1zeFAo1JzEqVKn9J1H74ddbCJNVZGo2I1izUB5i4uI4AuTLsMJojL2RHleZLsofsGgkutL6BO36c+gDAAAAAAAAQEIPAAAAAAAA\",\n  \"sigs\": [\n    \"AB4ZihXxUMSs9Ju5Cstuuf/hvbTvvycuRk2TMuagLYNJgQuAeXmKyJF9DAXUtL8spIsHrDQgemn4NmojcNl8HQ3JFqhnaTC8gMX4fy/rGgqgL6CDcbikawUUjC4zlkflwg==\"\n  ]\n}\n\nOther examples​\n\nYou can find other examples in the repository, grouped into sub-directories. For example, there are directories for transaction block effects, protocol configs, stake connection, and more.\n\nINFO\n\nExamples in the repository are designed to work with the version of GraphQL built at the same revision. The links above point to examples intended for GraphQL v2024.1, the latest production version at the time of writing.\n\nRelated links​\nGraphQL migration: Migrating to GraphQL guides you through migrating Sui RPC projects from JSON-RPC to GraphQL.\nGraphQL concepts: GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.\nGraphQL reference: Auto-generated GraphQL reference for Sui RPC.\nEdit this page\nPrevious\nGet SUI Tokens\nNext\nYour First Sui dApp\nDiscovering the schema\nFinding the reference gas price for latest epoch\nFinding information about a specific historical epoch\nFinding a transaction block by its digest\nFinding the last ten transactions that are not a system transaction\nFinding all transactions that touched a given object\nFiltering transaction blocks by a function\nFinding transaction balance changes\nFetching a dynamic field on an object\nFetching all dynamic fields on an object\nPaginating checkpoints forward, five at a time\nPaginating checkpoints backwards, five at a time\nExecuting a transaction\nOther examples\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/advanced",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nMigrating to GraphQL\nMigrating to Move 2024\nAsset Tokenization\nCustom Indexer\nOn-Chain Randomness\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesAdvanced Topics\nAdvanced Topics\n\nInformation in the Advanced Topics section covers coding practices, useful features, and other developer-focused considerations that might arise as you continue your development journey on Sui. The topics in this section aren't necessarily more difficult than other topics, but they include subjects you might not encounter or need to consider until you're developing more advanced solutions on the Sui network.\n\nAsset Tokenization​\n\nAsset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network. This involves converting the ownership or rights of an asset into digital tokens, which are then recorded and managed on the blockchain.\n\nGo to Asset Tokenization.\n\nCustom Indexer​\n\nYou can build custom indexers using the Sui micro-data ingestion framework. To create an indexer, you subscribe to a checkpoint stream with full checkpoint content. Establishing a custom indexer helps improve latency, allows pruning the data of your Sui Full node, and provides efficient assemblage of checkpoint data.\n\nGo to Custom Indexer.\n\nMigrating to GraphQL​\n\nSee the Migrating to GraphQL guide to upgrade your smart contracts to use the GraphQL API.\n\nThis guide compares JSON-RPC queries to their equivalent GraphQL counterpart. While it is possible to systematically rewrite JSON-RPC queries (for example, sui_getTotalTransactionBlocks) to their GraphQL counterparts using this guide, it is recommended that you revisit your application's query patterns to take full advantage of the flexibility that GraphQL offers in serving queries that touch multiple potentially nested endpoints (for example transactions, balances, coins), and use the following examples to get a flavor of how the two APIs express similar concepts.\n\nGo to Migrating to GraphQL.\n\nEdit this page\nPrevious\nzkLogin Example\nNext\nMigrating to GraphQL\nAsset Tokenization\nCustom Indexer\nMigrating to GraphQL\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/get-coins",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedGet SUI Tokens\nGet SUI Tokens\n\nSui faucet is a helpful tool where Sui developers can get free test SUI tokens to deploy and interact with their programs on Sui's Devnet and Testnet networks. There is no faucet for Sui Mainnet.\n\nPrerequisites​\n\nTo request tokens from the faucet, you must own a wallet address that can receive the SUI tokens. See the Get Sui Address topic if you don't already have an address or need to create a new one.\n\nRequest test tokens via the CLI​\n\nIf you are using the Devnet or Testnet networks, or you spun up a local network, you can use the Sui CLI to request tokens for your address. The sui client faucet uses the active network and active address that is currently set in the Sui CLI by default, but you can specify custom data through the following two arguments:\n\n--address argument to provide a specific address (or its alias),\n--url argument to provide a custom faucet endpoint.\nRequest test tokens through Discord​\nJoin Discord. If you try to join the Sui Discord channel using a newly created Discord account, you may need to wait a few days for validation.\nRequest test SUI tokens in the Sui #devnet-faucet or #testnet-faucet Discord channels. Send the following message to the channel with your client address: !faucet <Your client address>\nRequest test tokens through wallet​\n\nYou can request test tokens within Sui Wallet.\n\nRequest test tokens through cURL​\n\nUse the following cURL command to request tokens directly from the faucet server:\n\ncurl --location --request POST 'https://faucet.devnet.sui.io/gas' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"FixedAmountRequest\": {\n        \"recipient\": \"<YOUR SUI ADDRESS>\"\n    }\n}'\n\n\nIf you're working with a local network, replace 'https://faucet.devnet.sui.io/gas' with the appropriate value based on which package runs your network:\n\nsui-faucet: http://127.0.0.1:5003/gas\nsui-test-validator: http://127.0.0.1:9123/gas\nRequest test tokens through TypeScript SDK​\n\nYou can also access the faucet using the Sui TypeScript-SDK.\n\nimport { requestSuiFromFaucetV0, getFaucetHost } from '@mysten/sui.js/faucet';\n\n// get tokens from the Devnet faucet server\nawait requestSuiFromFaucetV0({\n  // connect to Devnet\n\thost: getFaucetHost('devnet'),\n\trecipient: '<YOUR SUI ADDRESS>',\n});\n\nTest tokens on a local network​\n\nIf you are running a local Sui network, you can get tokens from your local faucet. See the Connect to a Local Network topic for details.\n\nEdit this page\nPrevious\nGet Sui Address\nNext\nQuerying Sui RPC with GraphQL\nPrerequisites\nRequest test tokens via the CLI\nRequest test tokens through Discord\nRequest test tokens through wallet\nRequest test tokens through cURL\nRequest test tokens through TypeScript SDK\nTest tokens on a local network\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Connect to a Local Network | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/local-network",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedConnect to a Local Network\nConnect to a Local Network\n\nUse a Sui local network to test your dApps against the latest changes to Sui, and to prepare for the next Sui release to the Devnet or Testnet network. To set up a local network, Sui provides the sui-test-validator binary. The sui-test-validator starts a local network that includes a Sui Full node, a Sui validator, and a Sui faucet. You can use the included faucet to get test SUI to use on the local network.\n\nIf you haven't already, you need to install Sui on your system.\n\nStart the local network​\n\nTo start the local network, run the following command from your sui root folder.\n\nRUST_LOG=\"off,sui_node=info\" cargo run --bin sui-test-validator\n\n\nThe command starts the sui-test-validator. The RUST_LOG=off,sui_node=info turns off logging for all components except sui-node. If you want to see more detailed logs, you can remove RUST_LOG from the command.\n\nImportant: Each time you start the sui-test-validator, the network starts as a new network with no previous data. The local network is not persistent.\n\nTo customize your local Sui network, such as changing the port used, include additional parameters in the command to start sui-test-validator:\n\nOPTIONS:\n        --epoch-duration-ms <EPOCH_DURATION_MS>\n            The duration for epochs (defaults to one minute) [default: 60000]\n\n        --faucet-port <FAUCET_PORT>\n            Port to start the Sui faucet on [default: 9123]\n\n        --fullnode-rpc-port <FULLNODE_RPC_PORT>\n            Port to start the Fullnode RPC server on [default: 9000]\n\n\nUse sui-test-validator --help to see these options in your console.\n\nAccess your local Full node​\n\nUse the following command to retrieve the total transaction count from your local network:\n\ncurl --location --request POST 'http://127.0.0.1:9000' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sui_getTotalTransactionBlocks\",\n  \"params\": []\n}'\n\n\nIf successful, the response resembles the following:\n\n{\n    \"jsonrpc\": \"2.0\",\n    \"result\": 168,\n    \"id\": 1\n}\n\nConnect the Sui Client CLI to your local network​\n\nYou can use the Sui Client CLI with any Sui network. By default it connects to Sui Devnet. To connect to your local network, create a new environment alias named local that sets the RPC URL the client uses to your local network.\n\nsui client new-env --alias local --rpc http://127.0.0.1:9000\n\n\nNext, use the following command to set the active environment to the new local environment you created.\n\nsui client switch --env local\n\n\nThe command returns:\n\nActive environment switched to [local]\n\nYou can check the current active environment with the following command:\n\nsui client active-env\n\n\nThe command returns:\n\nlocal\n\nShow the current active address​\n\nThe Sui Client CLI uses the active address for command if you don't specify one. Use the following command to show the active address on your local network.\n\nsui client active-address\n\n\nThe command returns an address:\n\n0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de\n\nUse the active address to get test SUI to use on your local network. Use the sui client addresses command to see all of the addresses on your local network.\n\nINFO\n\nThe address returned when you run the command is unique and does not match the one used in this example.\n\nUse the local faucet​\n\nTransactions on your local network require SUI coins to pay for gas fees just like other networks. You can use the currently active address with the faucet.\n\nSui CLI provides the sui client faucet command to get coins from the faucet. In the most basic case, run sui client faucet and wait up to 60 seconds for the coins to reach your address. Use sui client gas to check for the new coins.\n\nINFO\n\nThe faucet command uses the active address and the active network environment by default. If you need to pass in a different address or faucet server URL, check the help menu. If you're using a different network than a local network or the public ones (fullnode.network.sui.io), you will have to pass the URL to the faucet server.\n\nCheck the gas coin objects for the active address​\n\nAfter you get coins from the faucet, use the following command to view the coin objects for the address:\n\nsui client gas\n\n\nThe response resembles the following, but with different IDs:\n\n╭────────────────────────────────────────────────────────────────────┬────────────╮\n│ gasCoinId                                                          │ gasBalance │\n├────────────────────────────────────────────────────────────────────┼────────────┤\n│ 0x1d790713c1c3441a307782597c088f11230c47e609af2cec97f393123ea4de45 │ 200000000  │\n│ 0x20c1d5ad2e8693953fca09fd2fec0fbc52a787e0a0f77725220d36a09a5b312d │ 200000000  │\n│ 0x236714566110f5624516faa0da215ad29f8daa611e8b651d1e972168207567b2 │ 200000000  │\n│ 0xc81f30256bb04ad84bc4a92017cffd7c1f98286e028fa504d8515ad72ddd1088 │ 200000000  │\n│ 0xf61c8b21b305cc8e062b3a37de8c3a37583e17f437a449a2ab42321d019aeeb4 │ 200000000  │\n╰────────────────────────────────────────────────────────────────────┴────────────╯\n\nGenerate example data​\n\nUse the TypeScript SDK to add example data to your network. Run the following command from the sui root folder:\n\npnpm --filter @mysten/sui.js test:e2e\n\n\nFor additional information about example data for testing, see https://github.com/MystenLabs/sui/tree/main/sdk/typescript#testing.\n\nTroubleshooting​\n\nIf you do not use Node.js 18, you might see the following message:\n\nRetrying requesting from faucet: Retry failed: fetch is not defined\n\nTo resolve this, switch or update to Node.js 18 and then try again.\n\nTest with the Sui TypeScript SDK​\n\nThe published version of the Sui TypeScript SDK might be an earlier version than the version of Sui you installed for your local network. To make sure you're using the latest version of the SDK, use the experimental-tagged version (for example, 0.0.0-experimental-20230317184920) in the Current Tags section of the Sui NPM registry.\n\nEdit this page\nPrevious\nConnect to a Sui Network\nNext\nGet Sui Address\nStart the local network\nAccess your local Full node\nConnect the Sui Client CLI to your local network\nShow the current active address\nUse the local faucet\nCheck the gas coin objects for the active address\nGenerate example data\nTroubleshooting\nTest with the Sui TypeScript SDK\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Get Sui Address | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/get-address",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedGet Sui Address\nGet Sui Address\n\nAn address is a way to uniquely and anonymously identify an account that exists on the Sui blockchain network. In other words, an address is a way for a user to store and use tokens on the Sui network, without providing any personally identifying information (such as email address, phone number, and so on). For example, if you want to purchase a number of SUI tokens to play a game, you must specify an address where these tokens are to be deposited.\n\nThe Sui address is unique, similarly to the way a social security number or a personal identification number is unique to one person. However, in Sui you can create and own multiple addresses, all of which are unique.\n\nIn Sui, an address is 32 bytes and is often encoded in base58 with a 0x prefix. For example, this is a valid Sui address: 0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331. You can use a Sui network explorer to find more information about this address and the objects it owns.\n\nIf you'd like to understand how a Sui address is derived from private keys and other cryptography related topics, see the Keys and Addresses topic.\n\nHow to obtain a Sui address​\n\nSui provides multiple ways to obtain a Sui address. The following are the two most common.\n\nSui Wallet​\n\nOne of the most straightforward ways to obtain a Sui address for first-time users is through the Sui Wallet Chrome browser extension. After you install the extension, there are several ways to create an address.\n\nOpen the Chrome Sui Wallet browser extension and then:\n\nUse your gmail/twitch/facebook account (ZkLogin) and follow the on-screen instructions\nClick More Options → Create a new passphrase account. Then follow the on-screen instructions.\n\nFor more information on the Sui Wallet and how to keep it secure, see the Sui Wallet documentation.\n\nCommand line interface​\n\nIf you are using the Sui command line interface (CLI) to interact with the Sui network, you can use the sui client command to generate a new address. By default, when the Sui CLI runs for the first time it will prompt you to set up your local wallet, and then it generates one Sui address and the associated secret recovery phrase. Make sure you write down the secret recovery phrase and store it in a safe place.\n\nTo generate a new Sui address use sui client new-address ed25519, which specifies the keypair scheme flag to be of type ed25519.\n\nFor more information, see the Sui Client CLI documentation.\n\nTo see all the generated addresses in the local wallet on your machine, run sui keytool list. For more information about the keytool options, see the Sui Keytool CLI documentation.\n\nDANGER\n\nThe private keys associated with the Sui addresses are stored locally on the machine where the CLI is installed, in the ~/.sui/sui_config/sui.keystore file. Make sure you do not expose this to anyone, as they can use it to get access to your account.\n\nEdit this page\nPrevious\nConnect to a Local Network\nNext\nGet SUI Tokens\nHow to obtain a Sui address\nSui Wallet\nCommand line interface\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Connect to a Sui Network | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/connect",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedConnect to a Sui Network\nConnect to a Sui Network\n\nSui has Mainnet, Devnet, and Testnet networks available. You can use one of the test networks, Devnet or Testnet, to experiment with the version of Sui running on that network. You can also spin up a local Sui network for local development.\n\nThe Sui Testnet and Devnet networks consist of four validator nodes operated by Mysten Labs. Clients send transactions and read requests via this endpoint: https://fullnode.<SUI-NETWORK-VERSION>.sui.io:443 using JSON-RPC.\n\nYou can request test SUI tokens through the Sui devnet-faucet and testnet-faucet Discord channels, depending on which version of the network you use. If connected to Localnet, use cURL to request tokens from your local faucet. The coins on these networks have no financial value. There is no faucet service for Mainnet.\n\nSee announcements about Sui in the #announcements Discord channel.\n\nSee the terms of service for using Sui networks.\n\nINFO\n\nTestnet and Devnet data persistence is not guaranteed. Devnet data is wiped regularly as part of scheduled software updates. The data on Testnet persists through the regular update process, but might be wiped when necessary. Testnet data wipes are announced ahead of time.\n\nFor more information about the release schedule of Sui networks, see Sui Network Release.\n\nSui CLI​\n\nSui provides Sui command line interface (CLI) to interact with Sui networks:\n\nCreate and manage your private keys\nCreate example NFTs\nCall and publish Move modules\nEnvironment set up​\n\nFirst, Install Sui. After you install Sui, request SUI test tokens through Discord for the network you are using: Devnet or Testnet. If connected to Localnet, use cURL to request tokens from your local faucet.\n\nTo check whether Sui is already installed, run the following command:\n\nwhich sui\n\n\nIf Sui is installed, the command returns the path to the Sui binary. If Sui is not installed, it returns sui not found.\n\nSee the Sui Releases page to view the changes in each Sui release.\n\nConfigure Sui client​\n\nIf you previously ran sui genesis to create a local network, it created a Sui client configuration file (client.yaml) that connects to localhost at http://0.0.0.0:9000. See Connect to a custom RPC endpoint to update the client.yaml file.\n\nTo connect the Sui client to a network, run the following command:\n\nsui client\n\n\nIf you receive the sui-client help output in the console, you already have a client.yaml file. See Connect to a custom RPC endpoint to add a new environment alias or to switch the currently active network.\n\nThe first time you start Sui client without having a client.yaml file, the console displays the following message:\n\nConfig file [\"<PATH-TO-FILE>/client.yaml\"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?\n\n\nPress y and then press Enter. The process then requests the RPC server URL:\n\nSui Full node server URL (Defaults to Sui Devnet if not specified) :\n\n\nPress Enter to connect to Sui Devnet. To use a custom RPC server, Sui Testnet, or Sui Mainnet, enter the URL to the correct RPC endpoint and then press Enter.\n\nIf you enter a URL, the process prompts for an alias for the environment:\n\nEnvironment alias for [<URL-ENTERED>] :\n\n\nType an alias name and press Enter.\n\nSelect key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2 for secp256r1):\n\n\nPress 0, 1, or 2 to select a key scheme and the press Enter.\n\nSui returns a message similar to the following (depending on the key scheme you selected) that includes the address and 12-word recovery phrase for the address:\n\nGenerated new keypair for address with scheme \"ed25519\" [0xb9c83a8b40d3263c9ba40d551514fbac1f8c12e98a4005a0dac072d3549c2442]\nSecret Recovery Phrase : [cap wheat many line human lazy few solid bored proud speed grocery]\n\nConnect to a custom RPC endpoint​\n\nIf you previously used sui genesis with the force option (-f or --force), your client.yaml file already includes two RPC endpoints: localnet at http://0.0.0.0:9000 and devnet at https://fullnode.devnet.sui.io:443. You can view the defined environments with the sui client envs command, and switch between them with the sui client switch command.\n\nIf you previously installed a Sui client that connected to a Sui network, or created a local network, you can modify your existing client.yaml file to change the configured RPC endpoint. The sui client commands that relate to environments read from and write to the client.yaml file.\n\nTo check currently available environment aliases, run the following command:\n\nsui client envs\n\n\nThe command outputs the available environment aliases, with (active) denoting the currently active network.\n\nlocalnet => http://0.0.0.0:9000 (active)\ndevnet => https://fullnode.devnet.sui.io:443\n\n\nTo add a new alias for a custom RPC endpoint, run the following command. Replace values in < > with values for your installation:\n\nsui client new-env --alias <ALIAS> --rpc <RPC-SERVER-URL>\n\n\nTo switch the active network, run the following command:\n\nsui client switch --env <ALIAS>\n\n\nIf you encounter an issue, delete the Sui configuration directory (~/.sui/sui_config) and reinstall the latest Sui binaries.\n\nEdit this page\nPrevious\nInstall Sui\nNext\nConnect to a Local Network\nSui CLI\nEnvironment set up\nConfigure Sui client\nConnect to a custom RPC endpoint\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Install Sui | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started/sui-install",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting StartedInstall Sui\nInstall Sui\n\nThe quickest way to install Sui is using the binaries delivered with every release. If you require more control over the install process, you can install from source. To take advantage of containerization, you can utilize the Docker images in the docker folder of the sui repository.\n\nSupported operating systems​\n\nSui supports the following operating systems:\n\nLinux - Ubuntu version 20.04 (Bionic Beaver)\nmacOS - macOS Monterey\nMicrosoft Windows - Windows 10 and 11\nQuick install using Homebrew or Chocolatey​\n\nUse one of the following commands for Homebrew (MacOS, Linux, or Windows Subsystem for Linux) or Chocolatey (Windows) to install Sui.\n\nHomebrew\nChocolatey\nbrew install sui\n\nINFO\n\nIf you use this method to install Sui, you are all set. The quick install is suitable for most use cases. The remaining installation methods are for those wanting more control over the installation process.\n\nDownload binaries from GitHub​\n\nEach Sui release provides a set of binaries for several operating systems. You can download these binaries from GitHub and use them to install Sui.\n\nLinux\nmacOS\nWindows\n\nGo to https://github.com/MystenLabs/sui.\n\nIn the right pane, find the Releases section.\n\nClick the release tagged Latest to open the release's page.\n\nIn the Assets section of the release, select the .tgz compressed file that corresponds to your operating system.\n\nExtract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a sui folder at the user root of your system for demonstration purposes. Replace references to this location in subsequent steps if you choose a different directory.\n\nNavigate to the expanded folder. You should have the following extracted files:\n\nName\tDescription\nmove-analyzer\tLanguage Server Protocol implementation.\nsui\tMain Sui binary.\nsui-bridge\tSui native bridge.\nsui-data-ingestion\tCapture Full node data for indexer to store in a database.\nsui-faucet\tLocal faucet to mint coins on local network.\nsui-graphql-rpc\tGraphQL service for Sui RPC.\nsui-node\tRun a local node.\nsui-test-validator\tRun test validators on a local network for development.\nsui-tool\tProvides utilities for Sui.\n\nAdd the folder containing the extracted files to your PATH variable. To do so, you can update your ~/.bashrc to include the location of the Sui binaries. If using the suggested location, you type export PATH=$PATH:~/sui and press Enter.\n\nStart a new terminal session or type source ~/.bashrc to load the new PATH value.\n\nINFO\n\nRunning binaries other than sui might require installing prerequisites itemized in the following section.\n\nConfirm the installation​\n\nTo confirm that Sui installed correctly, type sui --version in your console or terminal and press Enter. The response should provide the Sui version installed. If the console or terminal responds with a command not found error, make sure the full path to your Sui binaries is included in your PATH variable.\n\nInstall from Cargo​\n\nRun the following command to install Sui binaries from the testnet branch:\n\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui\n\n\nThe install process can take a while to complete. You can monitor installation progress in the terminal. If you encounter an error, make sure to install the latest version of all prerequisites and then try the command again.\n\nTo update to the latest stable version of Rust:\n\nrustup update stable\n\n\nThe command installs Sui components in the ~/.cargo/bin folder.\n\nUpgrade from Cargo​\n\nIf you previously installed the Sui binaries, you can update them to the most recent release with the same command you used to install them (changing testnet to the desired branch):\n\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui\n\nBuild from source​\n\nFollow the instructions in this topic to install the Rust crates (packages) required to interact with Sui networks, including the Sui CLI.\n\nTo install Sui from source, you first need to install its prerequisites for your operating system. After installing the supporting technologies, you can install Sui binaries from source.\n\nYou can also download the source code to have local access to files.\n\nPrerequisites​\n\nYour system needs the following prerequisites available to successfully install Sui.\n\nRust and Cargo​\n\nSui requires Rust and Cargo (Rust's package manager) on all supported operating systems. The suggested method to install Rust is with rustup using cURL.\n\nSome other commands in the installation instructions also require cURL to run. If you can't run the cURL command to install Rust, see the instructions to install cURL for your operating system in the following section before you install Rust.\n\nUse the following command to install Rust and Cargo on macOS or Linux:\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n\nIf you use Windows 11, see information about using the Rust installer on the Rust website. The installer checks for C++ build tools and prompts you to install them if necessary. Select the option that best defines your environment and follow the instructions in the install wizard.\n\nFor additional installation options, see Install Rust.\n\nSui uses the latest version of Cargo to build and manage dependencies. See the Cargo installation page on the Rust website for more information.\n\nUse the following command to update Rust with rustup:\n\nrustup update stable\n\nAdditional prerequisites by operating system​\n\nSelect the appropriate tab to view the requirements for your system.\n\nLinux\nmacOS\nWindows\n\nThe prerequisites needed for the Linux operating system include:\n\ncURL\nRust and Cargo\nGit CLI\nCMake\nGCC\nlibssl-dev\nlibclang-dev\nlibpq-dev\nbuild-essential\nINFO\n\nThe Linux instructions assume a distribution that uses the APT package manager. You might need to adjust the instructions to use other package managers.\n\nInstall the prerequisites listed in this section. Use the following command to update apt-get:\n\nsudo apt-get update\n\nAll Linux prerequisites​\n\nReference the relevant sections that follow to install each prerequisite individually, or run the following to install them all at once:\n\nsudo apt-get install curl git-all cmake gcc libssl-dev pkg-config libclang-dev libpq-dev build-essential\n\ncURL​\n\nInstall cURL with the following command:\n\nsudo apt-get install curl\n\n\nVerify that cURL installed correctly with the following command:\n\ncurl --version\n\nGit CLI​\n\nRun the following command to install Git, including the Git CLI:\n\nsudo apt-get install git-all\n\n\nFor more information, see Install Git on Linux on the GitHub website.\n\nCMake​\n\nUse the following command to install CMake.\n\nsudo apt-get install cmake\n\n\nTo customize the installation, see Installing CMake on the CMake website.\n\nGCC​\n\nUse the following command to install the GNU Compiler Collection, gcc:\n\nsudo apt-get install gcc\n\nlibssl-dev​\n\nUse the following command to install libssl-dev:\n\nsudo apt-get install libssl-dev\n\n\nIf the version of Linux you use doesn't support libssl-dev, find an equivalent package for it on the ROS Index.\n\n(Optional) If you have OpenSSL you might also need to also install pkg-config:\n\nsudo apt-get install pkg-config\n\nlibclang-dev​\n\nUse the following command to install libclang-dev:\n\nsudo apt-get install libclang-dev\n\n\nIf the version of Linux you use doesn't support libclang-dev, find an equivalent package for it on the ROS Index.\n\nlibpq-dev​\n\nUse the following command to install libpq-dev:\n\nsudo apt-get install libpq-dev\n\n\nIf the version of Linux you use doesn't support libpq-dev, find an equivalent package for it on the ROS Index.\n\nbuild-essential​\n\nUse the following command to install build-essential:\n\nsudo apt-get install build-essential\n\nUsing Sui from command line​\n\nWith Sui installed, you can interact with Sui networks using the Sui CLI. For more details, see the Sui CLI reference.\n\nNext steps​\n\nNow that you have Sui installed, it's time to start developing. Check out the following topics to start working with Sui:\n\nRead about the Sui CLI, the most straightforward way to start exploring Sui networks.\nLearn about the available networks and connect to one.\nGet some coins on a development network.\nBuild your first dApp to start your on-chain journey.\nEdit this page\nPrevious\nGetting Started\nNext\nConnect to a Sui Network\nSupported operating systems\nQuick install using Homebrew or Chocolatey\nDownload binaries from GitHub\nInstall from Cargo\nUpgrade from Cargo\nBuild from source\nUsing Sui from command line\nNext steps\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper Guides\nDeveloper Guides\n\nThe developer guides are meant to introduce you to the Move programming language and its implementation on the Sui network through examples, tasks, and conceptual content.\n\nGet started​\n\nIf you are completely new to Move, you should start with the aptly named Getting Started section. Topics in that section introduce you to the Sui monorepo, guide you through installing Sui binaries, and introduce you to some key core concepts of blockchain technology, particularly how they relate to Sui.\n\nGo to Getting Started.\n\nYour first dApp​\n\nIf you prefer to jump right in to coding (after installing Sui, of course), then the Your First dApp is the place for you. These topics show you how to work with Move packages and get them published on-chain.\n\nGo to Your First Sui dApp.\n\nSui 101​\n\nThe Sui 101 section introduces the basics of Sui that help you create smart contracts. These topics assume you are familiar with Move and the Sui blockchain.\n\nGo to Sui 101.\n\nCryptography​\n\nThe Cryptography section demonstrates how to secure your smart contracts with cryptography to ensure authentication for access to sensitive data.\n\nGo to Cryptography.\n\nAdvanced Topics​\n\nThe Advanced Topics section includes guides for advanced solutions rather than advanced users (like migrating to GraphQL or asset tokenization). These topics assume you are familiar with Move and the Sui blockchain.\n\nGo to Advanced Topics.\n\nApp Examples​\n\nThe App Examples section is for anyone who learns best from reverse engineering code written by Sui and Move experts. These examples demonstrate concepts and tasks documented throughout this site and typically include detailed explanations through code comments and specific documentation. Check back often as the available examples continue to grow.\n\nGo to App Examples.\n\nSui developer cheat sheet​\n\nThe cheat sheet collects notes from Sui and Move developers into a single location. This document surfaces important information that might get lost in the quantity of content available. Use this often-updated page to see around corners when starting a Move project or to refresh your memory on important concepts to be mindful of.\n\nGo to Sui Developer Cheat Sheet.\n\nReferences​\n\nIf you're familiar with both Move and Sui and just need some reference material to refresh your memory on that function you haven't used in a while, then the References section of the documentation should surface the information you need.\n\nGo to References.\n\nEdit this page\nPrevious\nOverview\nNext\nGetting Started\nGet started\nYour first dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nSui developer cheat sheet\nReferences\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Your First Sui dApp | Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/first-app",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nWrite a Move Package\nBuild and Test Packages\nPublish a Package\nDebugging\nClient App with Sui TypeScript SDK\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesYour First Sui dApp\nYour First Sui dApp\n\nBefore you can create your first dApp, you must have Sui installed.\n\nYou use Move to write packages that live on chain, meaning they exist on the Sui network you publish them to. The instructions in this section walk you through writing a basic package, debugging and testing your code, and publishing. You need to follow these instructions in order to complete the exercise.\n\nYou use the move Sui CLI command for some instructions. The Sui CLI installs with the binaries, so you have it on your system if you follow the install instructions. To verify you have it installed, run the following command in a terminal or console.\n\n$ sui --version\n\n\nIf the console does not respond with a version number similar to the following, see the instructions to install Sui.\n\n$ sui 1.xx.x-abc123xyz\n\nConnecting to a network​\n\nAfter installing Sui, you can connect to a network. Sui has three public networks (Devnet, Testnet, Mainnet), and you can also run and connect to a local Sui network. For each network, you need an on-chain address specific to that network. The address is an object with a unique ID in the form 0x8bd4613c004aac53d06bb7ceb7f46832c9ae69bdc105dfc5fcac225d2061fcac. In addition to that address, you need SUI to pay for the gas fees associated with your on-chain activity, like publishing packages and making Move calls to those packages. For all networks besides Mainnet, you can get free SUI coins for your account to facilitate package development. For the purposes of this example, connect to the Testnet network.\n\nConnect to Testnet​\n\nIf you already have a network config set up, switch your active environment to Testnet. The following instruction is for the initial set up.\n\nIn your terminal or console, use the following command to begin the configuration:\n$ sui client\n\nAt the prompt, type y and press Enter to connect to a Sui Full node server.\nAt the following prompt, type the address of the Testnet server (https://fullnode.testnet.sui.io:443) and press Enter.\nAt the following prompt, type testnet to give the network an alias and press Enter. You can use the alias in subsequent commands instead of typing the complete URL.\nAt the following prompt, type 0 and press Enter. The selection creates an address in the ed25519 signing scheme.\nThe response provides an alias for your address, the actual address ID, and a secret recovery phrase. Be sure to save this information for later reference. Because this is on the Testnet network, the security of this information is not as important as if it were on Mainnet.\nIn your terminal or console, use the following command to get SUI for your account.\n$ sui client faucet\n\nYou can confirm that you received SUI by using the following command. There may be a delay in receiving coins depending on the activity of the network.\n$ sui client gas\n\n\nYou are now connected to the Sui Testnet network and should have an account with available SUI.\n\nRelated links​\nWrite a Move Package: Continue this example by creating the necessary Move code for your package.\nConnect to a Sui Network: Connect to an available Sui network.\nConnect to a Local Network: Start and connect to a local Sui network.\nGet Sui Address: Get an address for the current Sui network.\nGet SUI Tokens: Get SUI for the active address on Devnet, Testnet, or a local network.\nEdit this page\nPrevious\nQuerying Sui RPC with GraphQL\nNext\nWrite a Move Package\nConnecting to a network\nConnect to Testnet\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/dev-cheat-sheet",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesDev Cheat Sheet\nSui Developer Cheat Sheet\n\nQuick reference on best practices for Sui Network developers.\n\nMove​\nGeneral​\nRead about package upgrades and write upgrade-friendly code:\nPackages are immutable, so buggy package code can be called forever. Add protections at the object level instead.\nIf you upgrade a package P to P', other packages and clients that depend on P will continue using P, not auto-update to P'. Both dependent packages and client code must be explicitly updated to point at P'.\nPackages that expect to be extended by dependent packages can avoid breaking their extensions with each upgrade by providing a standard (unchanging) interface that all versions conform to. See this example for message sending across a bridge from Wormhole. Extension packages that produce messages to send can use prepare_message from any version of the Wormhole package to produce a MessageTicket while client code to send the message must pass that MessageTicket into publish_message in the latest version of the package.\npublic function signatures cannot be deleted or changed, but public(friend) functions can. Use public(friend) or private visibility liberally unless you are exposing library functions that will live forever.\nIt is not possible to delete struct types, add new fields (though you can add dynamic fields), or add new abilities via an upgrade. Introduce new types carefully—they will live forever!\nUse vector-backed collections (vector, VecSet, VecMap, PriorityQueue) with a known maximum size of ≤ 1000 items.\nUse dynamic field-backed collections (Table, Bag, ObjectBag, ObjectTable, LinkedTable) for any collection that allows third-party addition, larger collections, and collections of unknown size.\nMove objects have a maximum size of 250KB—any attempt to create a larger object leads to an aborted transaction. Ensure that your objects do not have an ever-growing vector-backed collection.\nIf your function f needs a payment in (e.g.) SUI from the caller, use fun f(payment: Coin<SUI>) not fun f(payment: &mut Coin<SUI>, amount: u64). This is safer for callers—they know exactly how much they are paying, and do not need to trust f to extract the right amount.\nDon't micro-optimize gas usage. Sui computation costs are rounded up to the closest bucket, so only very drastic changes will make a difference. In particular, if your transaction is already in the lowest cost bucket, it can't get any cheaper.\nFollow the Move coding conventions for consistent style.\nComposability​\nUse the display standard to customize how your objects show up in wallets, apps, and explorers\nAvoid “self-transfers”—whenever possible, instead of writing transfer::transfer(obj, tx_context::sender(ctx)), return obj from the current function. This allows a caller or programmable transaction block to use obj.\nTesting​\nUse sui::test_scenario to mimic multi-transaction, multi-sender test scenarios.\nUse the sui::test_utils module for better test error messages via assert_eq, debug printing via print, and test-only destruction via destroy.\nUse sui move test --coverage to compute code coverage information for your tests, and sui move coverage source --module <name> to see uncovered lines highlighted in red. Push coverage all the way to 100% if feasible.\nApps​\nFor optimal performance and data consistency, apps should submit writes and reads for the same full node. In the TS SDK, this means that apps should use the wallet's signTransactionBlock API, then submit the transaction via a call to execute_transactionBlock on the app's full node, not use the wallet's signAndExecuteTransactionBlock API. This ensures read-after-write-consistency--reads from the app's full node will reflect writes from the transaction right away instead of waiting for a checkpoint.\nFor lower latency, use executeTransactionBlock with \"showEffects\": false and \"showEvents\": false if your app needs to know that a transaction was confirmed, but does not immediately need to see the transaction effects or read the objects/events written by the transaction.\nApps should implement a local cache for frequently read data rather than over-fetching from the full node.\nWhenever possible, use programmable transaction blocks to compose existing on-chain functionality rather than publishing new smart contract code. Programmable transaction blocks allow large-scale batching and heterogeneous composition, driving already-low gas fees down even further.\nApps should leave gas budget, gas price, and coin selection to the wallet. This gives wallets more flexibility, and it's the wallet's responsibility to dry run a transaction to ensure it doesn't fail.\nSigning​\nNever sign two concurrent transactions that are touching the same owned object. Either use independent owned objects, or wait for one transaction to conclude before sending the next one. Violating this rule might lead to client equivocation, which locks up the owned objects involved in the two transactions until the end of the current epoch.\nAny sui client command that crafts a transaction (e.g., sui client publish, sui client call) can accept the --serialize-output flag to output a base64 transaction to be signed.\nSui supports several signature schemes for transaction signing, including native multisig.\nzkLogin​\nCall the proving service as sparingly as possible. Design your app flows such that you call the proving service only when the user is about to perform a real transaction.\nBeware of how you cache the ephemeral private key. Treat the private key akin to a piece of highly sensitive data, e.g., password. If an (unexpired) ephemeral private key and its corresponding ZK proof are leaked, then an attacker can steal user's assets.\nEdit this page\nPrevious\nFrontend\nNext\nOperator Guides\nMove\nGeneral\nComposability\nTesting\nApps\nSigning\nzkLogin\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/sui-full-node",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesSui Full Node Configuration\nSui Full Node Configuration\nINFO\n\nThese instructions are for advanced users. If you just need a local development environment, you should instead follow the instructions in Create a Local Sui Network to create a local Full node, validators, and faucet.\n\nSui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.\n\nThis role enables validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.\n\nFeatures​\n\nSui Full nodes:\n\nTrack and verify the state of the blockchain, independently and locally.\nServe read requests from clients.\nState synchronization​\n\nSui Full nodes sync with validators to receive new transactions on the network.\n\nA transaction requires a few round trips to 2f+1 validators to form a transaction certificate (TxCert).\n\nThis synchronization process includes:\n\nFollowing 2f+1 validators and listening for newly committed transactions.\nMaking sure that 2f+1 validators recognize the transaction and that it reaches finality.\nExecuting the transaction locally and updating the local DB.\n\nThis synchronization process requires listening to at a minimum 2f+1 validators to ensure that a Full node has properly processed all new transactions. Sui will improve the synchronization process with the introduction of checkpoints and the ability to synchronize with other Full nodes.\n\nArchitecture​\n\nA Sui Full node is essentially a read-only view of the network state. Unlike validator nodes, Full nodes cannot sign transactions, although they can validate the integrity of the chain by re-executing transactions that a quorum of validators previously committed.\n\nToday, a Sui Full node maintains the full history of the chain.\n\nValidator nodes store only the latest transactions on the frontier of the object graph (for example, transactions with >0 unspent output objects).\n\nFull node setup​\n\nFollow the instructions here to run your own Sui Full.\n\nHardware requirements​\n\nSuggested minimum hardware to run a Sui Full node:\n\nCPUs: 8 physical cores / 16 vCPUs\nRAM: 128 GB\nStorage (SSD): 4 TB NVMe drive\nSoftware requirements​\n\nSui recommends running Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also run a Sui Full node on macOS.\n\nMake sure to update Rust.\n\nUse the following command to install additional Linux dependencies.\n\nsudo apt-get update \\\n&& sudo apt-get install -y --no-install-recommends \\\ntzdata \\\nlibprotobuf-dev \\\nca-certificates \\\nbuild-essential \\\nlibssl-dev \\\nlibclang-dev \\\nlibpq-dev \\\npkg-config \\\nopenssl \\\nprotobuf-compiler \\\ngit \\\nclang \\\ncmake\n\nConfigure a Full node​\n\nYou can configure a Sui Full node either using Docker or by building from source.\n\nUsing Docker Compose​\n\nFollow the instructions in the Full node Docker Readme to run a Sui Full node using Docker, including resetting the environment.\n\nSetting up a local Sui repository​\n\nYou must get the latest source files from the Sui GitHub repository.\n\nSet up your fork of the Sui repository:\nGo to the Sui repository on GitHub and click the Fork button in the top right-hand corner of the screen.\nClone your personal fork of the Sui repository to your local machine (ensure that you insert your GitHub username into the URL): git clone https://github.com/<YOUR-GITHUB-USERNAME>/sui.git\ncd into your sui repository: cd sui\nSet up the Sui repository as a git remote: git remote add upstream https://github.com/MystenLabs/sui\nSync your fork: git fetch upstream\nCheck out the branch associated with the network version you want to run (for example, devnet to run a Devnet Full node): git checkout --track upstream/<BRANCH-NAME>\nSetting up a Full node from source​\n\nOpen a terminal or console to the sui directory you downloaded in the previous steps to complete the following:\n\nInstall the required prerequisites.\n\nMake a copy of the Full node YAML template: cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml\n\nDownload the genesis blob for the network to use:\n\nDevnet genesis blob: curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob\nTestnet genesis blob: curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob\nMainnet genesis blob: curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/mainnet/genesis.blob\n\nFor Testnet or Mainnet: Edit the fullnode.yaml file to include peer nodes for state synchronization. Append the following to the end of the current configuration:\n\nMainnet\nTestnet\np2p-config:\n  seed-peers:\n    - address: /dns/mel-00.mainnet.sui.io/udp/8084\n      peer-id: d32b55bdf1737ec415df8c88b3bf91e194b59ee3127e3f38ea46fd88ba2e7849\n    - address: /dns/ewr-00.mainnet.sui.io/udp/8084\n      peer-id: c7bf6cb93ca8fdda655c47ebb85ace28e6931464564332bf63e27e90199c50ee\n    - address: /dns/ewr-01.mainnet.sui.io/udp/8084\n      peer-id: 3227f8a05f0faa1a197c075d31135a366a1c6f3d4872cb8af66c14dea3e0eb66\n    - address: /dns/lhr-00.mainnet.sui.io/udp/8084\n      peer-id: c619a5e0f8f36eac45118c1f8bda28f0f508e2839042781f1d4a9818043f732c\n    - address: /dns/sui-mainnet-ssfn-1.nodeinfra.com/udp/8084\n      peer-id: 0c52ca8d2b9f51be4a50eb44ace863c05aadc940a7bd15d4d3f498deb81d7fc6\n    - address: /dns/sui-mainnet-ssfn-2.nodeinfra.com/udp/8084\n      peer-id: 1dbc28c105aa7eb9d1d3ac07ae663ea638d91f2b99c076a52bbded296bd3ed5c\n    - address: /dns/sui-mainnet-ssfn-ashburn-na.overclock.run/udp/8084\n      peer-id: 5ff8461ab527a8f241767b268c7aaf24d0312c7b923913dd3c11ee67ef181e45\n    - address: /dns/sui-mainnet-ssfn-dallas-na.overclock.run/udp/8084\n      peer-id: e1a4f40d66f1c89559a195352ba9ff84aec28abab1d3aa1c491901a252acefa6\n    - address: /dns/ssn01.mainnet.sui.rpcpool.com/udp/8084\n      peer-id: fadb7ccb0b7fc99223419176e707f5122fef4ea686eb8e80d1778588bf5a0bcd\n    - address: /dns/ssn02.mainnet.sui.rpcpool.com/udp/8084\n      peer-id: 13783584a90025b87d4604f1991252221e5fd88cab40001642f4b00111ae9b7e\n\n\nOptional: Skip this step to accept the default paths to resources. Edit the fullnode.yaml file to use custom paths.\n\nUpdate the db-path field with the path to the Full node database. db-path: \"/db-files/sui-fullnode\"\n\nUpdate the genesis-file-location with the path to genesis.blob.\n\ngenesis:\n    genesis-file-location: \"/sui-fullnode/genesis.blob\"\n\nStarting services​\n\nAt this point, your Sui Full node is ready to connect to the Sui network.\n\nOpen a terminal or console to the sui directory.\nStart the Sui Full node: cargo run --release --bin sui-node -- --config-path fullnode.yaml\nOptional: Publish/subscribe to notifications using JSON-RPC via websocket.\n\nIf your setup is successful, your Sui Full node is now connected to the appropriate network.\n\nYour Full node serves the read endpoints of the Sui JSON-RPC API at: http://127.0.0.1:9000.\n\nTroubleshooting​\n\nIf you receive a cannot find -lpq error, you are missing the libpq library. Use sudo apt-get install libpq-dev to install on Linux, or brew install libpq on MacOS. After you install on MacOS, create a Homebrew link using brew link --force libpq. For further context, reference the issue on Stack Overflow.\n\nIf you receive the following error:\n\npanicked at error binding to 0.0.0.0:9184: error creating server listener: Address already in use (os error 98)\n\n\nThen update the metrics address in your fullnode.yaml file to use port 9180.\n\nmetrics-address: \"0.0.0.0:9180\"\n\nMonitoring​\n\nMonitor your Full node using the instructions at Logging, Tracing, Metrics, and Observability.\n\nThe default metrics port is 9184. To change the port, edit your fullnode.yaml file.\n\nUpdate your Full node​\n\nWhenever Sui releases a new version, you must update your Full node with the release to ensure compatibility with the network it connects to. For example, if you use Sui Testnet you should install the version of Sui running on Sui Testnet.\n\nUpdate with Docker Compose​\n\nFollow the instructions to reset the environment, namely by running the command:\n\ndocker-compose down --volumes\n\nUpdate from source​\n\nIf you followed the instructions for Building from Source, use the following steps to update your Full node:\n\nShut down your running Full node.\ncd into your local Sui repository:\ncd sui\n\nRemove the database and 'genesis.blob' file:\nrm -r suidb genesis.blob\n\nFetch the source from the latest release:\ngit fetch upstream\n\nReset your branch:\ngit checkout -B <BRANCH-NAME> --track upstream/<BRANCH-NAME>\n\nDownload the latest genesis blob:\nDevnet genesis blob:\ncurl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob\n\nTestnet genesis blob:\ncurl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob\n\nUpdate your fullnode.yaml configuration file, if needed.\nRestart your Sui Full node:\ncargo run --release --bin sui-node -- --config-path fullnode.yaml\n\n\nYour Full node starts on: http://127.0.0.1:9000.\n\nObject pruning​\n\nSui adds new object versions to the database as part of transaction execution. This makes previous versions ready for garbage collection. However, without pruning, this can result in database performance degradation and requires large amounts of storage space. Sui identifies the objects that are eligible for pruning in each checkpoint, and then performs the pruning in the background.\n\nYou can enable pruning for a Sui node by adding the authority-store-pruning-config config to fullnode.yaml file:\n\nauthority-store-pruning-config:\n  # Number of epoch dbs to keep \n  # Not relevant for object pruning\n  num-latest-epoch-dbs-to-retain: 3\n  # The amount of time, in seconds, between running the object pruning task.\n  # Not relevant for object pruning\n  epoch-db-pruning-period-secs: 3600\n  # Number of epochs to wait before performing object pruning.\n  # When set to 0, Sui prunes old object versions as soon\n  # as possible. This is also called *aggressive pruning*, and results in the most effective\n  # garbage collection method with the lowest disk usage possible. \n  # This is the recommended setting for Sui Validator nodes since older object versions aren't\n  # necessary to execute transactions.\n  # When set to 1, Sui prunes only object versions from transaction checkpoints\n  # previous to the current epoch. In general, when set to N (where N >= 1), Sui prunes  \n  # only object versions from checkpoints up to `current - N` epoch. \n  # It is therefore possible to have multiple versions of an object present \n  # in the database. This setting is recommended for Sui Full nodes as they might need to serve \n  # RPC requests that require looking up objects by ID and Version (rather than just latest\n  # version). However, if your Full node does not serve RPC requests you should then also enable  \n  # aggressive pruning.\n  num-epochs-to-retain: 0\n  # Advanced setting: Maximum number of checkpoints to prune in a batch. The default\n  # settings are appropriate for most use cases.\n  max-checkpoints-in-batch: 10\n  # Advanced setting: Maximum number of transactions in one batch of pruning run. The default\n  # settings are appropriate for most use cases.\n  max-transactions-in-batch: 1000\n\nTransaction pruning​\n\nTransaction pruning removes previous transactions and effects from the database. Sui periodically creates checkpoints. Each checkpoint contains the transactions that occurred during the checkpoint and their associated effects.\n\nSui performs transaction pruning in the background after checkpoints complete.\n\nYou can enable transaction pruning for your Full node or Validator node by adding num-epochs-to-retain-for-checkpoints to the authority-store-pruning-config config for the node:\n\nauthority-store-pruning-config:\n  num-latest-epoch-dbs-to-retain: 3\n  epoch-db-pruning-period-secs: 3600\n  num-epochs-to-retain: 0\n  max-checkpoints-in-batch: 10\n  max-transactions-in-batch: 1000\n  # Number of epochs to wait before performing transaction pruning.\n  # When this is N (where N >= 2), Sui prunes transactions and effects from \n  # checkpoints up to the `current - N` epoch. Sui never prunes transactions and effects from the current and\n  # immediately prior epoch. N = 2 is a recommended setting for Sui Validator nodes and Sui Full nodes that don't \n  # serve RPC requests.\n  num-epochs-to-retain-for-checkpoints: 2\n  # Ensures that individual database files periodically go through the compaction process.\n  # This helps reclaim disk space and avoid fragmentation issues\n  periodic-compaction-threshold-days: 1\n\nINFO\n\nIf you prune transactions, Archival nodes can help ensure lagging peer nodes don't lose any information. For more information, see Sui Archives.\n\nEdit this page\nPrevious\nOperator Guides\nNext\nSui Validator Node Configuration\nFeatures\nState synchronization\nArchitecture\nFull node setup\nHardware requirements\nSoftware requirements\nConfigure a Full node\nUsing Docker Compose\nSetting up a local Sui repository\nSetting up a Full node from source\nStarting services\nTroubleshooting\nMonitoring\nUpdate your Full node\nUpdate with Docker Compose\nUpdate from source\nObject pruning\nTransaction pruning\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/references/sui-api",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nSui RPC\nSui RPC\nINFO\n\nThe Sui RPC is upgrading from JSON-RPC to GraphQL. See GraphQL for Sui RPC for more information.\n\nSuiJSON is a JSON-based format with restrictions that allow Sui to align JSON inputs more closely with Move call arguments.\n\nThis table shows the restrictions placed on JSON types to make them SuiJSON compatible:\n\nJSON\tSuiJSON Restrictions\tMove Type Mapping\nNumber\tMust be unsigned integer\tu8, u6, u32, u64 (encoded as String), u128 (encoded as String), u256 (encoded as String)\nString\tNo restrictions\tVector<u8>, Address, ObjectID, TypeTag, Identifier, Unsigned integer (256 bit max)\nBoolean\tNo restrictions\tBool\nArray\tMust be homogeneous JSON and of SuiJSON type\tVector\nNull\tNot allowed\tN/A\nObject\tNot allowed\tN/A\nType coercion reasoning​\n\nDue to the loosely typed nature of JSON/SuiJSON and the strongly typed nature of Move types, you sometimes need to overload SuiJSON types to represent multiple Move types.\n\nFor example SuiJSON::Number can represent both u8 and u32. This means you have to coerce and sometimes convert types.\n\nWhich type you coerce depends on the expected Move type. For example, if the Move function expects a u8, you must have received a SuiJSON::Number with a value less than 256. More importantly, you have no way to easily express Move addresses in JSON, so you encode them as hex strings prefixed by 0x.\n\nAdditionally, Move supports u128 and u256 but JSON doesn't. As a result Sui allows encoding numbers as strings.\n\nType coercion rules​\nMove Type\tSuiJSON Representations\tValid Examples\tInvalid Examples\nBool\tBool\ttrue, false\t\nu8\tSupports 3 formats: Unsigned number < 256. Decimal string with value < 256. One byte hex string prefixed with 0x.\t7 \"70\" \"0x43\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 300: U8 must be less than 256 \" 9\": Spaces not allowed in string \"9A\": Hex num must be prefixed with 0x \"0x09CD\": Too large for U8\nu16\tThree formats are supported Unsigned number < 65536. Decimal string with value < 65536. Two byte hex string prefixed with 0x.\t712 \"570\" \"0x423\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 98342300: U16 must be less than 65536 \" 19\": Spaces not allowed in string \"9EA\": Hex num must be prefixed with 0x \"0x049C1D\": Too large for U16\nu32\tThree formats are supported Unsigned number < 4294967296. Decimal string with value < 4294967296. One byte hex string prefixed with 0x.\t9823247 \"987120\" \"0x4BADE93\"\t-5: negative not allowed 3.9: float not allowed NaN: not allowed 123456789123456: U32 must be less than 4294967296 \" 9\": Spaces not allowed in string \"9A\": Hex num must be prefixed with 0x \"0x3FF1FF9FFDEFF\": Too large for U32\nu64\tSupports two formats Decimal string with value < U64::MAX. Up to 8 byte hex string prefixed with 0x.\t\"747944370\" \"0x2B1A39A15E\"\t123434: Although this is a valid U64 number, it must be encoded as a string\nu128\tTwo formats are supported Decimal string with value < U128::MAX. Up to 16 byte hex string prefixed with 0x.\t\"74794734937420002470\" \"0x2B1A39A1514E1D8A7CE\"\t34: Although this is a valid U128 number, it must be encoded as a string\nu256\tTwo formats are supported Decimal string with value < U256::MAX. Up to 32 byte hex string prefixed with 0x.\t\"747947349374200024707479473493742000247\" \"0x2B1762FECADA39753FCAB2A1514E1D8A7CE\"\t123434: Although this is a valid U256 number, it must be encoded as a string 0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de\nAddress\t32 byte hex string prefixed with 0x\t\"0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de\"\t0xbc33: string too short bc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de: missing 0x prefix 0xG2B1A39A1514E1D8A7CE45919CFEB4FEE70B4E01: invalid hex char G\nObjectID\t32 byte hex string prefixed with 0x\t\"0x1b879f00b03357c95a908b7fb568712f5be862c5cb0a5894f62d06e9098de6dc\"\tSimilar to above\nIdentifier\tTypically used for module and function names. Encoded as one of the following: A String whose first character is a letter and the remaining characters are letters, digits or underscore. A String whose first character is an underscore, and there is at least one further letter, digit or underscore\t\"function\", \"_function\", \"some_name\", \"____some_name\", \"Another\"\t\"_\": missing trailing underscore, digit or letter, \"8name\": cannot start with digit, \".function\": cannot start with period, \" \": cannot be empty space, \"func name\": cannot have spaces\nVector<Move Type>\tHomogeneous vector of aforementioned types including nested vectors of primitive types (only \"flat\" vectors of ObjectIDs are allowed)\t[1,2,3,4]: simple U8 vector [[3,600],[],[0,7,4]]: nested U32 vector [\"0x2B1A39A1514E1D8A7CE45919CFEB4FEE\", \"0x2B1A39A1514E1D8A7CE45919CFEB4FEF\"]: ObjectID vector\t[1,2,3,false]: not homogeneous JSON [1,2,null,4]: invalid elements [1,2,\"7\"]: although Sui allows encoding numbers as strings meaning this array can evaluate to [1,2,7], the array is still ambiguous so it fails the homogeneity check.\nVector<u8>\tFor convenience, Sui allows: U8 vectors represented as UTF-8 (and ASCII) strings.\t\"√®ˆbo72 √∂†∆˚–œ∑π2ie\": UTF-8 \"abcdE738-2 _=?\": ASCII\t\nEdit this page\nPrevious\nOverview\nNext\nGraphQL for Sui RPC\nType coercion reasoning\nType coercion rules\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/operator/validator-config",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nSui Full Node Configuration\nSui Validator Node Configuration\nData Management\nDatabase Snapshots\nSui Archives\nGenesis\nValidator Committee\nValidator Tasks\nNode Tools\nSui Exchange Integration Guide\nOperator GuidesSui Validator Node Configuration\nSui Validator Node Configuration\n\nValidators on the Sui network run special nodes and have additional tasks and responsibilities beyond those of Full node operators.\n\nRequirements to run a validator on Sui​\n\nTo run a Sui validator, you must set up and configure a Sui Validator node. After you have a running node, you must have a minimum of 30 million SUI in your staking pool to join the validator set on the Sui network.\n\nTo learn how to set up and configure a Sui Validator node, see Sui for Node Operators on GitHub. The guide includes all of the information you need to configure your Validator node. It also provides guidance on the tasks you must perform after you join the validator set.\n\nSpecific steps you must take include:\n\nInstall and configure Sui\nConfigure Port and Protocol settings\nKey management\nStorage configuration\nSoftware updates\nOn-chain commands\nUpdate the Gas Price Survey\nReporting other validators\nValidator staking pool requirements​\n\nThere are minimum staking requirements a validator must satisfy to become active and to stay in the active validator set.\n\nMore precisely:\n\nA validator candidate must accrue at least 30M SUI of stake before they can request to join the validator set.\nIf an active validator’s stake falls below 20M SUI, they have seven epochs of grace period to gain back the stake before being removed from the validator set.\nIf an active validator’s stake falls below 15M SUI, they are removed from the validator set at the end of the current epoch boundary. Sui uses 24-hour epochs.\nHardware requirements to run a Validator node​\n\nSuggested minimum hardware specifications to run a Sui Validator node:\n\nCPU: 24 physical cores (or 48 virtual cores)\nMemory: 128 GB\nStorage: 4 TB NVME\nNetwork: 1 Gbps\nValidator consensus and voting power​\n\nThe total voting power on Sui is always 10,000, regardless of the amount staked. Therefore, the quorum threshold is 6,667. There is no limit to the amount of SUI users can stake with a validator. Each validator has consensus voting power proportional to SUI in its staking pool, with one exception: the voting power of an individual validator is capped at 1,000 (10% of the total). If a validator accumulates more than 10% of total stake, the validator's voting power remains fixed at 10%, and the remaining voting power is spread across the rest of the validator set.\n\nUser staking and withdrawals​\n\nWhen users stake SUI tokens, these SUI objects are wrapped into StakedSUI objects. The calculation to determine each user's relative ownership of the staking pool is done directly with the timestamp of the StakedSUI object (which determines the moment at which the deposit took place) and the change in the exchange rates between the deposit epoch and the withdrawal epoch. Each staking pool's data structure contains a time series with that pool's exchange rates. These exchange rates can be used to determine the withdrawals of any of the pool's stakers.\n\nStake withdrawals are processed immediately with the exchange rate prevailing at the previous epoch's exchange rate. Withdrawals do not have to wait for the current epoch to close. Withdrawals include both the original stake the user deposited and all the stake rewards accumulated up to the previous epoch. Stakers do not earn the rewards accruing to their stake during the epoch at which they withdraw. Since there is no way to know how many stake rewards will be accumulated during the current epoch until the epoch closes, these cannot be included in the withdrawal. Hence, any user can withdraw their stake immediately and receive:\n\nSUI withdrawn at E' = ( SUI deposited at E ) * ( Exchange Rate at E'-1 / Exchange Rate at E )\n\nFind the exchange rate​\n\nEach epoch change emits a 0x2::validator_set::ValidatorEpochInfo event per validator with the exchange rate information. You can use the Events API to query events.\n\nStaking rewards​\n\nWithin a given validator staking pool, all stakers receive the same proportion of rewards through the pool's exchange rate appreciation. In addition, since validators earn commissions over the stake they manage, validators receive additional StakedSUI objects at the end of each epoch in proportion to the amount of commissions their staking pool earns.\n\nStaking rewards are funded by transaction gas fees collected during the current epoch and by stake subsidies released at the end of the epoch.\n\nStakeRewards = StakeSubsidies + GasFees\n\nStake subsidies are intended to subsidize the network during its early phases and are funded by a 10% allocation of SUI tokens. After this allocation depletes, the entirety of stake rewards will be made up of gas fees collected through regular network operations.\n\nStake rewards are made up of gas fees and stake subsidies. The total amount distributed throughout each epoch is determined as follows:\n\nStake Subsidies: The amount distributed in each epoch is determined prior to the beginning of the epoch according to a predefined schedule.\nGas Fees: Each epoch's amount depends on the total gas fees collected throughout the epoch. Each Sui transaction pays gas fees depending on two variables, the amount of executed gas units and the gas price: _GasFee = GasPrice _ GasUnits*\n\nThe total amount of gas fees collected corresponds to the sum of gas fees across all transactions processed in the epoch. During regular market conditions, the vast majority of transactions should have a GasPrice equal to the ReferenceGasPrice.\n\nUser staking and rewards​\n\nA stake deposit request goes into a pending state immediately in the staking pool as soon as it is made. Sui Wallet reflects any pending stake deposit requests for the user's account. However, pending stake deposit requests do not take effect until the end of the epoch during which the request is made.\n\nA withdrawal (un-stake) request is processed immediately as soon as it is received. The staker obtains the originally deposited SUI together with all accrued stake rewards up to the previous epoch boundary – in other words, they do not include stake rewards for the current epoch.\n\nUsers can't withdraw a portion of their active stake. They must withdraw all staked SUI at the same time. Users can, however, stake using multiple StakedSui objects by splitting their SUI into multiple coins. They can then perform a partial withdrawal from a validator by un-staking only some of the StakedSUI objects.\n\nReference gas price​\n\nSui is designed such that end-users can expect the gas price to be stable and predictable during regular network operations. This is achieved by having validators set the network's reference gas price at the beginning of each epoch.\n\nOperationally this is achieved through a gas price survey that occurs as follows:\n\nDuring each epoch E, each validator submits what they think the optimal reference gas price should be for the next epoch E+1.\nAt the epoch boundary, when Sui transitions from epoch E to epoch E+1, the network observes the gas price quotes across the validator set and sets the 2/3 percentile weighted by stake as the epoch's reference gas price. Hence the reference gas price is constant throughout each epoch and is only updated when the epoch changes.\n\nFor example, assume that there are seven validators with equal stake, and the price quotes they submit are {15, 1, 4, 2, 8, 3, 23}. The protocol sets the reference gas price at 8.\n\nIn practice, the process for submitting a gas price quote for the Gas Price Survey is a straightforward one. Each validator owns an object that contains their quote for the reference gas price. To change their response, they must update the value in that object.\n\nFor example, to set the price quote for the next epoch to 42, run:\n\nTIP\n\nBeginning with the Sui v1.24.1 release, the --gas-budget flag is no longer required for CLI commands.\n\nsui client call --package <PACKAGE-ID> --module sui_system --function request_set_gas_price --args 0x5 \\\"42\\\" --gas-budget <GAS-AMOUNT>\n\n\nImportantly, the gas object's value persists across epochs so that a validator who does not update and submit a new quote uses the same quote from the previous epoch. Hence, a validator seeking to optimize its own operations should update its quote every epoch in response to changes in network operations and market conditions.\n\nValidator slashing and tallying rule​\n\nSui is designed to encourage and enforce community monitoring of the validator set. This is done through the Tallying Rule by which each validator monitors and scores every other validator in order to ensure that everyone is operating efficiently and in the network's best interest. Validators that receive a low score can be penalized with slashed stake rewards.\n\nThe protocol only computes the global Tallying Rule score at the epoch boundary and so relies on validators monitoring actively and changing their individual scores whenever they detect changes in other validator behavior. In general, the Tallying Rule default option should always be a score of one for all validators and only be changed to zero upon determining bad operations. In practice, the Tallying Rule consists of a set of objects each validator owns that default to scores of one and thus a validator will generally be passive and only update the object corresponding to another validator's score whenever needed.\n\nFor example, to report a validator whose Sui address is 0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446 as bad or non-performant, run:\n\nsui client call --package <PACKAGE-ID> --module sui_system --function report_validator --args 0x5 0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446 --gas-budget <GAS-AMOUNT>\n\n\nThe Tallying Rule should be implemented through a social equilibrium. The validator set should actively monitor itself and if one validator is clearly non-performant, then the other validators should score that validator with a 0 and slash its rewards. Community members can launch public dashboards tracking validator performance and that can be used as further signal into a validator's operations. There is no limit on the number of validators that can receive a 0 tallying score in an epoch.\n\nEdit this page\nPrevious\nSui Full Node Configuration\nNext\nData Management\nRequirements to run a validator on Sui\nValidator staking pool requirements\nHardware requirements to run a Validator node\nValidator consensus and voting power\nUser staking and withdrawals\nFind the exchange rate\nStaking rewards\nUser staking and rewards\nReference gas price\nValidator slashing and tallying rule\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/sui-101",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nShared versus Owned Objects\nCreate Coins and Tokens\nCreate a Non-Fungible Token\nUsing Events\nAccess On-Chain Time\nSigning and Sending Transactions\nSponsored Transaction\nWorking with PTBs\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesSui 101\nSui 101\n\nIn many education systems, 101-level classes are those that teach core competencies to build a foundation for the more advanced topics that are to come. The topics in this section provide the same experience for the Sui blockchain. They examine the core Sui development concepts that you use to build apps on Sui. As you start developing more advanced solutions, knowledge of these topics provides a good base for understanding the more advanced concepts you will employ.\n\nCreating coins and NFTs on Sui​\n\nEverything on the Sui blockchain is an object. These topics use code examples to demonstrate how to create these specific types of objects.\n\nCreate Coins\nCreate NFTs\nWorking with PTBs​\n\nYou can create programmable transaction blocks (PTBs) on Sui to perform multiple commands in a single transaction. The Working with PTBs topics demonstrate how to build efficient PTBs using the Sui TypeScript SDK.\n\nGo to Working with PTBs.\n\nUsing Events​\n\nYou can emit events from your published packages on the Sui network. Using Events demonstrates how to emit events from your on-chain packages and monitor the activity of other objects emitting events.\n\nGo to Using Events.\n\nShared versus Owned Objects​\n\nObjects on Sui, unlike other blockchains, can be owned as well as shared. You can create transactions that leverage either type or both. Shared versus Owned Objects examines the differences and what considerations you should account for when deciding how to structure your on-chain app.\n\nGo to Shared versus Owned Objects.\n\nAccess On-Chain Time​\n\nSui provides a Clock module you can use to get network-based time. Access On-Chain Time examines the Clock module and the behavior of the available methods that affect transaction processing speed and the temporal exactness of the data you receive.\n\nGo to Access On-Chain Time.\n\nEdit this page\nPrevious\nClient App with Sui TypeScript SDK\nNext\nShared versus Owned Objects\nCreating coins and NFTs on Sui\nWorking with PTBs\nUsing Events\nShared versus Owned Objects\nAccess On-Chain Time\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/sui-move-concepts",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nGraphQL for the Sui RPC\nObject Model\nMove Overview\nStrings\nCollections\nModule Initializers\nEntry Functions\nOne-Time Witness\nPackage Upgrades\nConventions\nTransactions\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nApp DevelopersMove Overview\nMove Concepts\n\nMove is an open source language for writing safe packages to manipulate on-chain objects (sometimes referred to as \"smart contracts\"). Move is a platform-agnostic language to enable common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. Move is adaptable to meet the needs of the blockchain the code operates on, see Move on Sui to review enhancements made to Move for optimization on the Sui blockchain.\n\nYou can use Move to define, create, and manage programmable Sui objects representing user-level assets. Sui's object system is implemented by adding new functionality to Move while also imposing additional restrictions. See Object Model for more details.\n\nMove on Sui​\n\nMove on Sui contains some important differences from Move on other blockchains. Sui takes advantage of Move's security and flexibility and enhances it with the features described in the following sections to vastly improve throughput, reduce delays in finality, and make Move programming more approachable. For full details, see the Sui Smart Contracts Platform white paper.\n\nTIP\n\nWhere the Sui documentation refers to the Move language, the content is documenting the specific Move implementation on the Sui blockchain. If relevant, the documentation expressly refers to the original use case for the Move language as Move on Diem.\n\nIn general, Move on Diem code written for other systems works in Sui with these exceptions:\n\nGlobal storage operators\nKey abilities\nKey differences​\n\nKey differences with Move on Sui include:\n\nSui uses its own object-centric global storage\nAddresses represent Object IDs\nSui objects have globally unique IDs\nSui has module initializers (init)\nSui entry points take object references as input\nObject-centric global storage​\n\nIn Move on Diem, global storage is part of the programming model. Resources and modules are held in global storage, owned by an account which has an address. Transactions are free to access resources from any account in global storage when they run, using special operations such as move_to and move_from.\n\nThis approach introduces a scaling issue, as it is not possible to statically determine which transactions are contending over the same resource and which are not. This is similar to the scaling issues faced by other blockchains where smart contracts typically store account information in large, internal mappings, which limit throughput.\n\nMove on Sui addresses the scaling issue by not having global storage, or its related operations. When objects (in contrast to resources) and packages (sets of modules) are stored on Sui, they are each given unique identifiers. All a transaction's inputs are explicitly specified up-front using these unique identifiers, to allow the chain to schedule transactions with non-overlapping inputs in parallel.\n\nAddresses represent Object IDs​\n\nIn Move on Diem, there is a 16-byte address type used to represent account addresses in global storage. A 16 byte address is sufficient for the Move on Diem security model.\n\nSui doesn't have global storage, so address is re-purposed as a 32-byte identifier used for both objects and accounts. Each transaction is signed by an account (the \"sender\") that is accessible from the transaction context, and each object stores its address wrapped in its id: UID field. (Refer to object.move in the Sui framework for details).\n\nObject with key ability, globally unique IDs​\n\nIn Move on Diem, the key ability indicates that the type is a resource, meaning it (along with an account address) can be used as a key in global storage.\n\nOn Sui, the key ability indicates that a struct is an object type and comes with an additional requirement that the first field of the struct has signature id: UID, to contain the object's unique address on-chain. Sui's bytecode verifier ensures that new objects are always assigned fresh UIDs (identifiers are never re-used).\n\nModule initializers​\n\nAs described in Object-centric global storage, you publish Move modules into Sui storage. The Sui runtime executes a special initializer function you optionally define in a module only once at the time of module publication to pre-initialize module-specific data (for example, creating singleton objects).\n\nEntry points take object references as input​\n\nYou can call public functions from Sui transactions (called programmable transaction blocks). These functions can take objects by value, by immutable reference, or by mutable reference. If taken by value, you can destroy the object, wrap it (in another object), or transfer it (to a Sui ID specified by an address). If taken by mutable reference, the modified version of the object saves to storage without any change in ownership. In any case, the Sui network authenticates the object and declares it's usage as a part of the transaction.\n\nIn addition to calling public functions, you can call a function that is marked entry even if it is private as long as other non-entry functions have not used its inputs.\n\nExplore concepts​\n\nSome of the features of Move are defined in this section using commented code examples.\n\nInit​\n\nThe init function is a special function that executes only once - when you publish the associated module. See Init for details.\n\nEntry functions​\n\nThe entry modifier for functions enables safe and direct invocation of module functions, much like scripts. See Entry for details.\n\nStrings​\n\nMove does not have a native type for strings, but it has a useful wrapper. See Strings for examples.\n\nOne-time witness​\n\nA one-time witness (OTW) is a special instance of a type created in the module initializer and guaranteed to be unique with only one instance. See One-Time Witness for an example.\n\nEdit this page\nPrevious\nObject and Package Versioning\nNext\nStrings\nMove on Sui\nKey differences\nObject-centric global storage\nAddresses represent Object IDs\nObject with key ability, globally unique IDs\nModule initializers\nEntry points take object references as input\nExplore concepts\nInit\nEntry functions\nStrings\nOne-time witness\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides/developer/getting-started",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nDeveloper GuidesGetting Started\nGetting Started\n\nSui is the first internet-scale programmable blockchain platform. That might read like marketing speak, but as you peruse the documentation to understand the technology, you will discover that Sui addresses many of the problems that hold blockchains back from mass adoption.\n\nBefore you can get started developing on Sui, you need to understand the code repository and install its binaries.\n\nInstall Sui​\n\nUse one of the following commands for Homebrew (MacOS, Linux, or Windows Subsystem for Linux) or Chocolatey (Windows) to install Sui.\n\nHomebrew\nChocolatey\nbrew install sui\n\n\nYou can also install Sui from binaries or from source, as detailed in the Install Sui page.\n\nGo to Install Sui.\n\nAfter installing Sui​\n\nAfter you have Sui installed on your system, you can begin to connect with a network and publish smart contracts.\n\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Coins\nGraphQL queries​\n\nUse the GraphQL service for Sui RPC to interact with on-chain data.\n\nGo to Query Sui RPC with GraphQL.\n\nMove IDEs and plugins​\n\nThe following table lists proven choices for IDEs with Move extensions. These IDEs and plugins are not required, but they provide a better experience for developing on Sui.\n\nIDE\tMove plugin\tDescription\nVisual Studio Code\t• Move extension\n• Move syntax\tThe recommended free IDE for Move development from Microsoft.\nIntelliJ IDEA\tMove Language Plugin\tA commercial IDE from JetBrains.\nEmacs\tmove-mode\tA free and open source text editor.\nGithub Codespaces\tMove Syntax\tA web-based IDE from GitHub.\nINFO\n\nSome plugins might not yet provide highlighting support for Move 2024.\n\nRelated links​\n\nAfter installing Sui and setting up your development environment, use the information in the following sections to continue your development journey.\n\nApp Examples: A mix of end-to-end examples that you can draw inspiration from in your own projects.\nSui 101: Topics that you should know when just starting out to develop on Sui.\nAdvanced Topics: Topics that you might not find beneficial until you start solving more complex problems.\nCryptography: Leverage cryptography functions to provide security for your smart contract actions.\nEdit this page\nPrevious\nDeveloper Guides\nNext\nInstall Sui\nInstall Sui\nAfter installing Sui\nGraphQL queries\nMove IDEs and plugins\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/cryptography",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nTransaction Authentication\nzkLogin\nCheckpoint Verification\nSui Architecture\nTokenomics\nResearch Papers\nCryptography\nCryptography\n\nCryptographic agility is core to Sui. The system supports multiple cryptography algorithms and primitives and can switch between them rapidly. With Sui, you can choose the right cryptography solution for your system and implement the latest algorithms as they become available.\n\nSui defines its cryptography primitives, such as public key, signature, aggregated signature, and hash functions, under one unified type alias or enum wrapper that is shared across the entire repository. Making changes to these primitives affects all of an application's components. You can quickly update application cryptography and be assured of uniform security.\n\nTransaction Authentication​\n\nTransaction authentication features on Sui provide security against unauthorized access to on-chain data. Transaction Authentication provides an overview of related topics.\n\nGo to Transaction Authentication.\n\nzkLogin​\n\nzkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential, without publicly linking the two. zkLogin provides a description of the primitive and how to implement it.\n\nGo to zkLogin.\n\nRelated links​\nCryptography guides: See the cryptography guides for instruction on applying these concepts.\nEdit this page\nPrevious\nGas Smashing\nNext\nTransaction Authentication\nTransaction Authentication\nzkLogin\nRelated links\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts/tokenomics",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nProof of Stake\nValidators and Staking Pools\nStaking and Unstaking\nSUI Coin\nSUI Bridging\nStorage Fund\nSui Gas Pricing\nGas in Sui\nResearch Papers\nTokenomics\nSui Tokenomics\n\nThe collective ideation that the term tokenomics encompasses includes a wide range of concepts that define the science and behavior of blockchain economies. In basic terms, tokenomics are the financial foundation of blockchains. Much the same way a building with a poor foundation is doomed to fail, a blockchain without a well-researched, extensively planned, and painstakingly implemented token economy eventually crumbles.\n\nSui tokenomics are based on sound financial concepts informed by extensive blockchain research. Designed for scale, the Sui tokenomic structure is designed to support the financial needs of web3 now and into the future.\n\nThe Sui economy​\n\nThree main types of participants characterize the Sui economy:\n\nUsers submit transactions to the Sui platform to create, mutate, and transfer digital assets or interact with more sophisticated applications enabled by smart contracts, interoperability, and composability.\nSUI token holders have the option of staking their tokens to validators and participating in the proof-of-stake mechanism. SUI owners also hold the rights to participate in Sui governance.\nValidators manage transaction processing and execution on the Sui platform.\nCore components​\n\nThe Sui economy is composed of five core components:\n\nSUI: The SUI token is the Sui platform native asset.\nGas fees: Gas fees are charged on all network operations and used to reward participants of the proof-of-stake mechanism and prevent spam and denial-of-service attacks.\nStorage fund: The Sui storage fund is used to shift stake rewards across time and compensate future validators for storage costs of previously stored on-chain data.\nProof-of-stake: The delegated proof-of-stake mechanism is used to select, incentivize, and reward honest behavior by Sui Validators and the SUI owners that stake with them.\nVoting: On-chain voting is used for governance and protocol upgrades.\nTokenomics visualized​\n\nThe following flowchart presents the tokenomic flow of Sui at a high level. Referring back to this chart after you learn concepts in this section should provide additional clarity.\n\nTokenomics whitepaper​\n\nBeyond the topics in this section of the documentation, you can read The Sui Smart Contracts Platform: Economics and Incentives whitepaper to learn more about tokenomic design on Sui.\n\nEdit this page\nPrevious\nProtocol Upgrades\nNext\nProof of Stake\nThe Sui economy\nCore components\nTokenomics visualized\nTokenomics whitepaper\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "References Overview | Sui Documentation",
      "url": "https://docs.sui.io/references",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui RPC\nGraphQL\nJSON-RPC\nRPC Best Practices\nSui CLI\nSui Client CLI\nSui Client PTB CLI\nSui Console CLI\nSui Keytool CLI\nSui Move CLI\nSui Validator CLI\nSui SDKs\ndApp Kit\nRust SDK\nTypeScript SDK\nMove\nFramework\nThe Move Book\nThe Move Reference\nGlossary\nContribute\nOverview\nReferences Overview\n\nAlready familiar with Sui? Use these valuable resources to continue your development journey.\n\nSui RPC​\n\nReference the Sui framework and Sui RPC documentation for details of the code that powers the Sui blockchain.\n\nGraphQL for Sui RPC\nGraphQL is a public service for the Sui RPC that enables you to efficiently interact with the Sui network.\nJSON-RPC\n\nUse GraphQL for the Sui RPC for new projects. Use the JSON-RPC reference for legacy projects that have not migrated to GraphQL yet.\n\nMove​\n\nMove powers smart contract logic for the Sui blockchain. Use these resources to learn Move or refresh your memory.\n\nSui framework\nThe Sui framework libraries include Move modules that provide the logic for Sui and its standards. A Rust process creates the documentation for the modules directly from comments in the code.\nThe Move Book\n\nThe Move Book is a comprehensive guide to the Move programming language on the Sui blockchain.\n\nThe Move Reference\n\nThe Move Reference documents the architecture and syntax of the Move programming language.\n\nSui CLI​\n\nInteract directly with Sui networks and its features using the Sui command line interface (CLI). The CLI is divided into separate base commands that target a specific set of features.\n\nSui Client CLI\n\nCreate a client on a Sui network to generate addresses, access networks, and more with the Sui Client CLI.\n\nSui Client PTB CLI\n\nBuild, preview, and execute programmable transaction blocks directly from your terminal with the Sui Client PTB CLI.\n\nSui Move CLI\n\nAccess Sui Move functions on chain using the Sui Move CLI.\n\nSui software development kits​\n\nOfficial software development kits (SDKs) available for Sui include the TypeScript SDK and Rust SDK.\n\nSui TypeScript SDK\n\nThe Sui TypeScript SDK has its own microsite. Click this box to go there.\n\nSui Rust SDK\nThe Sui Rust SDK provides Rust wrappers around the Sui API. Using the SDK, you can interact with Sui networks using the Rust programming language.\nEdit this page\nNext\nSui RPC\nSui RPC\nMove\nSui CLI\nSui software development kits\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Standards Overview | Sui Documentation",
      "url": "https://docs.sui.io/standards",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nCoin\nClosed-Loop Token\nSui Kiosk\nKiosk Apps\nDeepBook\nSui Object Display\nWallet Standard\nOverview\nSui Standards Overview\n\nStandards on the Sui blockchain are features, frameworks, or apps that you can extend or customize.\n\nClosed Loop Token\nUsing the Closed-Loop Token standard, you can limit the applications that can use the token and set up custom policies for transfers, spends, and conversions. The `sui::token` module in the Sui framework defines the standard.\nCoin\nThe Sui Coin standard enables you to create a broad range of fungible tokens on the Sui network to satisfy a number of use cases. The Coin standed on Sui is equivalent to the ERC-20 technical standard on Ethereum.\nDeepbook\nA central limit order book that offers features and functionality for marketplaces on Sui. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy.\nKiosk\nKiosk is a decentralized system for commerce applications on Sui. Kiosk is a part of the Sui framework, native to the system, and available to everyone.\nKiosk Apps\nKiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.\nSui Object Display\nThe Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type.\nWallet Standard\nThe Wallet Standard defines how wallets can automatically be discovered and interacted with from dApps.\nEdit this page\nNext\nCoin\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/concepts",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nSui Components\nApp Developers\nCryptography\nSui Architecture\nTokenomics\nResearch Papers\nOverview\nSui Concepts Overview\n\nSui is different than other blockchains. The concepts explored in this section provide a background to the Sui blockchain and web3 in general.\n\nMove​\nMove overview\nMove is an open source language for writing safe packages to manipulate on-chain objects\nPackage upgrades\nSui provides a method of upgrading your packages while still retaining their immutable properties.\nObjects​\nObject Model\nEverything on the Sui blockchain is an object, with metadata, type of ownership, and a referencing scheme.\nDynamic Fields\nDynamic fields and dynamic object fields on Sui are added and removed dynamically, affect gas only when accessed, and store heterogeneous values.\nTransfer to Object\nOn Sui, you can transfer objects to objects in the same way you can transfer objects to addresses.\nCryptography​\nzkLogin\nzkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.\nTransaction authentication\nTransaction security is arguably the most important feature of a blockchain. Sui provides multiple features to secure your transactions, whether on chain or off.\nTokenomics​\nSUI token\nThe native asset on Sui is called SUI. The coin uses the capitalized version of SUI to distinguish the coin from the Sui network.\nGas in Sui\nA Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates.\nStorage fund\nSui includes an efficient and sustainable economic mechanism for financing data storage, which is important given the ability of Sui to store arbitrarily large amounts of on-chain data.\nEdit this page\nNext\nSui Components\nMove\nObjects\nCryptography\nTokenomics\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/guides",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nOverview\nDeveloper Guides\nGetting Started\nInstall Sui\nConnect to a Sui Network\nConnect to a Local Network\nGet Sui Address\nGet SUI Tokens\nQuerying Sui RPC with GraphQL\nYour First Sui dApp\nSui 101\nCryptography\nAdvanced Topics\nApp Examples\nDev Cheat Sheet\nOperator Guides\nOverview\nGuides Overview\n\nOften, the best way to learn a new technology is through experience. The content in this section contains concrete examples to guide your development on the Sui network. Whether you're a web3 novice or a seasoned Sui pro, the guides in this section help you get the most out of your Sui development experience.\n\nGuides by role​\n\nInstructions for common tasks, based on your role in the Sui ecosystem.\n\nDeveloper guides\n\nGuides for developers of all levels.\n\nOperator guides\n\nGuides for validators and node operators.\n\nGet started developing on Sui​\n\nYou must crawl before you can run. Start your Sui journey here.\n\nInstall Sui\n\nInstall Sui on your Windows, MacOS, or Linux system.\n\nYour first Sui dApp\n\nWith Sui installed, you're ready to start developing.\n\nSui 101 for developers​\n\nLearn the basics of Sui and how they might differ from other blockchains.\n\nTransactions on Sui\n\nTransactions on Sui are more powerful than other blockchains. Learn why and how to use them.\n\nAccess time on chain\nAccess network-based time for your transactions. Sui provides a Clock module to capture near-real time or epoch time in your Sui packages.\nUsing events\n\nMonitor the Sui network and programmatically react to on-chain events.\n\nValidating and operating nodes on Sui​\n\nProcesses and guides for validators and node operators on the Sui network.\n\nValidator configuration\nLearn how to set up, configure, and manage a Sui Validator node, including staking, reference gas price, and tallying rules.\nRun a Sui Full node\n\nLearn how to operate a Full node on Sui.\n\nFull node data management\n\nOptimize your Full node configuration for efficient node operation.\n\nEdit this page\nNext\nDeveloper Guides\nGuides by role\nGet started developing on Sui\nSui 101 for developers\nValidating and operating nodes on Sui\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    },
    {
      "title": "Sui Documentation",
      "url": "https://docs.sui.io/",
      "html": "Skip to main content\nGuides\nConcepts\nStandards\nReferences\nSearch\nGet started\nSui Documentation\nDiscover the power of Sui through examples, guides, and concepts\nAbout Sui\nTokenomics\nCryptography\nStandards\nDevelopers\nGetting started\nSui Developer Basics\nMove\nValidators and Node operators\nValidator configuration\nRun a Sui Full node\nReferences\nSui dApp Kit\nSui API\nSui framework (GitHub)\nRust SDK (GitHub)\nResources\nSui ecosystem directory\nSui blog\nSui dev cheat sheet\nBuild your dApp on Sui\nWhy Sui?\nSui is the first internet-scale programmable blockchain platform\nUnmatched scalability, instant settlement\nA safe smart contract language accessible to mainstream developers\nAbility to define rich and composable on-chain assets\nBetter user experience for web3 apps\nScalability\n\nSui scales horizontally to meet the demands of applications. Network capacity grows in proportion to the increase in Sui validators' processing power by adding workers, resulting in low gas fees even during high network traffic. This scalability characteristic is in sharp contrast to other blockchains with rigid bottlenecks.\n\nMove\n\nMove design prevents issues such as reentrancy vulnerabilities, poison tokens, and spoofed token approvals that attackers have leveraged to steal millions on other platforms. The emphasis on safety and expressivity provides a more straightforward transition from web 2.0 to web3 for developers, without the need to understand the intricacies of the underlying infrastructure.\n\nOn-chain assets\n\nRich on-chain assets enable new applications and economies based on utility without relying solely on artificial scarcity. Developers can implement dynamic NFTs that you can upgrade, bundle, and group in an application-specific manner, such as changes in avatars and customizable items based on gameplay. This capability delivers stronger in-game economies as NFT behavior gets fully reflected on-chain, making NFTs more valuable and delivering more engaging feedback loops.\n\nBuilt for Web3\n\nSui aims to be the most accessible smart contract platform, empowering developers to create great user experiences in web3. To usher in the next billion users, Sui empowers developers with various tools to take advantage of the power of the Sui blockchain. The Sui Development Kit (SDK) will enable developers to build without boundaries.\n\n© 2024 SUI FOUNDATION | DOCUMENTATION DISTRIBUTED UNDER CC BY 4.0"
    }
  ]