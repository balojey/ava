[
    {
      "title": "Page not found - Move by Example",
      "url": "https://examples.sui.io/samples//basics/one-time-witness.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nDocument not found (404)\n\nThis URL is invalid, sorry. Please use the navigation bar or search to continue."
    },
    {
      "title": "Page not found - Move by Example",
      "url": "https://examples.sui.io/basics//samples/coin.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nDocument not found (404)\n\nThis URL is invalid, sorry. Please use the navigation bar or search to continue."
    },
    {
      "title": "Move by Example",
      "url": "https://examples.sui.io/print.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nMove by Example\n\nThis book is being deprecated in favor of the Move Book, which is a more comprehensive and up-to-date resource for learning Move. The Move Book not only features a more in-depth explanation of Move's concepts, but also includes a more extensive set of examples and exercises. We recommend that you use the Move Book as your primary resource for learning Move.\n\nWelcome to the companion book to docs.sui.io. There we describe the Move on Sui and explain how to use it to write smart contracts.\n\nInstead, this site builds upon the application examples already highlighted with component-by-component examples you may reference at any time. What is more expressive in the world of code than the code itself? In this book, you'll find examples for most of the features of Sui Move as well as a number of advanced patterns that can be used right away to improve your modules.\n\nAll code samples in this book are written with the assumption that you use Move on Sui, which can installed with this command:\n\n$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch \"main\" sui\n\n\nKeep in mind that the branch is set to main. If you're developing with our devnet, instead follow the instructions to install Sui.\n\nBasics\n\nThis section covers the main features of Sui Move. Use the left navigation menu to access the section's sub-pages.\n\nMove.toml\n\nEvery Move package has a package manifest in the form of a Move.toml file - it is placed in the root of the package. The manifest itself contains a number of sections, primary of which are:\n\n[package] - includes package metadata such as name and author\n[dependencies] - specifies dependencies of the project\n[addresses] - address aliases (eg @examples will be treated as a 0x0 address)\n[package]\nname = \"examples\"\nedition = \"2024.beta\" \n# license = \"\"           # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\n# authors = [\"...\"]      # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/mainnet\" }\n\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision can be a branch, a tag, and a commit hash.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n\n# To resolve a version conflict and force a specific version for dependency\n# override use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n\n[addresses]\nexamples = \"0x0\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies]\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n\n[dev-addresses]\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n# alice = \"0xB0B\"\n\nStdlib and Sui Framework\n\nThe Sui dependency adds two addresses to the package:\n\nstd = 0x1 - address of the standard library\nsui = 0x2 - address of the Sui Framework\nLearn more\nMove.toml (Docs)\nInit Function\n\nInit is a special function which gets called when a module is published. It is guaranteed that it will never be called again. It can take the &mut TxContext as the last argument and a One-Time-Witness (optional) as the first argument.\n\nfun init(ctx: &mut TxContext) { /* ... */ }\n\n\nFor example:\n\nmodule examples::init_function {\n    /// The one of a kind - created in the module initializer.\n    public struct CreatorCap has key {\n        id: UID\n    }\n\n    /// This function is only called once on module publish.\n    /// Use it to make sure something has happened only once, like\n    /// here - only module author will own a version of a\n    /// `CreatorCap` struct.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(CreatorCap {\n            id: object::new(ctx),\n        }, ctx.sender())\n    }\n}\n\nLearn more\nModule Initializers (Docs)\nModule initializer in Publish a Package (Docs)\nEntry Function\n\nAn entry function visibility modifier restricts calling a function from another package but allows direct calls in a transaction block. Entry functions can't return a value that doesn't have drop ability.\n\nmodule examples::object {\n    /// An object is a struct with `key` ability and `id: UID` field.\n    public struct Object has key {\n        id: UID\n    }\n\n    /// If function is defined as public - any module can call it.\n    /// Non-entry functions are also allowed to have return values.\n    public fun create(ctx: &mut TxContext): Object {\n        Object { id: object::new(ctx) }\n    }\n\n    /// Entrypoints can't have return values as they can only be called\n    /// directly in a transaction and the returned value can't be used.\n    /// However, `entry` without `public` disallows calling this method from\n    /// other Move modules.\n    entry fun create_and_transfer(to: address, ctx: &mut TxContext) {\n        transfer::transfer(create(ctx), to)\n    }\n}\n\n\nEntry functions can be public, and that would make them callable from other modules. However, the return value restrictions still apply.\n\nLearn more\nEntry Functions (Docs)\nStrings\n\nMove does not have a native type for strings, but it has a handy wrapper! Sui supports String type as a transaction argument (encoded as vector<u8> on the client).\n\nmodule examples::strings {\n    use std::string::String;\n\n    /// A dummy Object that holds a String type\n    public struct Name has key, store {\n        id: UID,\n        /// Here it is - the String type\n        name: String\n    }\n\n    /// Create a name Object by passing raw bytes\n    public fun mint_name(name: String, ctx: &mut TxContext): Name {\n        Name { id: object::new(ctx), name }\n    }\n}\n\nString operations\n\nTo create a string from a vector of bytes, use string::utf8:\n\nmodule examples::string_operations {\n    use std::string::String;\n\n    /// Constants can't be Strings; and they're not public.\n    const HELLO_WORLD: vector<u8> = b\"Hello, World!\";\n\n    /// But a function can pack a string and make it accessible.\n    /// Note: `string::utf8` fails if the string is not valid UTF-8.\n    public fun hello_world(): String {\n        HELLO_WORLD.to_string()\n    }\n\n    /// Checks if it's a valid UTF-8 String and returns an option\n    public fun new_string_safe(bytes: vector<u8>): Option<String> {\n        bytes.try_to_string()\n    }\n}\n\nShared Object\n\nShared object is an object that is shared using a sui::transfer::share_object function and is accessible to everyone both mutably and immutably.\n\nWhen sharing an object defined in this module, use transfer::share_object; for types defined in other modules, use transfer::public_share_object. Inside a transaction block, only the latter is allowed.\n\n/// Unlike `Owned` objects, `Shared` ones can be accessed by anyone on the\n/// network. Extended functionality and accessibility of this kind of objects\n/// requires additional effort by securing access if needed.\nmodule examples::donuts {\n    use sui::sui::SUI;\n    use sui::coin::Coin;\n    use sui::balance::{Self, Balance};\n\n    /// For when Coin balance is too low.\n    const ENotEnough: u64 = 0;\n\n    /// Capability that grants an owner the right to collect profits.\n    public struct ShopOwnerCap has key { id: UID }\n\n    /// A purchasable Donut. For simplicity's sake we ignore implementation.\n    public struct Donut has key { id: UID }\n\n    /// A shared object. `key` ability is required.\n    public struct DonutShop has key {\n        id: UID,\n        price: u64,\n        balance: Balance<SUI>\n    }\n\n    /// Init function is often ideal place for initializing\n    /// a shared object as it is called only once.\n    ///\n    /// To share an object `transfer::share_object` is used.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        // Share the object to make it accessible to everyone!\n        transfer::share_object(DonutShop {\n            id: object::new(ctx),\n            price: 1000,\n            balance: balance::zero()\n        })\n    }\n\n    /// Entry function available to everyone who owns a Coin.\n    public fun buy_donut(\n        shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext\n    ) {\n        assert!(payment.value() >= shop.price, ENotEnough);\n\n        // Take amount = `shop.price` from Coin<SUI>\n        let paid = payment.balance_mut().split(shop.price);\n\n        // Put the coin to the Shop's balance\n        shop.balance.join(paid);\n\n        transfer::transfer(Donut {\n            id: object::new(ctx)\n        }, ctx.sender())\n    }\n\n    /// Consume donut and get nothing...\n    public fun eat_donut(d: Donut) {\n        let Donut { id } = d;\n        id.delete();\n    }\n\n    /// Take coin from `DonutShop` and transfer it to tx sender.\n    /// Requires authorization with `ShopOwnerCap`.\n    public fun collect_profits(\n        _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = shop.balance.value();\n        shop.balance.split(amount).into_coin(ctx)\n    }\n}\n\nTransfer\n\nTo make an object freely transferable, use a combination of key and store abilities.\n\n/// A freely transfererrable Wrapper for custom data.\nmodule examples::wrapper {\n    /// An object with `store` can be transferred in any\n    /// module without a custom transfer implementation.\n    public struct Wrapper<T: store> has key, store {\n        id: UID,\n        contents: T\n    }\n\n    /// View function to read contents of a `Container`.\n    public fun contents<T: store>(c: &Wrapper<T>): &T {\n        &c.contents\n    }\n\n    /// Anyone can create a new object\n    public fun create<T: store>(\n        contents: T, ctx: &mut TxContext\n    ): Wrapper<T> {\n        Wrapper {\n            contents,\n            id: object::new(ctx),\n        }\n    }\n\n    /// Destroy `Wrapper` and get T.\n    public fun destroy<T: store> (c: Wrapper<T>): T {\n        let Wrapper { id, contents } = c;\n        id.delete();\n        contents\n    }\n}\n\nmodule examples::profile {\n    use sui::url::{Self, Url};\n    use std::string::String;\n\n    // using Wrapper functionality\n    use examples::wrapper::{Self, Wrapper};\n\n    /// Profile information, not an object, can be wrapped\n    /// into a transferable container\n    public struct ProfileInfo has store {\n        name: String,\n        url: Url\n    }\n\n    /// Read `name` field from `ProfileInfo`.\n    public fun name(info: &ProfileInfo): &String {\n        &info.name\n    }\n\n    /// Read `url` field from `ProfileInfo`.\n    public fun url(info: &ProfileInfo): &Url {\n        &info.url\n    }\n\n    /// Creates new `ProfileInfo` and wraps into `Wrapper`.\n    /// Then transfers to sender.\n    public fun create_profile(\n        name: vector<u8>, url: vector<u8>, ctx: &mut TxContext\n    ): Wrapper<ProfileInfo> {\n        // create a new container and wrap ProfileInfo into it\n        // return the container to the caller\n        wrapper::create(ProfileInfo {\n            name: name.to_string(),\n            url: url::new_unsafe_from_bytes(url)\n        }, ctx)\n    }\n}\n\nCustom transfer\n\nIn Sui Move, objects defined with only key ability can not be transferred by default. To enable transfers, publisher has to create a custom transfer function. This function can include any arguments, for example a fee, that users have to pay to transfer.\n\nmodule examples::restricted_transfer {\n    use sui::balance::{Self, Balance};\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n\n    /// For when paid amount is not equal to the transfer price.\n    const EWrongAmount: u64 = 0;\n\n    /// A Capability that allows bearer to create new `TitleDeed`s.\n    public struct GovernmentCapability has key { id: UID }\n\n    /// An object that marks a property ownership. Can only be issued\n    /// by an authority.\n    public struct TitleDeed has key {\n        id: UID,\n        // ... some additional fields\n    }\n\n    /// A centralized registry that approves property ownership\n    /// transfers and collects fees.\n    public struct LandRegistry has key {\n        id: UID,\n        balance: Balance<SUI>,\n        fee: u64\n    }\n\n    /// Create a `LandRegistry` on module init.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(GovernmentCapability {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(LandRegistry {\n            id: object::new(ctx),\n            balance: balance::zero<SUI>(),\n            fee: 10000\n        })\n    }\n\n    /// Create `TitleDeed` and transfer it to the property owner.\n    /// Only owner of the `GovernmentCapability` can perform this action.\n    public fun issue_title_deed(\n        _: &GovernmentCapability,\n        `for`: address,\n        ctx: &mut TxContext\n    ) {\n        transfer::transfer(TitleDeed {\n            id: object::new(ctx)\n        }, `for`)\n    }\n\n    /// A custom transfer function. Required due to `TitleDeed` not having\n    /// a `store` ability. All transfers of `TitleDeed`s have to go through\n    /// this function and pay a fee to the `LandRegistry`.\n    public fun transfer_ownership(\n        registry: &mut LandRegistry,\n        paper: TitleDeed,\n        fee: Coin<SUI>,\n        to: address,\n    ) {\n        assert!(&fee.value() == registry.fee, EWrongAmount);\n\n        // add a payment to the LandRegistry balance\n        registry.balance.join(fee.into_balance());\n\n        // finally call the transfer function\n        transfer::transfer(paper, to)\n    }\n}\n\nLearn more\nCustom Transfer Rules (Docs)\nClock\n\nSui has built-in support for a clock. The clock is a special object that can be used to get the current time. It is a shared object, and can be accessed by anyone.\n\nClock has a reserved address 0x6. While being a shared object, it can't be accessed mutably, and a transaction attempting to do so will fail.\n\nmodule examples::clock {\n    // Import the `clock` module and the `Clock` type.\n    use sui::clock::Clock;\n\n    /// A dummy object that hold the time it was created.\n    /// What if we could sell a timestamp...?\n    public struct Timestamp has key, store {\n        id: UID,\n        timestamp: u64,\n    }\n\n    /// Creates a new `Timestamp` Object using the `Clock`.\n    public fun new(clock: &Clock, ctx: &mut TxContext): Timestamp {\n        // The `timestamp_ms` is the main function of the `Clock` module.\n        let timestamp = clock.timestamp_ms();\n\n        Timestamp { timestamp, id: object::new(ctx) }\n    }\n}\n\nLearn more\nAccess On-Chain Time (Docs)\nEvents\n\nEvents are the main way to track actions on chain.\n\n/// Extended example of a shared object. Now with addition of events!\nmodule examples::donuts_with_events {\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::balance::{Self, Balance};\n\n    // This is the only dependency you need for events.\n    use sui::event;\n\n    /// For when Coin balance is too low.\n    const ENotEnough: u64 = 0;\n\n    /// Capability that grants an owner the right to collect profits.\n    public struct ShopOwnerCap has key { id: UID }\n\n    /// A purchasable Donut. For simplicity's sake we ignore implementation.\n    public struct Donut has key { id: UID }\n\n    public struct DonutShop has key {\n        id: UID,\n        price: u64,\n        balance: Balance<SUI>\n    }\n\n    // ====== Events ======\n\n    /// For when someone has purchased a donut.\n    public struct DonutBought has copy, drop {\n        id: ID\n    }\n\n    /// For when DonutShop owner has collected profits.\n    public struct ProfitsCollected has copy, drop {\n        amount: u64\n    }\n\n    // ====== Functions ======\n\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(DonutShop {\n            id: object::new(ctx),\n            price: 1000,\n            balance: balance::zero()\n        })\n    }\n\n    /// Buy a donut.\n    public fun buy_donut(\n        shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext\n    ) {\n        assert!(coin::value(payment) >= shop.price, ENotEnough);\n\n        let paid = payment.balance_mut().split(shop.price);\n        let id = object::new(ctx);\n\n        shop.balance.join(paid);\n\n        // Emit the event using future object's ID.\n        event::emit(DonutBought { id: id.to_inner() });\n        transfer::transfer(Donut { id }, ctx.sender())\n    }\n\n    /// Consume donut and get nothing...\n    public fun eat_donut(d: Donut) {\n        let Donut { id } = d;\n        object::delete(id);\n    }\n\n    /// Take coin from `DonutShop` and transfer it to tx sender.\n    /// Requires authorization with `ShopOwnerCap`.\n    public fun collect_profits(\n        _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = shop.balance.value();\n\n        // simply create new type instance and emit it\n        event::emit(ProfitsCollected { amount });\n        shop.balance.split(amount).into_coin(ctx)\n    }\n}\n\nLearn more\nUsing Events (Docs)\nOne Time Witness\n\nOne Time Witness (OTW) is a special instance of a type which is created only in the module initializer and is guaranteed to be unique and have only one instance. It is important for cases where we need to make sure that a witness-authorized action was performed only once (for example - creating a new Coin). In Sui Move a type is considered an OTW if its definition has the following properties:\n\nNamed after the module but uppercased\nHas only drop ability\n\nTo check whether an instance is an OTW, sui::types::is_one_time_witness(witness) should be used.\n\nTo get an instance of this type, you need to add it as the first argument to the init() function: Sui runtime supplies both initializer arguments automatically.\n\nmodule examples::mycoin {\n\n    /// Name matches the module name\n    public struct MYCOIN has drop {}\n\n    /// The instance is received as the first argument\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        /* ... */\n    }\n}\n\n\nExample which illustrates how OTW could be used:\n\n/// This example illustrates how One Time Witness works.\n///\n/// One Time Witness (OTW) is an instance of a type which is guaranteed to\n/// be unique across the system. It has the following properties:\n///\n/// - created only in module initializer\n/// - named after the module (uppercased)\n/// - cannot be packed manually\n/// - has a `drop` ability\nmodule examples::one_time_witness_registry {\n    use std::string::String;\n\n    // This dependency allows us to check whether type\n    // is a one-time witness (OTW)\n    use sui::types;\n\n    /// For when someone tries to send a non OTW struct\n    const ENotOneTimeWitness: u64 = 0;\n\n    /// An object of this type will mark that there's a type,\n    /// and there can be only one record per type.\n    public struct UniqueTypeRecord<phantom T> has key {\n        id: UID,\n        name: String\n    }\n\n    /// Expose a public function to allow registering new types with\n    /// custom names. With a `is_one_time_witness` call we make sure\n    /// that for a single `T` this function can be called only once.\n    public fun add_record<T: drop>(\n        witness: T,\n        name: String,\n        ctx: &mut TxContext\n    ) {\n        // This call allows us to check whether type is an OTW;\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n\n        // Share the record for the world to see. :)\n        transfer::share_object(UniqueTypeRecord<T> {\n            id: object::new(ctx),\n            name\n        });\n    }\n}\n\n/// Example of spawning an OTW.\nmodule examples::my_otw {\n    use examples::one_time_witness_registry as registry;\n\n    /// Type is named after the module but uppercased\n    public struct MY_OTW has drop {}\n\n    /// To get it, use the first argument of the module initializer.\n    /// It is a full instance and not a reference type.\n    fun init(witness: MY_OTW, ctx: &mut TxContext) {\n        registry::add_record(\n            witness, // here it goes\n            b\"My awesome record\".to_string(),\n            ctx\n        )\n    }\n}\n\nPublisher\n\nPublisher Object serves as a way to represent the publisher authority. The object itself does not imply any specific use case and has only two main functions: package::from_module<T> and package::from_package<T> which allow checking whether a type T belongs to a module or a package for which the Publisher object was created.\n\nWe strongly advise to issue the Publisher object for most of the packages that define new Objects - it is required to set the \"Display\" as well as to allow the type to be traded in the \"Kiosk\" ecosystem.\n\nAlthough Publisher itself is a utility, it enables the \"proof of ownership\" functionality, for example, it is crucial for the Object Display.\n\nTo set up a Publisher, a One-Time-Witness (OTW) is required - this way we ensure the Publisher object is initialized only once for a specific module (but can be multiple for a package) as well as that the creation function is called in the publish transaction.\n\n/// A simple package that defines an OTW and claims a `Publisher`\n/// object for the sender.\nmodule examples::owner {\n    use sui::package;\n\n    /// OTW is a struct with only `drop` and is named\n    /// after the module - but uppercased. See \"One Time\n    /// Witness\" page for more details.\n    public struct OWNER has drop {}\n\n    /// Some other type to use in a dummy check\n    public struct ThisType {}\n\n    /// After the module is published, the sender will receive\n    /// a `Publisher` object. Which can be used to set Display\n    /// or manage the transfer policies in the `Kiosk` system.\n    fun init(otw: OWNER, ctx: &mut TxContext) {\n        package::claim_and_keep(otw, ctx)\n    }\n}\n\n/// A module that utilizes the `Publisher` object to give a token\n/// of appreciation and a `TypeOwnerCap` for the owned type.\nmodule examples::type_owner {\n    use sui::package::{Self, Publisher};\n\n    /// Trying to claim ownership of a type with a wrong `Publisher`.\n    const ENotOwner: u64 = 0;\n\n    /// A capability granted to those who want an \"objective\"\n    /// confirmation of their ownership :)\n    public struct TypeOwnerCap<phantom T> has key, store {\n        id: UID\n    }\n\n    /// Uses the `Publisher` object to check if the caller owns the type `T`.\n    public fun prove_ownership<T>(\n        publisher: &Publisher, ctx: &mut TxContext\n    ): TypeOwnerCap<T> {\n        assert!(package::from_package<T>(publisher), ENotOwner);\n        TypeOwnerCap<T> { id: object::new(ctx) }\n    }\n}\n\nObject Display\n\nA creator or a builder who owns a Publisher object can use the sui::display module to define display properties for their objects. To get a Publisher object check out the Publisher page.\n\nDisplay<T> is an object that specifies a set of named templates for the type T (for example, for a type 0x2::capy::Capy the display would be Display<0x2::capy::Capy>). All objects of the type T will be processed in the Sui Full Node RPC through the matching Display definition and will have processed result attached when an object is queried.\n\nDescription\n\nSui Object Display is a template engine which allows for on-chain display configuration for type to be handled off-chain by the ecosystem. It has the ability to use an object's data for substitution into a template string.\n\nThere's no limitation to what fields can be set, all object properties can be accessed via the {property} syntax and inserted as a part of the template string (see examples for the illustration).\n\nExample\n\nFor the following Hero module, the Display would vary based on the \"name\", \"id\" and \"image_url\" properties of the type \"Hero\". The template defined in the init function can be represented as:\n\n{\n    \"name\": \"{name}\",\n    \"link\": \"https://sui-heroes.io/hero/{id}\",\n    \"image_url\": \"ipfs://{img_url}\",\n    \"description\": \"A true Hero of the Sui ecosystem!\",\n    \"project_url\": \"https://sui-heroes.io\",\n    \"creator\": \"Unknown Sui Fan\"\n}\n\n/// Example of an unlimited \"Sui Hero\" collection - anyone is free to\n/// mint their Hero. Shows how to initialize the `Publisher` and how\n/// to use it to get the `Display<Hero>` object - a way to describe a\n/// type for the ecosystem.\nmodule examples::my_hero {\n    use std::string::String;\n\n    // The creator bundle: these two packages often go together.\n    use sui::package;\n    use sui::display;\n\n    /// The Hero - an outstanding collection of digital art.\n    public struct Hero has key, store {\n        id: UID,\n        name: String,\n        img_url: String,\n    }\n\n    /// One-Time-Witness for the module.\n    public struct MY_HERO has drop {}\n\n    /// In the module initializer we claim the `Publisher` object\n    /// to then create a `Display`. The `Display` is initialized with\n    /// a set of fields (but can be modified later) and published via\n    /// the `update_version` call.\n    ///\n    /// Keys and values are set in the initializer but could also be\n    /// set after publishing if a `Publisher` object was created.\n    fun init(otw: MY_HERO, ctx: &mut TxContext) {\n        let keys = vector[\n            b\"name\".to_string(),\n            b\"link\".to_string(),\n            b\"image_url\".to_string(),\n            b\"description\".to_string(),\n            b\"project_url\".to_string(),\n            b\"creator\".to_string(),\n        ];\n\n        let values = vector[\n            // For `name` we can use the `Hero.name` property\n            b\"{name}\".to_string(),\n            // For `link` we can build a URL using an `id` property\n            b\"https://sui-heroes.io/hero/{id}\".to_string(),\n            // For `image_url` we use an IPFS template + `img_url` property.\n            b\"ipfs://{img_url}\".to_string(),\n            // Description is static for all `Hero` objects.\n            b\"A true Hero of the Sui ecosystem!\".to_string(),\n            // Project URL is usually static\n            b\"https://sui-heroes.io\".to_string(),\n            // Creator field can be any\n            b\"Unknown Sui Fan\".to_string()\n        ];\n\n        // Claim the `Publisher` for the package!\n        let publisher = package::claim(otw, ctx);\n\n        // Get a new `Display` object for the `Hero` type.\n        let mut display = display::new_with_fields<Hero>(\n            &publisher, keys, values, ctx\n        );\n\n        // Commit first version of `Display` to apply changes.\n        display.update_version();\n\n        transfer::public_transfer(publisher, ctx.sender());\n        transfer::public_transfer(display, ctx.sender());\n    }\n\n    /// Anyone can mint their `Hero`!\n    public fun mint(name: String, img_url: String, ctx: &mut TxContext): Hero {\n        let id = object::new(ctx);\n        Hero { id, name, img_url }\n    }\n}\n\nMethods description\n\nDisplay is created via the display::new<T> call, which can be performed either in a custom function (or a module initializer) or as a part of a programmable transaction.\n\nmodule sui::display {\n    /// Get a new Display object for the `T`.\n    /// Publisher must be the publisher of the T, `from_package`\n    /// check is performed.\n    public fun new<T>(pub: &Publisher): Display<T> { /* ... */ }\n}\n\n\nOnce acquired, the Display can be modified:\n\nmodule sui::display {\n    /// Sets multiple fields at once\n    public fun add_multiple(\n        self: &mut Display,\n        keys: vector<String>,\n        values: vector<String\n    ) { /* ... */ }\n\n    /// Edit a single field\n    public fun edit(self: &mut Display, key: String, value: String) { /* ... */ }\n\n    /// Remove a key from Display\n    public fun remove(self: &mut Display, key: String ) { /* ... */ }\n}\n\n\nTo apply changes and set the Display for the T, one last call is required: update_version publishes version by emitting an event which Full Node listens to and uses to get a template for the type.\n\nmodule sui::display {\n    /// Update the version of Display and emit an event\n    public fun update_version(self: &mut Display) { /* ... */ }\n}\n\nLearn more\nSui Object Display (Docs)\nPatterns\n\nThis part covers the programming patterns that are widely used in Move; some of which can exist only in Move.\n\nViews and Accessors\n\nStruct fields are private to the module. To access them from outside the module, you must define an accessor function. The convention is to name the function after the field. It's up to the developer to decide which of the fields should be accessible from outside the module.\n\n/// This module implements a simple object that represents a user record. All\n/// of the fields of the record can be read by using the getter functions. The\n/// email and phone fields can be changed by using the mutable access functions.\nmodule examples::record {\n    use std::string::String;\n\n    /// A single record of a user. An Object!\n    public struct UserRecord has key, store {\n        id: UID,\n        name: String,\n        age: u8,\n        email: String,\n        phone: String,\n    }\n\n    /// Creates a new user record\n    public fun new(\n        name: String, age: u8, email: String, phone: String, ctx: &mut TxContext\n    ): UserRecord {\n        UserRecord {\n            id: object::new(ctx),\n            name, age, email, phone,\n        }\n    }\n\n    // === Mutable Accessors ===\n\n    /// Return a mutable reference to the user's email.\n    ///\n    /// Hint: the `_mut` suffix on the function name marks this function as\n    /// a mutable accessor.\n    public fun email_mut(self: &mut UserRecord): &mut String { &mut self.email }\n\n    /// Return a mutable reference to the user's phone\n    public fun phone_mut(self: &mut UserRecord): &mut String { &mut self.phone }\n\n    // === Views ===\n\n    /// Returns the user's name.\n    /// Hint: view functions match property names.\n    public fun name(self: &UserRecord): String { self.name }\n\n    /// Returns the user's age\n    public fun age(self: &UserRecord): u8 { self.age }\n\n    /// Returns the user's email\n    public fun email(self: &UserRecord): String { self.email }\n\n    /// Returns the user's phone\n    public fun phone(self: &UserRecord): String { self.phone }\n}\n\n\nThis pattern is used in almost every application of Move.\n\nCapability\n\nCapability is a pattern that allows authorizing actions with an object. One of the most common capabilities is TreasuryCap (defined in sui::coin).\n\nmodule examples::item {\n    use std::string::String;\n\n    /// Type that marks Capability to create new `Item`s.\n    public struct AdminCap has key { id: UID }\n\n    /// Custom NFT-like type.\n    public struct Item has key, store { id: UID, name: String }\n\n    /// Module initializer is called once on module publish.\n    /// Here we create only one instance of `AdminCap` and send it to the publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(AdminCap {\n            id: object::new(ctx)\n        }, ctx.sender())\n    }\n\n    /// The entry function can not be called if `AdminCap` is not passed as\n    /// the first argument. Hence only owner of the `AdminCap` can perform\n    /// this action.\n    public fun create_and_send(\n        _: &AdminCap, name: vector<u8>, to: address, ctx: &mut TxContext\n    ) {\n        transfer::transfer(Item {\n            id: object::new(ctx),\n            name: name.to_string()\n        }, to)\n    }\n}\n\nWitness\n\nWitness is a pattern that is used for confirming the ownership of a type. To do so, one passes a drop instance of a type. Coin relies on this implementation.\n\n/// Module that defines a generic type `Guardian<T>` which can only be\n/// instantiated with a witness.\nmodule examples::guardian {\n    /// Phantom parameter T can only be initialized in the `create_guardian`\n    /// function. But the types passed here must have `drop`.\n    public struct Guardian<phantom T: drop> has key, store {\n        id: UID\n    }\n\n    /// The first argument of this function is an actual instance of the\n    /// type T with `drop` ability. It is dropped as soon as received.\n    public fun create_guardian<T: drop>(\n        _witness: T, ctx: &mut TxContext\n    ): Guardian<T> {\n        Guardian { id: object::new(ctx) }\n    }\n}\n\n/// Custom module that makes use of the `guardian`.\nmodule examples::peace_guardian {\n    // Use the `guardian` as a dependency.\n    use examples::guardian;\n\n    /// This type is intended to be used only once.\n    public struct PEACE has drop {}\n\n    /// Module initializer is the best way to ensure that the\n    /// code is called only once. With `Witness` pattern it is\n    /// often the best practice.\n    fun init(ctx: &mut TxContext) {\n        transfer::public_transfer(\n            guardian::create_guardian(PEACE {}, ctx),\n            ctx.sender()\n        )\n    }\n}\n\n\nThis pattern is used in these examples:\n\nLiquidity pool\nRegulated coin\nTransferable Witness\n/// This pattern is based on a combination of two others: Capability and a Witness.\n/// Since Witness is something to be careful with, spawning it should be allowed\n/// only to authorized users (ideally only once). But some scenarios require\n/// type authorization by module X to be used in another module Y. Or, possibly,\n/// there's a case where authorization should be performed after some time.\n///\n/// For these rather rare scerarios, a storable witness is a perfect solution.\nmodule examples::transferable_witness {\n    /// Witness now has a `store` that allows us to store it inside a wrapper.\n    public struct WITNESS has store, drop {}\n\n    /// Carries the witness type. Can be used only once to get a Witness.\n    public struct WitnessCarrier has key { id: UID, witness: WITNESS }\n\n    /// Send a `WitnessCarrier` to the module publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            WitnessCarrier { id: object::new(ctx), witness: WITNESS {} },\n            ctx.sender()\n        )\n    }\n\n    /// Unwrap a carrier and get the inner WITNESS type.\n    public fun get_witness(carrier: WitnessCarrier): WITNESS {\n        let WitnessCarrier { id, witness } = carrier;\n        id.delete();\n        witness\n    }\n}\n\nHot Potato\n\nHot Potato is a name for a struct that has no abilities, hence it can only be packed and unpacked in its module. In this struct, you must call function B after function A in the case where function A returns a potato and function B consumes it.\n\nmodule examples::trade_in {\n    use sui::sui::SUI;\n    use sui::coin::Coin;\n\n    /// Price for the first phone model in series\n    const MODEL_ONE_PRICE: u64 = 10000;\n\n    /// Price for the second phone model\n    const MODEL_TWO_PRICE: u64 = 20000;\n\n    /// For when someone tries to purchase non-existing model\n    const EWrongModel: u64 = 1;\n\n    /// For when paid amount does not match the price\n    const EIncorrectAmount: u64 = 2;\n\n    /// A phone; can be purchased or traded in for a newer model\n    public struct Phone has key, store { id: UID, model: u8 }\n\n    /// Payable receipt. Has to be paid directly or paid with a trade-in option.\n    /// Cannot be stored, owned or dropped - has to be used to select one of the\n    /// options for payment: `trade_in` or `pay_full`.\n    public struct Receipt { price: u64 }\n\n    /// Get a phone, pay later.\n    /// Receipt has to be passed into one of the functions that accept it:\n    ///  in this case it's `pay_full` or `trade_in`.\n    public fun buy_phone(model: u8, ctx: &mut TxContext): (Phone, Receipt) {\n        assert!(model == 1 || model == 2, EWrongModel);\n\n        let price = if (model == 1) MODEL_ONE_PRICE else MODEL_TWO_PRICE;\n\n        (\n            Phone { id: object::new(ctx), model },\n            Receipt { price }\n        )\n    }\n\n    /// Pay the full price for the phone and consume the `Receipt`.\n    public fun pay_full(receipt: Receipt, payment: Coin<SUI>) {\n        let Receipt { price } = receipt;\n        assert!(payment.value() == price, EIncorrectAmount);\n\n        // for simplicity's sake transfer directly to @examples account\n        transfer::public_transfer(payment, @examples);\n    }\n\n    /// Give back an old phone and get 50% of its price as a discount for the new one.\n    public fun trade_in(receipt: Receipt, old_phone: Phone, payment: Coin<SUI>) {\n        let Receipt { price } = receipt;\n        let tradein_price = if (old_phone.model == 1) {\n            MODEL_ONE_PRICE\n        } else {\n            MODEL_TWO_PRICE\n        };\n        let to_pay = price - (tradein_price / 2);\n\n        assert!(payment.value() == to_pay, EIncorrectAmount);\n\n        transfer::public_transfer(old_phone, @examples);\n        transfer::public_transfer(payment, @examples);\n    }\n}\n\n\nThis pattern is used in these examples:\n\nFlash Loan\nID Pointer\n\nID Pointer is a technique that separates the main data (an object) and its accessors / capabilities by linking the latter to the original. There's a few different directions in which this pattern can be used:\n\nissuing transferable capabilities for shared objects (for example, a TransferCap that changes 'owner' field of a shared object)\nsplitting dynamic data and static (for example, an NFT and its Collection information)\navoiding unnecessary type linking (and witness requirement) in generic applications (LP token for a LiquidityPool)\n/// This example implements a simple `Lock` and `Key` mechanics\n/// on Sui where `Lock<T>` is a shared object that can contain any object,\n/// and `Key` is an owned object which is required to get access to the\n/// contents of the lock.\n///\n/// `Key` is linked to its `Lock` using an `ID` field. This check allows\n/// off-chain discovery of the target as well as splits the dynamic\n/// transferable capability and the 'static' contents. Another benefit of\n/// this approach is that the target asset is always discoverable while its\n/// `Key` can be wrapped into another object (eg a marketplace listing).\nmodule examples::lock_and_key {\n    /// Lock is empty, nothing to take.\n    const ELockIsEmpty: u64 = 0;\n\n    /// Key does not match the Lock.\n    const EKeyMismatch: u64 = 1;\n\n    /// Lock already contains something.\n    const ELockIsFull: u64 = 2;\n\n    /// Lock that stores any content inside it.\n    public struct Lock<T: store + key> has key {\n        id: UID,\n        locked: Option<T>\n    }\n\n    /// A key that is created with a Lock; is transferable\n    /// and contains all the needed information to open the Lock.\n    public struct Key<phantom T: store + key> has key, store {\n        id: UID,\n        lock_id: ID,\n    }\n\n    /// Returns an ID of a Lock for a given Key.\n    public fun key_for<T: store + key>(key: &Key<T>): ID {\n        key.lock_id\n    }\n\n    /// Lock some content inside a shared object. A Key is created and is\n    /// sent to the transaction sender. For example, we could turn the\n    /// lock into a treasure chest by locking some `Coin<SUI>` inside.\n    ///\n    /// Return the Key to the caller so they decide what to do with it.\n    public fun create<T: store + key>(obj: T, ctx: &mut TxContext): Key<T> {\n        let id = object::new(ctx);\n        let lock_id = id.to_inner();\n\n        transfer::share_object(Lock<T> {\n            id,\n            locked: option::some(obj),\n        });\n\n        Key<T> { id: object::new(ctx), lock_id }\n    }\n\n    /// Lock something inside a shared object using a Key. Aborts if\n    /// lock is not empty or if key doesn't match the lock.\n    public fun lock<T: store + key>(\n        obj: T,\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ) {\n        assert!(lock.locked.is_none(), ELockIsFull);\n        assert!(&key.lock_id == object::borrow_id(lock), EKeyMismatch);\n\n        lock.locked.fill(obj);\n    }\n\n    /// Unlock the Lock with a Key and access its contents.\n    /// Can only be called if both conditions are met:\n    /// - key matches the lock\n    /// - lock is not empty\n    public fun unlock<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ): T {\n        assert!(lock.locked.is_some(), ELockIsEmpty);\n        assert!(&key.lock_id == object::borrow_id(lock), EKeyMismatch);\n\n        lock.locked.extract()\n    }\n}\n\n\nThis pattern is used in these examples:\n\nLock\nEscrow\nHero\nTic Tac Toe\nAuction\nTesting\n\nTests are an important part of any software project. They are especially important in blockchain applications because smart contracts control digital assets. Move has a built-in testing framework that allows you to write tests for your modules.\n\nTo test a package, use the sui move test command. This command will run all the tests in the package, and print the results to the console.\n\n$ sui move test\n\nSimple Test\n\nTests are functions, marked with the #[test] attribute. They are not included into the compiled program, and are only used for testing purposes.\n\nmodule examples::simple_tests {\n\n    /// A point in 2D space. Has an `x` and `y` coordinate.\n    public struct Point has copy, drop {\n        x: u8,\n        y: u8,\n    }\n\n    /// Create a point.\n    public fun new(x: u8, y: u8): Point { Point { x, y } }\n\n    /// Move a point to a new location.\n    public fun move_xy(p: &mut Point, x: u8, y: u8) {\n        p.x = x;\n        p.y = y;\n    }\n\n    /// Get the x coordinate of a point.\n    public fun x(p: &Point): u8 { p.x }\n\n    /// Get the y coordinate of a point.\n    public fun y(p: &Point): u8 { p.y }\n\n    #[test]\n    // The function marked with `#[test]` is a test. The name of the function\n    // will be shown in the test output, so it should be descriptive.\n    //\n    // The function doesn't take any arguments, and doesn't return anything.\n    fun test_point_new_and_move() {\n        let mut p1 = new(1, 2);\n\n        // normally, a test should contain correctness assertions\n        assert!(x(&p1) == 1, 0);\n        assert!(y(&p1) == 2, 1);\n\n        move_xy(&mut p1, 3, 4);\n\n        // while not a requirement, abort codes should be unique,\n        // it's easier to debug when they are\n        assert!(x(&p1) == 3, 2);\n        assert!(y(&p1) == 4, 3);\n    }\n}\n\nTest Fail Cases\n\nTests should also cover the failure cases. Move provides a special attribute to mark tests that are expected to fail. The #[expected_failure] attribute can be used to mark a test that is expected to fail. It can be used with or without an abort code. If an abort code is provided, the test will fail if it does not abort with the provided code. If no abort code is provided, the test will fail if it does not abort.\n\nmodule examples::expected_failure {\n    /// Trying to take a value out of an empty container.\n    const EContainerEmpty: u64 = 0;\n    /// Trying to put a value into a full container.\n    const EContainerFull: u64 = 1;\n    /// Function is not implemented.\n    const ENotImplemented: u64 = 3;\n\n    /// A container that can hold a value of type T or nothing.\n    public struct Container<T> has copy, store, drop {\n        inner: Option<T>\n    }\n\n    /// Creates a new container with the given value.\n    public fun new<T>(inner: T): Container<T> {\n        Container { inner: option::some(inner) }\n    }\n\n    /// Creates a new empty container.\n    public fun empty<T>(): Container<T> {\n        Container { inner: option::none() }\n    }\n\n    /// Takes the value out of the container. Aborts if the container is empty.\n    public fun take<T>(container: &mut Container<T>): T {\n        assert!(container.inner.is_some(), EContainerEmpty);\n        container.inner.extract()\n    }\n\n    /// Put a value into the container. Aborts if the container is full.\n    public fun put<T>(container: &mut Container<T>, value: T) {\n        assert!(container.inner.is_none(), EContainerFull);\n        container.inner.fill(value);\n    }\n\n    #[test]\n    // An example of a regular test function. Not expected to fail.\n    fun create_empty() {\n        let container = empty<u64>();\n        assert!(container.inner.is_none(), 0);\n    }\n\n    #[test]\n    #[expected_failure]\n    // The \"expected_failure\" attribute can be added to a test function. And\n    // the test will pass if it the function fails with any abort code.\n    fun showcase_expected_failure_fail() {\n        abort ENotImplemented\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EContainerEmpty)]\n    // It is considered a good practice to specify the expected abort code. It\n    // is especially important when a function has multiple abort points.\n    //\n    // The abort code is a constant that is used to identify the expected\n    // code. It can be both a value and a name of a constant. It also allows\n    // importing constants from other modules!\n    fun try_take_from_empty_container_fail() {\n        let mut container = empty<u64>();\n        let _ = container.take();\n    }\n\n    #[test, expected_failure(abort_code = EContainerFull)]\n    // Attributes can be combined into a single attribute list, separated by\n    // commas. Purely a style choice.\n    fun try_put_into_full_container_fail() {\n        let mut container = new(42u64); // create a container with a value\n        container.put(42); // try to put another value into it\n    }\n}\n\nDummy Context\n\nThis example illustrates how to create a TxContext for object testing without using the Test Scenario framework.\n\n/// This module contains an example of a simple application with a simple set of\n/// rules: a letter can only be read once, and then it is burned.\n///\n/// The tests in this module demonstrate how to use the `tx_context` module to\n/// create a custom `TxContext` for testing purposes without using a heavier\n/// `test_scenario` module.\n///\n/// The UIDs of objects generated with dummy context will remain the same in\n/// every test, so the consistency of the tests is guaranteed. However, for a\n/// single test, there should be only one `tx_context::dummy()` call, otherwise\n/// it is possible to create objects with the same UID in the same test.\nmodule examples::burn_after_reading {\n    use std::string::String;\n\n    /// Attempt to burn before reading.\n    const ENotReadYet: u64 = 0;\n\n    /// A simple letter Object which can be read and then burned.\n    public struct Letter has key, store {\n        id: UID,\n        content: String,\n        is_read: bool,\n        sender: address,\n    }\n\n    /// Write a new letter, signed by the sender.\n    public fun new(content: String, ctx: &mut TxContext): Letter {\n        Letter {\n            id: object::new(ctx),\n            content,\n            is_read: false,\n            sender: ctx.sender()\n        }\n    }\n\n    /// Read the letter and get the contents.\n    public fun read(l: &mut Letter): String {\n        l.is_read = true;\n        l.content\n    }\n\n    /// Burn once read. Only sender address can be recovered from the ashes, the\n    /// letter is gone forever.\n    public fun burn(l: Letter): address {\n        let Letter { id, content: _, is_read, sender } = l;\n        assert!(is_read, ENotReadYet);\n        id.delete();\n        sender\n    }\n\n    #[test]\n    // This test uses the dummy context to create and read a letter. By using\n    // the `tx_context::dummy()` function, we can create a dummy context which\n    // has the `sender = 0x0` and `epoch = 0`. This allows us to create objects\n    // without using a more complex test scenario.\n    fun test_new_read_letter() {\n\n        // This is where the magic happens! Because context has `drop`, we can\n        // assign it directly as `&mut` reference and use in the test.\n        let ctx = &mut tx_context::dummy();\n        let mut letter = new(b\"Directed by Ethan and Joel Coen\".to_string(), ctx);\n\n        // burn after reading\n        read(&mut letter);\n        burn(letter);\n    }\n\n    #[test]\n    // It is also possible to create custom contexts for testing. Especially if\n    // there's a need to test the behavior of the contract based on the sender\n    // or the epoch.\n    //\n    // The `tx_context::new_from_hint` function can create a context with tx\n    // hash generated from a number. Alternatively, you can use `tx_context::new`\n    // and provide 32-byte hash manually.\n    fun test_fan_letter() {\n\n        // this is the best way to create a custom `TxContext`\n        let ctx = &mut tx_context::new_from_hint(\n            @0xC4AD,  // sender\n            0u64,     // hint, used to generate tx hash\n            1,        // epoch\n            0,        // epoch_timestamp_ms\n            0,        // `ids_created` (normally should be `0`)\n        );\n\n        let mut letter = new(b\"Uhhh... Osbourne?... Osbourne Cox?\".to_string(), ctx);\n\n        // read, burn, but keep the sender\n        read(&mut letter);\n        let sender = burn(letter);\n\n        // check the sender is correct\n        assert!(sender == @0xC4AD, 0);\n    }\n\n    #[test, expected_failure(abort_code = ENotReadYet)]\n    // This test makes sure the letter cannot be burned before reading. And\n    // expects the transaction to fail with `ENotReadYet` abort code.\n    //\n    // It uses the `tx_context::new` method with a custom tx hash.\n    fun test_burn_before_read() {\n        use sui::hash::blake2b256;\n\n        let tx_hash = blake2b256(&b\"some seed for hashing\");\n        let ctx = &mut tx_context::new(\n            @0x0,    // sender\n            tx_hash, // tx hash\n            0,       // epoch\n            0,       // epoch_timestamp_ms\n            0,       // `ids_created` (normally should be `0`)\n        );\n\n        let letter = new(b\"What did we learn, Palmer?\".to_string(), ctx);\n        burn(letter);\n    }\n}\n\nTest Scenario\n\nFor complicated transaction testing, Sui features the test_scenario module. This module provides functions to emulate transactions, define senders, and check the results of transactions.\n\n/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::balance::{Self, Balance};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    public struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    public struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    public struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin.value() > 0, ECantBeZero);\n        store.balance.join(coin.into_balance());\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = store.balance.value();\n        store.balance.split(amount).into_coin(ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let mut scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            init_for_testing(scenario.ctx());\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = scenario.next_tx(manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = prev_effects.created();\n        let shared_ids = prev_effects.shared();\n        let sent_ids = prev_effects.transferred_to_account();\n        let events_num = prev_effects.num_user_events();\n\n        assert!(created_ids.length() == 2, 0);\n        assert!(shared_ids.length() == 1, 1);\n        assert!(sent_ids.size() == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let mut store = scenario.take_shared<BlackBooks>();\n            let ctx = scenario.ctx();\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = store.purchase(coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        scenario.next_tx(fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = scenario.take_from_sender_by_id<LittleBookOfCalm>(book_id);\n            // send the book back to Manny\n            transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let mut store = scenario.take_shared<BlackBooks>();\n            let ctx = scenario.ctx();\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = store.purchase(coin, ctx);\n            transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let mut store = scenario.take_shared<BlackBooks>();\n            let cap = scenario.take_from_sender<StoreOwnerCap>();\n            let ctx = scenario.ctx();\n            let coin = store.collect(&cap, ctx);\n\n            transfer::public_transfer(coin, bernard);\n            transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        scenario.end();\n    }\n}\n\nTest Only\n\nThe #[test_only] attribute allows creating a module member that will only be available in the test environment. This is useful for creating initializers and other helper functions that are needed for testing but would be dangerous to expose in the production environment. The attribute can also be used to define test-only types, friends and dependencies.\n\nmodule examples::registry {\n    use std::type_name::{Self, TypeName};\n\n    /// Singleton object that can be created only once.\n    public struct TypeRegistry has key {\n        id: UID,\n        /// Simple counter to keep track of the number of records.\n        records: vector<TypeName>,\n    }\n\n    /// Create and share a new `Registry` object.\n    fun init(ctx: &mut TxContext) {\n        sui::transfer::share_object(TypeRegistry {\n            id: object::new(ctx),\n            records: vector[]\n        })\n    }\n\n    /// Add a new record to the `Registry` object with the type name of `T`.\n    public fun register_type<T>(r: &mut TypeRegistry) {\n        r.records.push_back(type_name::get<T>())\n    }\n\n    /// Getter for the `records` field.\n    public fun records(registry: &TypeRegistry): &vector<TypeName> {\n        &registry.records\n    }\n\n    // === Test and test-only members ===\n\n    #[test_only]\n    // The #[test_only] attribute makes the function only available in test mode.\n    // Meaning that it can be used in functions marked with #[test] and in other\n    // functions marked with #[test_only].\n    //\n    // We allow creating a TypeRegistry object for tests! Also, in tests it's often\n    // a good idea to allow for customizing the object's state.\n    public fun new_for_testing(ctx: &mut TxContext): TypeRegistry {\n        TypeRegistry {\n            id: object::new(ctx),\n            records: vector[]\n        }\n    }\n\n    #[test_only]\n    // It's also a good idea to mark test_only functions with suffixes like\n    // `_for_testing` to make it clear that they are only available in tests.\n    public fun reset_for_testing(reg: &mut TypeRegistry) {\n        reg.records = vector[];\n    }\n\n\n    // Test_only can be applied to any module member. Including structs!\n    #[test_only] public struct TestOnlyStruct {}\n\n    // Dependencies can be marked as \"test_only\".\n    // Some dependencies are only available in test mode such as `sui::test_utils`.\n    #[test_only] use sui::test_utils;\n\n    #[test]\n    // In tests we can use the `new_for_testing` function to create a new\n    // `Registry` object.\n    fun test_registry() {\n        let ctx = &mut tx_context::dummy();\n        let mut registry = new_for_testing(ctx);\n\n        assert!(registry.records().length() == 0, 0);\n\n        // we can use `TestOnlyStruct` because it's marked with `#[test_only]`\n        register_type<TestOnlyStruct>(&mut registry);\n\n        assert!(registry.records().length() == 1, 0);\n\n        // super helpful utility which is only available in tests!\n        test_utils::destroy(registry);\n    }\n}\n\n#[test_only]\n// #[test_only] can also be applied to modules. All of the module's members\n// will be test_only and don't need to be marked individually.\nmodule examples::registry_tests {\n    use sui::test_utils;\n    use examples::registry::{Self, TestOnlyStruct};\n\n    public struct AnotherTestOnlyStruct {}\n\n    #[test]\n    fun test_with_two_structs() {\n        let ctx = &mut tx_context::dummy();\n        let mut reg = registry::new_for_testing(ctx);\n\n        reg.register_type<TestOnlyStruct>();\n        reg.reset_for_testing();\n\n        assert!(reg.records().length() == 0, 0);\n\n        reg.register_type<AnotherTestOnlyStruct>();\n\n        assert!(reg.records().length() == 1, 0);\n\n        test_utils::destroy(reg);\n    }\n}\n\nSamples\n\nThis section contains a growing collection of ready-to-go samples for common blockchain use cases.\n\nNFT\n\nIn Sui, everything is an NFT - Objects are unique, non-fungible and owned. So technically, a simple type publishing is enough.\n\nmodule examples::puppy {\n    use std::string::String;\n    use sui::event;\n\n    /// An example NFT that can be minted by anybody. A Puppy is\n    /// a freely-transferable object. Owner can add new traits to\n    /// their puppy at any time and even change the image to the\n    /// puppy's liking.\n    public struct Puppy has key, store {\n        id: UID,\n        /// Name of the Puppy\n        name: String,\n        /// Grumpy or chill?\n        traits: vector<String>,\n        /// The URL of the Puppy's image\n        url: String,\n    }\n\n    /// Event: emitted when a new Puppy is minted.\n    public struct PuppyMinted has copy, drop {\n        /// ID of the Puppy\n        puppy_id: ID,\n        /// The address of the NFT minter\n        minted_by: address,\n    }\n\n    /// Mint a new Puppy with the given `name`, `traits` and `url`.\n    /// The object is returned to sender and they're free to transfer\n    /// it to themselves or anyone else.\n    public fun mint(\n        name: String,\n        traits: vector<String>,\n        url: String,\n        ctx: &mut TxContext\n    ): Puppy {\n        let id = object::new(ctx);\n\n        event::emit(PuppyMinted {\n            puppy_id: id.to_inner(),\n            minted_by: ctx.sender(),\n        });\n\n        Puppy { id, name, traits, url }\n    }\n\n    /// Some puppies get new traits over time... owner of one can\n    /// add a new trait to their puppy at any time.\n    public fun add_trait(puppy: &mut Puppy, trait: String) {\n        puppy.traits.push_back(trait);\n    }\n\n    /// As the puppy grows, owners can change the image to reflect\n    /// the puppy's current state and look.\n    public fun set_url(puppy: &mut Puppy, url: String) {\n        puppy.url = url;\n    }\n\n    /// It's a good practice to allow the owner to destroy the NFT\n    /// and get a storage rebate. Not a requirement and depends on\n    /// your use case. At last, who doesn't love puppies?\n    public fun destroy(puppy: Puppy) {\n        let Puppy { id, url: _, name: _, traits: _ } = puppy;\n        id.delete()\n    }\n\n    // Getters for properties.\n    // Struct fields are always private and unless there's a getter,\n    // other modules can't access them. It's up to the module author\n    // to decide which fields to expose and which to keep private.\n\n    /// Get the Puppy's `name`\n    public fun name(puppy: &Puppy): String { puppy.name }\n\n    /// Get the Puppy's `traits`\n    public fun traits(puppy: &Puppy): &vector<String> { &puppy.traits }\n\n    /// Get the Puppy's `url`\n    public fun url(puppy: &Puppy): String { puppy.url }\n}\n\nCreate a Coin\n\nPublishing a coin is Sui is almost as simple as publishing a new type. However it is a bit tricky as it requires using a One Time Witness.\n\nmodule examples::mycoin {\n    use sui::coin;\n\n    /// The type identifier of coin. The coin will have a type\n    /// tag of kind: `Coin<package_object::mycoin::MYCOIN>`\n    /// Make sure that the name of the type matches the module's name.\n    public struct MYCOIN has drop {}\n\n    /// Module initializer is called once on module publish. A treasury\n    /// cap is sent to the publisher, who then controls minting and burning\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,                // decimals\n            b\"MYC\",           // symbol\n            b\"My Coin\",       // name\n            b\"Don't ask why\", // description\n            option::none(),   // icon url\n            ctx\n        );\n\n        // transfer the `TreasuryCap` to the sender, so they can mint and burn\n        transfer::public_transfer(treasury, ctx.sender());\n\n        // metadata is typically frozen after creation\n        transfer::public_freeze_object(metadata);\n    }\n}\n\n\nThe Coin<T> is a generic implementation of a Coin on Sui. Owner of the TreasuryCap gets control over the minting and burning of coins. Further transactions can be sent directly to the sui::coin::Coin with TreasuryCap object as authorization.\n\nRegulated Coin\n\nSui provides a way to create a Coin with a global Denylist. This is useful for creating a regulated coin, where the issuer can restrict certain accounts from holding the coin. The denylist functionality is native to the network and maintains the fast path.\n\nmodule examples::reg_coin {\n    use sui::coin;\n\n    /// The type identifier of coin. The coin will have a type\n    /// tag of kind: `Coin<package_object::reg_coin::REG_COIN>`\n    /// Make sure that the name of the type matches the module's name.\n    public struct REG_COIN has drop {}\n\n    /// Module initializer is called once on module publish. A treasury\n    /// cap is sent to the publisher, who then controls minting and burning\n    fun init(witness: REG_COIN, ctx: &mut TxContext) {\n        // Unlike regular currency, regulated currency uses a different method.\n        let (treasury, denycap, metadata) = coin::create_regulated_currency(\n            witness,\n            6,                           // decimals\n            b\"REG\",                      // symbol\n            b\"My Coin\",                  // name\n            b\"Do good, and you're good\", // description\n            option::none(),              // icon url\n            ctx\n        );\n\n        // transfer the `TreasuryCap` to the sender, so they can mint and burn\n        transfer::public_transfer(treasury, ctx.sender());\n\n        // transfer the `DenyCap` to the sender, so they can freeze and\n        // unfreeze accounts from using the currency\n        transfer::public_transfer(denycap, ctx.sender());\n\n        // metadata is typically frozen after creation\n        transfer::public_freeze_object(metadata);\n    }\n\n    // === Entry Functions (can be replaced by direct calls in PTBs) ===\n\n    use sui::deny_list::DenyList;\n    use sui::coin::DenyCap;\n\n    /// Add an account to denylist preventing them from using the currency.\n    /// DenyList is a special shared object with reserved address `0x403`.\n    entry fun block_account(\n        deny_list: &mut DenyList,\n        deny_cap: &mut DenyCap<REG_COIN>,\n        account: address,\n        ctx: &mut TxContext\n    ) {\n        coin::deny_list_add(deny_list, deny_cap, account, ctx);\n    }\n\n    /// Remove an account from denylist allowing them to use the currency.\n    /// DenyList is a special shared object with reserved address `0x403`.\n    entry fun unblock_account(\n        deny_list: &mut DenyList,\n        deny_cap: &mut DenyCap<REG_COIN>,\n        account: address,\n        ctx: &mut TxContext\n    ) {\n        coin::deny_list_remove(deny_list, deny_cap, account, ctx);\n    }\n}\n\n\nCurrently, the Denylist is only supported for the Coin type. In the future, it may be extended to some other system types.\n\nAdditional Resources\n\nTo find out more about Sui Move and its usage, check out these links:\n\nSui Move examples in 'mystenLabs/sui' repo\nHow Move on Sui differs from Diem-style Move\nWhy we created Sui Move\nApplication Examples on Sui"
    },
    {
      "title": "Additional Resources - Move by Example",
      "url": "https://examples.sui.io/LINKS.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nAdditional Resources\n\nTo find out more about Sui Move and its usage, check out these links:\n\nSui Move examples in 'mystenLabs/sui' repo\nHow Move on Sui differs from Diem-style Move\nWhy we created Sui Move\nApplication Examples on Sui"
    },
    {
      "title": "Coin with Denylist - Move by Example",
      "url": "https://examples.sui.io/samples/regulated-coin.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nRegulated Coin\n\nSui provides a way to create a Coin with a global Denylist. This is useful for creating a regulated coin, where the issuer can restrict certain accounts from holding the coin. The denylist functionality is native to the network and maintains the fast path.\n\nmodule examples::reg_coin {\n    use sui::coin;\n\n    /// The type identifier of coin. The coin will have a type\n    /// tag of kind: `Coin<package_object::reg_coin::REG_COIN>`\n    /// Make sure that the name of the type matches the module's name.\n    public struct REG_COIN has drop {}\n\n    /// Module initializer is called once on module publish. A treasury\n    /// cap is sent to the publisher, who then controls minting and burning\n    fun init(witness: REG_COIN, ctx: &mut TxContext) {\n        // Unlike regular currency, regulated currency uses a different method.\n        let (treasury, denycap, metadata) = coin::create_regulated_currency(\n            witness,\n            6,                           // decimals\n            b\"REG\",                      // symbol\n            b\"My Coin\",                  // name\n            b\"Do good, and you're good\", // description\n            option::none(),              // icon url\n            ctx\n        );\n\n        // transfer the `TreasuryCap` to the sender, so they can mint and burn\n        transfer::public_transfer(treasury, ctx.sender());\n\n        // transfer the `DenyCap` to the sender, so they can freeze and\n        // unfreeze accounts from using the currency\n        transfer::public_transfer(denycap, ctx.sender());\n\n        // metadata is typically frozen after creation\n        transfer::public_freeze_object(metadata);\n    }\n\n    // === Entry Functions (can be replaced by direct calls in PTBs) ===\n\n    use sui::deny_list::DenyList;\n    use sui::coin::DenyCap;\n\n    /// Add an account to denylist preventing them from using the currency.\n    /// DenyList is a special shared object with reserved address `0x403`.\n    entry fun block_account(\n        deny_list: &mut DenyList,\n        deny_cap: &mut DenyCap<REG_COIN>,\n        account: address,\n        ctx: &mut TxContext\n    ) {\n        coin::deny_list_add(deny_list, deny_cap, account, ctx);\n    }\n\n    /// Remove an account from denylist allowing them to use the currency.\n    /// DenyList is a special shared object with reserved address `0x403`.\n    entry fun unblock_account(\n        deny_list: &mut DenyList,\n        deny_cap: &mut DenyCap<REG_COIN>,\n        account: address,\n        ctx: &mut TxContext\n    ) {\n        coin::deny_list_remove(deny_list, deny_cap, account, ctx);\n    }\n}\n\n\nCurrently, the Denylist is only supported for the Coin type. In the future, it may be extended to some other system types."
    },
    {
      "title": "Create a Coin (ERC20) - Move by Example",
      "url": "https://examples.sui.io/samples/coin.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nCreate a Coin\n\nPublishing a coin is Sui is almost as simple as publishing a new type. However it is a bit tricky as it requires using a One Time Witness.\n\nmodule examples::mycoin {\n    use sui::coin;\n\n    /// The type identifier of coin. The coin will have a type\n    /// tag of kind: `Coin<package_object::mycoin::MYCOIN>`\n    /// Make sure that the name of the type matches the module's name.\n    public struct MYCOIN has drop {}\n\n    /// Module initializer is called once on module publish. A treasury\n    /// cap is sent to the publisher, who then controls minting and burning\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,                // decimals\n            b\"MYC\",           // symbol\n            b\"My Coin\",       // name\n            b\"Don't ask why\", // description\n            option::none(),   // icon url\n            ctx\n        );\n\n        // transfer the `TreasuryCap` to the sender, so they can mint and burn\n        transfer::public_transfer(treasury, ctx.sender());\n\n        // metadata is typically frozen after creation\n        transfer::public_freeze_object(metadata);\n    }\n}\n\n\nThe Coin<T> is a generic implementation of a Coin on Sui. Owner of the TreasuryCap gets control over the minting and burning of coins. Further transactions can be sent directly to the sui::coin::Coin with TreasuryCap object as authorization."
    },
    {
      "title": "Make an NFT - Move by Example",
      "url": "https://examples.sui.io/samples/nft.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nNFT\n\nIn Sui, everything is an NFT - Objects are unique, non-fungible and owned. So technically, a simple type publishing is enough.\n\nmodule examples::puppy {\n    use std::string::String;\n    use sui::event;\n\n    /// An example NFT that can be minted by anybody. A Puppy is\n    /// a freely-transferable object. Owner can add new traits to\n    /// their puppy at any time and even change the image to the\n    /// puppy's liking.\n    public struct Puppy has key, store {\n        id: UID,\n        /// Name of the Puppy\n        name: String,\n        /// Grumpy or chill?\n        traits: vector<String>,\n        /// The URL of the Puppy's image\n        url: String,\n    }\n\n    /// Event: emitted when a new Puppy is minted.\n    public struct PuppyMinted has copy, drop {\n        /// ID of the Puppy\n        puppy_id: ID,\n        /// The address of the NFT minter\n        minted_by: address,\n    }\n\n    /// Mint a new Puppy with the given `name`, `traits` and `url`.\n    /// The object is returned to sender and they're free to transfer\n    /// it to themselves or anyone else.\n    public fun mint(\n        name: String,\n        traits: vector<String>,\n        url: String,\n        ctx: &mut TxContext\n    ): Puppy {\n        let id = object::new(ctx);\n\n        event::emit(PuppyMinted {\n            puppy_id: id.to_inner(),\n            minted_by: ctx.sender(),\n        });\n\n        Puppy { id, name, traits, url }\n    }\n\n    /// Some puppies get new traits over time... owner of one can\n    /// add a new trait to their puppy at any time.\n    public fun add_trait(puppy: &mut Puppy, trait: String) {\n        puppy.traits.push_back(trait);\n    }\n\n    /// As the puppy grows, owners can change the image to reflect\n    /// the puppy's current state and look.\n    public fun set_url(puppy: &mut Puppy, url: String) {\n        puppy.url = url;\n    }\n\n    /// It's a good practice to allow the owner to destroy the NFT\n    /// and get a storage rebate. Not a requirement and depends on\n    /// your use case. At last, who doesn't love puppies?\n    public fun destroy(puppy: Puppy) {\n        let Puppy { id, url: _, name: _, traits: _ } = puppy;\n        id.delete()\n    }\n\n    // Getters for properties.\n    // Struct fields are always private and unless there's a getter,\n    // other modules can't access them. It's up to the module author\n    // to decide which fields to expose and which to keep private.\n\n    /// Get the Puppy's `name`\n    public fun name(puppy: &Puppy): String { puppy.name }\n\n    /// Get the Puppy's `traits`\n    public fun traits(puppy: &Puppy): &vector<String> { &puppy.traits }\n\n    /// Get the Puppy's `url`\n    public fun url(puppy: &Puppy): String { puppy.url }\n}\n"
    },
    {
      "title": "Samples - Move by Example",
      "url": "https://examples.sui.io/samples/index.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nSamples\n\nThis section contains a growing collection of ready-to-go samples for common blockchain use cases."
    },
    {
      "title": "Test Scenario - Move by Example",
      "url": "https://examples.sui.io/testing/test-scenario.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTest Scenario\n\nFor complicated transaction testing, Sui features the test_scenario module. This module provides functions to emulate transactions, define senders, and check the results of transactions.\n\n/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::balance::{Self, Balance};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    public struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    public struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    public struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin.value() > 0, ECantBeZero);\n        store.balance.join(coin.into_balance());\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = store.balance.value();\n        store.balance.split(amount).into_coin(ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let mut scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            init_for_testing(scenario.ctx());\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = scenario.next_tx(manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = prev_effects.created();\n        let shared_ids = prev_effects.shared();\n        let sent_ids = prev_effects.transferred_to_account();\n        let events_num = prev_effects.num_user_events();\n\n        assert!(created_ids.length() == 2, 0);\n        assert!(shared_ids.length() == 1, 1);\n        assert!(sent_ids.size() == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let mut store = scenario.take_shared<BlackBooks>();\n            let ctx = scenario.ctx();\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = store.purchase(coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        scenario.next_tx(fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = scenario.take_from_sender_by_id<LittleBookOfCalm>(book_id);\n            // send the book back to Manny\n            transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let mut store = scenario.take_shared<BlackBooks>();\n            let ctx = scenario.ctx();\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = store.purchase(coin, ctx);\n            transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let mut store = scenario.take_shared<BlackBooks>();\n            let cap = scenario.take_from_sender<StoreOwnerCap>();\n            let ctx = scenario.ctx();\n            let coin = store.collect(&cap, ctx);\n\n            transfer::public_transfer(coin, bernard);\n            transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        scenario.end();\n    }\n}\n"
    },
    {
      "title": "Test Only Members - Move by Example",
      "url": "https://examples.sui.io/testing/test-only.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTest Only\n\nThe #[test_only] attribute allows creating a module member that will only be available in the test environment. This is useful for creating initializers and other helper functions that are needed for testing but would be dangerous to expose in the production environment. The attribute can also be used to define test-only types, friends and dependencies.\n\nmodule examples::registry {\n    use std::type_name::{Self, TypeName};\n\n    /// Singleton object that can be created only once.\n    public struct TypeRegistry has key {\n        id: UID,\n        /// Simple counter to keep track of the number of records.\n        records: vector<TypeName>,\n    }\n\n    /// Create and share a new `Registry` object.\n    fun init(ctx: &mut TxContext) {\n        sui::transfer::share_object(TypeRegistry {\n            id: object::new(ctx),\n            records: vector[]\n        })\n    }\n\n    /// Add a new record to the `Registry` object with the type name of `T`.\n    public fun register_type<T>(r: &mut TypeRegistry) {\n        r.records.push_back(type_name::get<T>())\n    }\n\n    /// Getter for the `records` field.\n    public fun records(registry: &TypeRegistry): &vector<TypeName> {\n        &registry.records\n    }\n\n    // === Test and test-only members ===\n\n    #[test_only]\n    // The #[test_only] attribute makes the function only available in test mode.\n    // Meaning that it can be used in functions marked with #[test] and in other\n    // functions marked with #[test_only].\n    //\n    // We allow creating a TypeRegistry object for tests! Also, in tests it's often\n    // a good idea to allow for customizing the object's state.\n    public fun new_for_testing(ctx: &mut TxContext): TypeRegistry {\n        TypeRegistry {\n            id: object::new(ctx),\n            records: vector[]\n        }\n    }\n\n    #[test_only]\n    // It's also a good idea to mark test_only functions with suffixes like\n    // `_for_testing` to make it clear that they are only available in tests.\n    public fun reset_for_testing(reg: &mut TypeRegistry) {\n        reg.records = vector[];\n    }\n\n\n    // Test_only can be applied to any module member. Including structs!\n    #[test_only] public struct TestOnlyStruct {}\n\n    // Dependencies can be marked as \"test_only\".\n    // Some dependencies are only available in test mode such as `sui::test_utils`.\n    #[test_only] use sui::test_utils;\n\n    #[test]\n    // In tests we can use the `new_for_testing` function to create a new\n    // `Registry` object.\n    fun test_registry() {\n        let ctx = &mut tx_context::dummy();\n        let mut registry = new_for_testing(ctx);\n\n        assert!(registry.records().length() == 0, 0);\n\n        // we can use `TestOnlyStruct` because it's marked with `#[test_only]`\n        register_type<TestOnlyStruct>(&mut registry);\n\n        assert!(registry.records().length() == 1, 0);\n\n        // super helpful utility which is only available in tests!\n        test_utils::destroy(registry);\n    }\n}\n\n#[test_only]\n// #[test_only] can also be applied to modules. All of the module's members\n// will be test_only and don't need to be marked individually.\nmodule examples::registry_tests {\n    use sui::test_utils;\n    use examples::registry::{Self, TestOnlyStruct};\n\n    public struct AnotherTestOnlyStruct {}\n\n    #[test]\n    fun test_with_two_structs() {\n        let ctx = &mut tx_context::dummy();\n        let mut reg = registry::new_for_testing(ctx);\n\n        reg.register_type<TestOnlyStruct>();\n        reg.reset_for_testing();\n\n        assert!(reg.records().length() == 0, 0);\n\n        reg.register_type<AnotherTestOnlyStruct>();\n\n        assert!(reg.records().length() == 1, 0);\n\n        test_utils::destroy(reg);\n    }\n}\n"
    },
    {
      "title": "Dummy Context - Move by Example",
      "url": "https://examples.sui.io/testing/dummy-context.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nDummy Context\n\nThis example illustrates how to create a TxContext for object testing without using the Test Scenario framework.\n\n/// This module contains an example of a simple application with a simple set of\n/// rules: a letter can only be read once, and then it is burned.\n///\n/// The tests in this module demonstrate how to use the `tx_context` module to\n/// create a custom `TxContext` for testing purposes without using a heavier\n/// `test_scenario` module.\n///\n/// The UIDs of objects generated with dummy context will remain the same in\n/// every test, so the consistency of the tests is guaranteed. However, for a\n/// single test, there should be only one `tx_context::dummy()` call, otherwise\n/// it is possible to create objects with the same UID in the same test.\nmodule examples::burn_after_reading {\n    use std::string::String;\n\n    /// Attempt to burn before reading.\n    const ENotReadYet: u64 = 0;\n\n    /// A simple letter Object which can be read and then burned.\n    public struct Letter has key, store {\n        id: UID,\n        content: String,\n        is_read: bool,\n        sender: address,\n    }\n\n    /// Write a new letter, signed by the sender.\n    public fun new(content: String, ctx: &mut TxContext): Letter {\n        Letter {\n            id: object::new(ctx),\n            content,\n            is_read: false,\n            sender: ctx.sender()\n        }\n    }\n\n    /// Read the letter and get the contents.\n    public fun read(l: &mut Letter): String {\n        l.is_read = true;\n        l.content\n    }\n\n    /// Burn once read. Only sender address can be recovered from the ashes, the\n    /// letter is gone forever.\n    public fun burn(l: Letter): address {\n        let Letter { id, content: _, is_read, sender } = l;\n        assert!(is_read, ENotReadYet);\n        id.delete();\n        sender\n    }\n\n    #[test]\n    // This test uses the dummy context to create and read a letter. By using\n    // the `tx_context::dummy()` function, we can create a dummy context which\n    // has the `sender = 0x0` and `epoch = 0`. This allows us to create objects\n    // without using a more complex test scenario.\n    fun test_new_read_letter() {\n\n        // This is where the magic happens! Because context has `drop`, we can\n        // assign it directly as `&mut` reference and use in the test.\n        let ctx = &mut tx_context::dummy();\n        let mut letter = new(b\"Directed by Ethan and Joel Coen\".to_string(), ctx);\n\n        // burn after reading\n        read(&mut letter);\n        burn(letter);\n    }\n\n    #[test]\n    // It is also possible to create custom contexts for testing. Especially if\n    // there's a need to test the behavior of the contract based on the sender\n    // or the epoch.\n    //\n    // The `tx_context::new_from_hint` function can create a context with tx\n    // hash generated from a number. Alternatively, you can use `tx_context::new`\n    // and provide 32-byte hash manually.\n    fun test_fan_letter() {\n\n        // this is the best way to create a custom `TxContext`\n        let ctx = &mut tx_context::new_from_hint(\n            @0xC4AD,  // sender\n            0u64,     // hint, used to generate tx hash\n            1,        // epoch\n            0,        // epoch_timestamp_ms\n            0,        // `ids_created` (normally should be `0`)\n        );\n\n        let mut letter = new(b\"Uhhh... Osbourne?... Osbourne Cox?\".to_string(), ctx);\n\n        // read, burn, but keep the sender\n        read(&mut letter);\n        let sender = burn(letter);\n\n        // check the sender is correct\n        assert!(sender == @0xC4AD, 0);\n    }\n\n    #[test, expected_failure(abort_code = ENotReadYet)]\n    // This test makes sure the letter cannot be burned before reading. And\n    // expects the transaction to fail with `ENotReadYet` abort code.\n    //\n    // It uses the `tx_context::new` method with a custom tx hash.\n    fun test_burn_before_read() {\n        use sui::hash::blake2b256;\n\n        let tx_hash = blake2b256(&b\"some seed for hashing\");\n        let ctx = &mut tx_context::new(\n            @0x0,    // sender\n            tx_hash, // tx hash\n            0,       // epoch\n            0,       // epoch_timestamp_ms\n            0,       // `ids_created` (normally should be `0`)\n        );\n\n        let letter = new(b\"What did we learn, Palmer?\".to_string(), ctx);\n        burn(letter);\n    }\n}\n"
    },
    {
      "title": "Test Fail Cases - Move by Example",
      "url": "https://examples.sui.io/testing/expected-failure.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTest Fail Cases\n\nTests should also cover the failure cases. Move provides a special attribute to mark tests that are expected to fail. The #[expected_failure] attribute can be used to mark a test that is expected to fail. It can be used with or without an abort code. If an abort code is provided, the test will fail if it does not abort with the provided code. If no abort code is provided, the test will fail if it does not abort.\n\nmodule examples::expected_failure {\n    /// Trying to take a value out of an empty container.\n    const EContainerEmpty: u64 = 0;\n    /// Trying to put a value into a full container.\n    const EContainerFull: u64 = 1;\n    /// Function is not implemented.\n    const ENotImplemented: u64 = 3;\n\n    /// A container that can hold a value of type T or nothing.\n    public struct Container<T> has copy, store, drop {\n        inner: Option<T>\n    }\n\n    /// Creates a new container with the given value.\n    public fun new<T>(inner: T): Container<T> {\n        Container { inner: option::some(inner) }\n    }\n\n    /// Creates a new empty container.\n    public fun empty<T>(): Container<T> {\n        Container { inner: option::none() }\n    }\n\n    /// Takes the value out of the container. Aborts if the container is empty.\n    public fun take<T>(container: &mut Container<T>): T {\n        assert!(container.inner.is_some(), EContainerEmpty);\n        container.inner.extract()\n    }\n\n    /// Put a value into the container. Aborts if the container is full.\n    public fun put<T>(container: &mut Container<T>, value: T) {\n        assert!(container.inner.is_none(), EContainerFull);\n        container.inner.fill(value);\n    }\n\n    #[test]\n    // An example of a regular test function. Not expected to fail.\n    fun create_empty() {\n        let container = empty<u64>();\n        assert!(container.inner.is_none(), 0);\n    }\n\n    #[test]\n    #[expected_failure]\n    // The \"expected_failure\" attribute can be added to a test function. And\n    // the test will pass if it the function fails with any abort code.\n    fun showcase_expected_failure_fail() {\n        abort ENotImplemented\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EContainerEmpty)]\n    // It is considered a good practice to specify the expected abort code. It\n    // is especially important when a function has multiple abort points.\n    //\n    // The abort code is a constant that is used to identify the expected\n    // code. It can be both a value and a name of a constant. It also allows\n    // importing constants from other modules!\n    fun try_take_from_empty_container_fail() {\n        let mut container = empty<u64>();\n        let _ = container.take();\n    }\n\n    #[test, expected_failure(abort_code = EContainerFull)]\n    // Attributes can be combined into a single attribute list, separated by\n    // commas. Purely a style choice.\n    fun try_put_into_full_container_fail() {\n        let mut container = new(42u64); // create a container with a value\n        container.put(42); // try to put another value into it\n    }\n}\n"
    },
    {
      "title": "Test Attribute - Move by Example",
      "url": "https://examples.sui.io/testing/test-attribute.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nSimple Test\n\nTests are functions, marked with the #[test] attribute. They are not included into the compiled program, and are only used for testing purposes.\n\nmodule examples::simple_tests {\n\n    /// A point in 2D space. Has an `x` and `y` coordinate.\n    public struct Point has copy, drop {\n        x: u8,\n        y: u8,\n    }\n\n    /// Create a point.\n    public fun new(x: u8, y: u8): Point { Point { x, y } }\n\n    /// Move a point to a new location.\n    public fun move_xy(p: &mut Point, x: u8, y: u8) {\n        p.x = x;\n        p.y = y;\n    }\n\n    /// Get the x coordinate of a point.\n    public fun x(p: &Point): u8 { p.x }\n\n    /// Get the y coordinate of a point.\n    public fun y(p: &Point): u8 { p.y }\n\n    #[test]\n    // The function marked with `#[test]` is a test. The name of the function\n    // will be shown in the test output, so it should be descriptive.\n    //\n    // The function doesn't take any arguments, and doesn't return anything.\n    fun test_point_new_and_move() {\n        let mut p1 = new(1, 2);\n\n        // normally, a test should contain correctness assertions\n        assert!(x(&p1) == 1, 0);\n        assert!(y(&p1) == 2, 1);\n\n        move_xy(&mut p1, 3, 4);\n\n        // while not a requirement, abort codes should be unique,\n        // it's easier to debug when they are\n        assert!(x(&p1) == 3, 2);\n        assert!(y(&p1) == 4, 3);\n    }\n}\n"
    },
    {
      "title": "Testing - Move by Example",
      "url": "https://examples.sui.io/testing/index.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTesting\n\nTests are an important part of any software project. They are especially important in blockchain applications because smart contracts control digital assets. Move has a built-in testing framework that allows you to write tests for your modules.\n\nTo test a package, use the sui move test command. This command will run all the tests in the package, and print the results to the console.\n\n$ sui move test\n"
    },
    {
      "title": "ID Pointer - Move by Example",
      "url": "https://examples.sui.io/patterns/id-pointer.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nID Pointer\n\nID Pointer is a technique that separates the main data (an object) and its accessors / capabilities by linking the latter to the original. There's a few different directions in which this pattern can be used:\n\nissuing transferable capabilities for shared objects (for example, a TransferCap that changes 'owner' field of a shared object)\nsplitting dynamic data and static (for example, an NFT and its Collection information)\navoiding unnecessary type linking (and witness requirement) in generic applications (LP token for a LiquidityPool)\n/// This example implements a simple `Lock` and `Key` mechanics\n/// on Sui where `Lock<T>` is a shared object that can contain any object,\n/// and `Key` is an owned object which is required to get access to the\n/// contents of the lock.\n///\n/// `Key` is linked to its `Lock` using an `ID` field. This check allows\n/// off-chain discovery of the target as well as splits the dynamic\n/// transferable capability and the 'static' contents. Another benefit of\n/// this approach is that the target asset is always discoverable while its\n/// `Key` can be wrapped into another object (eg a marketplace listing).\nmodule examples::lock_and_key {\n    /// Lock is empty, nothing to take.\n    const ELockIsEmpty: u64 = 0;\n\n    /// Key does not match the Lock.\n    const EKeyMismatch: u64 = 1;\n\n    /// Lock already contains something.\n    const ELockIsFull: u64 = 2;\n\n    /// Lock that stores any content inside it.\n    public struct Lock<T: store + key> has key {\n        id: UID,\n        locked: Option<T>\n    }\n\n    /// A key that is created with a Lock; is transferable\n    /// and contains all the needed information to open the Lock.\n    public struct Key<phantom T: store + key> has key, store {\n        id: UID,\n        lock_id: ID,\n    }\n\n    /// Returns an ID of a Lock for a given Key.\n    public fun key_for<T: store + key>(key: &Key<T>): ID {\n        key.lock_id\n    }\n\n    /// Lock some content inside a shared object. A Key is created and is\n    /// sent to the transaction sender. For example, we could turn the\n    /// lock into a treasure chest by locking some `Coin<SUI>` inside.\n    ///\n    /// Return the Key to the caller so they decide what to do with it.\n    public fun create<T: store + key>(obj: T, ctx: &mut TxContext): Key<T> {\n        let id = object::new(ctx);\n        let lock_id = id.to_inner();\n\n        transfer::share_object(Lock<T> {\n            id,\n            locked: option::some(obj),\n        });\n\n        Key<T> { id: object::new(ctx), lock_id }\n    }\n\n    /// Lock something inside a shared object using a Key. Aborts if\n    /// lock is not empty or if key doesn't match the lock.\n    public fun lock<T: store + key>(\n        obj: T,\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ) {\n        assert!(lock.locked.is_none(), ELockIsFull);\n        assert!(&key.lock_id == object::borrow_id(lock), EKeyMismatch);\n\n        lock.locked.fill(obj);\n    }\n\n    /// Unlock the Lock with a Key and access its contents.\n    /// Can only be called if both conditions are met:\n    /// - key matches the lock\n    /// - lock is not empty\n    public fun unlock<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ): T {\n        assert!(lock.locked.is_some(), ELockIsEmpty);\n        assert!(&key.lock_id == object::borrow_id(lock), EKeyMismatch);\n\n        lock.locked.extract()\n    }\n}\n\n\nThis pattern is used in these examples:\n\nLock\nEscrow\nHero\nTic Tac Toe\nAuction"
    },
    {
      "title": "Hot Potato - Move by Example",
      "url": "https://examples.sui.io/patterns/hot-potato.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nHot Potato\n\nHot Potato is a name for a struct that has no abilities, hence it can only be packed and unpacked in its module. In this struct, you must call function B after function A in the case where function A returns a potato and function B consumes it.\n\nmodule examples::trade_in {\n    use sui::sui::SUI;\n    use sui::coin::Coin;\n\n    /// Price for the first phone model in series\n    const MODEL_ONE_PRICE: u64 = 10000;\n\n    /// Price for the second phone model\n    const MODEL_TWO_PRICE: u64 = 20000;\n\n    /// For when someone tries to purchase non-existing model\n    const EWrongModel: u64 = 1;\n\n    /// For when paid amount does not match the price\n    const EIncorrectAmount: u64 = 2;\n\n    /// A phone; can be purchased or traded in for a newer model\n    public struct Phone has key, store { id: UID, model: u8 }\n\n    /// Payable receipt. Has to be paid directly or paid with a trade-in option.\n    /// Cannot be stored, owned or dropped - has to be used to select one of the\n    /// options for payment: `trade_in` or `pay_full`.\n    public struct Receipt { price: u64 }\n\n    /// Get a phone, pay later.\n    /// Receipt has to be passed into one of the functions that accept it:\n    ///  in this case it's `pay_full` or `trade_in`.\n    public fun buy_phone(model: u8, ctx: &mut TxContext): (Phone, Receipt) {\n        assert!(model == 1 || model == 2, EWrongModel);\n\n        let price = if (model == 1) MODEL_ONE_PRICE else MODEL_TWO_PRICE;\n\n        (\n            Phone { id: object::new(ctx), model },\n            Receipt { price }\n        )\n    }\n\n    /// Pay the full price for the phone and consume the `Receipt`.\n    public fun pay_full(receipt: Receipt, payment: Coin<SUI>) {\n        let Receipt { price } = receipt;\n        assert!(payment.value() == price, EIncorrectAmount);\n\n        // for simplicity's sake transfer directly to @examples account\n        transfer::public_transfer(payment, @examples);\n    }\n\n    /// Give back an old phone and get 50% of its price as a discount for the new one.\n    public fun trade_in(receipt: Receipt, old_phone: Phone, payment: Coin<SUI>) {\n        let Receipt { price } = receipt;\n        let tradein_price = if (old_phone.model == 1) {\n            MODEL_ONE_PRICE\n        } else {\n            MODEL_TWO_PRICE\n        };\n        let to_pay = price - (tradein_price / 2);\n\n        assert!(payment.value() == to_pay, EIncorrectAmount);\n\n        transfer::public_transfer(old_phone, @examples);\n        transfer::public_transfer(payment, @examples);\n    }\n}\n\n\nThis pattern is used in these examples:\n\nFlash Loan"
    },
    {
      "title": "Transferable Witness - Move by Example",
      "url": "https://examples.sui.io/patterns/transferable-witness.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTransferable Witness\n/// This pattern is based on a combination of two others: Capability and a Witness.\n/// Since Witness is something to be careful with, spawning it should be allowed\n/// only to authorized users (ideally only once). But some scenarios require\n/// type authorization by module X to be used in another module Y. Or, possibly,\n/// there's a case where authorization should be performed after some time.\n///\n/// For these rather rare scerarios, a storable witness is a perfect solution.\nmodule examples::transferable_witness {\n    /// Witness now has a `store` that allows us to store it inside a wrapper.\n    public struct WITNESS has store, drop {}\n\n    /// Carries the witness type. Can be used only once to get a Witness.\n    public struct WitnessCarrier has key { id: UID, witness: WITNESS }\n\n    /// Send a `WitnessCarrier` to the module publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            WitnessCarrier { id: object::new(ctx), witness: WITNESS {} },\n            ctx.sender()\n        )\n    }\n\n    /// Unwrap a carrier and get the inner WITNESS type.\n    public fun get_witness(carrier: WitnessCarrier): WITNESS {\n        let WitnessCarrier { id, witness } = carrier;\n        id.delete();\n        witness\n    }\n}\n"
    },
    {
      "title": "Witness - Move by Example",
      "url": "https://examples.sui.io/patterns/witness.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nWitness\n\nWitness is a pattern that is used for confirming the ownership of a type. To do so, one passes a drop instance of a type. Coin relies on this implementation.\n\n/// Module that defines a generic type `Guardian<T>` which can only be\n/// instantiated with a witness.\nmodule examples::guardian {\n    /// Phantom parameter T can only be initialized in the `create_guardian`\n    /// function. But the types passed here must have `drop`.\n    public struct Guardian<phantom T: drop> has key, store {\n        id: UID\n    }\n\n    /// The first argument of this function is an actual instance of the\n    /// type T with `drop` ability. It is dropped as soon as received.\n    public fun create_guardian<T: drop>(\n        _witness: T, ctx: &mut TxContext\n    ): Guardian<T> {\n        Guardian { id: object::new(ctx) }\n    }\n}\n\n/// Custom module that makes use of the `guardian`.\nmodule examples::peace_guardian {\n    // Use the `guardian` as a dependency.\n    use examples::guardian;\n\n    /// This type is intended to be used only once.\n    public struct PEACE has drop {}\n\n    /// Module initializer is the best way to ensure that the\n    /// code is called only once. With `Witness` pattern it is\n    /// often the best practice.\n    fun init(ctx: &mut TxContext) {\n        transfer::public_transfer(\n            guardian::create_guardian(PEACE {}, ctx),\n            ctx.sender()\n        )\n    }\n}\n\n\nThis pattern is used in these examples:\n\nLiquidity pool\nRegulated coin"
    },
    {
      "title": "Capability - Move by Example",
      "url": "https://examples.sui.io/patterns/capability.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nCapability\n\nCapability is a pattern that allows authorizing actions with an object. One of the most common capabilities is TreasuryCap (defined in sui::coin).\n\nmodule examples::item {\n    use std::string::String;\n\n    /// Type that marks Capability to create new `Item`s.\n    public struct AdminCap has key { id: UID }\n\n    /// Custom NFT-like type.\n    public struct Item has key, store { id: UID, name: String }\n\n    /// Module initializer is called once on module publish.\n    /// Here we create only one instance of `AdminCap` and send it to the publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(AdminCap {\n            id: object::new(ctx)\n        }, ctx.sender())\n    }\n\n    /// The entry function can not be called if `AdminCap` is not passed as\n    /// the first argument. Hence only owner of the `AdminCap` can perform\n    /// this action.\n    public fun create_and_send(\n        _: &AdminCap, name: vector<u8>, to: address, ctx: &mut TxContext\n    ) {\n        transfer::transfer(Item {\n            id: object::new(ctx),\n            name: name.to_string()\n        }, to)\n    }\n}\n"
    },
    {
      "title": "Views and Accessors - Move by Example",
      "url": "https://examples.sui.io/patterns/views-and-accessors.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nViews and Accessors\n\nStruct fields are private to the module. To access them from outside the module, you must define an accessor function. The convention is to name the function after the field. It's up to the developer to decide which of the fields should be accessible from outside the module.\n\n/// This module implements a simple object that represents a user record. All\n/// of the fields of the record can be read by using the getter functions. The\n/// email and phone fields can be changed by using the mutable access functions.\nmodule examples::record {\n    use std::string::String;\n\n    /// A single record of a user. An Object!\n    public struct UserRecord has key, store {\n        id: UID,\n        name: String,\n        age: u8,\n        email: String,\n        phone: String,\n    }\n\n    /// Creates a new user record\n    public fun new(\n        name: String, age: u8, email: String, phone: String, ctx: &mut TxContext\n    ): UserRecord {\n        UserRecord {\n            id: object::new(ctx),\n            name, age, email, phone,\n        }\n    }\n\n    // === Mutable Accessors ===\n\n    /// Return a mutable reference to the user's email.\n    ///\n    /// Hint: the `_mut` suffix on the function name marks this function as\n    /// a mutable accessor.\n    public fun email_mut(self: &mut UserRecord): &mut String { &mut self.email }\n\n    /// Return a mutable reference to the user's phone\n    public fun phone_mut(self: &mut UserRecord): &mut String { &mut self.phone }\n\n    // === Views ===\n\n    /// Returns the user's name.\n    /// Hint: view functions match property names.\n    public fun name(self: &UserRecord): String { self.name }\n\n    /// Returns the user's age\n    public fun age(self: &UserRecord): u8 { self.age }\n\n    /// Returns the user's email\n    public fun email(self: &UserRecord): String { self.email }\n\n    /// Returns the user's phone\n    public fun phone(self: &UserRecord): String { self.phone }\n}\n\n\nThis pattern is used in almost every application of Move."
    },
    {
      "title": "Patterns - Move by Example",
      "url": "https://examples.sui.io/patterns/index.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nPatterns\n\nThis part covers the programming patterns that are widely used in Move; some of which can exist only in Move."
    },
    {
      "title": "Object Display - Move by Example",
      "url": "https://examples.sui.io/basics/display.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nObject Display\n\nA creator or a builder who owns a Publisher object can use the sui::display module to define display properties for their objects. To get a Publisher object check out the Publisher page.\n\nDisplay<T> is an object that specifies a set of named templates for the type T (for example, for a type 0x2::capy::Capy the display would be Display<0x2::capy::Capy>). All objects of the type T will be processed in the Sui Full Node RPC through the matching Display definition and will have processed result attached when an object is queried.\n\nDescription\n\nSui Object Display is a template engine which allows for on-chain display configuration for type to be handled off-chain by the ecosystem. It has the ability to use an object's data for substitution into a template string.\n\nThere's no limitation to what fields can be set, all object properties can be accessed via the {property} syntax and inserted as a part of the template string (see examples for the illustration).\n\nExample\n\nFor the following Hero module, the Display would vary based on the \"name\", \"id\" and \"image_url\" properties of the type \"Hero\". The template defined in the init function can be represented as:\n\n{\n    \"name\": \"{name}\",\n    \"link\": \"https://sui-heroes.io/hero/{id}\",\n    \"image_url\": \"ipfs://{img_url}\",\n    \"description\": \"A true Hero of the Sui ecosystem!\",\n    \"project_url\": \"https://sui-heroes.io\",\n    \"creator\": \"Unknown Sui Fan\"\n}\n\n/// Example of an unlimited \"Sui Hero\" collection - anyone is free to\n/// mint their Hero. Shows how to initialize the `Publisher` and how\n/// to use it to get the `Display<Hero>` object - a way to describe a\n/// type for the ecosystem.\nmodule examples::my_hero {\n    use std::string::String;\n\n    // The creator bundle: these two packages often go together.\n    use sui::package;\n    use sui::display;\n\n    /// The Hero - an outstanding collection of digital art.\n    public struct Hero has key, store {\n        id: UID,\n        name: String,\n        img_url: String,\n    }\n\n    /// One-Time-Witness for the module.\n    public struct MY_HERO has drop {}\n\n    /// In the module initializer we claim the `Publisher` object\n    /// to then create a `Display`. The `Display` is initialized with\n    /// a set of fields (but can be modified later) and published via\n    /// the `update_version` call.\n    ///\n    /// Keys and values are set in the initializer but could also be\n    /// set after publishing if a `Publisher` object was created.\n    fun init(otw: MY_HERO, ctx: &mut TxContext) {\n        let keys = vector[\n            b\"name\".to_string(),\n            b\"link\".to_string(),\n            b\"image_url\".to_string(),\n            b\"description\".to_string(),\n            b\"project_url\".to_string(),\n            b\"creator\".to_string(),\n        ];\n\n        let values = vector[\n            // For `name` we can use the `Hero.name` property\n            b\"{name}\".to_string(),\n            // For `link` we can build a URL using an `id` property\n            b\"https://sui-heroes.io/hero/{id}\".to_string(),\n            // For `image_url` we use an IPFS template + `img_url` property.\n            b\"ipfs://{img_url}\".to_string(),\n            // Description is static for all `Hero` objects.\n            b\"A true Hero of the Sui ecosystem!\".to_string(),\n            // Project URL is usually static\n            b\"https://sui-heroes.io\".to_string(),\n            // Creator field can be any\n            b\"Unknown Sui Fan\".to_string()\n        ];\n\n        // Claim the `Publisher` for the package!\n        let publisher = package::claim(otw, ctx);\n\n        // Get a new `Display` object for the `Hero` type.\n        let mut display = display::new_with_fields<Hero>(\n            &publisher, keys, values, ctx\n        );\n\n        // Commit first version of `Display` to apply changes.\n        display.update_version();\n\n        transfer::public_transfer(publisher, ctx.sender());\n        transfer::public_transfer(display, ctx.sender());\n    }\n\n    /// Anyone can mint their `Hero`!\n    public fun mint(name: String, img_url: String, ctx: &mut TxContext): Hero {\n        let id = object::new(ctx);\n        Hero { id, name, img_url }\n    }\n}\n\nMethods description\n\nDisplay is created via the display::new<T> call, which can be performed either in a custom function (or a module initializer) or as a part of a programmable transaction.\n\nmodule sui::display {\n    /// Get a new Display object for the `T`.\n    /// Publisher must be the publisher of the T, `from_package`\n    /// check is performed.\n    public fun new<T>(pub: &Publisher): Display<T> { /* ... */ }\n}\n\n\nOnce acquired, the Display can be modified:\n\nmodule sui::display {\n    /// Sets multiple fields at once\n    public fun add_multiple(\n        self: &mut Display,\n        keys: vector<String>,\n        values: vector<String\n    ) { /* ... */ }\n\n    /// Edit a single field\n    public fun edit(self: &mut Display, key: String, value: String) { /* ... */ }\n\n    /// Remove a key from Display\n    public fun remove(self: &mut Display, key: String ) { /* ... */ }\n}\n\n\nTo apply changes and set the Display for the T, one last call is required: update_version publishes version by emitting an event which Full Node listens to and uses to get a template for the type.\n\nmodule sui::display {\n    /// Update the version of Display and emit an event\n    public fun update_version(self: &mut Display) { /* ... */ }\n}\n\nLearn more\nSui Object Display (Docs)"
    },
    {
      "title": "Publisher - Move by Example",
      "url": "https://examples.sui.io/basics/publisher.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nPublisher\n\nPublisher Object serves as a way to represent the publisher authority. The object itself does not imply any specific use case and has only two main functions: package::from_module<T> and package::from_package<T> which allow checking whether a type T belongs to a module or a package for which the Publisher object was created.\n\nWe strongly advise to issue the Publisher object for most of the packages that define new Objects - it is required to set the \"Display\" as well as to allow the type to be traded in the \"Kiosk\" ecosystem.\n\nAlthough Publisher itself is a utility, it enables the \"proof of ownership\" functionality, for example, it is crucial for the Object Display.\n\nTo set up a Publisher, a One-Time-Witness (OTW) is required - this way we ensure the Publisher object is initialized only once for a specific module (but can be multiple for a package) as well as that the creation function is called in the publish transaction.\n\n/// A simple package that defines an OTW and claims a `Publisher`\n/// object for the sender.\nmodule examples::owner {\n    use sui::package;\n\n    /// OTW is a struct with only `drop` and is named\n    /// after the module - but uppercased. See \"One Time\n    /// Witness\" page for more details.\n    public struct OWNER has drop {}\n\n    /// Some other type to use in a dummy check\n    public struct ThisType {}\n\n    /// After the module is published, the sender will receive\n    /// a `Publisher` object. Which can be used to set Display\n    /// or manage the transfer policies in the `Kiosk` system.\n    fun init(otw: OWNER, ctx: &mut TxContext) {\n        package::claim_and_keep(otw, ctx)\n    }\n}\n\n/// A module that utilizes the `Publisher` object to give a token\n/// of appreciation and a `TypeOwnerCap` for the owned type.\nmodule examples::type_owner {\n    use sui::package::{Self, Publisher};\n\n    /// Trying to claim ownership of a type with a wrong `Publisher`.\n    const ENotOwner: u64 = 0;\n\n    /// A capability granted to those who want an \"objective\"\n    /// confirmation of their ownership :)\n    public struct TypeOwnerCap<phantom T> has key, store {\n        id: UID\n    }\n\n    /// Uses the `Publisher` object to check if the caller owns the type `T`.\n    public fun prove_ownership<T>(\n        publisher: &Publisher, ctx: &mut TxContext\n    ): TypeOwnerCap<T> {\n        assert!(package::from_package<T>(publisher), ENotOwner);\n        TypeOwnerCap<T> { id: object::new(ctx) }\n    }\n}\n"
    },
    {
      "title": "One Time Witness - Move by Example",
      "url": "https://examples.sui.io/basics/one-time-witness.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nOne Time Witness\n\nOne Time Witness (OTW) is a special instance of a type which is created only in the module initializer and is guaranteed to be unique and have only one instance. It is important for cases where we need to make sure that a witness-authorized action was performed only once (for example - creating a new Coin). In Sui Move a type is considered an OTW if its definition has the following properties:\n\nNamed after the module but uppercased\nHas only drop ability\n\nTo check whether an instance is an OTW, sui::types::is_one_time_witness(witness) should be used.\n\nTo get an instance of this type, you need to add it as the first argument to the init() function: Sui runtime supplies both initializer arguments automatically.\n\nmodule examples::mycoin {\n\n    /// Name matches the module name\n    public struct MYCOIN has drop {}\n\n    /// The instance is received as the first argument\n    fun init(witness: MYCOIN, ctx: &mut TxContext) {\n        /* ... */\n    }\n}\n\n\nExample which illustrates how OTW could be used:\n\n/// This example illustrates how One Time Witness works.\n///\n/// One Time Witness (OTW) is an instance of a type which is guaranteed to\n/// be unique across the system. It has the following properties:\n///\n/// - created only in module initializer\n/// - named after the module (uppercased)\n/// - cannot be packed manually\n/// - has a `drop` ability\nmodule examples::one_time_witness_registry {\n    use std::string::String;\n\n    // This dependency allows us to check whether type\n    // is a one-time witness (OTW)\n    use sui::types;\n\n    /// For when someone tries to send a non OTW struct\n    const ENotOneTimeWitness: u64 = 0;\n\n    /// An object of this type will mark that there's a type,\n    /// and there can be only one record per type.\n    public struct UniqueTypeRecord<phantom T> has key {\n        id: UID,\n        name: String\n    }\n\n    /// Expose a public function to allow registering new types with\n    /// custom names. With a `is_one_time_witness` call we make sure\n    /// that for a single `T` this function can be called only once.\n    public fun add_record<T: drop>(\n        witness: T,\n        name: String,\n        ctx: &mut TxContext\n    ) {\n        // This call allows us to check whether type is an OTW;\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n\n        // Share the record for the world to see. :)\n        transfer::share_object(UniqueTypeRecord<T> {\n            id: object::new(ctx),\n            name\n        });\n    }\n}\n\n/// Example of spawning an OTW.\nmodule examples::my_otw {\n    use examples::one_time_witness_registry as registry;\n\n    /// Type is named after the module but uppercased\n    public struct MY_OTW has drop {}\n\n    /// To get it, use the first argument of the module initializer.\n    /// It is a full instance and not a reference type.\n    fun init(witness: MY_OTW, ctx: &mut TxContext) {\n        registry::add_record(\n            witness, // here it goes\n            b\"My awesome record\".to_string(),\n            ctx\n        )\n    }\n}\n"
    },
    {
      "title": "Events - Move by Example",
      "url": "https://examples.sui.io/basics/events.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nEvents\n\nEvents are the main way to track actions on chain.\n\n/// Extended example of a shared object. Now with addition of events!\nmodule examples::donuts_with_events {\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::balance::{Self, Balance};\n\n    // This is the only dependency you need for events.\n    use sui::event;\n\n    /// For when Coin balance is too low.\n    const ENotEnough: u64 = 0;\n\n    /// Capability that grants an owner the right to collect profits.\n    public struct ShopOwnerCap has key { id: UID }\n\n    /// A purchasable Donut. For simplicity's sake we ignore implementation.\n    public struct Donut has key { id: UID }\n\n    public struct DonutShop has key {\n        id: UID,\n        price: u64,\n        balance: Balance<SUI>\n    }\n\n    // ====== Events ======\n\n    /// For when someone has purchased a donut.\n    public struct DonutBought has copy, drop {\n        id: ID\n    }\n\n    /// For when DonutShop owner has collected profits.\n    public struct ProfitsCollected has copy, drop {\n        amount: u64\n    }\n\n    // ====== Functions ======\n\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(DonutShop {\n            id: object::new(ctx),\n            price: 1000,\n            balance: balance::zero()\n        })\n    }\n\n    /// Buy a donut.\n    public fun buy_donut(\n        shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext\n    ) {\n        assert!(coin::value(payment) >= shop.price, ENotEnough);\n\n        let paid = payment.balance_mut().split(shop.price);\n        let id = object::new(ctx);\n\n        shop.balance.join(paid);\n\n        // Emit the event using future object's ID.\n        event::emit(DonutBought { id: id.to_inner() });\n        transfer::transfer(Donut { id }, ctx.sender())\n    }\n\n    /// Consume donut and get nothing...\n    public fun eat_donut(d: Donut) {\n        let Donut { id } = d;\n        object::delete(id);\n    }\n\n    /// Take coin from `DonutShop` and transfer it to tx sender.\n    /// Requires authorization with `ShopOwnerCap`.\n    public fun collect_profits(\n        _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = shop.balance.value();\n\n        // simply create new type instance and emit it\n        event::emit(ProfitsCollected { amount });\n        shop.balance.split(amount).into_coin(ctx)\n    }\n}\n\nLearn more\nUsing Events (Docs)"
    },
    {
      "title": "Clock - Move by Example",
      "url": "https://examples.sui.io/basics/clock.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nClock\n\nSui has built-in support for a clock. The clock is a special object that can be used to get the current time. It is a shared object, and can be accessed by anyone.\n\nClock has a reserved address 0x6. While being a shared object, it can't be accessed mutably, and a transaction attempting to do so will fail.\n\nmodule examples::clock {\n    // Import the `clock` module and the `Clock` type.\n    use sui::clock::Clock;\n\n    /// A dummy object that hold the time it was created.\n    /// What if we could sell a timestamp...?\n    public struct Timestamp has key, store {\n        id: UID,\n        timestamp: u64,\n    }\n\n    /// Creates a new `Timestamp` Object using the `Clock`.\n    public fun new(clock: &Clock, ctx: &mut TxContext): Timestamp {\n        // The `timestamp_ms` is the main function of the `Clock` module.\n        let timestamp = clock.timestamp_ms();\n\n        Timestamp { timestamp, id: object::new(ctx) }\n    }\n}\n\nLearn more\nAccess On-Chain Time (Docs)"
    },
    {
      "title": "Custom transfer - Move by Example",
      "url": "https://examples.sui.io/basics/custom-transfer.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nCustom transfer\n\nIn Sui Move, objects defined with only key ability can not be transferred by default. To enable transfers, publisher has to create a custom transfer function. This function can include any arguments, for example a fee, that users have to pay to transfer.\n\nmodule examples::restricted_transfer {\n    use sui::balance::{Self, Balance};\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n\n    /// For when paid amount is not equal to the transfer price.\n    const EWrongAmount: u64 = 0;\n\n    /// A Capability that allows bearer to create new `TitleDeed`s.\n    public struct GovernmentCapability has key { id: UID }\n\n    /// An object that marks a property ownership. Can only be issued\n    /// by an authority.\n    public struct TitleDeed has key {\n        id: UID,\n        // ... some additional fields\n    }\n\n    /// A centralized registry that approves property ownership\n    /// transfers and collects fees.\n    public struct LandRegistry has key {\n        id: UID,\n        balance: Balance<SUI>,\n        fee: u64\n    }\n\n    /// Create a `LandRegistry` on module init.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(GovernmentCapability {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        transfer::share_object(LandRegistry {\n            id: object::new(ctx),\n            balance: balance::zero<SUI>(),\n            fee: 10000\n        })\n    }\n\n    /// Create `TitleDeed` and transfer it to the property owner.\n    /// Only owner of the `GovernmentCapability` can perform this action.\n    public fun issue_title_deed(\n        _: &GovernmentCapability,\n        `for`: address,\n        ctx: &mut TxContext\n    ) {\n        transfer::transfer(TitleDeed {\n            id: object::new(ctx)\n        }, `for`)\n    }\n\n    /// A custom transfer function. Required due to `TitleDeed` not having\n    /// a `store` ability. All transfers of `TitleDeed`s have to go through\n    /// this function and pay a fee to the `LandRegistry`.\n    public fun transfer_ownership(\n        registry: &mut LandRegistry,\n        paper: TitleDeed,\n        fee: Coin<SUI>,\n        to: address,\n    ) {\n        assert!(&fee.value() == registry.fee, EWrongAmount);\n\n        // add a payment to the LandRegistry balance\n        registry.balance.join(fee.into_balance());\n\n        // finally call the transfer function\n        transfer::transfer(paper, to)\n    }\n}\n\nLearn more\nCustom Transfer Rules (Docs)"
    },
    {
      "title": "Transfer - Move by Example",
      "url": "https://examples.sui.io/basics/transfer.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nTransfer\n\nTo make an object freely transferable, use a combination of key and store abilities.\n\n/// A freely transfererrable Wrapper for custom data.\nmodule examples::wrapper {\n    /// An object with `store` can be transferred in any\n    /// module without a custom transfer implementation.\n    public struct Wrapper<T: store> has key, store {\n        id: UID,\n        contents: T\n    }\n\n    /// View function to read contents of a `Container`.\n    public fun contents<T: store>(c: &Wrapper<T>): &T {\n        &c.contents\n    }\n\n    /// Anyone can create a new object\n    public fun create<T: store>(\n        contents: T, ctx: &mut TxContext\n    ): Wrapper<T> {\n        Wrapper {\n            contents,\n            id: object::new(ctx),\n        }\n    }\n\n    /// Destroy `Wrapper` and get T.\n    public fun destroy<T: store> (c: Wrapper<T>): T {\n        let Wrapper { id, contents } = c;\n        id.delete();\n        contents\n    }\n}\n\nmodule examples::profile {\n    use sui::url::{Self, Url};\n    use std::string::String;\n\n    // using Wrapper functionality\n    use examples::wrapper::{Self, Wrapper};\n\n    /// Profile information, not an object, can be wrapped\n    /// into a transferable container\n    public struct ProfileInfo has store {\n        name: String,\n        url: Url\n    }\n\n    /// Read `name` field from `ProfileInfo`.\n    public fun name(info: &ProfileInfo): &String {\n        &info.name\n    }\n\n    /// Read `url` field from `ProfileInfo`.\n    public fun url(info: &ProfileInfo): &Url {\n        &info.url\n    }\n\n    /// Creates new `ProfileInfo` and wraps into `Wrapper`.\n    /// Then transfers to sender.\n    public fun create_profile(\n        name: vector<u8>, url: vector<u8>, ctx: &mut TxContext\n    ): Wrapper<ProfileInfo> {\n        // create a new container and wrap ProfileInfo into it\n        // return the container to the caller\n        wrapper::create(ProfileInfo {\n            name: name.to_string(),\n            url: url::new_unsafe_from_bytes(url)\n        }, ctx)\n    }\n}\n"
    },
    {
      "title": "Shared Object - Move by Example",
      "url": "https://examples.sui.io/basics/shared-object.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nShared Object\n\nShared object is an object that is shared using a sui::transfer::share_object function and is accessible to everyone both mutably and immutably.\n\nWhen sharing an object defined in this module, use transfer::share_object; for types defined in other modules, use transfer::public_share_object. Inside a transaction block, only the latter is allowed.\n\n/// Unlike `Owned` objects, `Shared` ones can be accessed by anyone on the\n/// network. Extended functionality and accessibility of this kind of objects\n/// requires additional effort by securing access if needed.\nmodule examples::donuts {\n    use sui::sui::SUI;\n    use sui::coin::Coin;\n    use sui::balance::{Self, Balance};\n\n    /// For when Coin balance is too low.\n    const ENotEnough: u64 = 0;\n\n    /// Capability that grants an owner the right to collect profits.\n    public struct ShopOwnerCap has key { id: UID }\n\n    /// A purchasable Donut. For simplicity's sake we ignore implementation.\n    public struct Donut has key { id: UID }\n\n    /// A shared object. `key` ability is required.\n    public struct DonutShop has key {\n        id: UID,\n        price: u64,\n        balance: Balance<SUI>\n    }\n\n    /// Init function is often ideal place for initializing\n    /// a shared object as it is called only once.\n    ///\n    /// To share an object `transfer::share_object` is used.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        // Share the object to make it accessible to everyone!\n        transfer::share_object(DonutShop {\n            id: object::new(ctx),\n            price: 1000,\n            balance: balance::zero()\n        })\n    }\n\n    /// Entry function available to everyone who owns a Coin.\n    public fun buy_donut(\n        shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext\n    ) {\n        assert!(payment.value() >= shop.price, ENotEnough);\n\n        // Take amount = `shop.price` from Coin<SUI>\n        let paid = payment.balance_mut().split(shop.price);\n\n        // Put the coin to the Shop's balance\n        shop.balance.join(paid);\n\n        transfer::transfer(Donut {\n            id: object::new(ctx)\n        }, ctx.sender())\n    }\n\n    /// Consume donut and get nothing...\n    public fun eat_donut(d: Donut) {\n        let Donut { id } = d;\n        id.delete();\n    }\n\n    /// Take coin from `DonutShop` and transfer it to tx sender.\n    /// Requires authorization with `ShopOwnerCap`.\n    public fun collect_profits(\n        _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = shop.balance.value();\n        shop.balance.split(amount).into_coin(ctx)\n    }\n}\n"
    },
    {
      "title": "Strings - Move by Example",
      "url": "https://examples.sui.io/basics/strings.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nStrings\n\nMove does not have a native type for strings, but it has a handy wrapper! Sui supports String type as a transaction argument (encoded as vector<u8> on the client).\n\nmodule examples::strings {\n    use std::string::String;\n\n    /// A dummy Object that holds a String type\n    public struct Name has key, store {\n        id: UID,\n        /// Here it is - the String type\n        name: String\n    }\n\n    /// Create a name Object by passing raw bytes\n    public fun mint_name(name: String, ctx: &mut TxContext): Name {\n        Name { id: object::new(ctx), name }\n    }\n}\n\nString operations\n\nTo create a string from a vector of bytes, use string::utf8:\n\nmodule examples::string_operations {\n    use std::string::String;\n\n    /// Constants can't be Strings; and they're not public.\n    const HELLO_WORLD: vector<u8> = b\"Hello, World!\";\n\n    /// But a function can pack a string and make it accessible.\n    /// Note: `string::utf8` fails if the string is not valid UTF-8.\n    public fun hello_world(): String {\n        HELLO_WORLD.to_string()\n    }\n\n    /// Checks if it's a valid UTF-8 String and returns an option\n    public fun new_string_safe(bytes: vector<u8>): Option<String> {\n        bytes.try_to_string()\n    }\n}\n"
    },
    {
      "title": "Entry Functions - Move by Example",
      "url": "https://examples.sui.io/basics/entry-functions.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nEntry Function\n\nAn entry function visibility modifier restricts calling a function from another package but allows direct calls in a transaction block. Entry functions can't return a value that doesn't have drop ability.\n\nmodule examples::object {\n    /// An object is a struct with `key` ability and `id: UID` field.\n    public struct Object has key {\n        id: UID\n    }\n\n    /// If function is defined as public - any module can call it.\n    /// Non-entry functions are also allowed to have return values.\n    public fun create(ctx: &mut TxContext): Object {\n        Object { id: object::new(ctx) }\n    }\n\n    /// Entrypoints can't have return values as they can only be called\n    /// directly in a transaction and the returned value can't be used.\n    /// However, `entry` without `public` disallows calling this method from\n    /// other Move modules.\n    entry fun create_and_transfer(to: address, ctx: &mut TxContext) {\n        transfer::transfer(create(ctx), to)\n    }\n}\n\n\nEntry functions can be public, and that would make them callable from other modules. However, the return value restrictions still apply.\n\nLearn more\nEntry Functions (Docs)"
    },
    {
      "title": "Init Function - Move by Example",
      "url": "https://examples.sui.io/basics/init-function.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nInit Function\n\nInit is a special function which gets called when a module is published. It is guaranteed that it will never be called again. It can take the &mut TxContext as the last argument and a One-Time-Witness (optional) as the first argument.\n\nfun init(ctx: &mut TxContext) { /* ... */ }\n\n\nFor example:\n\nmodule examples::init_function {\n    /// The one of a kind - created in the module initializer.\n    public struct CreatorCap has key {\n        id: UID\n    }\n\n    /// This function is only called once on module publish.\n    /// Use it to make sure something has happened only once, like\n    /// here - only module author will own a version of a\n    /// `CreatorCap` struct.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(CreatorCap {\n            id: object::new(ctx),\n        }, ctx.sender())\n    }\n}\n\nLearn more\nModule Initializers (Docs)\nModule initializer in Publish a Package (Docs)"
    },
    {
      "title": "Move.toml - Move by Example",
      "url": "https://examples.sui.io/basics/move-toml.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nMove.toml\n\nEvery Move package has a package manifest in the form of a Move.toml file - it is placed in the root of the package. The manifest itself contains a number of sections, primary of which are:\n\n[package] - includes package metadata such as name and author\n[dependencies] - specifies dependencies of the project\n[addresses] - address aliases (eg @examples will be treated as a 0x0 address)\n[package]\nname = \"examples\"\nedition = \"2024.beta\" \n# license = \"\"           # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\n# authors = [\"...\"]      # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/mainnet\" }\n\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision can be a branch, a tag, and a commit hash.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n\n# To resolve a version conflict and force a specific version for dependency\n# override use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n\n[addresses]\nexamples = \"0x0\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies]\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n\n[dev-addresses]\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n# alice = \"0xB0B\"\n\nStdlib and Sui Framework\n\nThe Sui dependency adds two addresses to the package:\n\nstd = 0x1 - address of the standard library\nsui = 0x2 - address of the Sui Framework\nLearn more\nMove.toml (Docs)"
    },
    {
      "title": "Sui Basics - Move by Example",
      "url": "https://examples.sui.io/basics/index.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nBasics\n\nThis section covers the main features of Sui Move. Use the left navigation menu to access the section's sub-pages."
    },
    {
      "title": "How to use this book - Move by Example",
      "url": "https://examples.sui.io/index.html",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nMove by Example\n\nThis book is being deprecated in favor of the Move Book, which is a more comprehensive and up-to-date resource for learning Move. The Move Book not only features a more in-depth explanation of Move's concepts, but also includes a more extensive set of examples and exercises. We recommend that you use the Move Book as your primary resource for learning Move.\n\nWelcome to the companion book to docs.sui.io. There we describe the Move on Sui and explain how to use it to write smart contracts.\n\nInstead, this site builds upon the application examples already highlighted with component-by-component examples you may reference at any time. What is more expressive in the world of code than the code itself? In this book, you'll find examples for most of the features of Sui Move as well as a number of advanced patterns that can be used right away to improve your modules.\n\nAll code samples in this book are written with the assumption that you use Move on Sui, which can installed with this command:\n\n$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch \"main\" sui\n\n\nKeep in mind that the branch is set to main. If you're developing with our devnet, instead follow the instructions to install Sui."
    },
    {
      "title": "How to use this book - Move by Example",
      "url": "https://examples.sui.io/",
      "html": "1. How to use this book\n2. Sui Basics\n2.1. Move.toml\n2.2. Init Function\n2.3. Entry Functions\n2.4. Strings\n2.5. Shared Object\n2.6. Transfer\n2.7. Custom transfer\n2.8. Clock\n2.9. Events\n2.10. One Time Witness\n2.11. Publisher\n2.12. Object Display\n3. Patterns\n3.1. Views and Accessors\n3.2. Capability\n3.3. Witness\n3.4. Transferable Witness\n3.5. Hot Potato\n3.6. ID Pointer\n4. Testing\n4.1. Test Attribute\n4.2. Test Fail Cases\n4.3. Dummy Context\n4.4. Test Scenario\n4.5. Test Only Members\n5. Samples\n5.1. Make an NFT\n5.2. Create a Coin (ERC20)\n5.3. Coin with Denylist\n6. Additional Resources\nMove by Example\n \nMove by Example\n\nThis book is being deprecated in favor of the Move Book, which is a more comprehensive and up-to-date resource for learning Move. The Move Book not only features a more in-depth explanation of Move's concepts, but also includes a more extensive set of examples and exercises. We recommend that you use the Move Book as your primary resource for learning Move.\n\nWelcome to the companion book to docs.sui.io. There we describe the Move on Sui and explain how to use it to write smart contracts.\n\nInstead, this site builds upon the application examples already highlighted with component-by-component examples you may reference at any time. What is more expressive in the world of code than the code itself? In this book, you'll find examples for most of the features of Sui Move as well as a number of advanced patterns that can be used right away to improve your modules.\n\nAll code samples in this book are written with the assumption that you use Move on Sui, which can installed with this command:\n\n$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch \"main\" sui\n\n\nKeep in mind that the branch is set to main. If you're developing with our devnet, instead follow the instructions to install Sui."
    }
  ]