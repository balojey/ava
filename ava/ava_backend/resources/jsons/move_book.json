[
    {
      "title": "Functions - The Move Reference",
      "url": "https://move-book.com/reference/functions.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nFunctions\n\nFunctions are declared inside of modules and define the logic and behavior of the module. Functions can be reused, either being called from other functions or as entry points for execution.\n\nDeclaration\n\nFunctions are declared with the fun keyword followed by the function name, type parameters, parameters, a return type, and finally the function body.\n\n<visibility>? <entry>? fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <function_body>\n\n\nFor example\n\nfun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n\nVisibility\n\nModule functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or as entry points.\n\nmodule a::m {\n    fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n\n\nTo allow access from other modules, the function must be declared public or public(package). Tangential to visibility, an entry function can be called as an entry point for execution.\n\npublic visibility\n\nA public function can be called by any function defined in any module. As shown in the following example, a public function can be called by:\n\nother functions defined in the same module,\nfunctions defined in another module, or\nas an entry point for execution.\nmodule a::m {\n    public fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid\n    }\n}\n\n\nFore more details on the entry point to execution see the section below.\n\npublic(package) visibility\n\nThe public(package) visibility modifier is a more restricted form of the public modifier to give more control about where a function can be used. A public(package) function can be called by:\n\nother functions defined in the same module, or\nother functions defined in the same package (the same address)\nmodule a::m {\n    public(package) fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid, also in `a`\n    }\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        b::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`\n    }\n}\n\nDEPRECATED public(friend) visibility\n\nBefore the addition of public(package), public(friend) was used to allow limited public access to functions in the same package, but where the list of allowed modules had to be explicitly enumerated by the callee's module. see Friends for more details.\n\nentry modifier\n\nIn addition to public functions, you might have some functions in your modules that you want to use as the entry point to execution. The entry modifier is designed to allow module functions to initiate execution, without having to expose the functionality to other modules.\n\nEssentially, the combination of pbulic and entry functions define the \"main\" functions of a module, and they specify where Move programs can start executing.\n\nKeep in mind though, an entry function can still be called by other Move functions. So while they can serve as the start of a Move program, they aren't restricted to that case.\n\nFor example:\n\nmodule a::m {\n    entry fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid!\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n\n\nentry functions may have restrictions on their parameters and return types. Although, these restrictions are specific to each individual deployment of Move.\n\nThe documentation for entry functions on Sui can be found here..\n\nTo enable easier testing, entry functions can be called from #[test] and #[test_only] contexts.\n\nmodule a::m {\n    entry fun foo(): u64 { 0 }\n}\nmodule a::m_test {\n    #[test]\n    fun my_test(): u64 { a::m::foo() } // valid!\n    #[test_only]\n    fun my_test_helper(): u64 { a::m::foo() } // valid!\n}\n\nName\n\nFunction names can start with letters a to z. After the first character, function names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nfun fOO() {}\nfun bar_42() {}\nfun bAZ_19() {}\n\nType Parameters\n\nAfter the name, functions can have type parameters\n\nfun id<T>(x: T): T { x }\nfun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }\n\n\nFor more details, see Move generics.\n\nParameters\n\nFunctions parameters are declared with a local variable name followed by a type annotation\n\nfun add(x: u64, y: u64): u64 { x + y }\n\n\nWe read this as x has type u64\n\nA function does not have to have any parameters at all.\n\nfun useless() { }\n\n\nThis is very common for functions that create new or empty data structures\n\nmodule a::example {\n  public struct Counter { count: u64 }\n\n  fun new_counter(): Counter {\n      Counter { count: 0 }\n  }\n}\n\nReturn type\n\nAfter the parameters, a function specifies its return type.\n\nfun zero(): u64 { 0 }\n\n\nHere : u64 indicates that the function's return type is u64.\n\nUsing tuples, a function can return multiple values:\n\nfun one_two_three(): (u64, u64, u64) { (0, 1, 2) }\n\n\nIf no return type is specified, the function has an implicit return type of unit (). These functions are equivalent:\n\nfun just_unit(): () { () }\nfun just_unit() { () }\nfun just_unit() { }\n\n\nAs mentioned in the tuples section, these tuple \"values\" do not exist as runtime values. This means that a function that returns unit () does not return any value during execution.\n\nFunction body\n\nA function's body is an expression block. The return value of the function is the last value in the sequence\n\nfun example(): u64 {\n    let x = 0;\n    x = x + 1;\n    x // returns 'x'\n}\n\n\nSee the section below for more information on returns\n\nFor more information on expression blocks, see Move variables.\n\nNative Functions\n\nSome functions do not have a body specified, and instead have the body provided by the VM. These functions are marked native.\n\nWithout modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that native functions are used for either standard library code or for functionality needed for the given Move environment.\n\nMost native functions you will likely see are in standard library code, such as vector\n\nmodule std::vector {\n    native public fun length<Element>(v: &vector<Element>): u64;\n    ...\n}\n\nCalling\n\nWhen calling a function, the name can be specified either through an alias or fully qualified\n\nmodule a::example {\n    public fun zero(): u64 { 0 }\n}\n\nmodule b::other {\n    use a::example::{Self, zero};\n    fun call_zero() {\n        // With the `use` above all of these calls are equivalent\n        a::example::zero();\n        example::zero();\n        zero();\n    }\n}\n\n\nWhen calling a function, an argument must be given for every parameter.\n\nmodule a::example {\n    public fun takes_none(): u64 { 0 }\n    public fun takes_one(x: u64): u64 { x }\n    public fun takes_two(x: u64, y: u64): u64 { x + y }\n    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }\n}\n\nmodule b::other {\n    fun call_all() {\n        a::example::takes_none();\n        a::example::takes_one(0);\n        a::example::takes_two(0, 1);\n        a::example::takes_three(0, 1, 2);\n    }\n}\n\n\nType arguments can be either specified or inferred. Both calls are equivalent.\n\nmodule aexample {\n    public fun id<T>(x: T): T { x }\n}\n\nmodule b::other {\n    fun call_all() {\n        a::example::id(0);\n        a::example::id<u64>(0);\n    }\n}\n\n\nFor more details, see Move generics.\n\nReturning values\n\nThe result of a function, its \"return value\", is the final value of its function body. For example\n\nfun add(x: u64, y: u64): u64 {\n    x + y\n}\n\n\nThe return value here is the result of x + y.\n\nAs mentioned above, the function's body is an expression block. The expression block can sequence various statements, and the final expression in the block will be be the value of that block\n\nfun double_and_add(x: u64, y: u64): u64 {\n    let double_x = x * 2;\n    let double_y = y * 2;\n    double_x + double_y\n}\n\n\nThe return value here is the result of double_x + double_y\n\nreturn expression\n\nA function implicitly returns the value that its body evaluates to. However, functions can also use the explicit return expression:\n\nfun f1(): u64 { return 0 }\nfun f2(): u64 { 0 }\n\n\nThese two functions are equivalent. In this slightly more involved example, the function subtracts two u64 values, but returns early with 0 if the second value is too large:\n\nfun safe_sub(x: u64, y: u64): u64 {\n    if (y > x) return 0;\n    x - y\n}\n\n\nNote that the body of this function could also have been written as if (y > x) 0 else x - y.\n\nHowever return really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:\n\nuse std::vector;\nuse std::option::{Self, Option};\nfun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        if (vector::borrow(v, i) == target) return option::some(i);\n        i = i + 1\n    };\n\n    option::none()\n}\n\n\nUsing return without an argument is shorthand for return (). That is, the following two functions are equivalent:\n\nfun foo() { return }\nfun foo() { return () }\n"
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/concepts/user-interaction.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Abort and Assert - The Move Reference",
      "url": "https://move-book.com/reference/abort-and-assert.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nAbort and Assert\n\nreturn and abort are two control flow constructs that end execution, one for the current function and one for the entire transaction.\n\nMore information on return can be found in the linked section\n\nabort\n\nabort is an expression that takes one argument: an abort code of type u64. For example:\n\nabort 42\n\n\nThe abort expression halts execution the current function and reverts all changes made to state by the current transaction (note though that this guarantee must be upheld by the adapter of the specific deployment of Move). There is no mechanism for \"catching\" or otherwise handling an abort.\n\nLuckily, in Move transactions are all or nothing, meaning any changes to storage are made all at once only if the transaction succeeds. For Sui, this means no objects are modified.\n\nBecause of this transactional commitment of changes, after an abort there is no need to worry about backing out changes. While this approach is lacking in flexibility, it is incredibly simple and predictable.\n\nSimilar to return, abort is useful for exiting control flow when some condition cannot be met.\n\nIn this example, the function will pop two items off of the vector, but will abort early if the vector does not have two items\n\nuse std::vector;\n\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    if (vector::length(v) < 2) abort 42;\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nThis is even more useful deep inside a control-flow construct. For example, this function checks that all numbers in the vector are less than the specified bound. And aborts otherwise\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        if (cur > bound) abort 42;\n        i = i + 1;\n    }\n}\n\nassert\n\nassert is a builtin, macro operation provided by the Move compiler. It takes two arguments, a condition of type bool and a code of type u64\n\nassert!(condition: bool, code: u64)\n\n\nSince the operation is a macro, it must be invoked with the !. This is to convey that the arguments to assert are call-by-expression. In other words, assert is not a normal function and does not exist at the bytecode level. It is replaced inside the compiler with\n\nif (condition) () else abort code\n\n\nassert is more commonly used than just abort by itself. The abort examples above can be rewritten using assert\n\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    assert!(vector::length(v) >= 2, 42); // Now uses 'assert'\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nand\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        assert!(cur <= bound, 42); // Now uses 'assert'\n        i = i + 1;\n    }\n}\n\n\nNote that because the operation is replaced with this if-else, the argument for the code is not always evaluated. For example:\n\nassert!(true, 1 / 0)\n\n\nWill not result in an arithmetic error, it is equivalent to\n\nif (true) () else (1 / 0)\n\n\nSo the arithmetic expression is never evaluated!\n\nAbort codes in the Move VM\n\nWhen using abort, it is important to understand how the u64 code will be used by the VM.\n\nNormally, after successful execution, the Move VM, and the adapter for the specific deployment, determine the changes made to storage.\n\nIf an abort is reached, the VM will instead indicate an error. Included in that error will be two pieces of information:\n\nThe module that produced the abort (package/address value and module name)\nThe abort code.\n\nFor example\n\nmodule 0x2::example {\n    public fun aborts() {\n        abort 42\n    }\n}\n\nmodule 0x3::invoker {\n    public fun always_aborts() {\n        0x2::example::aborts()\n    }\n}\n\n\nIf a transaction, such as the function always_aborts above, calls 0x2::example::aborts, the VM would produce an error that indicated the module 0x2::example and the code 42.\n\nThis can be useful for having multiple aborts being grouped together inside a module.\n\nIn this example, the module has two separate error codes used in multiple functions\n\nmodule 0x42::example {\n\n    use std::vector;\n\n    const EEmptyVector: u64 = 0;\n    const EIndexOutOfBounds: u64 = 1;\n\n    // move i to j, move j to k, move k to i\n    public fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {\n        let n = vector::length(v);\n        assert!(n > 0, EEmptyVector);\n        assert!(i < n, EIndexOutOfBounds);\n        assert!(j < n, EIndexOutOfBounds);\n        assert!(k < n, EIndexOutOfBounds);\n\n        vector::swap(v, i, k);\n        vector::swap(v, j, k);\n    }\n\n    public fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {\n        let n = vector::length(v);\n        assert!(n > 0, EEmptyVector);\n        assert!(i < n, EIndexOutOfBounds);\n        assert!(j < n, EIndexOutOfBounds);\n        assert!(i > j, EIndexOutOfBounds);\n\n        (vector::remove<T>(v, i), vector::remove<T>(v, j))\n    }\n}\n\nThe type of abort\n\nThe abort i expression can have any type! This is because both constructs break from the normal control flow, so they never need to evaluate to the value of that type.\n\nThe following are not useful, but they will type check\n\nlet y: address = abort 0;\n\n\nThis behavior can be helpful in situations where you have a branching instruction that produces a value on some branches, but not all. For example:\n\nlet b =\n    if (x == 0) false\n    else if (x == 1) true\n    else abort 42;\n//       ^^^^^^^^ `abort 42` has type `bool`\n"
    },
    {
      "title": "Constants - The Move Reference",
      "url": "https://move-book.com/reference/constants.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nConstants\n\nConstants are a way of giving a name to shared, static values inside of a module.\n\nThe constant's value must be known at compilation. The constant's value is stored in the compiled module. And each time the constant is used, a new copy of that value is made.\n\nDeclaration\n\nConstant declarations begin with the const keyword, followed by a name, a type, and a value.\n\nconst <name>: <type> = <expression>;\n\n\nFor example\n\nmodule a::example {\n    const MY_ADDRESS: address = @a;\n\n    public fun permissioned(addr: address) {\n        assert!(addr == MY_ADDRESS, 0);\n    }\n}\n\nNaming\n\nConstants must start with a capital letter A to Z. After the first letter, constant names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nconst FLAG: bool = false;\nconst EMyErrorCode: u64 = 0;\nconst ADDRESS_42: address = @0x42;\n\n\nEven though you can use letters a to z in a constant. The general style guidelines are to use just uppercase letters A to Z, with underscores _ between each word. For error codes, we use E as a prefix and then upper camel case (also known as Pascal case) for the rest of the name, as seen in EMyErrorCode.\n\nThe current naming restriction of starting with A to Z is in place to give room for future language features.\n\nVisibility\n\npublic or public(package) constants are not currently supported. const values can be used only in the declaring module. However, as a convenience, they can be used across modules in unit tests attributes.\n\nValid Expressions\n\nCurrently, constants are limited to the primitive types bool, u8, u16, u32, u64, u128, u256, address, and vector<T>, where T is the valid type for a constant.\n\nValues\n\nCommonly, consts are assigned a simple value, or literal, of their type. For example\n\nconst MY_BOOL: bool = false;\nconst MY_ADDRESS: address = @0x70DD;\nconst BYTES: vector<u8> = b\"hello world\";\nconst HEX_BYTES: vector<u8> = x\"DEADBEEF\";\n\nComplex Expressions\n\nIn addition to literals, constants can include more complex expressions, as long as the compiler is able to reduce the expression to a value at compile time.\n\nCurrently, equality operations, all boolean operations, all bitwise operations, and all arithmetic operations can be used.\n\nconst RULE: bool = true && false;\nconst CAP: u64 = 10 * 100 + 1;\nconst SHIFTY: u8 = {\n    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)\n};\nconst HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\nconst REM: u256 =\n    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\nconst EQUAL: bool = 1 == 1;\n\n\nIf the operation would result in a runtime exception, the compiler will give an error that it is unable to generate the constant's value\n\nconst DIV_BY_ZERO: u64 = 1 / 0; // ERROR!\nconst SHIFT_BY_A_LOT: u64 = 1 << 100; // ERROR!\nconst NEGATIVE_U64: u64 = 0 - 1; // ERROR!\n\n\nAdditionally, constants can refer to other constants within the same module.\n\nconst BASE: u8 = 4;\nconst SQUARE: u8 = BASE * BASE;\n\n\nNote though, that any cycle in the constant definitions results in an error.\n\nconst A: u16 = B + 1;\nconst B: u16 = A + 1; // ERROR!\n"
    },
    {
      "title": "Vector - The Move Reference",
      "url": "https://move-book.com/reference/primitive-types/vector.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nVector\n\nvector<T> is the only primitive collection type provided by Move. A vector<T> is a homogeneous collection of T's that can grow or shrink by pushing/popping values off the \"end\".\n\nA vector<T> can be instantiated with any type T. For example, vector<u64>, vector<address>, vector<0x42::my_module::MyData>, and vector<vector<u8>> are all valid vector types.\n\nLiterals\nGeneral vector Literals\n\nVectors of any type can be created with vector literals.\n\nSyntax\tType\tDescription\nvector[]\tvector[]: vector<T> where T is any single, non-reference type\tAn empty vector\nvector[e1, ..., en]\tvector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0\tA vector with n elements (of length n)\n\nIn these cases, the type of the vector is inferred, either from the element type or from the vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be specified explicitly:\n\nvector<T>[]: vector<T>\nvector<T>[e1, ..., en]: vector<T>\n\nExample Vector Literals\n(vector[]: vector<bool>);\n(vector[0u8, 1u8, 2u8]: vector<u8>);\n(vector<u128>[]: vector<u128>);\n(vector<address>[@0x42, @0x100]: vector<address>);\n\nvector<u8> literals\n\nA common use-case for vectors in Move is to represent \"byte arrays\", which are represented with vector<u8>. These values are often used for cryptographic purposes, such as a public key or a hash result. These values are so common that specific syntax is provided to make the values more readable, as opposed to having to use vector[] where each individual u8 value is specified in numeric form.\n\nThere are currently two supported types of vector<u8> literals, byte strings and hex strings.\n\nByte Strings\n\nByte strings are quoted string literals prefixed by a b, e.g. b\"Hello!\\n\".\n\nThese are ASCII encoded strings that allow for escape sequences. Currently, the supported escape sequences are:\n\nEscape Sequence\tDescription\n\\n\tNew line (or Line feed)\n\\r\tCarriage return\n\\t\tTab\n\\\\\tBackslash\n\\0\tNull\n\\\"\tQuote\n\\xHH\tHex escape, inserts the hex byte sequence HH\nHex Strings\n\nHex strings are quoted string literals prefixed by a x, e.g. x\"48656C6C6F210A\".\n\nEach byte pair, ranging from 00 to FF, is interpreted as hex encoded u8 value. So each byte pair corresponds to a single entry in the resulting vector<u8>.\n\nExample String Literals\nfun byte_and_hex_strings() {\n    assert!(b\"\" == x\"\", 0);\n    assert!(b\"Hello!\\n\" == x\"48656C6C6F210A\", 1);\n    assert!(b\"\\x48\\x65\\x6C\\x6C\\x6F\\x21\\x0A\" == x\"48656C6C6F210A\", 2);\n    assert!(\n        b\"\\\"Hello\\tworld!\\\"\\n \\r \\\\Null=\\0\" ==\n            x\"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00\",\n        3\n    );\n}\n\nOperations\n\nvector supports the following operations via the std::vector module in the Move standard library:\n\nFunction\tDescription\tAborts?\nvector::empty<T>(): vector<T>\tCreate an empty vector that can store values of type T\tNever\nvector::singleton<T>(t: T): vector<T>\tCreate a vector of size 1 containing t\tNever\nvector::push_back<T>(v: &mut vector<T>, t: T)\tAdd t to the end of v\tNever\nvector::pop_back<T>(v: &mut vector<T>): T\tRemove and return the last element in v\tIf v is empty\nvector::borrow<T>(v: &vector<T>, i: u64): &T\tReturn an immutable reference to the T at index i\tIf i is not in bounds\nvector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T\tReturn a mutable reference to the T at index i\tIf i is not in bounds\nvector::destroy_empty<T>(v: vector<T>)\tDelete v\tIf v is not empty\nvector::append<T>(v1: &mut vector<T>, v2: vector<T>)\tAdd the elements in v2 to the end of v1\tNever\nvector::contains<T>(v: &vector<T>, e: &T): bool\tReturn true if e is in the vector v. Otherwise, returns false\tNever\nvector::swap<T>(v: &mut vector<T>, i: u64, j: u64)\tSwaps the elements at the ith and jth indices in the vector v\tIf i or j is out of bounds\nvector::reverse<T>(v: &mut vector<T>)\tReverses the order of the elements in the vector v in place\tNever\nvector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)\tReturn (true, i) if e is in the vector v at index i. Otherwise, returns (false, 0)\tNever\nvector::remove<T>(v: &mut vector<T>, i: u64): T\tRemove the ith element of the vector v, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector\tIf i is out of bounds\nvector::swap_remove<T>(v: &mut vector<T>, i: u64): T\tSwap the ith element of the vector v with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector\tIf i is out of bounds\n\nMore operations may be added over time.\n\nExample\nuse std::vector;\n\nlet mut v = vector::empty<u64>();\nvector::push_back(&mut v, 5);\nvector::push_back(&mut v, 6);\n\nassert!(*vector::borrow(&v, 0) == 5, 42);\nassert!(*vector::borrow(&v, 1) == 6, 42);\nassert!(vector::pop_back(&mut v) == 6, 42);\nassert!(vector::pop_back(&mut v) == 5, 42);\n\nDestroying and copying vectors\n\nSome behaviors of vector<T> depend on the abilities of the element type, T. For example, vectors containing elements that do not have drop cannot be implicitly discarded like v in the example above--they must be explicitly destroyed with vector::destroy_empty.\n\nNote that vector::destroy_empty will abort at runtime unless vec contains zero elements:\n\nfun destroy_any_vector<T>(vec: vector<T>) {\n    vector::destroy_empty(vec) // deleting this line will cause a compiler error\n}\n\n\nBut no error would occur for dropping a vector that contains elements with drop:\n\nfun destroy_droppable_vector<T: drop>(vec: vector<T>) {\n    // valid!\n    // nothing needs to be done explicitly to destroy the vector\n}\n\n\nSimilarly, vectors cannot be copied unless the element type has copy. In other words, a vector<T> has copy if and only if T has copy. Note that it will be implicitly copied if needed:\n\nlet x = vector[10];\nlet y = x; // implicit copy\nlet z = x;\n(y, z)\n\n\nKeep in mind, copies of large vectors can be expensive. If this is a concern, annotating the intended usage can prevent accidental copies. For example,\n\nlet x = vector[10];\nlet y = move x;\nlet z = x; // ERROR! x has been moved\n(y, z)\n\n\nFor more details see the sections on type abilities and generics.\n\nOwnership\n\nAs mentioned above, vector values can be copied only if the elements can be copied. In that case, the copy can be done via a copy or a dereference *."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/move-basics/debugging.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/programmability/cryptography-and-hashing.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/move-basics/bcs.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/programmability/witness-and-abstract-implementation.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/reference/type-abilities.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Book\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/programmability/hot-potato.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Structs - The Move Reference",
      "url": "https://move-book.com/reference/structs.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nStructs and Resources\n\nA struct is a user-defined data structure containing typed fields. Structs can store any non-reference, non-tuple type, including other structs.\n\nStructs can be used to define all \"asset\" values or unrestricted values, where the operations performed on those values can be controlled by the struct's abilities. By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped, and cannot be stored in storage. This means that all values have to have ownership transferred (linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can relax this behavior by giving the struct abilities which allow values to be copied or dropped and also to be stored in storage or to define storage schemas.\n\nDefining Structs\n\nStructs must be defined inside a module, and the struct's fields can either be named or positional:\n\nmodule a::m {\n    public struct Foo { x: u64, y: bool }\n    public struct Bar {}\n    public struct Baz { foo: Foo, }\n    //                          ^ note: it is fine to have a trailing comma\n\n    public struct PosFoo(u64, bool)\n    public struct PosBar()\n    public struct PosBaz(Foo)\n}\n\n\nStructs cannot be recursive, so the following definitions are invalid:\n\npublic struct Foo { x: Foo }\n//                     ^ ERROR! recursive definition\n\npublic struct A { b: B }\npublic struct B { a: A }\n//                   ^ ERROR! recursive definition\n\npublic struct D(D)\n//              ^ ERROR! recursive definition\n\nVisibility\n\nAs you may have noticed, all structs are declared as public. This means that the type of the struct can be referred to from any other module. However, the fields of the struct, and the ability to create or destroy the struct, are still internal to the module that defines the struct.\n\nIn the future, we plan on adding to declare structs as public(package) or as internal, much like functions.\n\nAbilities\n\nAs mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value to be used in these ways (e.g., copied, dropped, stored in an object, or used to define a storable object), structs can be granted abilities by annotating them with has <ability>:\n\nmodule a::m {\n    public struct Foo has copy, drop { x: u64, y: bool }\n}\n\n\nThe ability declaration can occur either before or after the struct's fields. However, only one or the other can be used, and not both. If declared after the struct's fields, the ability declaration must be terminated with a semicolon:\n\nmodule a::m {\n    public PreNamedAbilities has copy, drop { x: u64, y: bool }\n    public struct PostNamedAbilities { x: u64, y: bool } has copy, drop;\n    public struct PostNamedAbilitiesInvalid { x: u64, y: bool } has copy, drop\n    //                                                                        ^ ERROR! missing semicolon\n\n    public struct NamedInvalidAbilities has copy { x: u64, y: bool } has drop;\n    //                                                               ^ ERROR! duplicate ability declaration\n\n    public PrePositionalAbilities has copy, drop (u64, bool)\n    public struct PostPositionalAbilities (u64, bool) has copy, drop;\n    public struct PostPositionalAbilitiesInvalid (u64, bool) has copy, drop\n    //                                                                     ^ ERROR! missing semicolon\n    public struct InvalidAbilities has copy (u64, bool) has drop;\n    //                                                  ^ ERROR! duplicate ability declaration\n}\n\n\nFor more details, see the section on annotating a struct's abilities.\n\nNaming\n\nStructs must start with a capital letter A to Z. After the first letter, struct names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\npublic struct Foo {}\npublic struct BAR {}\npublic struct B_a_z_4_2 {}\npublic struct P_o_s_Foo()\n\n\nThis naming restriction of starting with A to Z is in place to give room for future language features. It may or may not be removed later.\n\nUsing Structs\nCreating Structs\n\nValues of a struct type can be created (or \"packed\") by indicating the struct name, followed by value for each field.\n\nFor a struct with named fields, the order of the fields does not matter, but the field name needs to be provided. For a struct with positional fields, the order of the fields must match the order of the fields in the struct definition, and it must be created using () instead of {} to enclose the parameters.\n\nmodule a::m {\n    public struct Foo has drop { x: u64, y: bool }\n    public struct Baz has drop { foo: Foo }\n    public struct Positional(u64, bool) has drop;\n\n    fun example() {\n        let foo = Foo { x: 0, y: false };\n        let baz = Baz { foo: foo };\n        // Note: positional struct values are created using parentheses and\n        // based on position instead of name.\n        let pos = Positional(0, false);\n        let pos_invalid = Positional(false, 0);\n        //                           ^ ERROR! Fields are out of order and the types don't match.\n    }\n}\n\n\nFor structs with named fields, you can use the following shorthand if you have a local variable with the same name as the field:\n\nlet baz = Baz { foo: foo };\n// is equivalent to\nlet baz = Baz { foo };\n\n\nThis is sometimes called \"field name punning\".\n\nDestroying Structs via Pattern Matching\n\nStruct values can be destroyed by binding or assigning them in patterns using similar syntax to constructing them.\n\nmodule a::m {\n    public struct Foo { x: u64, y: bool }\n    public struct Bar(Foo)\n    public struct Baz {}\n    public struct Qux()\n\n    fun example_destroy_foo() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: foo_y } = foo;\n        //        ^ shorthand for `x: x`\n\n        // two new bindings\n        //   x: u64 = 3\n        //   foo_y: bool = false\n    }\n\n    fun example_destroy_foo_wildcard() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: _ } = foo;\n\n        // only one new binding since y was bound to a wildcard\n        //   x: u64 = 3\n    }\n\n    fun example_destroy_foo_assignment() {\n        let x: u64;\n        let y: bool;\n        Foo { x, y } = Foo { x: 3, y: false };\n\n        // mutating existing variables x and y\n        //   x = 3, y = false\n    }\n\n    fun example_foo_ref() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &foo;\n\n        // two new bindings\n        //   x: &u64\n        //   y: &bool\n    }\n\n    fun example_foo_ref_mut() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &mut foo;\n\n        // two new bindings\n        //   x: &mut u64\n        //   y: &mut bool\n    }\n\n    fun example_destroy_bar() {\n        let bar = Bar(Foo { x: 3, y: false });\n        let Bar(Foo { x, y }) = bar;\n        //            ^ nested pattern\n\n        // two new bindings\n        //   x: u64 = 3\n        //   y: bool = false\n    }\n\n    fun example_destroy_baz() {\n        let baz = Baz {};\n        let Baz {} = baz;\n    }\n\n    fun example_destroy_qux() {\n        let qux = Qux();\n        let Qux() = qux;\n    }\n}\n\nAccessing Struct Fields\n\nFields of a struct can be accessed using the dot operator ..\n\nFor structs with named fields, the fields can be accessed by their name:\n\npublic struct Foo { x: u64, y: bool }\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n\n\nFor positional structs, fields can be accessed by their position in the struct definition:\n\npublic struct PosFoo(u64, bool)\nlet pos_foo = PosFoo(3, true);\nlet x = pos_foo.0;  // x == 3\nlet y = pos_foo.1;  // y == true\n\n\nAccessing struct fields without borrowing or copying them is subject to the field's ability constraints. For more details see the sections on borrowing structs and fields and reading and writing fields for more information.\n\nBorrowing Structs and Fields\n\nThe & and &mut operator can be used to create references to structs or fields. These examples include some optional type annotations (e.g., : &Foo) to demonstrate the type of operations.\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref: &Foo = &foo;\nlet y: bool = foo_ref.y;         // reading a field via a reference to the struct\nlet x_ref: &u64 = &foo.x;        // borrowing a field by extending a reference to the struct\n\nlet x_ref_mut: &mut u64 = &mut foo.x;\n*x_ref_mut = 42;            // modifying a field via a mutable reference\n\n\nIt is possible to borrow inner fields of nested structs:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar(foo);\n\nlet x_ref = &bar.0.x;\n\n\nYou can also borrow a field via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &foo;\nlet x_ref = &foo_ref.x;\n// this has the same effect as let x_ref = &foo.x\n\nReading and Writing Fields\n\nIf you need to read and copy a field's value, you can then dereference the borrowed field:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar(copy foo);\nlet x: u64 = *&foo.x;\nlet y: bool = *&foo.y;\nlet foo2: Foo = *&bar.0;\n\n\nMore canonically, the dot operator can be used to read fields of a struct without any borrowing. As is true with dereferencing, the field type must have the copy ability.\n\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n\n\nDot operators can be chained to access nested fields:\n\nlet bar = Bar(Foo { x: 3, y: true });\nlet x = baz.0.x; // x = 3;\n\n\nHowever, this is not permitted for fields that contain non-primitive types, such a vector or another struct:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar(foo);\nlet foo2: Foo = *&bar.0;\nlet foo3: Foo = bar.0; // error! must add an explicit copy with *&\n\n\nWe can mutably borrow a field to a struct to assign it a new value:\n\nlet mut foo = Foo { x: 3, y: true };\n*&mut foo.x = 42;     // foo = Foo { x: 42, y: true }\n*&mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })\n*&mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })\n*&mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })\n\n\nSimilar to dereferencing, we can instead directly use the dot operator to modify a field. And in both cases, the field type must have the drop ability.\n\nlet mut foo = Foo { x: 3, y: true };\nfoo.x = 42;     // foo = Foo { x: 42, y: true }\nfoo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })\nbar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })\nbar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })\n\n\nThe dot syntax for assignment also works via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &mut foo;\nfoo_ref.x = foo_ref.x + 1;\n\nPrivileged Struct Operations\n\nMost struct operations on a struct type T can only be performed inside the module that declares T:\n\nStruct types can only be created (\"packed\"), destroyed (\"unpacked\") inside the module that defines the struct.\nThe fields of a struct are only accessible inside the module that defines the struct.\n\nFollowing these rules, if you want to modify your struct outside the module, you will need to provide public APIs for them. The end of the chapter contains some examples of this.\n\nHowever as stated in the visibility section above, struct types are always visible to another module\n\nmodule a::m {\n    public struct Foo has drop { x: u64 }\n\n    public fun new_foo(): Foo {\n        Foo { x: 42 }\n    }\n}\n\nmodule a::n {\n    use a::m::Foo;\n\n    public struct Wrapper has drop {\n        foo: Foo\n        //   ^ valid the type is public\n\n    }\n\n    fun f1(foo: Foo) {\n        let x = foo.x;\n        //      ^ ERROR! cannot access fields of `Foo` outside of `a::m`\n    }\n\n    fun f2() {\n        let foo_wrapper = Wrapper { foo: m::new_foo() };\n        //                               ^ valid the function is public\n    }\n}\n\n\nOwnership\n\nAs mentioned above in Defining Structs, structs are by default linear and ephemeral. This means they cannot be copied or dropped. This property can be very useful when modeling real world assets like money, as you do not want money to be duplicated or get lost in circulation.\n\nmodule a::m {\n    public struct Foo { x: u64 }\n\n    public fun copying() {\n        let foo = Foo { x: 100 };\n        let foo_copy = copy foo; // ERROR! 'copy'-ing requires the 'copy' ability\n        let foo_ref = &foo;\n        let another_copy = *foo_ref // ERROR! dereference requires the 'copy' ability\n    }\n\n    public fun destroying_1() {\n        let foo = Foo { x: 100 };\n\n        // error! when the function returns, foo still contains a value.\n        // This destruction requires the 'drop' ability\n    }\n\n    public fun destroying_2(f: &mut Foo) {\n        *f = Foo { x: 100 } // error!\n                            // destroying the old value via a write requires the 'drop' ability\n    }\n}\n\n\nTo fix the example fun destroying_1, you would need to manually \"unpack\" the value:\n\nmodule a::m {\n    public struct Foo { x: u64 }\n\n    public fun destroying_1_fixed() {\n        let foo = Foo { x: 100 };\n        let Foo { x: _ } = foo;\n    }\n}\n\n\nRecall that you are only able to deconstruct a struct within the module in which it is defined. This can be leveraged to enforce certain invariants in a system, for example, conservation of money.\n\nIf on the other hand, your struct does not represent something valuable, you can add the abilities copy and drop to get a struct value that might feel more familiar from other programming languages:\n\nmodule a::m {\n    public struct Foo has copy, drop { x: u64 }\n\n    public fun run() {\n        let foo = Foo { x: 100 };\n        let foo_copy = foo;\n        //             ^ this code copies foo,\n        //             whereas `let x = move foo` would move foo\n\n        let x = foo.x;            // x = 100\n        let x_copy = foo_copy.x;  // x = 100\n\n        // both foo and foo_copy are implicitly discarded when the function returns\n    }\n}\n\nStorage\n\nStructs can be used to define storage schemas, but the details are different per deployment of Move. See the documentation for the key ability and Sui objects for more details."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/move-basics/functions.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Address - The Move Reference",
      "url": "https://move-book.com/reference/primitive-types/address.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nAddress\n\naddress is a built-in type in Move that is used to represent locations (sometimes called accounts) in storage. An address value is a 256-bit (32 byte) identifier. Move uses addresses to differentiate packages of modules, where each package has its own address and modules. Specific deployments of Move might also use the address value for storage operations.\n\nFor Sui, address is used to represent \"accounts\", and also objects via strong type wrappers (with sui::object::UID and sui::object::ID).\n\nAlthough an address is a 256 bit integer under the hood, Move addresses are intentionally opaque---they cannot be created from integers, they do not support arithmetic operations, and they cannot be modified. Specific deployments of Move might have native functions to enable some of these operations (e.g., creating an address from bytes vector<u8>), but these are not part of the Move language itself.\n\nWhile there are runtime address values (values of type address), they cannot be used to access modules at runtime.\n\nAddresses and Their Syntax\n\nAddresses come in two flavors, named or numerical. The syntax for a named address follows the same rules for any named identifier in Move. The syntax of a numerical address is not restricted to hex-encoded values, and any valid u256 numerical value can be used as an address value, e.g., 42, 0xCAFE, and 10_000 are all valid numerical address literals.\n\nTo distinguish when an address is being used in an expression context or not, the syntax when using an address differs depending on the context where it's used:\n\nWhen an address is used as an expression, the address must be prefixed by the @ character, i.e., @<numerical_value> or @<named_address_identifier>.\nOutside of expression contexts, the address may be written without the leading @ character, i.e., <numerical_value> or <named_address_identifier>.\n\nIn general, you can think of @ as an operator that takes an address from being a namespace item to being an expression item.\n\nNamed Addresses\n\nNamed addresses are a feature that allow identifiers to be used in place of numerical values in any spot where addresses are used, and not just at the value level. Named addresses are declared and bound as top level elements (outside of modules and scripts) in Move packages, or passed as arguments to the Move compiler.\n\nNamed addresses only exist at the source language level and will be fully substituted for their value at the bytecode level. Because of this, modules and module members should be accessed through the module's named address and not through the numerical value assigned to the named address during compilation. So while use my_addr::foo is equivalent to use 0x2::foo (if my_addr is assigned 0x2), it is a best practice to always use the my_addr name.\n\nExamples\n// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000001\nlet a1: address = @0x1;\n// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000042\nlet a2: address = @0x42;\n// shorthand for\n// 0x00000000000000000000000000000000000000000000000000000000DEADBEEF\nlet a3: address = @0xDEADBEEF;\n// shorthand for\n// 0x000000000000000000000000000000000000000000000000000000000000000A\nlet a4: address = @0x0000000000000000000000000000000A;\n// Assigns `a5` the value of the named address `std`\nlet a5: address = @std;\n// Any valid numerical value can be used as an address\nlet a6: address = @66;\nlet a7: address = @42_000;\n\nmodule 66::some_module {   // Not in expression context, so no @ needed\n    use 0x1::other_module; // Not in expression context so no @ needed\n    use std::vector;       // Can use a named address as a namespace item\n    ...\n}\n\nmodule std::other_module {  // Can use a named address when declaring a module\n    ...\n}\n"
    },
    {
      "title": "Integers - The Move Reference",
      "url": "https://move-book.com/reference/primitive-types/integers.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nIntegers\n\nMove supports six unsigned integer types: u8, u16, u32, u64, u128, and u256. Values of these types range from 0 to a maximum that depends on the size of the type.\n\nType\tValue Range\nUnsigned 8-bit integer, u8\t0 to 28 - 1\nUnsigned 16-bit integer, u16\t0 to 216 - 1\nUnsigned 32-bit integer, u32\t0 to 232 - 1\nUnsigned 64-bit integer, u64\t0 to 264 - 1\nUnsigned 128-bit integer, u128\t0 to 2128 - 1\nUnsigned 256-bit integer, u256\t0 to 2256 - 1\nLiterals\n\nLiteral values for these types are specified either as a sequence of digits (e.g.,112) or as hex literals, e.g., 0xFF. The type of the literal can optionally be added as a suffix, e.g., 112u8. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be u64.\n\nNumber literals can be separated by underscores for grouping and readability. (e.g.,1_234_5678, 1_000u128, 0xAB_CD_12_35).\n\nIf a literal is too large for its specified (or inferred) size range, an error is reported.\n\nExamples\n// literals with explicit annotations;\nlet explicit_u8 = 1u8;\nlet explicit_u16 = 1u16;\nlet explicit_u32 = 1u32;\nlet explicit_u64 = 2u64;\nlet explicit_u128 = 3u128;\nlet explicit_u256 = 1u256;\nlet explicit_u64_underscored = 154_322_973u64;\n\n// literals with simple inference\nlet simple_u8: u8 = 1;\nlet simple_u16: u16 = 1;\nlet simple_u32: u32 = 1;\nlet simple_u64: u64 = 2;\nlet simple_u128: u128 = 3;\nlet simple_u256: u256 = 1;\n\n// literals with more complex inference\nlet complex_u8 = 1; // inferred: u8\n// right hand argument to shift must be u8\nlet _unused = 10 << complex_u8;\n\nlet x: u8 = 38;\nlet complex_u8 = 2; // inferred: u8\n// arguments to `+` must have the same type\nlet _unused = x + complex_u8;\n\nlet complex_u128 = 133_876; // inferred: u128\n// inferred from function argument type\nfunction_that_takes_u128(complex_u128);\n\n// literals can be written in hex\nlet hex_u8: u8 = 0x1;\nlet hex_u16: u16 = 0x1BAE;\nlet hex_u32: u32 = 0xDEAD80;\nlet hex_u64: u64 = 0xCAFE;\nlet hex_u128: u128 = 0xDEADBEEF;\nlet hex_u256: u256 = 0x1123_456A_BCDE_F;\n\nOperations\nArithmetic\n\nEach of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) must be of the same type. If you need to operate over values of different types, you will need to first perform a cast. Similarly, if you expect the result of the operation to be too large for the integer type, perform a cast to a larger size before performing the operation.\n\nAll arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).\n\nSyntax\tOperation\tAborts If\n+\taddition\tResult is too large for the integer type\n-\tsubtraction\tResult is less than zero\n*\tmultiplication\tResult is too large for the integer type\n%\tmodular division\tThe divisor is 0\n/\ttruncating division\tThe divisor is 0\nBitwise\n\nThe integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.\n\nBitwise operations do not abort.\n\nSyntax\tOperation\tDescription\n&\tbitwise and\tPerforms a boolean and for each bit pairwise\n|\tbitwise or\tPerforms a boolean or for each bit pairwise\n^\tbitwise xor\tPerforms a boolean exclusive or for each bit pairwise\nBit Shifts\n\nSimilar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must always be a u8 and need not match the left side operand (the number you are shifting).\n\nBit shifts can abort if the number of bits to shift by is greater than or equal to 8, 16, 32, 64, 128 or 256 for u8, u16, u32, u64, u128 and u256 respectively.\n\nSyntax\tOperation\tAborts if\n<<\tshift left\tNumber of bits to shift by is greater than the size of the integer type\n>>\tshift right\tNumber of bits to shift by is greater than the size of the integer type\nComparisons\n\nInteger types are the only types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you must cast one of them first.\n\nComparison operations do not abort.\n\nSyntax\tOperation\n<\tless than\n>\tgreater than\n<=\tless than or equal to\n>=\tgreater than or equal to\nEquality\n\nLike all types with drop, all integer types support the \"equal\" and \"not equal\" operations. Both arguments need to be of the same type. If you need to compare integers of different types, you must cast one of them first.\n\nEquality operations do not abort.\n\nSyntax\tOperation\n==\tequal\n!=\tnot equal\n\nFor more details see the section on equality\n\nCasting\n\nInteger types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.\n\nCasts do not truncate. Casting aborts if the result is too large for the specified type.\n\nSyntax\tOperation\tAborts if\n(e as T)\tCast integer expression e into an integer type T\te is too large to represent as a T\n\nHere, the type of e must be 8, 16, 32, 64, 128 or 256 and T must be u8, u16, u32, u64, u128, or u256.\n\nFor example:\n\n(x as u8)\n(y as u16)\n(873u16 as u32)\n(2u8 as u64)\n(1 + 3 as u128)\n(4/2 + 12345 as u256)\nOwnership\n\nAs with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy."
    },
    {
      "title": "Bool - The Move Reference",
      "url": "https://move-book.com/reference/primitive-types/bool.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nBool\n\nbool is Move's primitive type for boolean true and false values.\n\nLiterals\n\nLiterals for bool are either true or false.\n\nOperations\nLogical\n\nbool supports three logical operations:\n\nSyntax\tDescription\tEquivalent Expression\n&&\tshort-circuiting logical and\tp && q is equivalent to if (p) q else false\n||\tshort-circuiting logical or\tp || q is equivalent to if (p) true else q\n!\tlogical negation\t!p is equivalent to if (p) false else true\nControl Flow\n\nbool values are used in several of Move's control-flow constructs:\n\nif (bool) { ... }\nwhile (bool) { .. }\nassert!(bool, u64)\nOwnership\n\nAs with the other scalar values built-in to the language, boolean values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy."
    },
    {
      "title": "Modules - The Move Reference",
      "url": "https://move-book.com/reference/modules.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nModules\n\nModules are the core program unit that define types along with functions that operate on these types. Struct types define the schema of Move's storage, and module functions define the rules interacting with values of those types. While modules themselves are also stored in storage, they are not accessible from within a Move program. In a blockchain environment, the modules are stored on chain in a process typically referred to as \"publishing\". After being published, entry and public functions can be invoked according to the rules of that particular Move instance.\n\nSyntax\n\nA module has the following syntax:\n\nmodule <address>::<identifier> {\n    (<use> | <type> | <function> | <constant>)*\n}\n\n\nwhere <address> is a valid address specifying the module's package.\n\nFor example:\n\nmodule 0x42::test {\n    public struct Example has copy, drop { i: u64 }\n\n    use std::debug;\n\n    const ONE: u64 = 1;\n\n    public fun print(x: u64) {\n        let sum = x + ONE;\n        let example = Example { i: sum };\n        debug::print(&sum)\n    }\n}\n\nNames\n\nThe module test_addr::test part specifies that the module test will be published under the numerical address value assigned for the name test_addr in the package settings.\n\nModules should normally be declared using named addresses (as opposed to using the numerical value directly). For example:\n\nmodule test_addr::test {\n    public struct Example has copy, drop { a: address }\n\n    friend test_addr::another_test;\n\n    public fun print() {\n        let example = Example { a: @test_addr };\n        debug::print(&example)\n    }\n}\n\n\nThese named addresses commonly match the name of the package.\n\nBecause named addresses only exist at the source language level and during compilation, named addresses will be fully substituted for their value at the bytecode level. For example if we had the following code:\n\nfun example() {\n    my_addr::m::foo(@my_addr);\n}\n\n\nand we compiled it with my_addr set to 0xC0FFEE, then it would be operationally equivalent to the following:\n\nfun example() {\n    0xC0FFEE::m::foo(@0xC0FFEE);\n}\n\n\nWhile at the source level these two different accesses are equivalent, it is a best practice to always use the named address and not the numerical value assigned to that address.\n\nModule names can start with a lowercase letter from a to z or an uppercase letter from A to Z. After the first character, module names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nmodule a::my_module {}\nmodule a::foo_bar_42 {}\n\n\nTypically, module names start with a lowercase letter. A module named my_module should be stored in a source file named my_module.move.\n\nMembers\n\nAll members inside a module block can appear in any order. Fundamentally, a module is a collection of types and functions. The use keyword refers to members from other modules. The const keyword defines constants that can be used in the functions of a module.\n\nThe friend syntax is a deprecated concept for specifying a list of trusted modules. The concept has been superseded by public(package)"
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/special-topics/coding-conventions.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/storage/README.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Page not found - The Move Book",
      "url": "https://move-book.com/concepts/object-storage.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nPage not Found\n\nYou're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.\n\nHere are the links you may be looking for:\n\nThe Move Book - the main page of the book\nThe Move Reference - the Move Language Reference\n\nRecently we updated the structure of the book and some pages have been moved or renamed. If you're looking for the old version of the book, please, see the \"archive\" branch in the repository. Though we highly recommend using the latest version of the book."
    },
    {
      "title": "Concepts - The Move Book",
      "url": "https://move-book.com/concepts/",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nConcepts\n\nIn this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a package, how to interact with it, what is an account and a transaction, and how data is stored on Sui. While this chapter is not a complete reference, and you should refer to the Sui Documentation for that, it will give you a good understanding of the basic concepts required to write Move programs on Sui."
    },
    {
      "title": "Packages - The Move Reference",
      "url": "https://move-book.com/reference/packages.html",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nPackages\n\nPackages allow Move programmers to more easily re-use code and share it across projects. The Move package system allows programmers to easily:\n\nDefine a package containing Move code;\nParameterize a package by named addresses;\nImport and use packages in other Move code and instantiate named addresses;\nBuild packages and generate associated compilation artifacts from packages; and\nWork with a common interface around compiled Move artifacts.\nPackage Layout and Manifest Syntax\n\nA Move package source directory contains a Move.toml package manifest file, a generated Move.lock file, and a set of subdirectories:\n\na_move_package\n├── Move.toml      (required)\n├── Move.lock      (generated)\n├── sources        (required)\n├── doc_templates  (optional)\n├── examples       (optional, test & dev mode)\n└── tests          (optional, test mode)\n\n\nThe directories and files labeled \"required\" must be present for a directory to be considered a Move package and built. Optional directories may be present, and if so, they will be included in the compilation process depending on the mode used to build the package. For instance, when built in \"dev\" or \"test\" modes, the tests and examples directories will also be included.\n\nGoing through each of these in turn:\n\nThe Move.toml file is the package manifest and is required for a directory to be considered a Move package. This file contains metadata about the package, such as name, dependencies, and so on.\nThe Move.lock file is generated by the Move CLI and contains the fixed build versions of the package and its dependencies. It is used to ensure consistent versions are used across different builds and that changes in dependencies are apparent as a change in this file.\nThe sources directory is required and contains the Move modules that make up the package. Modules in this directory will always be included in the compilation process.\nThe doc_templates directory can contain documentation templates that will be used when generating documentation for the package.\nThe examples directory can hold additional code to be used only for development and/or tutorials, this will not be included when compiled outside of test or dev modes.\nThe tests directory can contain Move modules that are only included when compiled in test mode or when Move unit tests are run.\nMove.toml\n\nThe Move package manifest is defined within the Move.toml file and has the following syntax. Optional fields are marked with *, + denotes one or more elements:\n\n[package]\nname = <string>\nedition* = <string>      # e.g., \"2024.alpha\" to use the Move 2024 edition,\n                         # currently in alpha. Will default to the latest stable edition if not specified.\nlicense* = <string>              # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\nauthors* = [<string>,+]  # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n# Additional fields may be added to this section by external tools. E.g., on Sui the following sections are added:\npublished-at* = \"<hex-address>\" # The address that the package is published at. Should be set after the first publication.\n\n[dependencies] # (Optional section) Paths to dependencies\n# One or more lines declaring dependencies in the following format\n\n# ##### Local Dependencies #####\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n# To resolve a version conflict and force a specific version for dependency\n# override you can use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n# To instantiate address values in a dependency, use `addr_subst`\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n# ##### Git Dependencies #####\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision must be supplied, it can be a branch, a tag, or a commit hash.\n# If no `subdir` is specified, the root of the repository is used.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n[addresses]  # (Optional section) Declares named addresses in this package\n# One or more lines declaring named addresses in the following format\n# Addresses that match the name of the package must be set to `\"0x0\"` or they will be unable to be published.\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in \"dev\" and \"test\" modes\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can e.g., introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in \"dev\" and \"test\" modes\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n<addr_name> = \"<hex_address>\" # e.g., alice = \"0xB0B\"\n\n\nAn example of a minimal package manifest:\n\n[package]\nname = \"AName\"\n\n\nAn example of a more standard package manifest that also includes the Move standard library and instantiates the named address std from the LocalDep package with the address value 0x1:\n\n[package]\nname = \"AName\"\nlicense = \"Apache 2.0\"\n\n[addresses]\naddress_to_be_filled_in = \"_\"\nspecified_address = \"0xB0B\"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = \"projects/move-awesomeness\", addr_subst = { \"std\" = \"0x1\" } }\n# Git dependency\nMoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n\n[dev-addresses] # For use when developing this module\naddress_to_be_filled_in = \"0x101010101\"\n\n\nMost of the sections in the package manifest are self explanatory, but named addresses can be a bit difficult to understand so we examine them in more detail in Named Addresses During Compilation.\n\nNamed Addresses During Compilation\n\nRecall that Move has named addresses and that named addresses cannot be declared in Move. Instead they are declared at the package level: in the manifest file (Move.toml) for a Move package you declare named addresses in the package, instantiate other named addresses, and rename named addresses from other packages within the Move package system.\n\nLet's go through each of these actions, and how they are performed in the package's manifest one-by-one:\n\nDeclaring Named Addresses\n\nLet's say we have a Move module in example_pkg/sources/A.move as follows:\n\nmodule named_addr::a {\n    public fun x(): address { @named_addr }\n}\n\n\nWe could in example_pkg/Move.toml declare the named address named_addr in two different ways. The first:\n\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n\nDeclares named_addr as a named address in the package example_pkg and that this address can be any valid address value. In particular, an importing package can pick the value of the named address named_addr to be any address it wishes. Intuitively you can think of this as parameterizing the package example_pkg by the named address named_addr, and the package can then be instantiated later on by an importing package.\n\nnamed_addr can also be declared as:\n\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"0xCAFE\"\n\n\nwhich states that the named address named_addr is exactly 0xCAFE and cannot be changed. This is useful so other importing packages can use this named address without needing to worry about the exact value assigned to it.\n\nWith these two different declaration methods, there are two ways that information about named addresses can flow in the package graph:\n\nThe former (\"unassigned named addresses\") allows named address values to flow from the importation site to the declaration site.\nThe latter (\"assigned named addresses\") allows named address values to flow from the declaration site upwards in the package graph to usage sites.\n\nWith these two methods for flowing named address information throughout the package graph the rules around scoping and renaming become important to understand.\n\nScope and Renaming of Named Addresses\n\nA named address N in a package P is in scope if:\n\nP declares a named address N; or\nA package in one of P's transitive dependencies declares the named address N and there is a dependency path in the package graph between between P and the declaring package of N with no renaming of N.\n\nAdditionally, every named address in a package is exported. Because of this and the above scoping rules each package can be viewed as coming with a set of named addresses that will be brought into scope when the package is imported, e.g., if you import example_pkg, that import will also bring the named_addr named address into scope. Because of this, if P imports two packages P1 and P2 both of which declare a named address N an issue arises in P: which \"N\" is meant when N is referred to in P? The one from P1 or P2? To prevent this ambiguity around which package a named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a package are disjoint, and provide a way to rename named addresses when the package that brings them into scope is imported.\n\nRenaming a named address when importing can be done as follows in our P, P1, and P2 example above:\n\n[package]\nname = \"P\"\n...\n[dependencies]\nP1 = { local = \"some_path_to_P1\", addr_subst = { \"P1N\" = \"N\" } }\nP2 = { local = \"some_path_to_P2\"  }\n\n\nWith this renaming N refers to the N from P2 and P1N will refer to N coming from P1:\n\nmodule N::A {\n    public fun x(): address { @P1N }\n}\n\n\nIt is important to note that renaming is not local: once a named address N has been renamed to N2 in a package P all packages that import P will not see N but only N2 unless N is reintroduced from outside of P. This is why rule (2) in the scoping rules at the start of this section specifies a \"dependency path in the package graph between between P and the declaring package of N with no renaming of N.\"\n\nInstantiating Named Addresses\n\nNamed addresses can be instantiated multiple times across the package graph as long as it is always with the same value. It is an error if the same named address (regardless of renaming) is instantiated with differing values across the package graph.\n\nA Move package can only be compiled if all named addresses resolve to a value. This presents issues if the package wishes to expose an uninstantiated named address. This is what the [dev-addresses] section solves in part. This section can set values for named addresses, but cannot introduce any named addresses. Additionally, only the [dev-addresses] in the root package are included in dev mode. For example a root package with the following manifest would not compile outside of dev mode since named_addr would be uninstantiated:\n\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n[dev-addresses]\nnamed_addr = \"0xC0FFEE\"\n\nUsage and Artifacts\n\nThe Move package system comes with a command line option as part of the CLI: sui move <command> <command_flags>. Unless a particular path is provided, all package commands will run in the current enclosing Move package. The full list of commands and flags for the Move CLI can be found by running sui move --help.\n\nArtifacts\n\nA package can be compiled using CLI commands. This will create a build directory containing build-related artifacts (including bytecode binaries, source maps, and documentation). The general layout of the build directory is as follows:\n\na_move_package\n├── BuildInfo.yaml\n├── bytecode_modules\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.mv\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.mv\n│   ...\n│   └── *.mv\n├── docs\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.md\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.md\n│   ...\n│   └── *.md\n├── source_maps\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.mvsm\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.mvsm\n│   ...\n│   └── *.mvsm\n└── sources\n    ...\n    └── *.move\n    ├── dependencies\n    │   ├── <dep_pkg_name>\n    │   │   └── *.move\n    │   ...\n    │   └──  <dep_pkg_name>\n    │       └── *.move\n    ...\n    └── *.move\n\nMove.lock\n\nThe Move.lock file is generated at the root of the Move package when the package is built. The Move.lock file contains information about your package and its build configuration, and acts as a communication layer between the Move compiler and other tools, like chain-specific command line interfaces and third-party package managers.\n\nLike the Move.toml file, the Move.lock file is a text-based TOML file. Unlike the package manifest however, the Move.lock file is not intended for you to edit directly. Processes on the toolchain, like the Move compiler, access and edit the file to read and append relevant information to it. You also must not move the file from the root, as it needs to be at the same level as the Move.toml manifest in the package.\n\nIf you are using source control for your package, it's recommended practice to check in the Move.lock file that corresponds with your desired built or published package. This ensures that every build of your package is an exact replica of the original, and that changes to the build will be apparent as changes to the Move.lock file.\n\nThe Move.lock file is a TOML file that currently contains the following fields.\n\nNote: other fields may be added to the lock file either in the future, or by third-party package package managers as well.\n\nThe [move] Section\n\nThis section contains the core information needed in the lockfile:\n\nThe version of the lockfile (needed for backwards compatibility checking, and versioning lockfile changes in the future).\nThe hash of the Move.toml file that was used to generate this lock file.\nThe hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.\nThe list of dependencies.\n[move]\nversion = <string> # Lock file version, used for backwards compatibility checking.\nmanifest_digest = <hash> # Sha3-256 hash of the Move.toml file that was used to generate this lock file.\ndeps_digest = <hash> # Sha3-256 hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.\ndependencies = { (name = <string>)* } # List of dependencies. Not present if there are no dependencies.\n\nThe [move.package] Sections\n\nAfter the Move compiler resolves each of the dependencies for the package it writes the location of the dependency to the Move.lock file. If a dependency failed to resolve, the compiler will not write the Move.lock file and the build fails. If all dependencies resolve, the Move.lock file contains the locations (local and remote) of all of the package's transitive dependencies. These will be stored in the Move.lock file in the following format:\n\n# ...\n\n[[move.package]]\nname = \"A\"\nsource = { git = \"https://github.com/b/c.git\", subdir = \"e/f\", rev = \"a1b2c3\" }\n\n[[move.package]]\nname = \"B\"\nsource = { local = \"../local-dep\" }\n\nThe [move.toolchain-version] Section\n\nAs mentioned above, additional fields may be added to the lock file by external tools. For example, the Sui package manager adds toolchain version information to the lock file that can then be used for on-chain source verification:\n\n# ...\n\n[move.toolchain-version]\ncompiler-version = <string> # The version of the Move compiler used to build the package, e.g. \"1.21.0\"\nedition = <string> # The edition of the Move language used to build the package, e.g. \"2024.alpha\"\nflavor = <string> # The flavor of the Move compiler used to build the package, e.g. \"sui\"\n"
    },
    {
      "title": "The Move Book",
      "url": "https://move-book.com/print.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n \nThe Move Book\n\nThis is the Move Book - a comprehensive guide to the Move programming language and the Sui blockchain. The book is intended for developers who are interested in learning about Move and building on Sui.\n\nThe book is in active development and a work in progress. If you have any feedback or suggestions, feel free to open an issue or a pull request on the GitHub repository.\n\nIf you're looking for The Move Reference, you can find it here.\n\nForeword\n\nThis book is dedicated to Move, a smart contract language that captures the essence of safe programming with digital assets. Move is designed around the following values:\n\nSecure by default: Insecure languages are a serious barrier both to accessible smart contract development and to mainstream adoption of digital assets. The first duty of a smart contract language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing access control checks, arithmetic overflow, ...) by construction. Any changes to Move should preserve or enhance its existing security guarantees.\n\nExpressive by nature: Move must enable programmers to write any smart contract they can imagine. But we care as much about the way it feels to write Move as we do about what Move allows you to do - the language should be rich enough that the features needed for a task are available, and minimal enough that the choice is obvious. The Move toolchain should be a productivity enhancer and a thought partner.\n\nIntuitive for all: Smart contracts are only one part of a useful application. Move should understand the broader context of its usage and design with both the smart contract developer and the application developer in mind. It should be easy for developers to learn how to read Move-managed state, build Move powered transactions, and write new Move code.\n\nThe core technical elements of Move are:\n\nSafe, familiar, and flexible abstractions for digital assets via programmable objects.\nA rich ability system (inspired by linear types) that gives programmers extreme control of how values are created, destroyed, stored, copied, and transferred.\nA module system with strong encapsulation features to enable code reuse while maintaining this control.\nDynamic fields for creating hierarchical relationships between objects.\nProgrammable transaction blocks (PTBs) to enable atomic client-side composition of Move-powered APIs.\n\nMove was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered chains in production with several more in the works. Move is an embedded language with a platform-agnostic core, which means it takes on a slightly different personality in each chain that uses it.\n\nCreating a new programming language and bootstrapping a community around it is an ambitious, long term project. A language has to be an order of magnitude better than alternatives in relevant ways to have a chance, but even then the quality of the community matters more than the technical fundamentals. Move is a young language, but it's off to a good start in terms of both differentiation and community. A small, but fanatical group of smart contract programmers and core contributors united by the Move values are pushing the boundaries of what smart contracts can do, the applications they can enable, and who can (safely) write them. If that inspires you, read on!\n\n— Sam Blackshear, creator of Move\n\nBefore we begin\n\nMove requires an environment to run and develop applications, and in this small chapter we will cover the prerequisites for the Move language: how to set up your IDE, how to install the compiler and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you can skip this chapter and proceed to the next one.\n\nInstall Sui\n\nMove is a compiled language, so you need to install a compiler to be able to write and run Move programs. The compiler is included into the Sui binary, which can be installed or downloaded using one of the methods below.\n\nDownload Binary\n\nYou can download the latest Sui binary from the releases page. The binary is available for macOS, Linux and Windows. For education purposes and development, we recommend using the mainnet version.\n\nInstall using Homebrew (MacOS)\n\nYou can install Sui using the Homebrew package manager.\n\nbrew install sui\n\nInstall using Chocolatey (Windows)\n\nYou can install Sui using the Chocolatey package manager for Windows.\n\nchoco install sui\n\nBuild using Cargo (MacOS, Linux)\n\nYou can install and build Sui locally by using the Cargo package manager (requires Rust)\n\ncargo install --git https://github.com/MystenLabs/sui.git --bin sui --branch mainnet\n\n\nMake sure that your system has the latest Rust versions with the command below.\n\nrustup update stable\n\nTroubleshooting\n\nFor troubleshooting the installation process, please refer to the Install Sui Guide.\n\nSet up your IDE\n\nThere are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide basic features like syntax highlighting and error messages, though they differ in their additional features. Whatever IDE you choose, you'll need to use the terminal to run the Move CLI.\n\nIntelliJ Plugin does not support Move 2024 edition, some syntax won't get highlighted.\n\nVSCode\nVSCode is a free and open source IDE from Microsoft.\nMove (Extension) is a language server extension for Move maintained by MystenLabs.\nMove Syntax a simple syntax highlighting extension for Move by Damir Shamanaev.\nIntelliJ IDEA\nIntelliJ IDEA is a commercial IDE from JetBrains.\nMove Language Plugin provides a Move language extension for IntelliJ IDEA by Pontem Network.\nEmacs\nEmacs is a free and open source text editor.\nmove-mode is a Move mode for Emacs by Ashok Menon.\nGithub Codespaces\n\nThe Web-based IDE from Github can be run right in the browser and provides almost a full-featured VSCode experience.\n\nGithub Codespaces\nMove Syntax is also available in the extensions marketplace.\nMove 2024\n\nMove 2024 is the new edition of the Move language maintained by Mysten Labs. All of the examples in this book are written in Move 2024. If you're used to the pre-2024 version of Move, please, refer to the Move 2024 Migration Guide to learn about the changes and improvements in the new edition.\n\nHello, World!\n\nIn this chapter, you will learn how to create a new package, write a simple module, compile it, and run tests with the Move CLI. Make sure you have installed Sui and set up your IDE environment. Run the command below to test if Sui has been installed correctly.\n\n# It should print the client version. E.g. sui-client 1.22.0-036299745.\nsui client --version\n\n\nMove CLI is a command-line interface for the Move language; it is built into the Sui binary and provides a set of commands to manage packages, compile and test code.\n\nThe structure of the chapter is as follows:\n\nCreate a New Package\nDirectory Structure\nCompiling the Package\nRunning Tests\nCreate a New Package\n\nTo create a new program, we will use the sui move new command followed by the name of the application. Our first program will be called hello_world.\n\nNote: In this and other chapters, if you see code blocks with lines starting with $ (dollar sign), it means that the following command should be run in a terminal. The sign should not be included. It's a common way of showing commands in terminal environments.\n\n$ sui move new hello_world\n\n\nThe sui move command gives access to the Move CLI - a built-in compiler, test runner and a utility for all things Move. The new command followed by the name of the package will create a new package in a new folder. In our case, the folder name is \"hello_world\".\n\nWe can view the contents of the folder to see that the package was created successfully.\n\n$ ls -l hello_world\nMove.toml\nsources\ntests\n\nDirectory Structure\n\nMove CLI will create a scaffold of the application and pre-create the directory structure and all necessary files. Let's see what's inside.\n\nhello_world\n├── Move.toml\n├── sources\n│   └── hello_world.move\n└── tests\n    └── hello_world_tests.move\n\nManifest\n\nThe Move.toml file, known as the package manifest, contains definitions and configuration settings for the package. It is used by the Move Compiler to manage package metadata, fetch dependencies, and register named addresses. We will explain it in detail in the Concepts chapter.\n\nBy default, the package features one named address - the name of the package.\n\n[addresses]\nhello_world = \"0x0\"\n\nSources\n\nThe sources/ directory contains the source files. Move source files have .move extension, and are typically named after the module defined in the file. For example, in our case, the file name is hello_world.move and the Move CLI has already placed commented out code inside:\n\n/*\n/// Module: hello_world\nmodule hello_world::hello_world {\n\n}\n*/\n\n\nThe /* and */ are the comment delimiters in Move. Everything in between is ignored by the compiler and can be used for documentation or notes. We explain all ways to comment the code in the Basic Syntax.\n\nThe commented out code is a module definition, it starts with the keyword module followed by a named address (or an address literal), and the module name. The module name is a unique identifier for the module and has to be unique within the package. The module name is used to reference the module from other modules or transactions.\n\nTests\n\nThe tests/ directory contains package tests. The compiler excludes these files in the regular build process but uses them in test and dev modes. The tests are written in Move and are marked with the #[test] attribute. Tests can be grouped in a separate module (then it's usually called module_name_tests.move), or inside the module they're testing.\n\nModules, imports, constants and functions can be annotated with #[test_only]. This attribute is used to exclude modules, functions or imports from the build process. This is useful when you want to add helpers for your tests without including them in the code that will be published on chain.\n\nThe hello_world_tests.move file contains a commented out test module template:\n\n/*\n#[test_only]\nmodule hello_world::hello_world_tests {\n    // uncomment this line to import the module\n    // use hello_world::hello_world;\n\n    const ENotImplemented: u64 = 0;\n\n    #[test]\n    fun test_hello_world() {\n        // pass\n    }\n\n    #[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]\n    fun test_hello_world_fail() {\n        abort ENotImplemented\n    }\n}\n*/\n\nOther Folders\n\nAdditionally, Move CLI supports the examples/ folder. The files there are treated similarly to the ones placed under the tests/ folder - they're only built in the test and dev modes. They are to be examples of how to use the package or how to integrate it with other packages. The most popular use case is for documentation purposes and library packages.\n\nCompiling the Package\n\nMove is a compiled language, and as such, it requires the compilation of source files into Move Bytecode. It contains only necessary information about the module, its members, and types, and excludes comments and some identifiers (for example, for constants).\n\nTo demonstrate these features, let's replace the contents of the sources/hello_world.move file with the following:\n\n/// The module `hello_world` under named address `hello_world`.\n/// The named address is set in the `Move.toml`.\nmodule hello_world::hello_world {\n    // Imports the `String` type from the Standard Library\n    use std::string::String;\n\n    /// Returns the \"Hello, World!\" as a `String`.\n    public fun hello_world(): String {\n        b\"Hello, World!\".to_string()\n    }\n}\n\n\nDuring compilation, the code is built, but not run. A compiled package only includes functions that can be called by other modules or in a transaction. We will explain these concepts in the Concepts chapter. But now, let's see what happens when we run the sui move build.\n\n# run from the `hello_world` folder\n$ sui move build\n\n# alternatively, if you didn't `cd` into it\n$ sui move build --path hello_world\n\n\nIt should output the following message on your console.\n\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\n\n\nDuring the compilation, Move Compiler automatically creates a build folder where it places all fetched and compiled dependencies as well as the bytecode for the modules of the current package.\n\nIf you're using a versioning system, such as Git, build folder should be ignored. For example, you should use a .gitignore file and add build to it.\n\nRunning Tests\n\nBefore we get to testing, we should add a test. Move Compiler supports tests written in Move and provides the execution environment. The tests can be placed in both the source files and in the tests/ folder. Tests are marked with the #[test] attribute and are automatically discovered by the compiler. We explain tests in depth in the Testing section.\n\nReplace the contents of the tests/hello_world_tests.move with the following content:\n\n#[test_only]\nmodule hello_world::hello_world_tests {\n    use hello_world::hello_world;\n\n    #[test]\n    fun test_hello_world() {\n        assert!(hello_world::hello_world() == b\"Hello, World!\".to_string(), 0);\n    }\n}\n\n\nHere we import the hello_world module, and call its hello_world function to test that the output is indeed the string \"Hello, World!\". Now, that we have tests in place, let's compile the package in the test mode and run tests. Move CLI has the test command for this:\n\n$ sui move test\n\n\nThe output should be similar to the following:\n\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\nRunning Move unit tests\n[ PASS    ] 0x0::hello_world_tests::test_hello_world\nTest result: OK. Total tests: 1; passed: 1; failed: 0\n\n\nIf you're running the tests outside of the package folder, you can specify the path to the package:\n\n$ sui move test --path hello_world\n\n\nYou can also run a single or multiple tests at once by specifying a string. All the tests names containing the string will be run:\n\n$ sui move test test_hello\n\nNext Steps\n\nIn this section, we explained the basics of a Move package: its structure, the manifest, the build, and test flows. On the next page, we will write an application and see how the code is structured and what the language can do.\n\nFurther Reading\nPackage Manifest section\nPackage in The Move Reference\nHello, Sui!\n\nIn the previous section we created a new package and demonstrated the basic flow of creating, building, and testing a Move package. In this section, we will write a simple application that uses the storage model and can be interacted with. To do this, we will create a simple todo list application.\n\nCreate a New Package\n\nFollowing the same flow as in Hello, World!, we will create a new package called todo_list.\n\n$ sui move new todo_list\n\nAdd the code\n\nTo speed things up and focus on the application logic, we will provide the code for the todo list application. Replace the contents of the sources/todo_list.move file with the following code:\n\nNote: while the contents may seem overwhelming at first, we will break it down in the following sections. Try to focus on what's at hand right now.\n\n/// Module: todo_list\nmodule todo_list::todo_list {\n    use std::string::String;\n\n    /// List of todos. Can be managed by the owner and shared with others.\n    public struct TodoList has key, store {\n        id: UID,\n        items: vector<String>\n    }\n\n    /// Create a new todo list.\n    public fun new(ctx: &mut TxContext): TodoList {\n        let list = TodoList {\n            id: object::new(ctx),\n            items: vector[]\n        };\n\n        (list)\n    }\n\n    /// Add a new todo item to the list.\n    public fun add(list: &mut TodoList, item: String) {\n        list.items.push_back(item);\n    }\n\n    /// Remove a todo item from the list by index.\n    public fun remove(list: &mut TodoList, index: u64): String {\n        list.items.remove(index)\n    }\n\n    /// Delete the list and the capability to manage it.\n    public fun delete(list: TodoList) {\n        let TodoList { id, items: _ } = list;\n        id.delete();\n    }\n\n    /// Get the number of items in the list.\n    public fun length(list: &TodoList): u64 {\n        list.items.length()\n    }\n}\n\nBuild the package\n\nTo make sure that we did everything correctly, let's build the package by running the sui move build command. If everything is correct, you should see the output similar to the following:\n\n$ sui move build\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\n\n\nIf there are no errors following this output, you have successfully built the package. If there are errors, make sure that:\n\nThe code is copied correctly\nThe file name and the package name is correct\n\nThere are not many other reasons for the code to fail at this stage. But if you are still having issues, try looking up the structure of the package in this location.\n\nSet up an account\n\nTo publish and interact with the package, we need to set up an account. For the sake of simplicity and demonstration purposes, we will use sui devnet environment.\n\nIf you already have an account set up, you can skip this step.\n\nIf you are doing it for the first time, you will need to create a new account. To do this, run the sui client command, then the CLI will prompt you with multiple questions. The answers are marked below with >:\n\n$ sui client\nConfig file [\"/path/to/home/.sui/sui_config/client.yaml\"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?\n> y\nSui Full node server URL (Defaults to Sui Testnet if not specified) :\n>\nSelect key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):\n> 0\n\n\nAfter you have answered the questions, the CLI will generate a new keypair and save it to the configuration file. You can now use this account to interact with the network.\n\nTo check that we have the account set up correctly, run the sui client active-address command:\n\n$ sui client active-address\n0x....\n\n\nThe command will output the address of your account, it starts with 0x followed by 64 characters.\n\nRequesting Coins\n\nIn devnet and testnet environments, the CLI provides a way to request coins to your account, so you can interact with the network. To request coins, run the sui client faucet command:\n\n$ sui client faucet\nRequest successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.\n\n\nAfter waiting a little bit, you can check that the Coin object was sent to your account by running the sui client balance command:\n\n$ sui client balance\n╭────────────────────────────────────────╮\n│ Balance of coins owned by this address │\n├────────────────────────────────────────┤\n│ ╭──────────────────────────────────╮   │\n│ │ coin  balance (raw)  balance     │   │\n│ ├──────────────────────────────────┤   │\n│ │ Sui   1000000000    1.00 SUI     │   │\n│ ╰──────────────────────────────────╯   │\n╰────────────────────────────────────────╯\n\n\nAlternatively, you can query objects owned by your account, by running the sui client objects command. The actual output will be different, because the object ID is unique, and so is digest, but the structure will be similar:\n\n$ sui client objects\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │\n│ │ version    │  4                                                                   │ │\n│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                            │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n\n\nNow that we have the account set up and the coins in the account, we can interact with the network. We will start by publishing the package to the network.\n\nPublish\n\nTo publish the package to the network, we will use the sui client publish command. The command will automatically build the package and use its bytecode to publish in a single transaction.\n\nWe are using the --gas-budget argument during publishing. It specifies how much gas we are willing to spend on the transaction. We won't touch on this topic in this section, but it's important to know that every transaction in Sui costs gas, and the gas is paid in SUI coins.\n\nThe gas-budget is specified in MISTs. 1 SUI equals 10^9 MISTs. For the sake of demonstration, we will use 100,000,000 MISTs, which is 0.1 SUI.\n\n# run this from the `todo_list` folder\n$ sui client publish --gas-budget 100000000\n\n# alternatively, you can specify path to the package\n$ sui client publish --gas-budget 100000000 todo_list\n\n\nThe output of the publish command is rather lengthy, so we will show and explain it in parts.\n\n$ sui client publish --gas-budget 100000000\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\nSuccessfully verified dependencies on-chain against source.\nTransaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW\n\n\nAs you can see, when we run the publish command, the CLI first builds the package, then verifies the dependencies on-chain, and finally publishes the package. The output of the command is the transaction digest, which is a unique identifier of the transaction and can be used to query the transaction status.\n\nTransaction Data\n\nThe section titled TransactionData contains the information about the transaction we just sent. It features fields like sender, which is your address, the gas_budget set with the --gas-budget argument, and the Coin we used for payment. It also prints the Commands that were run by the CLI. In this example, the commands Publish and TransferObject were run - the latter transfers a special object UpgradeCap to the sender.\n\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │\n│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │\n│ Gas Budget: 100000000 MIST                                                                                   │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │\n│  │ Version: 7                                                                                                │\n│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\" │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │\n│ │ Commands                                                                │                                  │\n│ ├─────────────────────────────────────────────────────────────────────────┤                                  │\n│ │ 0  Publish:                                                             │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Dependencies:                                                        │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │\n│ │  └                                                                      │                                  │\n│ │                                                                         │                                  │\n│ │ 1  TransferObjects:                                                     │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Arguments:                                                           │                                  │\n│ │  │   Result 0                                                           │                                  │\n│ │  │ Address: Input  0                                                    │                                  │\n│ │  └                                                                      │                                  │\n│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nTransaction Effects\n\nTransaction Effects contains the status of the transaction, the changes that the transaction made to the state of the network and the objects involved in the transaction.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 411                                                                               │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │\n│  │ Owner: Immutable                                                                               │\n│  │ Version: 1                                                                                     │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 10404400 MIST                                                                    │\n│    Computation Cost: 1000000 MIST                                                                 │\n│    Storage Rebate: 978120 MIST                                                                    │\n│    Non-refundable Storage Fee: 9880 MIST                                                          │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │\n│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nEvents\n\nIf there were any events emitted, you would see them in this section. Our package does not use events, so the section is empty.\n\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n\nObject Changes\n\nThese are the changes to objects that transaction has made. In our case, we have created a new UpgradeCap object which is a special object that allows the sender to upgrade the package in the future, mutated the Gas object, and published a new package. Packages are also objects on Sui.\n\n╭──────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                   │\n├──────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::package::UpgradeCap                                                          │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │\n│  └──                                                                                             │\n│ Mutated Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │\n│  └──                                                                                             │\n│ Published Objects:                                                                               │\n│  ┌──                                                                                             │\n│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │\n│  │ Version: 1                                                                                    │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │\n│  │ Modules: todo_list                                                                            │\n│  └──                                                                                             │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nBalance Changes\n\nThis last section contains changes to SUI Coins, in our case, we have spent around 0.015 SUI, which in MIST is 10,500,000. You can see it under the amount field in the output.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Balance Changes                                                                                   │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: -10426280                                                                              │\n│  └──                                                                                              │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nAlternative Output\n\nIt is possible to specify the --json flag during publishing to get the output in JSON format. This is useful if you want to parse the output programmatically or store it for later use.\n\n$ sui client publish --gas-budget 100000000 --json\n\nUsing the Results\n\nAfter the package is published on chain, we can interact with it. To do this, we need to find the address (object ID) of the package. It's under the Published Objects section of the Object Changes output. The address is unique for each package, so you will need to copy it from the output.\n\nIn this example, the address is:\n\n0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\n\n\nNow that we have the address, we can interact with the package. In the next section, we will show how to interact with the package by sending transactions.\n\nSending Transactions\n\nTo demonstrate the interaction with the todo_list package, we will send a transaction to create a new list and add an item to it. Transactions are sent via the sui client ptb command, it allows using the Transaction Blocks at full capacity. The command may look big and complex, but we go through it step by step.\n\nPrepare the Variables\n\nBefore we construct the command, let's store the values we will use in the transaction. Replace the 0x4.... with the address of the package you have published. And MY_ADDRESS variable will be automatically set to your address from the CLI output.\n\n$ export PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\n$ export MY_ADDRESS=$(sui client active-address)\n\nBuilding the Transaction in CLI\n\nNow to building an actual transaction. The transaction will consist of two parts: we will call the new function in the todo_list package to create a new list, and then we will transfer the list object to our account. The transaction will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--assign sender @$MY_ADDRESS \\\n--move-call $PACKAGE_ID::todo_list::new \\\n--assign list \\\n--transfer-objects \"[list]\" sender\n\n\nIn this command, we are using the ptb subcommand to build a transaction. Parameters that follow it define the actual commands and actions that the transaction will perform. The first two calls we make are utility calls to set the sender address to the command inputs and set the gas budget for the transaction.\n\n# sets the gas budget for the transaction\n--gas-budget 100000000 \\n\n# registers a variable \"sender=@...\"\n--assign sender @$MY_ADDRESS \\n\n\n\nThen we perform the actual call to a function in the package. We use the --move-call followed by the package ID, the module name, and the function name. In this case, we are calling the new function in the todo_list package.\n\n# calls the \"new\" function in the \"todo_list\" package under the $PACKAGE_ID address\n--move-call $PACKAGE_ID::todo_list::new\n\n\nThe function that we defined actually returns a value, which we want need to store. We use the --assign command to give a name to the returned value. In this case, we are calling it list. And then we transfer the object to our account.\n\n--move-call $PACKAGE_ID::todo_list::new \\\n# assigns the result of the \"new\" function to the \"list\" variable (from the previous step)\n--assign list \\\n# transfers the object to the sender\n--transfer-objects \"[list]\" sender\n\n\nOnce the command is constructed, you can run it in the terminal. If everything is correct, you should see the output similar to the one we had in previous sections. The output will contain the transaction digest, the transaction data, and the transaction effects.\n\nSpoiler: Full transaction output\n\nThe section that we want to focus on is the \"Object Changes\". More specifically, the \"Created Objects\" part of it. It contains the object ID, the type and the version of the TodoList that you have created. We will use this object ID to interact with the list.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                        │\n├───────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                      │\n│  ┌──                                                                                                  │\n│  │ ObjectID: 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                       │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │\n│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │\n│  │ Version: 22                                                                                        │\n│  │ Digest: HyWdUpjuhjLY38dLpg6KPHQ3bt4BqQAbdF5gB8HQdEqG                                               │\n│  └──                                                                                                  │\n│ Mutated Objects:                                                                                      │\n│  ┌──                                                                                                  │\n│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │\n│  │ Version: 22                                                                                        │\n│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                               │\n│  └──                                                                                                  │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\nIn this example the object ID is 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553. And the owner should be your account address. We achieved this by transferring the object to the sender in the last command of the transaction.\n\nAnother way to test that you have successfully created the list is to check the account objects.\n\n$ sui client objects\n\n\nIt should have an object that looks similar to this:\n\n╭  ...                                                                                  ╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │\n│ │ version    │  22                                                                  │ │\n│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │\n│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n|  ...                                                                                  |\n\nPassing Objects to Functions\n\nThe TodoList that we created in the previous step is an object that you can interact with as its owner. You can call functions defined in the todo_list module on this object. To demonstrate this, we will add an item to the list. First, we will add just one item, and in the second transaction we will add 3 and remove another one.\n\nDouble check that you have variables set up from the previous step, and then add one more variable for the list object.\n\n$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\n\n\nNow we can construct the transaction to add an item to the list. The command will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish the Hello, Sui chapter'\"\n\n\nIn this command, we are calling the add function in the todo_list package. The function takes two arguments: the list object and the item to add. The item is a string, so we need to wrap it in single quotes. The command will add the item to the list.\n\nIf everything is correct, you should see the output similar to the one we had in previous sections. Now you can check the list object to see if the item was added.\n\n$ sui client object $LIST_ID\n\n\nThe output should contain the item that you have added.\n\n╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │\n│ version       │  24                                                                                                               │\n│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │\n│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │\n│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │\n│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │\n│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │\n│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │\n│ storageRebate │  1558000                                                                                                          │\n│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │\n│               │ │ dataType          │  moveObject                                                                               │ │\n│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │\n│               │ │ hasPublicTransfer │  true                                                                                     │ │\n│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │\n│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │\n│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │\n│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │\n│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │\n│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │\n│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │\n│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │\n│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │\n╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\nA JSON representation of the object can be obtained by adding the --json flag to the command.\n\n$ sui client object $LIST_ID --json\n\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"24\",\n  \"digest\": \"FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1\",\n  \"storageRebate\": \"1558000\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\"Finish the Hello, Sui chapter\"]\n    }\n  }\n}\n\nChaining Commands\n\nYou can chain multiple commands in a single transaction. This shows the power of Transaction Blocks! Using the same list object, we will add three more items and remove one. The command will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish Concepts chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Read the Move Basics chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Learn about Object Model'\" \\\n--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0\n\n\nIf previous commands were successful, this one should not be any different. You can check the list object to see if the items were added and removed. The JSON representation is a bit more readable!\n\nsui client object $LIST_ID --json\n\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"25\",\n  \"digest\": \"EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY\",\n  \"storageRebate\": \"1922800\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\n        \"Finish Concepts chapter\",\n        \"Read the Move Basics chapter\",\n        \"Learn about Object Model\"\n      ]\n    }\n  }\n}\n\n\nCommands don't have to be in the same package or operate on the same object. Within a single transaction block, you can interact with multiple packages and objects. This is a powerful feature that allows you to build complex interactions on-chain!\n\nConclusion\n\nIn this guide, we have shown how to publish a package on the Move blockchain and interact with it using the Sui CLI. We have demonstrated how to create a new list object, add items to it, and remove them. We have also shown how to chain multiple commands in a single transaction block. This guide should give you a good starting point for building your own applications on the Sui blockchain!\n\nConcepts\n\nIn this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a package, how to interact with it, what is an account and a transaction, and how data is stored on Sui. While this chapter is not a complete reference, and you should refer to the Sui Documentation for that, it will give you a good understanding of the basic concepts required to write Move programs on Sui.\n\nPackage\n\nMove is a language for writing smart contracts - programs that are stored and run on the blockchain. A single program is organized into a package. A package is published on the blockchain and is identified by an address. A published package can be interacted with by sending transactions calling its functions. It can also act as a dependency for other packages.\n\nTo create a new package, use the sui move new command. To learn more about the command, run sui move new --help.\n\nPackage consists of modules - separate scopes that contain functions, types, and other items.\n\npackage 0x...\n    module a\n        struct A1\n        fun hello_world()\n    module b\n        struct B1\n        fun hello_package()\n\nPackage Structure\n\nLocally, a package is a directory with a Move.toml file and a sources directory. The Move.toml file - called the \"package manifest\" - contains metadata about the package, and the sources directory contains the source code for the modules. Package usually looks like this:\n\nsources/\n    my_module.move\n    another_module.move\n    ...\ntests/\n    ...\nexamples/\n    using_my_module.move\nMove.toml\n\n\nThe tests directory is optional and contains tests for the package. Code placed into the tests directory is not published on-chain and is only availably in tests. The examples directory can be used for code examples, and is also not published on-chain.\n\nPublished Package\n\nDuring development, package doesn't have an address and it needs to be set to 0x0. Once a package is published, it gets a single unique address on the blockchain containing its modules' bytecode. A published package becomes immutable and can be interacted with by sending transactions.\n\n0x...\n    my_module: <bytecode>\n    another_module: <bytecode>\n\nLinks\nPackage Manifest\nAddress\nPackages in the Move Reference.\nPackage Manifest\n\nThe Move.toml is a manifest file that describes the package and its dependencies. It is written in TOML format and contains multiple sections, the most important of which are [package], [dependencies] and [addresses].\n\n[package]\nname = \"my_project\"\nversion = \"0.0.0\"\nedition = \"2024\"\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n[addresses]\nstd =  \"0x1\"\nalice = \"0xA11CE\"\n\n[dev-addresses]\nalice = \"0xB0B\"\n\nSections\nPackage\n\nThe [package] section is used to describe the package. None of the fields in this section are published on chain, but they are used in tooling and release management; they also specify the Move edition for the compiler.\n\nname - the name of the package when it is imported;\nversion - the version of the package, can be used in release management;\nedition - the edition of the Move language; currently, the only valid value is 2024.\nDependencies\n\nThe [dependencies] section is used to specify the dependencies of the project. Each dependency is specified as a key-value pair, where the key is the name of the dependency, and the value is the dependency specification. The dependency specification can be a git repository URL or a path to the local directory.\n\n# git repository\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n# local directory\nMyPackage = { local = \"../my-package\" }\n\n\nPackages also import addresses from other packages. For example, the Sui dependency adds the std and sui addresses to the project. These addresses can be used in the code as aliases for the addresses.\n\nResolving version conflicts with override\n\nSometimes dependencies have conflicting versions of the same package. For example, if you have two dependencies that use different versions of the Sui package, you can override the dependency in the [dependencies] section. To do so, add the override field to the dependency. The version of the dependency specified in the [dependencies] section will be used instead of the one specified in the dependency itself.\n\n[dependencies]\nSui = { override = true, git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\nDev-dependencies\n\nIt is possible to add [dev-dependencies] section to the manifest. It is used to override dependencies in the dev and test modes. For example, if you want to use a different version of the Sui package in the dev mode, you can add a custom dependency specification to the [dev-dependencies] section.\n\nAddresses\n\nThe [addresses] section is used to add aliases for the addresses. Any address can be specified in this section, and then used in the code as an alias. For example, if you add alice = \"0xA11CE\" to this section, you can use alice as 0xA11CE in the code.\n\nDev-addresses\n\nThe [dev-addresses] section is the same as [addresses], but only works for the test and dev modes. Important to note that it is impossible to introduce new aliases in this section, only override the existing ones. So in the example above, if you add alice = \"0xB0B\" to this section, the alice address will be 0xB0B in the test and dev modes, and 0xA11CE in the regular build.\n\nTOML styles\n\nThe TOML format supports two styles for tables: inline and multiline. The examples above are using the inline style, but it is also possible to use the multiline style. You wouldn't want to use it for the [package] section, but it can be useful for the dependencies.\n\n# Inline style\n[dependencies]\nSui = { override = true, git = \"\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nMyPackage = { local = \"../my-package\" }\n\n# Multiline style\n[dependencies.Sui]\noverride = true\ngit = \"https://github.com/MystenLabs/sui.git\"\nsubdir = \"crates/sui-framework/packages/sui-framework\"\nrev = \"framework/testnet\"\n\n[dependencies.MyPackage]\nlocal = \"../my-package\"\n\nFurther Reading\nPackages in the Move Reference.\nAddress\n\nAddress is a unique identifier of a location on the blockchain. It is used to identify packages, accounts, and objects. Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed with 0x. Addresses are case insensitive.\n\n0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1\n\n\nThe address above is an example of a valid address. It is 64 characters long (32 bytes) and prefixed with 0x.\n\nSui also has reserved addresses that are used to identify standard packages and objects. Reserved addresses are typically simple values that are easy to remember and type. For example, the address of the Standard Library is 0x1. Addresses, shorter than 32 bytes, are padded with zeros to the left.\n\n0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001\n\n\nHere are some examples of reserved addresses:\n\n0x1 - address of the Sui Standard Library (alias std)\n0x2 - address of the Sui Framework (alias sui)\n0x6 - address of the system Clock object\n\nYou can find all reserved addresses in the Appendix B.\n\nFurther reading\nAddress type in Move\nAccount\n\nAn account is a way to identify a user. An account is generated from a private key, and is identified by an address. An account can own objects, and can send transactions. Every transaction has a sender, and the sender is identified by an address.\n\nSui supports multiple cryptographic algorithms for account generation. The two supported curves are ed25519, secp256k1, and there is also a special way of generating an account - zklogin. The cryptographic agility - the unique feature of Sui - allows for flexibility in the account generation.\n\nFurther Reading\nCryptography in Sui in the Sui Blog\nKeys and Addresses in the Sui Docs\nSignatures in the Sui Docs\nTransaction\n\nTransaction is a fundamental concept in the blockchain world. It is a way to interact with a blockchain. Transactions are used to change the state of the blockchain, and they are the only way to do so. In Move, transactions are used to call functions in a package, deploy new packages, and upgrade existing ones.\n\nTransaction Structure\n\nEvery transaction explicitly specifies the objects it operates on!\n\nTransactions consist of:\n\na sender - the account that signs the transaction;\na list (or a chain) of commands - the operations to be executed;\ncommand inputs - the arguments for the commands: either pure - simple values like numbers or strings, or object - objects that the transaction will access;\na gas object - the Coin object used to pay for the transaction;\ngas price and budget - the cost of the transaction;\nCommands\n\nSui transactions may consist of multiple commands. Each command is a single built-in command (like publishing a package) or a call to a function in an already published package. The commands are executed in the order they are listed in the transaction, and they can use the results of the previous commands, forming a chain. Transaction either succeeds or fails as a whole.\n\nSchematically, a transaction looks like this (in pseudo-code):\n\nInputs:\n- sender = 0xa11ce\n\nCommands:\n- payment = SplitCoins(Gas, [ 1000 ])\n- item = MoveCall(0xAAA::market::purchase, [ payment ])\n- TransferObjects(item, sender)\n\n\nIn this example, the transaction consists of three commands:\n\nSplitCoins - a built-in command that splits a new coin from the passed object, in this case, the Gas object;\nMoveCall - a command that calls a function purchase in a package 0xAAA, module market with the given arguments - the payment object;\nTransferObjects - a built-in command that transfers the object to the recipient.\nTransaction Effects\n\nTransaction effects are the changes that a transaction makes to the blockchain state. More specifically, a transaction can change the state in the following ways:\n\nuse the gas object to pay for the transaction;\ncreate, update, or delete objects;\nemit events;\n\nThe result of the executed transaction consists of different parts:\n\nTransaction Digest - the hash of the transaction which is used to identify the transaction;\nTransaction Data - the inputs, commands and gas object used in the transaction;\nTransaction Effects - the status and the \"effects\" of the transaction, more specifically: the status of the transaction, updates to objects and their new versions, the gas object used, the gas cost of the transaction, and the events emitted by the transaction;\nEvents - the custom events emitted by the transaction;\nObject Changes - the changes made to the objects, including the change of ownership;\nBalance Changes - the changes made to the aggregate balances of the account involved in the transaction;\nMove Basics\n\nThis chapter is all about the basic syntax of the Move language. It covers the basics of the language, such as types, modules, functions, and control flow. It focuses on the language without a storage model or a blockchain, and explains the essential concepts of the language. To learn features specific to Sui, such as storage functions and abilities, refer to the Using Objects chapter, however, it is recommended to start with this chapter first.\n\nModule\n\nModule is the base unit of code organization in Move. Modules are used to group and isolate code, and all of the members of the module are private to the module by default. In this section you will learn how to define a module, how to declare its members and how to access them from other modules.\n\nModule declaration\n\nModules are declared using the module keyword followed by the package address, module name and the module body inside the curly braces {}. The module name should be in snake_case - all lowercase letters with underscores between words. Modules names must be unique in the package.\n\nUsually, a single file in the sources/ folder contains a single module. The file name should match the module name - for example, a donut_shop module should be stored in the donut_shop.move file. You can read more about coding conventions in the Coding Conventions section.\n\nmodule book::my_module {\n    // module body\n}\n\n\nStructs, functions, constants and imports all part of the module:\n\nStructs\nFunctions\nConstants\nImports\nStruct Methods\nAddress / Named address\n\nModule address can be specified as both: an address literal (does not require the @ prefix) or a named address specified in the Package Manifest. In the example below, both are identical because there's a book = \"0x0\" record in the [addresses] section of the Move.toml.\n\nmodule 0x0::address_literal { /* ... */ }\nmodule book::named_address { /* ... */ }\n\n\nAddresses section in the Move.toml:\n\n# Move.toml\n[addresses]\nbook = \"0x0\"\n\nModule members\n\nModule members are declared inside the module body. To illustrate that, let's define a simple module with a struct, a function and a constant:\n\nmodule book::my_module_with_members {\n    // import\n    use book::my_module;\n\n    // a constant\n    const CONST: u8 = 0;\n\n    // a struct\n    public struct Struct {}\n\n    // method alias\n    public use fun function as Struct.struct_fun;\n\n    // function\n    fun function(_: &Struct) { /* function body */ }\n}\n\nFurther reading\nModules in the Move Reference.\nComments\n\nComments are a way to add notes or document your code. They are ignored by the compiler and don't result in the Move bytecode. You can use comments to explain what your code does, to add notes to yourself or other developers, to temporarily remove a part of your code, or to generate documentation. There are three types of comments in Move: line comment, block comment, and doc comment.\n\nLine comment\nmodule book::comments_line {\n    fun some_function() {\n        // this is a comment line\n    }\n}\n\n\nYou can use double slash // to comment out the rest of the line. Everything after // will be ignored by the compiler.\n\nmodule book::comments_line_2 {\n    // let's add a note to everything!\n    fun some_function_with_numbers() {\n        let a = 10;\n        // let b = 10 this line is commented and won't be executed\n        let b = 5; // here comment is placed after code\n        a + b; // result is 15, not 10!\n    }\n}\n\nBlock comment\n\nBlock comments are used to comment out a block of code. They start with /* and end with */. Everything between /* and */ will be ignored by the compiler. You can use block comments to comment out a single line or multiple lines. You can even use them to comment out a part of a line.\n\nmodule book::comments_block {\n    fun /* you can comment everywhere */ go_wild() {\n        /* here\n           there\n           everywhere */ let a = 10;\n        let b = /* even here */ 10; /* and again */\n        a + b;\n    }\n    /* you can use it to remove certain expressions or definitions\n    fun empty_commented_out() {\n\n    }\n    */\n}\n\n\nThis example is a bit extreme, but it shows how you can use block comments to comment out a part of a line.\n\nDoc comment\n\nDocumentation comments are special comments that are used to generate documentation for your code. They are similar to block comments, but they start with three slashes /// and are placed before the definition of the item they document.\n\n/// Module has documentation!\nmodule book::comments_doc {\n\n    /// This is a 0x0 address constant!\n    const AN_ADDRESS: address = @0x0;\n\n    /// This is a struct!\n    public struct AStruct {\n        /// This is a field of a struct!\n        a_field: u8,\n    }\n\n    /// This function does something!\n    /// And it's documented!\n    fun do_something() {}\n}\n\nPrimitive Types\n\nFor simple values, Move has a number of built-in primitive types. They're the base that makes up all other types. The primitive types are:\n\nBooleans\nUnsigned Integers\nAddress - covered in the next section\n\nHowever, before we get to the types, let's first look at how to declare and assign variables in Move.\n\nVariables and assignment\n\nVariables are declared using the let keyword. They are immutable by default, but can be made mutable using the let mut keyword. The syntax for the let mut statement is:\n\nlet <variable_name>[: <type>]  = <expression>;\nlet mut <variable_name>[: <type>] = <expression>;\n\n\nWhere:\n\n<variable_name> - the name of the variable\n<type> - the type of the variable, optional\n<expression> - the value to be assigned to the variable\nlet x: bool = true;\nlet mut y: u8 = 42;\n\n\nA mutable variable can be reassigned using the = operator.\n\ny = 43;\n\n\nVariables can also be shadowed by re-declaring.\n\nlet x: u8 = 42;\nlet x: u8 = 43;\n\nBooleans\n\nThe bool type represents a boolean value - yes or no, true or false. It has two possible values: true and false which are keywords in Move. For booleans, there's no need to explicitly specify the type - the compiler can infer it from the value.\n\nlet x = true;\nlet y = false;\n\n\nBooleans are often used to store flags and to control the flow of the program. Please, refer to the Control Flow section for more information.\n\nInteger Types\n\nMove supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:\n\nu8 - 8-bit\nu16 - 16-bit\nu32 - 32-bit\nu64 - 64-bit\nu128 - 128-bit\nu256 - 256-bit\nlet x: u8 = 42;\nlet y: u16 = 42;\n// ...\nlet z: u256 = 42;\n\n\nUnlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer the type from the value, usually defaulting to u64. However, sometimes the compiler is unable to infer the type and will require an explicit type annotation. It can either be provided during assignment or by using a type suffix.\n\n// Both are equivalent\nlet x: u8 = 42;\nlet x = 42u8;\n\nOperations\n\nMove supports the standard arithmetic operations for integers: addition, subtraction, multiplication, division, and remainder. The syntax for these operations is:\n\nSyntax\tOperation\tAborts If\n+\taddition\tResult is too large for the integer type\n-\tsubtraction\tResult is less than zero\n*\tmultiplication\tResult is too large for the integer type\n%\tmodular division\tThe divisor is 0\n/\ttruncating division\tThe divisor is 0\n\nThe type of the operands must match, otherwise, the compiler will raise an error. The result of the operation will be of the same type as the operands. To perform operations on different types, the operands need to be cast to the same type.\n\nCasting with as\n\nMove supports explicit casting between integer types. The syntax for it is:\n\n(<expression> as <type>)\n\n\nNote, that it requires parentheses around the expression to prevent ambiguity.\n\nlet x: u8 = 42;\nlet y: u16 = (x as u16);\n\n\nA more complex example, preventing overflow:\n\nlet x: u8 = 255;\nlet y: u8 = 255;\nlet z: u16 = (x as u16) + ((y as u16) * 2);\n\nOverflow\n\nMove does not support overflow / underflow, an operation that results in a value outside the range of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.\n\nlet x = 255u8;\nlet y = 1u8;\n\n// This will raise an error\nlet z = x + y;\n\nFurther reading\nBool in the Move Reference.\nInteger in the Move Reference.\nAddress Type\n\nTo represent addresses, Move uses a special type called address. It is a 32 byte value that can be used to represent any address on the blockchain. Addresses are used in two syntax forms: hexadecimal addresses prefixed with 0x and named addresses.\n\n// address literal\nlet value: address = @0x1;\n\n// named address registered in Move.toml\nlet value = @std;\nlet other = @sui;\n\n\nAn address literal starts with the @ symbol followed by a hexadecimal number or an identifier. The hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the Move.toml file and replaced with the corresponding address by the compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.\n\nConversion\n\nSui Framework offers a set of helper functions to work with addresses. Given that the address type is a 32 byte value, it can be converted to a u256 type and vice versa. It can also be converted to and from a vector<u8> type.\n\nExample: Convert an address to a u256 type and back.\n\nuse sui::address;\n\nlet addr_as_u256: u256 = address::to_u256(@0x1);\nlet addr = address::from_u256(addr_as_u256);\n\n\nExample: Convert an address to a vector<u8> type and back.\n\nuse sui::address;\n\nlet addr_as_u8: vector<u8> = address::to_bytes(@0x1);\nlet addr = address::from_bytes(addr_as_u8);\n\n\nExample: Convert an address into a string.\n\nuse sui::address;\nuse std::string::String;\n\nlet addr_as_string: String = address::to_string(@0x1);\n\nFurther reading\nAddress in the Move Reference.\nExpression\n\nIn programming languages expression is a unit of code which returns a value, in Move, almost everything is an expression, - with the sole exception of let statement which is a declaration. In this section, we cover the types of expressions and introduce the concept of scope.\n\nExpressions are sequenced with semicolons ;. If there's \"no expression\" after the semicolon, the compiler will insert a unit () - an empty expression.\n\nLiterals\n\nIn the Primitive Types section, we introduced the basic types of Move. And to illustrate them, we used literals. A literal is a notation for representing a fixed value in the source code. Literals are used to initialize variables and to pass arguments to functions. Move has the following literals:\n\ntrue and false for boolean values\n0, 1, 123123 or other numeric for integer values\n0x0, 0x1, 0x123 or other hexadecimal for integer values\nb\"bytes_vector\" for byte vector values\nx\"0A\" HEX literal for byte values\nlet b = true;     // true is a literal\nlet n = 1000;     // 1000 is a literal\nlet h = 0x0A;     // 0x0A is a literal\nlet v = b\"hello\"; // b'hello' is a byte vector literal\nlet x = x\"0A\";    // x'0A' is a byte vector literal\nlet c = vector[1, 2, 3]; // vector[] is a vector literal\n\nOperators\n\nArithmetic, logical, and bitwise operators are used to perform operations on values. The result of an operation is a value, so operators are also expressions.\n\nlet sum = 1 + 2;   // 1 + 2 is an expression\nlet sum = (1 + 2); // the same expression with parentheses\nlet is_true = true && false; // true && false is an expression\nlet is_true = (true && false); // the same expression with parentheses\n\nBlocks\n\nA block is a sequence of statements and expressions, and it returns the value of the last expression in the block. A block is written as a pair of curly braces {}. A block is an expression, so it can be used anywhere an expression is expected.\n\n// block with an empty expression, however, the compiler will\n// insert an empty expression automatically: `let none = { () }`\n// let none = {};\n\n// block with let statements and an expression.\nlet sum = {\n    let a = 1;\n    let b = 2;\n    a + b // last expression is the value of the block\n};\n\n// block is an expression, so it can be used in an expression and\n// doesn't have to be assigned to a variable.\n{\n    let a = 1;\n    let b = 2;\n    a + b; // not returned - semicolon.\n    // compiler automatically inserts an empty expression `()`\n};\n\nFunction Calls\n\nWe go into detail about functions in the Functions section. However, we already used function calls in the previous sections, so it's worth mentioning them here. A function call is an expression that calls a function and returns the value of the last expression in the function body.\n\nfun add(a: u8, b: u8): u8 {\n    a + b\n}\n\n#[test]\nfun some_other() {\n    let sum = add(1, 2); // add(1, 2) is an expression with type u8\n}\n\nControl Flow Expressions\n\nControl flow expressions are used to control the flow of the program. They are also expressions, so they return a value. We cover control flow expressions in the Control Flow section. Here's a very brief overview:\n\n// if is an expression, so it returns a value; if there are 2 branches,\n// the types of the branches must match.\nif (bool_expr) expr1 else expr2;\n\n// while is an expression, but it returns `()`.\nwhile (bool_expr) { expr; };\n\n// loop is an expression, but returns `()` as well.\nloop { expr; break };\n\nCustom Types with Struct\n\nMove's type system shines when it comes to defining custom types. User defined types can be custom tailored to the specific needs of the application. Not just on the data level, but also in its behavior. In this section we introduce the struct definition and how to use it.\n\nStruct\n\nTo define a custom type, you can use the struct keyword followed by the name of the type. After the name, you can define the fields of the struct. Each field is defined with the field_name: field_type syntax. Field definitions must be separated by commas. The fields can be of any type, including other structs.\n\nMove does not support recursive structs, meaning a struct cannot contain itself as a field.\n\n/// A struct representing an artist.\npublic struct Artist {\n    /// The name of the artist.\n    name: String,\n}\n\n/// A struct representing a music record.\npublic struct Record {\n    /// The title of the record.\n    title: String,\n    /// The artist of the record. Uses the `Artist` type.\n    artist: Artist,\n    /// The year the record was released.\n    year: u16,\n    /// Whether the record is a debut album.\n    is_debut: bool,\n    /// The edition of the record.\n    edition: Option<u16>,\n}\n\n\nIn the example above, we define a Record struct with five fields. The title field is of type String, the artist field is of type Artist, the year field is of type u16, the is_debut field is of type bool, and the edition field is of type Option<u16>. The edition field is of type Option<u16> to represent that the edition is optional.\n\nStructs are private by default, meaning they cannot be imported and used outside of the module they are defined in. Their fields are also private and can't be accessed from outside the module. See visibility for more information on different visibility modifiers.\n\nFields of a struct are private and can only be accessed by the module defining the struct. Reading and writing the fields of a struct in other modules is only possible if the module defining the struct provides public functions to access the fields.\n\nCreate and use an instance\n\nWe described how struct definition works. Now let's see how to initialize a struct and use it. A struct can be initialized using the struct_name { field1: value1, field2: value2, ... } syntax. The fields can be initialized in any order, and all of the fields must be set.\n\nlet mut artist = Artist {\n    name: b\"The Beatles\".to_string()\n};\n\n\nIn the example above, we create an instance of the Artist struct and set the name field to a string \"The Beatles\".\n\nTo access the fields of a struct, you can use the . operator followed by the field name.\n\n// Access the `name` field of the `Artist` struct.\nlet artist_name = artist.name;\n\n// Access a field of the `Artist` struct.\nassert!(artist.name == string::utf8(b\"The Beatles\"), 0);\n\n// Mutate the `name` field of the `Artist` struct.\nartist.name = string::utf8(b\"Led Zeppelin\");\n\n// Check that the `name` field has been mutated.\nassert!(artist.name == string::utf8(b\"Led Zeppelin\"), 1);\n\n\nOnly module defining the struct can access its fields (both mutably and immutably). So the above code should be in the same module as the Artist struct.\n\nUnpacking a struct\n\nStructs are non-discardable by default, meaning that the initiated struct value must be used: either stored or unpacked. Unpacking a struct means deconstructing it into its fields. This is done using the let keyword followed by the struct name and the field names.\n\n// Unpack the `Artist` struct and create a new variable `name`\n// with the value of the `name` field.\nlet Artist { name } = artist;\n\n\nIn the example above we unpack the Artist struct and create a new variable name with the value of the name field. Because the variable is not used, the compiler will raise a warning. To suppress the warning, you can use the underscore _ to indicate that the variable is intentionally unused.\n\n// Unpack the `Artist` struct and ignore the `name` field.\nlet Artist { name: _ } = artist;\n\nFurther reading\nStructs in the Move Reference.\nAbilities: Introduction\n\nMove has a unique type system which allows customizing type abilities. In the previous section, we introduced the struct definition and how to use it. However, the instances of the Artist and Record structs had to be unpacked for the code to compile. This is default behavior of a struct without abilities.\n\nThroughout the book you will see chapters with name Ability: <name>, where <name> is the name of the ability. These chapters will cover the ability in detail, how it works, and how to use it in Move.\n\nWhat are Abilities?\n\nAbilities are a way to allow certain behaviors for a type. They are a part of the struct declaration and define which behaviours are allowed for the instances of the struct.\n\nAbilities syntax\n\nAbilities are set in the struct definition using the has keyword followed by a list of abilities. The abilities are separated by commas. Move supports 4 abilities: copy, drop, key, and store, each of them is used to define a specific behaviour for the struct instances.\n\n/// This struct has the `copy` and `drop` abilities.\nstruct VeryAble has copy, drop {\n    // field: Type1,\n    // field2: Type2,\n    // ...\n}\n\nOverview\n\nA quick overview of the abilities:\n\nAll of the built-in types, except references, have copy, drop and store abilities. References have copy and drop.\n\ncopy - allows the struct to be copied. Explained in the Ability: Copy chapter.\ndrop - allows the struct to be dropped or discarded. Explained in the Ability: Drop chapter.\nkey - allows the struct to be used as a key in a storage. Explained in the Ability: Key chapter.\nstore - allows the struct to be stored in structs with the key ability. Explained in the Ability: Store chapter.\n\nWhile it is important to mention them here, we will go in detail about each ability in the following chapters and give a proper context on how to use them.\n\nNo abilities\n\nA struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a struct a Hot Potato. It is a joke, but it is also a good way to remember that a struct without abilities is like a hot potato - it can only be passed around and requires special handling. Hot Potato is one of the most powerful patterns in Move, we go in detail about it in the Hot Potato chapter.\n\nFurther reading\nType Abilities in the Move Reference.\nAbilities: Drop\nDrop ability\n\nThe drop ability - the simplest of them - allows the instance of a struct to be ignored or discarded. In many programming languages this behavior is considered default. However, in Move, a struct without the drop ability is not allowed to be ignored. This is a safety feature of the Move language, which ensures that all assets are properly handled. An attempt to ignore a struct without the drop ability will result in a compilation error.\n\nmodule book::drop_ability {\n\n    /// This struct has the `drop` ability.\n    public struct IgnoreMe has drop {\n        a: u8,\n        b: u8,\n    }\n\n    /// This struct does not have the `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    // Create an instance of the `IgnoreMe` struct and ignore it.\n    // Even though we constructed the instance, we don't need to unpack it.\n    fun test_ignore() {\n        let no_drop = NoDrop {};\n        let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack\n\n        // The value must be unpacked for the code to compile.\n        let NoDrop {} = no_drop; // OK\n    }\n}\n\n\nThe drop ability is often used on custom collection types to eliminate the need for special handling of the collection when it is no longer needed. For example, a vector type has the drop ability, which allows the vector to be ignored when it is no longer needed. However, the biggest feature of Move's type system is the ability to not have drop. This ensures that the assets are properly handled and not ignored.\n\nA struct with a single drop ability is called a Witness. We explain the concept of a Witness in the Witness and Abstract Implementation section.\n\nTypes with the drop Ability\n\nAll native types in Move have the drop ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the drop ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference.\nImporting Modules\n\nMove achieves high modularity and code reuse by allowing module imports. Modules within the same package can import each other, and a new package can depend on already existing packages and use their modules too. This section will cover the basics of importing modules and how to use them in your own code.\n\nImporting a Module\n\nModules defined in the same package can import each other. The use keyword is followed by the module path, which consists of the package address (or alias) and the module name separated by ::.\n\n// File: sources/module_one.move\nmodule book::module_one {\n    /// Struct defined in the same module.\n    public struct Character has drop {}\n\n    /// Simple function that creates a new `Character` instance.\n    public fun new(): Character { Character {} }\n}\n\n\nAnother module defined in the same package can import the first module using the use keyword.\n\n// File: sources/module_two.move\nmodule book::module_two {\n    use book::module_one; // importing module_one from the same package\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_and_ignore() {\n        let _ = module_one::new();\n    }\n}\n\nImporting Members\n\nYou can also import specific members from a module. This is useful when you only need a single function or a single type from a module. The syntax is the same as for importing a module, but you add the member name after the module path.\n\nmodule book::more_imports {\n    use book::module_one::new;       // imports the `new` function from the `module_one` module\n    use book::module_one::Character; // importing the `Character` struct from the `module_one` module\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n\nGrouping Imports\n\nImports can be grouped into a single use statement using the curly braces {}. This is useful when you need to import multiple members from the same module. Move allows grouping imports from the same module and from the same package.\n\nmodule book::grouped_imports {\n    // imports the `new` function and the `Character` struct from\n    /// the `module_one` module\n    use book::module_one::{new, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n\n\nSingle function imports are less common in Move, since the function names can overlap and cause confusion. A recommended practice is to import the entire module and use the module path to access the function. Types have unique names and should be imported individually.\n\nTo import members and the module itself in the group import, you can use the Self keyword. The Self keyword refers to the module itself and can be used to import the module and its members.\n\nmodule book::self_imports {\n    // imports the `Character` struct, and the `module_one` module\n    use book::module_one::{Self, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        module_one::new()\n    }\n}\n\nResolving Name Conflicts\n\nWhen importing multiple members from different modules, it is possible to have name conflicts. For example, if you import two modules that both have a function with the same name, you will need to use the module path to access the function. It is also possible to have modules with the same name in different packages. To resolve the conflict and avoid ambiguity, Move offers the as keyword to rename the imported member.\n\nmodule book::conflict_resolution {\n    // `as` can be placed after any import, including group imports\n    use book::module_one::{Self as mod, Character as Char};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create(): Char {\n        mod::new()\n    }\n}\n\nAdding an External Dependency\n\nEvery new package generated via the sui binary features a Move.toml file with a single dependency on the Sui Framework package. The Sui Framework depends on the Standard Library package. And both of these packages are available in default configuration. Package dependencies are defined in the Package Manifest as follows:\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nLocal = { local = \"../my_other_package\" }\n\n\nThe dependencies section contains a list of package dependencies. The key is the name of the package, and the value is either a git import table or a local path. The git import contains the URL of the package, the subdirectory where the package is located, and the revision of the package. The local path is a relative path to the package directory.\n\nIf a dependency is added to the Move.toml file, the compiler will automatically fetch (and later refetch) the dependencies when building the package.\n\nImporting a Module from Another Package\n\nNormally, packages define their addresses in the [addresses] section, so you can use the alias instead of the address. For example, instead of 0x2::coin module, you would use sui::coin. The sui alias is defined in the Sui Framework package. Similarly, the std alias is defined in the Standard Library package and can be used to access the standard library modules.\n\nTo import a module from another package, you use the use keyword followed by the module path. The module path consists of the package address (or alias) and the module name separated by ::.\n\nmodule book::imports {\n    use std::string; // std = 0x1, string is a module in the standard library\n    use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework\n}\n\nStandard Library\n\nThe Move Standard Library provides functionality for native types and operations. It is a standard collection of modules which do not interact with the storage, but provide basic tools for working and manipulating the data. It is the only dependency of the Sui Framework, and is imported together with it.\n\nMost Common Modules\n\nIn this book we go into detail about most of the modules in the Standard Library, however, it is also helpful to give an overview of the features, so that you can get a sense of what is available and which module implements it.\n\nModule\tDescription\tChapter\nstd::string\tProvides basic string operations\tString\nstd::ascii\tProvides basic ASCII operations\tString\nstd::option\tImplements an Option<T>\tOption\nstd::vector\tNative operations on the vector type\tVector\nstd::bcs\tContains the bcs::to_bytes() function\tBCS\nstd::address\tContains a single address::length function\tAddress\nstd::type_name\tAllows runtime type reflection\tType Reflection\nstd::hash\tHashing functions: sha2_256 and sha3_256\tCryptography and Hashing\nstd::debug\tContains debugging functions, which are available in only in test mode\tDebugging\nstd::bit_vector\tProvides operations on bit vectors\t-\nstd::fixed_point32\tProvides the FixedPoint32 type\t-\nExported Addresses\n\nStandard Library exports one named address - std = 0x1.\n\n[addresses]\nstd = \"0x1\"\n\nImplicit Imports\n\nSome of the modules are imported implicitly, and are available in the module without explicit use import. For Standard Library, these modules and types are:\n\nstd::vector\nstd::option\nstd::option::Option\nImporting std without Sui Framework\n\nThe Move Standard Library can be imported to the package directly. However, std alone is not enough to build a meaningful application, as it does not provide any storage capabilities, and can't interact with the on-chain state.\n\nMoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n\nSource Code\n\nThe source code of the Move Standard Library is available in the Sui repository.\n\nVector\n\nVectors are a native way to store collections of elements in Move. They are similar to arrays in other programming languages, but with a few differences. In this section, we introduce the vector type and its operations.\n\nVector syntax\n\nThe vector type is defined using the vector keyword followed by the type of the elements in angle brackets. The type of the elements can be any valid Move type, including other vectors. Move has a vector literal syntax that allows you to create vectors using the vector keyword followed by square brackets containing the elements (or no elements for an empty vector).\n\n// An empty vector of bool elements.\nlet empty: vector<bool> = vector[];\n\n// A vector of u8 elements.\nlet v: vector<u8> = vector[10, 20, 30];\n\n// A vector of vector<u8> elements.\nlet vv: vector<vector<u8>> = vector[\n    vector[10, 20],\n    vector[30, 40]\n];\n\n\nThe vector type is a built-in type in Move, and does not need to be imported from a module. However, vector operations are defined in the std::vector module, and you need to import the module to use them.\n\nVector operations\n\nThe standard library provides methods to manipulate vectors. The following are some of the most commonly used operations:\n\npush_back: Adds an element to the end of the vector.\npop_back: Removes the last element from the vector.\nlength: Returns the number of elements in the vector.\nis_empty: Returns true if the vector is empty.\nremove: Removes an element at a given index.\nlet mut v = vector[10u8, 20, 30];\n\nassert!(v.length() == 3, 0);\nassert!(!v.is_empty(), 1);\n\nv.push_back(40);\nlet last_value = v.pop_back();\n\nassert!(last_value == 40, 2);\n\nDestroying a Vector of non-droppable types\n\nA vector of non-droppable types cannot be discarded. If you define a vector of types without drop ability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an explicit call to destroy_empty function.\n\n    /// A struct without `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    fun test_destroy_empty() {\n        // Initialize a vector of `NoDrop` elements.\n        let v = vector<NoDrop>[];\n\n        // While we know that `v` is empty, we still need to call\n        // the explicit `destroy_empty` function to discard the vector.\n        v.destroy_empty();\n    }\n\nFurther reading\nVector in the Move Reference.\nOption\n\nOption is a type that represents an optional value which may or may not exist. The concept of Option in Move is borrowed from Rust, and it is a very useful primitive in Move. Option is defined in the Standard Library, and is defined as follows:\n\nFile: move-stdlib/source/option.move\n\n// File: move-stdlib/source/option.move\n/// Abstraction of a value that may or may not be present.\nstruct Option<Element> has copy, drop, store {\n    vec: vector<Element>\n}\n\n\nThe 'std::option' module is implicitly imported in every module, and you don't need to add an import.\n\nThe Option is a generic type which takes a type parameter Element. It has a single field vec which is a vector of Element. Vector can have length 0 or 1, and this is used to represent the presence or absence of a value.\n\nOption type has two variants: Some and None. Some variant contains a value and None variant represents the absence of a value. The Option type is used to represent the absence of a value in a type-safe way, and it is used to avoid the need for empty or undefined values.\n\nIn Practice\n\nTo showcase why Option type is necessary, let's look at an example. Consider an application which takes a user input and stores it in a variable. Some fields are required, and some are optional. For example, a user's middle name is optional. While we could use an empty string to represent the absence of a middle name, it would require extra checks to differentiate between an empty string and a missing middle name. Instead, we can use the Option type to represent the middle name.\n\nmodule book::user_registry {\n    use std::string::String;\n\n    /// A struct representing a user record.\n    public struct User has drop {\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    }\n\n    /// Create a new `User` struct with the given fields.\n    public fun register(\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    ): User {\n        User { first_name, middle_name, last_name }\n    }\n}\n\n\nIn the example above, the middle_name field is of type Option<String>. This means that the middle_name field can either contain a String value or be empty. This makes it clear that the middle name is optional, and it avoids the need for extra checks to differentiate between an empty string and a missing middle name.\n\nUsing Option\n\nTo use the Option type, you need to import the std::option module and use the Option type. You can then create an Option value using the some or none methods.\n\n// `option::some` creates an `Option` value with a value.\nlet mut opt = option::some(b\"Alice\");\n\n// `option.is_some()` returns true if option contains a value.\nassert!(opt.is_some(), 1);\n\n// internal value can be `borrow`ed and `borrow_mut`ed.\nassert!(opt.borrow() == &b\"Alice\", 0);\n\n// `option.extract` takes the value out of the option, leaving the option empty.\nlet inner = opt.extract();\n\n// `option.is_none()` returns true if option is None.\nassert!(opt.is_none(), 2);\n\nString\n\nWhile Move does not have a built-in type to represent strings, it does have two standard implementations for strings in the Standard Library. The std::string module defines a String type and methods for UTF-8 encoded strings, and the second module, std::ascii, provides an ASCII String type and its methods.\n\nSui execution environment automatically converts bytevector into String in transaction inputs. So in many cases, String does not to be constructed in the Transaction Block.\n\nStrings are bytes\n\nNo matter which type of string you use, it is important to know that strings are just bytes. The wrappers provided by the string and ascii modules are just that: wrappers. They do provide safety checks and methods to work with strings, but at the end of the day, they are just vectors of bytes.\n\nmodule book::custom_string {\n    /// Anyone can implement a custom string-like type by wrapping a vector.\n    public struct MyString {\n        bytes: vector<u8>,\n    }\n\n    /// Implement a `from_bytes` function to convert a vector of bytes to a string.\n    public fun from_bytes(bytes: vector<u8>): MyString {\n        MyString { bytes }\n    }\n\n    /// Implement a `bytes` function to convert a string to a vector of bytes.\n    public fun bytes(self: &MyString): &vector<u8> {\n        &self.bytes\n    }\n}\n\nWorking with UTF-8 Strings\n\nWhile there are two types of strings in the standard library, the string module should be considered the default. It has native implementations of many common operations, and hence is more efficient than the ascii module, which is fully implemented in Move.\n\nDefinition\n\nThe String type in the std::string module is defined as follows:\n\n// File: move-stdlib/sources/string.move\n/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\npublic struct String has copy, drop, store {\n    bytes: vector<u8>,\n}\n\nCreating a String\n\nTo create a new UTF-8 String instance, you can use the string::utf8 method. The Standard Library provides an alias .to_string() on the vector<u8> for convenience.\n\n// the module is `std::string` and the type is `String`\nuse std::string::{Self, String};\n\n// strings are normally created using the `utf8` function\n// type declaration is not necessary, we put it here for clarity\nlet hello: String = string::utf8(b\"Hello\");\n\n// The `.to_string()` alias on the `vector<u8>` is more convenient\nlet hello = b\"Hello\".to_string();\n\nCommon Operations\n\nUTF8 String provides a number of methods to work with strings. The most common operations on strings are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the bytes() method can be used to get the underlying byte vector.\n\nlet mut str = b\"Hello,\".to_string();\nlet another = b\" World!\".to_string();\n\n// append(String) adds the content to the end of the string\nstr.append(another);\n\n// `sub_string(start, end)` copies a slice of the string\nstr.sub_string(0, 5); // \"Hello\"\n\n// `length()` returns the number of bytes in the string\nstr.length(); // 12 (bytes)\n\n// methods can also be chained! Get a length of a substring\nstr.sub_string(0, 5).length(); // 5 (bytes)\n\n// whether the string is empty\nstr.is_empty(); // false\n\n// get the underlying byte vector for custom operations\nlet bytes: &vector<u8> = str.bytes();\n\nSafe UTF-8 Operations\n\nThe default utf8 method may abort if the bytes passed into it are not valid UTF-8. If you are not sure that the bytes you are passing are valid, you should use the try_utf8 method instead. It returns an Option<String>, which contains no value if the bytes are not valid UTF-8, and a string otherwise.\n\nHint: the name that starts with try_* indicates that the function returns an Option with the expected result or none if the operation fails. It is a common naming convention borrowed from Rust.\n\n// this is a valid UTF-8 string\nlet hello = b\"Hello\".try_to_string();\n\nassert!(hello.is_some(), 0); // abort if the value is not valid UTF-8\n\n// this is not a valid UTF-8 string\nlet invalid = b\"\\xFF\".try_to_string();\n\nassert!(invalid.is_none(), 0); // abort if the value is valid UTF-8\n\nUTF-8 Limitations\n\nThe string module does not provide a way to access individual characters in a string. This is because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to 4 bytes. Similarly, the length() method returns the number of bytes in the string, not the number of characters.\n\nHowever, methods like sub_string and insert check character boundaries and will abort when the index is in the middle of a character.\n\nASCII Strings\n\nThis section is coming soon!\n\nControl Flow\n\nControl flow statements are used to control the flow of execution in a program. They are used to make decisions, to repeat a block of code, and to exit a block of code early. Move has the following control flow statements (explained in detail below):\n\nif and if-else - making decisions on whether to execute a block of code\nloop and while loops - repeating a block of code\nbreak and continue statements - exiting a loop early\nreturn statement - exiting a function early\nConditional Statements\n\nThe if expression is used to make decisions in a program. It evaluates a boolean expression and executes a block of code if the expression is true. Paired with else, it can execute a different block of code if the expression is false.\n\nThe syntax for the if expression is:\n\nif (<bool_expression>) <expression>;\nif (<bool_expression>) <expression> else <expression>;\n\n\nJust like any other expression, if requires a semicolon, if there are other expressions following it. The else keyword is optional, except for the case when the resulting value is assigned to a variable. We will cover this below.\n\n    #[test]\n    fun test_if() {\n        let x = 5;\n\n        // `x > 0` is a boolean expression.\n        if (x > 0) {\n            std::debug::print(&b\"X is bigger than 0\".to_string())\n        };\n    }\n\n\nLet's see how we can use if and else to assign a value to a variable:\n\n    #[test]\n    fun test_if_else() {\n        let x = 5;\n        let y = if (x > 0) {\n            1\n        } else {\n            0\n        };\n\n        assert!(y == 1, 0);\n    }\n\n\nHere we assign the value of the if expression to the variable y. If x is greater than 0, y will be assigned the value 1, otherwise 0. The else block is necessary, because both branches must return a value of the same type. If we omit the else block, the compiler will throw an error.\n\nConditional expressions are one of the most important control flow statements in Move. They can use either user provided input or some already stored data to make decisions. In particular, they are used in the assert! macro to check if a condition is true, and if not, to abort execution. We will get to it very soon!\n\nRepeating Statements with Loops\n\nLoops are used to execute a block of code multiple times. Move has two built-in types of loops: loop and while. In many cases they can be used interchangeably, but usually while is used when the number of iterations is known in advance, and loop is used when the number of iterations is not known in advance or there are multiple exit points.\n\nLoops are helpful when dealing with collections, such as vectors, or when we want to repeat a block of code until a certain condition is met. However, it is important to be careful with loops, as they can lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.\n\nThe while loop\n\nThe while statement is used to execute a block of code as long as a boolean expression is true. Just like we've seen with if, the boolean expression is evaluated before each iteration of the loop. Just like conditional statements, the while loop is an expression and requires a semicolon if there are other expressions following it.\n\nThe syntax for the while loop is:\n\nwhile (<bool_expression>) { <expressions>; };\n\n\nHere is an example of a while loop with a very simple condition:\n\n    // This function iterates over the `x` variable until it reaches 10, the\n    // return value is the number of iterations it took to reach 10.\n    //\n    // If `x` is 0, then the function will return 10.\n    // If `x` is 5, then the function will return 5.\n    fun while_loop(mut x: u8): u8 {\n        let mut y = 0;\n\n        // This will loop until `x` is 10.\n        // And will never run if `x` is 10 or more.\n        while (x < 10) {\n            y = y + 1;\n            x = x + 1;\n        };\n\n        y\n    }\n\n    #[test]\n    fun test_while() {\n        assert!(while_loop(0) == 10, 0); // 10 times\n        assert!(while_loop(5) == 5, 0);  // 5 times\n        assert!(while_loop(10) == 0, 0); // loop never executed\n    }\n\nInfinite loop\n\nNow let's imagine a scenario where the boolean expression is always true. For example, if we literally passed true to the while condition. As you might expect, this would create an infinite loop, and this is almost what the loop statement works like.\n\n    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_while() {\n        let mut x = 0;\n\n        // This will loop forever.\n        while (true) {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n\n\nAn infinite while, or while without a condition, is a loop. The syntax for it is simple:\n\nloop { <expressions>; };\n\n\nLet's rewrite the previous example using loop instead of while:\n\n    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_loop() {\n        let mut x = 0;\n\n        // This will loop forever.\n        loop {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n\n\nInfinite loops on their own are not very useful in Move, since every operation in Move costs gas, and an infinite loop will lead to gas exhaustion. However, they can be used in combination with break and continue statements to create more complex loops.\n\nExiting a Loop Early\n\nAs we already mentioned, infinite loops are rather useless on their own. And that's where we introduce the break and continue statements. They are used to exit a loop early, and to skip the rest of the current iteration, respectively.\n\nSyntax for the break statement is (without a semicolon):\n\nbreak\n\n\nThe break statement is used to stop the execution of a loop and exit it early. It is often used in combination with a conditional statement to exit the loop when a certain condition is met. To illustrate this point, let's turn the infinite loop from the previous example into something that looks and behaves more like a while loop:\n\n    #[test]\n    fun test_break_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 5.\n        loop {\n            x = x + 1;\n\n            // If `x` is 5, then exit the loop.\n            if (x == 5) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 5, 0);\n    }\n\n\nAlmost identical to the while loop, right? The break statement is used to exit the loop when x is 5. If we remove the break statement, the loop will run forever, just like the previous example.\n\nSkipping an Iteration\n\nThe continue statement is used to skip the rest of the current iteration and start the next one. Similarly to break, it is used in combination with a conditional statement to skip the rest of the iteration when a certain condition is met.\n\nSyntax for the continue statement is (without a semicolon):\n\ncontinue\n\n\nThe example below skips odd numbers and prints only even numbers from 0 to 10:\n\n    #[test]\n    fun test_continue_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 10.\n        loop {\n            x = x + 1;\n\n            // If `x` is odd, then skip the rest of the iteration.\n            if (x % 2 == 1) {\n                continue // Skip the rest of the iteration.\n            };\n\n            std::debug::print(&x);\n\n            // If `x` is 10, then exit the loop.\n            if (x == 10) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 10, 0); // 10\n    }\n\n\nbreak and continue statements can be used in both while and loop loops.\n\nEarly Return\n\nThe return statement is used to exit a function early and return a value. It is often used in combination with a conditional statement to exit the function when a certain condition is met. The syntax for the return statement is:\n\nreturn <expression>\n\n\nHere is an example of a function that returns a value when a certain condition is met:\n\n    /// This function returns `true` if `x` is greater than 0 and not 5,\n    /// otherwise it returns `false`.\n    fun is_positive(x: u8): bool {\n        if (x == 5) {\n            return false\n        };\n\n        if (x > 0) {\n            return true\n        };\n\n        false\n    }\n\n    #[test]\n    fun test_return() {\n        assert!(is_positive(5) == false, 0);\n        assert!(is_positive(0) == false, 0);\n        assert!(is_positive(1) == true, 0);\n    }\n\n\nUnlike in other languages, the return statement is not required for the last expression in a function. The last expression in a function block is automatically returned. However, the return statement is useful when we want to exit a function early if a certain condition is met.\n\nConstants\n\nConstants are immutable values that are defined at the module level. They often serve as a way to give names to static values that are used throughout a module. For example, if there's a default price for a product, you might define a constant for it. Constants are stored in the module's bytecode, and each time they are used, the value is copied.\n\nmodule book::shop_price {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n\n    /// The price of an item in the shop.\n    const ITEM_PRICE: u64 = 100;\n    /// The owner of the shop, an address.\n    const SHOP_OWNER: address = @0xa11ce;\n\n    /// An item sold in the shop.\n    public struct Item { /* ... */ }\n\n    /// Purchase an item from the shop.\n    public fun purchase(coin: Coin<SUI>): Item {\n        assert!(coin.value() == ITEM_PRICE, 0);\n\n        transfer::public_transfer(coin, SHOP_OWNER);\n\n        Item { /* ... */ }\n    }\n}\n\nNaming Convention\n\nConstants must start with a capital letter - this is enforced at the compiler level. For constants used as a value, there's a convention to use uppercase letters and underscores to separate words. It's a way to make constants stand out from other identifiers in the code. One exception is made for error constants, which are written in ECamelCase.\n\n/// Price of the item used at the shop.\nconst ITEM_PRICE: u64 = 100;\n\n/// Error constant.\nconst EItemNotFound: u64 = 1;\n\nConstants are Immutable\n\nConstants can't be changed and assigned new values. They are part of the package bytecode, and inherently immutable.\n\nmodule book::immutable_constants {\n    const ITEM_PRICE: u64 = 100;\n\n    // emits an error\n    fun change_price() {\n        ITEM_PRICE = 200;\n    }\n}\n\nUsing Config Pattern\n\nA common use case for an application is to define a set of constants that are used throughout the codebase. But due to constants being private to the module, they can't be accessed from other modules. One way to solve this is to define a \"config\" module that exports the constants.\n\nmodule book::config {\n    const ITEM_PRICE: u64 = 100;\n    const TAX_RATE: u64 = 10;\n    const SHIPPING_COST: u64 = 5;\n\n    /// Returns the price of an item.\n    public fun item_price(): u64 { ITEM_PRICE }\n    /// Returns the tax rate.\n    public fun tax_rate(): u64 { TAX_RATE }\n    /// Returns the shipping cost.\n    public fun shipping_cost(): u64 { SHIPPING_COST }\n}\n\n\nThis way other modules can import and read the constants, and the update process is simplified. If the constants need to be changed, only the config module needs to be updated during the package upgrade.\n\nLinks\nConstants in the Move Reference\nCoding conventions for constants\nAssert and Abort\n\nA transaction can either succeed or fail. Successful execution applies all the changes made to objects and on-chain data, and the transaction is committed to the blockchain. If a transaction aborts, and changes are not applied. The abort keyword is used to abort a transaction and revert the changes made so far.\n\nIt is important to note that there is no catch mechanism in Move. If a transaction aborts, the changes made so far are reverted, and the transaction is considered failed.\n\nAbort\n\nThe abort keyword is used to abort the execution of a transaction. It is used in combination with an abort code, which will be returned to the caller of the transaction. The abort code is an integer of type u64 and can be any value.\n\nlet user_has_access = true;\n\n// abort with a predefined constant if `user_has_access` is false\nif (!user_has_access) {\n    abort 0\n};\n\n// there's an alternative syntax using parenthesis`\nif (user_has_access) {\n   abort(1)\n};\n\n\nThe code above will, of course, abort with abort code 1.\n\nassert!\n\nThe assert! macro is a built-in macro that can be used to assert a condition. If the condition is false, the transaction will abort with the given abort code. The assert! macro is a convenient way to abort a transaction if a condition is not met. The macro shortens the code otherwise written with an if expression + abort.\n\n// aborts if `user_has_access` is `false` with abort code 0\nassert!(user_has_access, 0);\n\n// expands into:\nif (!user_has_access) {\n    abort 0\n};\n\nError constants\n\nTo make error codes more descriptive, it is a good practice to define error constants. Error constants are defined as const declarations and are usually prefixed with E followed by a camel case name. Error constants are no different from other constants and don't have special handling. So their addition is purely a practice for better code readability.\n\n/// Error code for when the user has no access.\nconst ENoAccess: u64 = 0;\n/// Trying to access a field that does not exist.\nconst ENoField: u64 = 1;\n\n/// Updates a record.\npublic fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {\n    // asserts are way more readable now\n    assert!(user_has_access, ENoAccess);\n    assert!(field_exists, ENoField);\n\n    /* ... */\n}\n\nFurther reading\nAbort and Assert in the Move Reference.\nWe suggest reading the Better Error Handling guide to learn about best practices for error handling in Move.\nFunction\n\nFunctions are the building blocks of Move programs. They are called from user transactions and from other functions and group executable code into reusable units. Functions can take arguments and return a value. They are declared with the fun keyword at the module level. Just like any other module member, by default they're private and can only be accessed from within the module.\n\nmodule book::math {\n    /// Function takes two arguments of type `u64` and returns their sum.\n    /// The `public` visibility modifier makes the function accessible from\n    /// outside the module.\n    public fun add(a: u64, b: u64): u64 {\n        a + b\n    }\n\n    #[test]\n    fun test_add() {\n        let sum = add(1, 2);\n        assert!(sum == 3, 0);\n    }\n}\n\n\nIn this example, we define a function add that takes two arguments of type u64 and returns their sum. The function is called from the test_add function, which is a test function located in the same module. In the test we compare the result of the add function with the expected value and abort the execution if the result is different.\n\nFunction declaration\n\nThere's a convention to call functions in Move with the snake_case naming convention. This means that the function name should be all lowercase with words separated by underscores. For example, do_something, add, get_balance, is_authorized, and so on.\n\nA function is declared with the fun keyword followed by the function name (a valid Move identifier), a list of arguments in parentheses, and a return type. The function body is a block of code that contains a sequence of statements and expressions. The last expression in the function body is the return value of the function.\n\nfun return_nothing() {\n    // empty expression, function returns `()`\n}\n\nAccessing functions\n\nJust like any other module member, functions can be imported and accessed via a path. The path consists of the module path and the function name separated by ::. For example, if you have a function called add in the math module in the book package, the path to it will be book::math::add, or, if the module is imported, math::add.\n\nmodule book::use_math {\n    use book::math;\n\n    fun call_add() {\n        // function is called via the path\n        let sum = math::add(1, 2);\n    }\n}\n\nMultiple return values\n\nMove functions can return multiple values, which is useful when you need to return more than one value from a function. The return type of the function is a tuple of types. The return value is a tuple of expressions.\n\nfun get_name_and_age(): (vector<u8>, u8) {\n    (b\"John\", 25)\n}\n\n\nResult of a function call with tuple return has to be unpacked into variables via let (tuple) syntax:\n\n// Tuple must be destructured to access its elements.\n// Name and age are declared as immutable variables.\nlet (name, age) = get_name_and_age();\nassert!(name == b\"John\", 0);\nassert!(age == 25, 0);\n\n\nIf any of the declared values need to be declared as mutable, the mut keyword is placed before the variable name:\n\n// declare name as mutable, age as immutable\nlet (mut name, age) = get_name_and_age();\n\n\nIf some of the arguments are not used, they can be ignored with the _ symbol:\n\n// ignore the name, only use the age\nlet (_, age) = get_name_and_age();\n\nFurther reading\nFunctions in the Move Reference.\nStruct Methods\n\nMove Compiler supports receiver syntax, which allows defining methods which can be called on instances of a struct. This is similar to the method syntax in other programming languages. It is a convenient way to define functions which operate on the fields of a struct.\n\nMethod syntax\n\nIf the first argument of a function is a struct internal to the module, then the function can be called using the . operator. If the function uses a struct from another module, then method won't be associated with the struct by default. In this case, the function can be called using the standard function call syntax.\n\nWhen a module is imported, the methods are automatically associated with the struct.\n\nmodule book::hero {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    /// A method which casts a spell, consuming mana.\n    public fun heal_spell(hero: &mut Hero) {\n        hero.health = hero.health + 10;\n        hero.mana = hero.mana - 10;\n    }\n\n    /// A method which returns the health of the hero.\n    public fun health(hero: &Hero): u8 { hero.health }\n\n    /// A method which returns the mana of the hero.\n    public fun mana(hero: &Hero): u8 { hero.mana }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_methods() {\n        let mut hero = new();\n        hero.heal_spell();\n\n        assert!(hero.health() == 110, 1);\n        assert!(hero.mana() == 90, 2);\n    }\n}\n\nMethod Aliases\n\nFor modules that define multiple structs and their methods, it is possible to define method aliases to avoid name conflicts, or to provide a better-named method for a struct.\n\nThe syntax for aliases is:\n\n// for local method association\nuse fun function_path as Type.method_name;\n\n// exported alias\npublic use fun function_path as Type.method_name;\n\n\nPublic aliases are only allowed for structs defined in the same module. If a struct is defined in another module, an alias can still be created but cannot be made public.\n\nIn the example below, we changed the hero module and added another type - Villain. Both Hero and Villain have similar field names and methods. And to avoid name conflicts, we prefixed methods with hero_ and villain_ respectively. However, we can create aliases for these methods so that they can be called on the instances of the structs without the prefix.\n\nmodule book::hero_and_villain {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n    }\n\n    /// A struct representing a villain.\n    public struct Villain has drop {\n        health: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new_hero(): Hero { Hero { health: 100 } }\n\n    /// Create a new Villain.\n    public fun new_villain(): Villain { Villain { health: 100 } }\n\n    // Alias for the `hero_health` method. Will be imported automatically when\n    // the module is imported.\n    public use fun hero_health as Hero.health;\n\n    public fun hero_health(hero: &Hero): u8 { hero.health }\n\n    // Alias for the `villain_health` method. Will be imported automatically\n    // when the module is imported.\n    public use fun villain_health as Villain.health;\n\n    public fun villain_health(villain: &Villain): u8 { villain.health }\n\n    #[test]\n    // Test the methods of the `Hero` and `Villain` structs.\n    fun test_associated_methods() {\n        let hero = new_hero();\n        assert!(hero.health() == 100, 1);\n\n        let villain = new_villain();\n        assert!(villain.health() == 100, 3);\n    }\n}\n\n\nAs you can see, in the test function, we called the health method on the instances of Hero and Villain without the prefix. The compiler will automatically associate the methods with the structs.\n\nAliasing an external module's method\n\nIt is also possible to associate a function defined in another module with a struct from the current module. Following the same approach, we can create an alias for the method defined in another module. Let's use the bcs::to_bytes method from the Standard Library and associate it with the Hero struct. It will allow serializing the Hero struct to a vector of bytes.\n\n// TODO: better example (external module...)\nmodule book::hero_to_bytes {\n    // Alias for the `bcs::to_bytes` method. Imported aliases should be defined\n    // in the top of the module.\n    // public use fun bcs::to_bytes as Hero.to_bytes;\n\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_hero_serialize() {\n        // let mut hero = new();\n        // let serialized = hero.to_bytes();\n        // assert!(serialized.length() == 3, 1);\n    }\n}\n\nFurther reading\nMethod Syntax in the Move Reference.\nVisibility Modifiers\n\nEvery module member has a visibility. By default, all module members are private - meaning they are only accessible within the module they are defined in. However, you can add a visibility modifier to make a module member public - visible outside the module, or public(package) - visible in the modules within the same package, or entry - can be called from a transaction but can't be called from other modules.\n\nInternal Visibility\n\nA function or a struct defined in a module which has no visibility modifier is private to the module. It can't be called from other modules.\n\nmodule book::internal_visibility {\n    // This function can be called from other functions in the same module\n    fun internal() { /* ... */ }\n\n    // Same module -> can call internal()\n    fun call_internal() {\n        internal();\n    }\n}\n\nmodule book::try_calling_internal {\n    use book::internal_visibility;\n\n    // Different module -> can't call internal()\n    fun try_calling_internal() {\n        internal_visibility::internal();\n    }\n}\n\nPublic Visibility\n\nA struct or a function can be made public by adding the public keyword before the fun or struct keyword.\n\nmodule book::public_visibility {\n    // This function can be called from other modules\n    public fun public() { /* ... */ }\n}\n\n\nA public function can be imported and called from other modules. The following code will compile:\n\nmodule book::try_calling_public {\n    use book::public_visibility;\n\n    // Different module -> can call public()\n    fun try_calling_public() {\n        public_visibility::public();\n    }\n}\n\nPackage Visibility\n\nMove 2024 introduces the package visibility modifier. A function with package visibility can be called from any module within the same package. It can't be called from other packages.\n\nmodule book::package_visibility {\n    public(package) fun package_only() { /* ... */ }\n}\n\n\nA package function can be called from any module within the same package:\n\nmodule book::try_calling_package {\n    use book::package_visibility;\n\n    // Same package `book` -> can call package_only()\n    fun try_calling_package() {\n        package_visibility::package_only();\n    }\n}\n\nOwnership and Scope\n\nEvery variable in Move has a scope and an owner. The scope is the range of code where the variable is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the variable is dropped. This is a fundamental concept in Move, and it is important to understand how it works.\n\nOwnership\n\nA variable defined in a function scope is owned by this scope. The runtime goes through the function scope and executes every expression and statement. Once the function scope end, the variables defined in it are dropped or deallocated.\n\nmodule book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function\n    } // a is dropped here\n\n    #[test]\n    fun test_owner() {\n        owner();\n        // a is not valid here\n    }\n}\n\n\nIn the example above, the variable a is owned by the owner function, and the variable b is owned by the other function. When each of these functions are called, the variables are defined, and when the function ends, the variables are discarded.\n\nReturning a Value\n\nIf we changed the owner function to return the variable a, then the ownership of a would be transferred to the caller of the function.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a defined here\n        a // scope ends, a is returned\n    }\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        // a is valid here\n    } // a is dropped here\n}\n\nPassing by Value\n\nAdditionally, if we passed the variable a to another function, the ownership of a would be transferred to this function. When performing this operation, we move the value from one scope to another. This is also called move semantics.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 10;\n        a\n    } // a is returned\n\n    public fun take_ownership(v: u8) {\n        // v is owned by `take_ownership`\n    } // v is dropped here\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        take_ownership(a);\n        // a is not valid here\n    }\n}\n\nScopes with Blocks\n\nFunction has a main scope, and it can also have sub-scopes via the use of blocks. A block is a sequence of statements and expressions, and it has its own scope. Variables defined in a block are owned by this block, and when the block ends, the variables are dropped.\n\nmodule book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function's scope\n        {\n            let b = 2; // b is owned by the block\n            {\n                let c = 3; // c is owned by the block\n            }; // c is dropped here\n        }; // b is dropped here\n        // a = b; // error: b is not valid here\n        // a = c; // error: c is not valid here\n    } // a is dropped here\n}\n\n\nHowever, shall we use the return value of a block, the ownership of the variable is transferred to the caller of the block.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a is owned by the `owner` function's scope\n        let b = {\n            let c = 2; // c is owned by the block\n            c // c is returned\n        }; // c is dropped here\n        a + b // both a and b are valid here\n    }\n}\n\nCopyable Types\n\nSome types in Move are copyable, which means that they can be copied without transferring the ownership. This is useful for types that are small and cheap to copy, such as integers and booleans. Move compiler will automatically copy these types when they are passed to a function or returned from a function, or when they're moved to a scope and then accessed in their original scope.\n\nFurther reading\nLocal Variables and Scopes in the Move Reference.\nAbilities: Copy\n\nIn Move, the copy ability on a type indicates that the instance or the value of the type can be copied. While this behavior may feel very natural when working with numbers or other simple types, it is not the default for custom types in Move. This is because Move is designed to express digital assets and resources, and inability to copy is a key element of the resource model.\n\nHowever, Move type system allows you to define custom types with the copy ability.\n\npublic struct Copyable has copy {}\n\n\nIn the example above, we define a custom type Copyable with the copy ability. This means that instances of Copyable can be copied, both implicitly and explicitly.\n\nlet a = Copyable {};\nlet b = a;   // `a` is copied to `b`\nlet c = *&b; // explicit copy via dereference operator\n\nlet Copyable {} = a; // doesn't have `drop`\nlet Copyable {} = b; // doesn't have `drop`\nlet Copyable {} = c; // doesn't have `drop`\n\n\nIn the example above, a is copied to b implicitly, and then explicitly copied to c using the dereference operator. If Copyable did not have the copy ability, the code would not compile, and the Move compiler would raise an error.\n\nCopying and Drop\n\nThe copy ability is closely related to drop ability. If a type has the copy ability, very likely that it should have drop too. This is because the drop ability is required to clean up the resources when the instance is no longer needed. If a type has only copy, then managing its instances gets more complicated, as the values cannot be ignored.\n\npublic struct Value has copy, drop {}\n\n\nAll of the primitive types in Move behave as if they have the copy and drop abilities. This means that they can be copied and dropped, and the Move compiler will handle the memory management for them.\n\nTypes with the copy Ability\n\nAll native types in Move have the copy ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the copy ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference.\nReferences\n\nIn the Ownership and Scope section, we explained that when a value is passed to a function, it is moved to the function's scope. This means that the function becomes the owner of the value, and the original scope (owner) can no longer use it. This is an important concept in Move, as it ensures that the value is not used in multiple places at the same time. However, there are use cases when we want to pass a value to a function but retain the ownership. This is where references come into play.\n\nTo illustrate this, let's consider a simple example - an application for a metro (subway) pass. We will look at 4 different scenarios:\n\nCard can be purchased at the kiosk for a fixed price\nCard can be shown to inspectors to prove that the passenger has a valid pass\nCard can be used at the turnstile to enter the metro, and spend a ride\nCard can be recycled once it's empty\nLayout\n\nThe initial layout of the metro pass application is simple. We define the Card type and the USES constant that represents the number of rides for a single card. We also add an error constant for the case when the card is empty.\n\nmodule book::metro_pass {\n    /// Error code for when the card is empty.\n    const ENoUses: u64 = 0;\n\n    /// Number of uses for a metro pass card.\n    const USES: u8 = 3;\n\n    /// A metro pass card\n    public struct Card { uses: u8 }\n\n    /// Purchase a metro pass card.\n    public fun purchase(/* pass a Coin */): Card {\n        Card { uses: USES }\n    }\n}\n\nReference\n\nReferences are a way to show a value to a function without giving up the ownership. In our case, when we show the Card to the inspector, we don't want to give up the ownership of it, and we don't allow them to spend the rides. We just want to allow reading the value of the Card and prove its ownership.\n\nTo do so, in the function signature, we use the & symbol to indicate that we are passing a reference to the value, not the value itself.\n\n    /// Show the metro pass card to the inspector.\n    public fun is_valid(card: &Card): bool {\n        card.uses > 0\n    }\n\n\nNow the function can't take the ownership of the card, and it can't spend the rides. But it can read its value. Worth noting, that a signature like this makes it impossible to call the function without a Card at all. This is an important property which allows the Capability Pattern which we will cover in the next chapters.\n\nMutable Reference\n\nIn some cases, we want to allow the function to change the value of the Card. For example, when we use the Card at the turnstile, we want to spend a ride. To implement it, we use the &mut keyword in the function signature.\n\n    /// Use the metro pass card at the turnstile to enter the metro.\n    public fun enter_metro(card: &mut Card) {\n        assert!(card.uses > 0, ENoUses);\n        card.uses = card.uses - 1;\n    }\n\n\nAs you can see in the function body, the &mut reference allows mutating the value, and the function can spend the rides.\n\nPassing by Value\n\nLastly, let's give an illustration of what happens when we pass the value itself to the function. In this case, the function takes the ownership of the value, and the original scope can no longer use it. The owner of the Card can recycle it, and, hence, lose the ownership.\n\n    /// Recycle the metro pass card.\n    public fun recycle(card: Card) {\n        assert!(card.uses == 0, ENoUses);\n        let Card { uses: _ } = card;\n    }\n\n\nIn the recycle function, the Card is taken by value and can be unpacked and destroyed. The original scope can't use it anymore.\n\nFull Example\n\nTo illustrate the full flow of the application, let's put all the pieces together in a test.\n\n    #[test]\n    fun test_card_2024() {\n        // declaring variable as mutable because we modify it\n        let mut card = purchase();\n\n        card.enter_metro(); // modify the card but don't move it\n        assert!(card.is_valid(), 0); // read the card!\n\n        card.enter_metro(); // modify the card but don't move it\n        card.enter_metro(); // modify the card but don't move it\n\n        card.recycle(); // move the card out of the scope\n    }\n\nGenerics\n\nGenerics are a way to define a type or function that can work with any type. This is useful when you want to write a function which can be used with different types, or when you want to define a type that can hold any other type. Generics are the foundation of many advanced features in Move, such as collections, abstract implementations, and more.\n\nIn the Standard Library\n\nIn this chapter we already mentioned the vector type, which is a generic type that can hold any other type. Another example of a generic type in the standard library is the Option type, which is used to represent a value that may or may not be present.\n\nGeneric Syntax\n\nTo define a generic type or function, a type signature needs to have a list of generic parameters enclosed in angle brackets (< and >). The generic parameters are separated by commas.\n\n/// Container for any type `T`.\npublic struct Container<T> has drop {\n    value: T,\n}\n\n/// Function that creates a new `Container` with a generic value `T`.\npublic fun new<T>(value: T): Container<T> {\n    Container { value }\n}\n\n\nIn the example above, Container is a generic type with a single type parameter T, the value field of the container stores the T. The new function is a generic function with a single type parameter T, and it returns a Container with the given value. Generic types must be initialed with a concrete type, and generic functions must be called with a concrete type.\n\n#[test]\nfun test_container() {\n    // these three lines are equivalent\n    let container: Container<u8> = new(10); // type inference\n    let container = new<u8>(10); // create a new `Container` with a `u8` value\n    let container = new(10u8);\n\n    assert!(container.value == 10, 0x0);\n\n    // Value can be ignored only if it has the `drop` ability.\n    let Container { value: _ } = container;\n}\n\n\nIn the test function test_generic we demonstrate three equivalent ways to create a new Container with a u8 value. Because numeric types need to be inferred, we specify the type of the number literal.\n\nMultiple Type Parameters\n\nYou can define a type or function with multiple type parameters. The type parameters are then separated by commas.\n\n/// A pair of values of any type `T` and `U`.\npublic struct Pair<T, U> {\n    first: T,\n    second: U,\n}\n\n/// Function that creates a new `Pair` with two generic values `T` and `U`.\npublic fun new_pair<T, U>(first: T, second: U): Pair<T, U> {\n    Pair { first, second }\n}\n\n\nIn the example above, Pair is a generic type with two type parameters T and U, and the new_pair function is a generic function with two type parameters T and U. The function returns a Pair with the given values. The order of the type parameters is important, and it should match the order of the type parameters in the type signature.\n\n#[test]\nfun test_generic() {\n    // these three lines are equivalent\n    let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference\n    let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values\n    let pair_3 = new_pair(10u8, true);\n\n    assert!(pair_1.first == 10, 0x0);\n    assert!(pair_1.second, 0x0);\n\n    // Unpacking is identical.\n    let Pair { first: _, second: _ } = pair_1;\n    let Pair { first: _, second: _ } = pair_2;\n    let Pair { first: _, second: _ } = pair_3;\n\n}\n\n\nIf we added another instance where we swapped type parameters in the new_pair function, and tried to compare two types, we'd see that the type signatures are different, and cannot be compared.\n\n#[test]\nfun test_swap_type_params() {\n    let pair1: Pair<u8, bool> = new_pair(10u8, true);\n    let pair2: Pair<bool, u8> = new_pair(true, 10u8);\n\n    // this line will not compile\n    // assert!(pair1 == pair2, 0x0);\n\n    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool\n    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8\n\n    assert!(pf1 == ps2, 0x0); // 10 == 10\n    assert!(ps1 == pf2, 0x0); // true == true\n}\n\n\nTypes for variables pair1 and pair2 are different, and the comparison will not compile.\n\nWhy Generics?\n\nIn the examples above we focused on instantiating generic types and calling generic functions to create instances of these types. However, the real power of generics is the ability to define shared behavior for the base, generic type, and then use it independently of the concrete types. This is especially useful when working with collections, abstract implementations, and other advanced features in Move.\n\n/// A user record with name, age, and some generic metadata\npublic struct User<T> {\n    name: String,\n    age: u8,\n    /// Varies depending on application.\n    metadata: T,\n}\n\n\nIn the example above, User is a generic type with a single type parameter T, with shared fields name and age, and the generic metadata field which can store any type. No matter what the metadata is, all of the instances of User will have the same fields and methods.\n\n/// Updates the name of the user.\npublic fun update_name<T>(user: &mut User<T>, name: String) {\n    user.name = name;\n}\n\n/// Updates the age of the user.\npublic fun update_age<T>(user: &mut User<T>, age: u8) {\n    user.age = age;\n}\n\nPhantom Type Parameters\n\nIn some cases, you may want to define a generic type with a type parameter that is not used in the fields or methods of the type. This is called a phantom type parameter. Phantom type parameters are useful when you want to define a type that can hold any other type, but you want to enforce some constraints on the type parameter.\n\n/// A generic type with a phantom type parameter.\npublic struct Coin<phantom T> {\n    value: u64\n}\n\n\nThe Coin type here does not contain any fields or methods that use the type parameter T. It is used to differentiate between different types of coins, and to enforce some constraints on the type parameter T.\n\npublic struct USD {}\npublic struct EUR {}\n\n#[test]\nfun test_phantom_type() {\n    let coin1: Coin<USD> = Coin { value: 10 };\n    let coin2: Coin<EUR> = Coin { value: 20 };\n\n    // Unpacking is identical because the phantom type parameter is not used.\n    let Coin { value: _ } = coin1;\n    let Coin { value: _ } = coin2;\n}\n\n\nIn the example above, we demonstrate how to create two different instances of Coin with different phantom type parameters USD and EUR. The type parameter T is not used in the fields or methods of the Coin type, but it is used to differentiate between different types of coins. It will make sure that the USD and EUR coins are not mixed up.\n\nConstraints on Type Parameters\n\nType parameters can be constrained to have certain abilities. This is useful when you need the inner type to allow certain behavior, such as copy or drop. The syntax for constraining a type parameter is T: <ability> + <ability>.\n\n/// A generic type with a type parameter that has the `drop` ability.\npublic struct Droppable<T: drop> {\n    value: T,\n}\n\n/// A generic struct with a type parameter that has the `copy` and `drop` abilities.\npublic struct CopyableDroppable<T: copy + drop> {\n    value: T, // T must have the `copy` and `drop` abilities\n}\n\n\nMove Compiler will enforce that the type parameter T has the specified abilities. If the type parameter does not have the specified abilities, the code will not compile.\n\n/// Type without any abilities.\npublic struct NoAbilities {}\n\n#[test]\nfun test_constraints() {\n    // Fails - `NoAbilities` does not have the `drop` ability\n    // let droppable = Droppable<NoAbilities> { value: 10 };\n\n    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities\n    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };\n}\n\nFurther Reading\nGenerics in the Move Reference.\nType Reflection\n\nIn programming languages reflection is the ability of a program to examine and modify its own structure and behavior. In Move, there's a limited form of reflection that allows you to inspect the type of a value at runtime. This is useful when you need to store type information in a homogeneous collection, or when you need to check if a type belongs to a package.\n\nType reflection is implemented in the Standard Library module std::type_name. Expressed very roughly, it gives a single function get<T>() which returns the name of the type T.\n\nIn practice\n\nThe module is pretty straightforward, and operations allowed on the result are limited to getting a string representation and extracting the module and address of the type.\n\nmodule book::type_reflection {\n    use std::ascii::String;\n    use std::type_name::{Self, TypeName};\n\n    /// A function that returns the name of the type `T` and its module and address.\n    public fun do_i_know_you<T>(): (String, String, String) {\n        let type_name: TypeName = type_name::get<T>();\n\n        // there's a way to borrow\n        let str: &String = type_name.borrow_string();\n\n        let module_name: String = type_name.get_module();\n        let address_str: String = type_name.get_address();\n\n        // and a way to consume the value\n        let str = type_name.into_string();\n\n        (str, module_name, address_str)\n    }\n\n    #[test_only]\n    public struct MyType {}\n\n    #[test]\n    fun test_type_reflection() {\n        let (type_name, module_name, _address_str) = do_i_know_you<MyType>();\n\n        //\n        assert!(module_name == b\"type_reflection\".to_ascii_string(), 1);\n    }\n}\n\nFurther reading\n\nType reflection is an important part of the language, and it is a crucial part of some of the more advanced patterns.\n\nTesting\n\nA crucial part of any software development, and even more - blockchain development, is testing. Here, we will cover the basics of testing in Move and how to write and organize tests for your Move code.\n\nThe #[test] attribute\n\nTests in Move are functions marked with the #[test] attribute. This attribute tells the compiler that the function is a test function, and it should be run when the tests are executed. Test functions are regular functions, but they must take no any arguments and have no return value. They are excluded from the bytecode, and are never published.\n\nmodule book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n\nRunning Tests\n\nTo run tests, you can use the sui move test command. This command will first build the package in the test mode and then run all the tests found in the package. During test mode, modules from both sources/ and tests/ directories are processed, and the tests are executed.\n\n$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n\nTest Fail Cases with #[expected_failure]\n\nTests for fail cases can be marked with #[expected_failure]. This attribute placed on a #[test] function tells the compiler that the test is expected to fail. This is useful when you want to test that a function fails when a certain condition is met.\n\nThis attribute can only be placed on a #[test] function.\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test fails. If the test fails with a different abort code, the test will fail. If the execution did not abort, the test will also fail.\n\nmodule book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n\n\nThe abort_code argument can use constants defined in the tests module as well as imported from other modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\nUtilities with #[test_only]\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions or features. It simplifies the testing process and allows for more thorough testing. However, it is important to remember that these functions should not be included in the final package. This is where the #[test_only] attribute comes in handy.\n\nmodule book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n\n\nFunctions marked with the #[test_only] will be available to the test environment, and to the other modules if their visibility is set so.\n\nFurther Reading\nUnit Testing in the Move Reference.\nObject Model\n\nThis chapter describes the Object Model of Sui. It focuses on the theory and concepts behind the Object Model, preparing you for a practical dive into Sui Storage operations and resource ownership. For convenience and easier lookup, we split the chapter into several sections, each covering a specific aspect of the Object Model.\n\nIn no way should this chapter be considered a comprehensive guide to the Object Model. It is only a high-level overview of the concepts and principles behind the Object Model.\n\nFor a more detailed description, refer to the Sui Documentation.\n\nMove - Language for Digital Assets\n\nSmart-contract programming languages have historically focused on defining and managing digital assets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with digital currency tokens, establishing a blueprint for creating and managing digital currencies on the blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant evolution, popularising the concept of non-fungible tokens (NFTs), which represent unique, indivisible assets. These standards laid the groundwork for the complex digital assets we see today.\n\nHowever, Ethereum's programming model lacked a native representation of assets. In other words, externally, a Smart Contract behaved like an asset, but the language itself did not have a way to inherently represent assets. From the start, Move aimed to provide a first-class abstraction for assets, opening up new avenues for thinking about and programming assets.\n\nIt is important to highlight which properties are essential for an asset:\n\nOwnership: Every asset is associated with an owner(s), mirroring the straightforward concept of ownership in the physical world—just as you own a car, you can own a digital asset. Move enforces ownership in such a way that once an asset is moved, the previous owner completely loses any control over it. This mechanism ensures a clear and secure change of ownership.\n\nNon-copyable: In the real world, unique items cannot be duplicated effortlessly. Move applies this principle to digital assets, ensuring they cannot be arbitrarily copied within the program. This property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring the intrinsic value of physical assets.\n\nNon-discardable: Just as you cannot accidentally lose a house or a car without a trace, Move ensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly transferred or destroyed. This property guarantees the deliberate handling of digital assets, preventing accidental loss and ensuring accountability in asset management.\n\nMove managed to encapsulate these properties in its design, becoming an ideal language for digital assets.\n\nSummary\nMove was designed to provide a first-class abstraction for digital assets, enabling developers to create and manage assets natively.\nEssential properties of digital assets include ownership, non-copyability, and non-discardability, which Move enforces in its design.\nMove's asset model mirrors real-world asset management, ensuring secure and accountable asset ownership and transfer.\nFurther reading\nMove: A Language With Programmable Resources (pdf) by Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou*\nEvolution of Move\n\nWhile Move was created to manage digital assets, its initial storage model was bulky and not well-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had to create a new \"empty\" resource, and then Alice could transfer asset X to Bob. This process was not intuitive and presented implementation challenges, partly due to the restrictive design of Diem. Another drawback of the original design was the lack of built-in support for a \"transfer\" operation, requiring every module to implement its own storage transfer logic. Additionally, managing heterogeneous collections of assets in a single account was particularly challenging.\n\nSui addressed these challenges by redesigning the storage and ownership model of objects to more closely resemble real-world object interactions. With a native concept of ownership and transfer, Alice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different assets without any preparatory steps. These improvements laid the foundation for the Object Model in Sui.\n\nSummary\nMove's initial storage model was not well-suited for managing digital assets, requiring complex and restrictive transfer operations.\nSui introduced the Object Model, which provides a native concept of ownership, simplifying asset management and enabling heterogeneous collections.\nFurther reading\nWhy We Created Sui Move by Sam Blackshear\nWhat is an Object?\n\nThe Object Model in Sui can be viewed as a high-level abstraction representing digital assets as objects. These objects have their own type and associated behaviors, a unique identifier, and support native storage operations like transfer and share. Designed to be intuitive and easy to use, the Object Model enables a wide range of use cases to be implemented with ease.\n\nObjects in Sui have the following properties:\n\nType: Every object has a type, defining the structure and behavior of the object. Objects of different types cannot be mixed or used interchangeably, ensuring objects are used correctly according to their type system.\n\nUnique ID: Each object has a unique identifier, distinguishing it from other objects. This ID is generated upon the object's creation and is immutable. It's used to track and identify objects within the system.\n\nOwner: Every object is associated with an owner, who has control over the object. Ownership on Sui can be exclusive to an account, shared across the network, or frozen, allowing read-only access without modification or transfer capabilities. We will discuss ownership in more detail in the following sections.\n\nData: Objects encapsulate their data, simplifying management and manipulation. The data structure and operations are defined by the object's type.\n\nVersion: The transition from accounts to objects is facilitated by object versioning. Traditionally, blockchains use a nonce to prevent replay attacks. In Sui, the object's version acts as a nonce, preventing replay attacks for each object.\n\nDigest: Every object has a digest, which is a hash of the object's data. The digest is used to cryptographically verify the integrity of the object's data and ensures that it has not been tampered with. The digest is calculated when the object is created and is updated whenever the object's data changes.\n\nSummary\nObjects in Sui are high-level abstractions representing digital assets.\nObjects have a type, unique ID, owner, data, version, and digest.\nThe Object Model simplifies asset management and enables a wide range of use cases.\nFurther reading\nObject Model in Sui Documentation.\nOwnership\n\nSui introduces four distinct ownership types for objects: single owner, shared state, immutable shared state, and object-owner. Each model offers unique characteristics and suits different use cases, enhancing flexibility and control in object management.\n\nAccount Owner (or Single Owner)\n\nThe account owner, also known as the single owner model, is the foundational ownership type in Sui. Here, an object is owned by a single account, granting that account exclusive control over the object within the behaviors associated with its type. This model embodies the concept of true ownership, where the account possesses complete authority over the object, making it inaccessible to others for modification or transfer. This level of ownership clarity is a significant advantage over other blockchain systems, where ownership definitions can be more ambiguous, and smart contracts may have the ability to alter or transfer assets without the owner's consent.\n\nShared State\n\nSingle owner model has its limitations: for example, it is very tricky to implement a marketplace for digital assets without a shared state. For a generic marketplace scenario, imagine that Alice owns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come and buy the asset directly from the marketplace. The reason why this is tricky is that it is impossible to write a smart contract that would \"lock\" the asset in Alice's account and take it out when Bob buys it. First, it will be a violation of the single owner model, and second, it requires a shared access to the asset.\n\nTo facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this model, an object can be shared with the network. Shared objects can be read and modified by any account on the network, and the rules of interaction are defined by the implementation of the object. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other scenarios where multiple accounts need access to the same state.\n\nImmutable (Frozen) State\n\nSui also offers the frozen object model, where an object becomes permanently read-only. These immutable objects, while readable, cannot be modified or moved, providing a stable and constant state accessible to all network participants. Frozen objects are ideal for public data, reference materials, and other use cases where the state permanence is desirable.\n\nObject Owner\n\nThe last ownership model in Sui is the object owner. In this model, an object is owned by another object. This feature allows creating complex relationships between objects, store large heterogenious collections, and implementing extensible and modular systems. Practically speaking, since the transactions are initiated by accounts, the transaction still accesses the parent object, but it can then access the child objects through the parent object.\n\nA use case we love to mention is a game character. Alice can own the Hero object from a game, and the Hero can own items: also represented as objects, like a \"Map\", or a \"Compass\". Alice may take the \"Map\" from the \"Hero\" object, and then send it to Bob, or sell it on a marketplace. With object owner, it becomes very natural to imagine how the assets can be structured and managed in relation to each other.\n\nSummary\nSingle Owner: Objects are owned by a single account, granting exclusive control over the object.\nShared State: Objects can be shared with the network, allowing multiple accounts to read and modify the object.\nImmutable State: Objects become permanently read-only, providing a stable and constant state.\nObject Owner: Objects can own other objects, enabling complex relationships and modular systems.\nNext Steps\n\nIn the next section we will talk about transaction execution paths in Sui, and how the ownership models affect the transaction execution.\n\nFast Path & Consensus\n\nThe Object Model allows for variable transaction execution paths, depending on the object's ownership type. The transaction execution path determines how the transaction is processed and validated by the network. In this section, we'll explore the different transaction execution paths in Sui and how they interact with the consensus mechanism.\n\nConcurrency Challenge\n\nAt its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may try to modify or access the same data simultaneously in a decentralized environment. This requires a system for sequencing and validating transactions to support the network's consistency. Sui addresses this challenge through a consensus mechanism, ensuring all nodes agree on the transactions' sequence and state.\n\nConsider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same asset. The network must resolve this conflict to prevent double-spending, ensuring that at most one transaction succeeds while the other is rightfully rejected.\n\nFast Path\n\nHowever, not all transactions require the same level of validation and consensus. For example, if Alice wants to transfer an object that she owns to Bob, the network can process this transaction without sequencing it with respect to all other transactions in the network, as only Alice has the authority to access the object. This is known as the fast path execution, where transactions accessing account-owned objects are processed quickly without the need for extensive consensus. No concurrent data access -> simpler challenge -> fast path.\n\nAnother ownership model that allows for fast path execution is the immutable state. Since immutable objects cannot change, transactions involving them can be processed quickly without the need to sequence them.\n\nConsensus Path\n\nTransactions that do access shared state - on Sui it is represented with shared objects - require sequencing to ensure that the state is updated and consistented across all nodes. This is known as the execution through consensus, where transactions accessing shared objects are subject to the agreement process to maintain network consistency.\n\nObjects owned by Objects\n\nLastly, it is important to mention that objects owned by other objects are subject to the same rules as the parent object. If the parent object is shared, the child object is also transitively shared. If the parent object is immutable, the child object is also immutable.\n\nSummary\nFast Path: Transactions involving account-owned objects or immutable shared state are processed quickly without the need for extensive consensus.\nConsensus Path: Transactions involving shared objects require sequencing and consensus to ensure network integrity.\nObjects owned by Objects: Child objects inherit the ownership model of the parent object.\nUsing Objects\n\nIn the Object Model chapter we briefly explained the evolution of the Move language from an account-based model to an object-based model. In this chapter, we will dive deeper into the object model and explore how to use objects in your Sui applications. If you haven't read the Object Model chapter yet, we recommend you do so before continuing with this chapter.\n\nThe Key Ability\n\nIn the Basic Syntax chapter we already covered two out of four abilities - Drop and Copy. They affect the behaviour of the value in a scope and are not directly related to storage. It is time to cover the key ability, which allows the struct to be stored.\n\nHistorically, the key ability was created to mark the type as a key in the storage. A type with the key ability could be stored at top-level in the storage, and could be directly owned by an account or address. With the introduction of the Object Model, the key ability naturally became the defining ability for the object.\n\nObject Definition\n\nA struct with the key ability is considered an object and can be used in the storage functions. The Sui Verifier will require the first field of the struct to be named id and have the type UID.\n\npublic struct Object has key {\n    id: UID, // required\n    name: String,\n}\n\n/// Creates a new Object with a Unique ID\npublic fun new(name: String, ctx: &mut TxContext): Object {\n    Object {\n        id: object::new(ctx), // creates a new UID\n        name,\n    }\n}\n\n\nA struct with the key ability is still a struct, and can have any number of fields and associated functions. There is no special handling or syntax for packing, accessing or unpacking the struct.\n\nHowever, because the first field of an object struct must be of type UID - a non-copyable and non-droppable type (we will get to it very soon!), the struct transitively cannot have drop and copy abilities. Thus, the object is non-discardable by design.\n\nTypes with the key Ability\n\nDue to the UID requirement for types with key, none of the native types in Move can have the key ability, nor can any of the Standard Library types. The key ability is only present in the Sui Framework and custom types.\n\nNext Steps\n\nKey ability defines the object in Move, and objects are intended to be stored. In the next section we present the sui::transfer module, which provides native storage functions for objects.\n\nFurther reading\nType Abilities in the Move Reference.\nStorage Functions\n\nThe module that defines main storage operations is sui::transfer. It is implicitly imported in all packages that depend on the Sui Framework, so, like other implicitly imported modules (e.g. std::option or std::vector), it does not require adding a use statement.\n\nOverview\n\nThe transfer module provides functions to perform all three storage operations matching ownership types which we explained before:\n\nOn this page we will only talk about so-called restricted storage operations, later we will cover public ones, after the store ability is introduced.\n\nTransfer - send an object to an address, put it into account owned state;\nShare - put an object into a shared state, so it is available to everyone;\nFreeze - put an object into immutable state, so it becomes a public constant and can never change.\n\nThe transfer module is a go-to for most of the storage operations, except a special case with Dynamic Fields awaits us in the next chapter.\n\nOwnership and References: A Quick Recap\n\nIn the Ownership and Scope and References chapters, we covered the basics of ownership and references in Move. It is important that you understand these concepts when using storage functions. Here is a quick recap of the most important points:\n\nThe move semantics in Move means that the value is moved from one scope to another. In other words, if an instance of a type is passed to a function by value, it is moved to the function scope and can't be accessed in the caller scope anymore.\nTo maintain the ownership of the value, you can pass it by reference. Either by immutable reference &T or mutable reference &mut T. Then the value is borrowed and can be accessed in the caller scope, however the owner stays the same.\n/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n\nTransfer\n\nThe transfer::transfer function is a public function used to transfer an object to another address. Its signature is as follows, only accepts a type with the key ability and an address of the recipient. Please, note that the object is passed into the function by value, therefore it is moved to the function scope and then moved to the recipient address:\n\n// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to the transaction sender.\n\nmodule book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n\n\nWhen the module is published, the init function will get called, and the AdminCap object which we created there will be transferred to the transaction sender. The ctx.sender() function returns the sender address for the current transaction.\n\nOnce the AdminCap has been transferred to the sender, for example, to 0xa11ce, the sender, and only the sender, will be able to access the object. The object is now account owned.\n\nAccount owned objects are a subject to true ownership - only the account owner can access them. This is a fundamental concept in the Sui storage model.\n\nLet's extend the example with a function that uses AdminCap to authorize a mint of a new object and its transfer to another address:\n\n/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n\n\nThe mint_and_transfer function is a public function that \"could\" be called by anyone, but it requires an AdminCap object to be passed as the first argument by reference. Without it, the function will not be callable. This is a simple way to restrict access to privileged functions called Capability. Because the AdminCap object is account owned, only 0xa11ce will be able to call the mint_and_transfer function.\n\nThe Gifts sent to recipients will also be account owned, each gift being unique and owned exclusively by the recipient.\n\nA quick recap:\n\ntransfer function is used to send an object to an address;\nThe object becomes account owned and can only be accessed by the recipient;\nFunctions can be gated by requiring an object to be passed as an argument, creating a capability.\nFreeze\n\nThe transfer::freeze function is public function used to put an object into an immutable state. Once an object is frozen, it can never be changed, and it can be accessed by anyone by immutable reference.\n\nThe function signature is as follows, only accepts a type with the key ability. Just like all other storage functions, it takes the object by value:\n\n// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n\n\nLet's expand on the previous example and add a function that allows the admin to create a Config object and freeze it:\n\n/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n\n\nConfig is an object that has a message field, and the create_and_freeze function creates a new Config and freezes it. Once the object is frozen, it can be accessed by anyone by immutable reference. The message function is a public function that returns the message from the Config object. Config is now publicly available by its ID, and the message can be read by anyone.\n\nFunction definitions are not connected to the object's state. It is possible to define a function that takes a mutable reference to an object that is used as frozen. However, it won't be callable on a frozen object.\n\nThe message function can be called on an immutable Config object, however, two functions below are not callable on a frozen object:\n\n// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n\n\nTo summarize:\n\nfreeze_object function is used to put an object into an immutable state;\nOnce an object is frozen, it can never be changed, deleted or transferred, and it can be accessed by anyone by immutable reference;\nOwned -> Frozen\n\nSince the transfer::freeze signature accepts any type with the key ability, it can take an object that was created in the same scope, but it can also take an object that was owned by an account. This means that the freeze_object function can be used to freeze an object that was transferred to the sender. For security concerns, we would not want to freeze the AdminCap object - it would be a security risk to allow access to it to anyone. However, we can freeze the Gift object that was minted and transferred to the recipient:\n\nSingle Owner -> Immutable conversion is possible!\n\n/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n\nShare\n\nThe transfer::share function is a public function used to put an object into a shared state. Once an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable too). The function signature is as follows, only accepts a type with the key ability:\n\n// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\nSpecial Case: Shared Object Deletion\n\nWhile the shared object can't normally be taken by value, there is one special case where it can - if the function that takes it deletes the object. This is a special case in the Sui storage model, and it is used to allow the deletion of shared objects. To show how it works, we will create a function that creates and shares a Config object and then another one that deletes it:\n\n/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n\n\nThe create_and_share function creates a new Config object and shares it. The object is now publicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n\n\nThe delete_config function takes the Config object by value and deletes it, and Sui Verifier would allow this call. However, if the function returned the Config object back or attempted to freeze or transfer it, the Sui Verifier would reject the transaction.\n\n// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n\n\nTo summarize:\n\nshare_object function is used to put an object into a shared state;\nOnce an object is shared, it can be accessed by anyone by a mutable reference;\nShared objects can be deleted, but they can't be transferred or frozen.\nNext Steps\n\nNow that you know main features of the transfer module, you can start building more complex applications on Sui that involve storage operations. In the next chapter, we will cover the Store Ability which allows storing data inside objects and relaxes transfer restrictions which we barely touched on here. And after that we will cover the UID and ID types which are the most important types in the Sui storage model.\n\nAbility: Store\n\nNow that you have an understanding of top-level storage functions which are enabled by the key ability, we can talk about the last ability in the list - store.\n\nDefinition\n\nThe store is a special ability that allows a type to be stored in objects. This ability is required for the type to be used as a field in a struct that has the key ability. Another way to put it is that the store ability allows the value to be wrapped in an object.\n\nThe store ability also relaxes restrictions on transfer operations. We talk about it more in the Restricted and Public Transfer section.\n\nExample\n\nIn previous sections we already used types with the store ability: all objects must have a UID field, which we used in examples; we also used the String type as a part of the Config struct. The String type also has the store ability.\n\n/// This type has the `store` ability.\npublic struct Storable has store {}\n\n/// Config contains a `Storable` field which must have the `store` ability.\npublic struct Config has key, store {\n    id: UID,\n    stores: Storable,\n}\n\n/// MegaConfig contains a `Config` field which has the `store` ability.\npublic struct MegaConfig has key {\n    id: UID,\n    config: Config, // there it is!\n}\n\nTypes with the store Ability\n\nAll native types (except for references) in Move have the store ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the store ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference.\nUID and ID\n\nThe UID type is defined in the sui::object module and is a wrapper around an ID which, in turn, wraps the address type. The UIDs on Sui are guaranteed to be unique, and can't be reused after the object was deleted.\n\n// File: sui-framework/sources/object.move\n/// UID is a unique identifier of an object\npublic struct UID has store {\n    id: ID\n}\n\n/// ID is a wrapper around an address\npublic struct ID has store, drop {\n    bytes: address\n}\n\nFresh UID generation:\nUID is derived from the tx_hash and an index which is incremented for each new UID.\nThe derive_id function is implemented in the sui::tx_context module, and that is why TxContext is required for UID generation.\nSui Verifier will not allow using a UID that wasn't created in the same function. That prevents UIDs from being pre-generated and reused after the object was unpacked.\n\nNew UID is created with the object::new(ctx) function. It takes a mutable reference to TxContext, and returns a new UID.\n\nlet ctx = &mut tx_context::dummy();\nlet uid = object::new(ctx);\n\n\nOn Sui, UID acts as a representation of an object, and allows defining behaviors and features of an object. One of the key-features - Dynamic Fields - is possible because of the UID type being explicit. Additionally, it allows the Transfer To Object (TTO) which we will explain later in this chapter.\n\nUID lifecycle\n\nThe UID type is created with the object::new(ctx) function, and it is destroyed with the object::delete(uid) function. The object::delete consumes the UID by value, and it is impossible to delete it unless the value was unpacked from an Object.\n\nlet ctx = &mut tx_context::dummy();\n\nlet char = Character {\n    id: object::new(ctx)\n};\n\nlet Character { id } = char;\nid.delete();\n\nKeeping the UID\n\nThe UID does not need to be deleted immediately after the object struct is unpacked. Sometimes it may carry Dynamic Fields or objects transferred to it via Transfer To Object. In such cases, the UID may be kept and stored in a separate object.\n\nProof of Deletion\n\nThe ability to return the UID of an object may be utilized in pattern called proof of deletion. It is a rarely used technique, but it may be useful in some cases, for example, the creator or an application may incentivize the deletion of an object by exchanging the deleted IDs for some reward.\n\nIn framework development this method could be used ignore / bypass certain restrictions on \"taking\" the object. If there's a container that enforces certain logic on transfers, like Kiosk does, there could be a special scenario of skipping the checks by providing a proof of deletion.\n\nThis is one of the open topics for exploration and research, and it may be used in various ways.\n\nID\n\nWhen talking about UIDs we should also mention the ID type. It is a wrapper around the address type, and is used to represent an address-pointer. Usually, ID is used to point at an object, however, there's no restriction, and no guarantee that the ID points to an existing object.\n\nID can be received as a transaction argument in a Transaction Block. Alternatively, ID can be created from an address value using to_id() function.\n\nfresh_object_address\n\nTxContext provides the fresh_object_address function which can be utilized to create unique addresses and IDs - it may be useful in some application that assign unique identifiers to user actions - for example, an order_id in a marketplace.\n\nRestricted and Public Transfer\n\nStorage Operations that we described in the previous sections are restricted by default - they can only be called in the module defining the object. In other terms, the type must be internal to the module to be used in storage operations. This restriction is implemented in the Sui Verifier and is enforced at the bytecode level.\n\nHowever, to allow objects to be transferred and stored in other modules, these restrictions can be relaxed. The sui::transfer module offers a set of public_* functions that allow calling storage operations in other modules. The functions are prefixed with public_ and are available to all modules and transactions.\n\nPublic Storage Operations\n\nThe sui::transfer module provides the following public functions. They are almost identical to the ones we already covered, but can be called from any module.\n\n// File: sui-framework/sources/transfer.move\n/// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(object: T, to: address) {}\n\n/// Public version of the `share_object` function.\npublic fun public_share_object<T: key + store>(object: T) {}\n\n/// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(object: T) {}\n\n\nTo illustrate the usage of these functions, consider the following example: module A defines an ObjectK with key and ObjectKS with key + store abilities, and module B tries to implement a transfer function for these objects.\n\nIn this example we use transfer::transfer, but the behaviour is identical for share_object and freeze_object functions.\n\n/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`\n/// abilities respectively\nmodule book::transfer_a {\n    public struct ObjectX has key { id: UID }\n    public struct ObjectKS has key, store { id: UID }\n}\n\n/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts\n/// to implement different `transfer` functions for them\nmodule book::transfer_b {\n    // types are not internal to this module\n    use book::transfer_a::{ObjectK, ObjectKS};\n\n    // Fails! ObjectX is not `store`, and ObjectX is not internal to this module\n    public fun transfer_k(k: ObjectK, to: address) {\n        sui::transfer::transfer(k, to);\n    }\n\n    // Fails! ObjectKS has `store` but the function is not public\n    public fun transfer_ks(ks: ObjectKS, to: address) {\n        sui::transfer::transfer(ks, to);\n    }\n\n    // Fails! ObjectK is not `store`, `public_transfer` requires `store`\n    public fun public_transfer_k(k: ObjectK) {\n        sui::transfer::public_transfer(k);\n    }\n\n    // Works! ObjectKS has `store` and the function is public\n    public fun public_transfer_ks(y: ObjectKS, to: address) {\n        sui::transfer::public_transfer(y, to);\n    }\n}\n\n\nTo expand on the example above:\n\n transfer_x fails because ObjectK is not internal to module transfer_b\n transfer_y fails because ObjectKS is not internal to module transfer_b\n public_transfer_x fails because ObjectK does not have the store ability\n public_transfer_y works because ObjectKS has the store ability and the transfer is public\nImplications of store\n\nThe decision on whether to add the store ability to a type should be made carefully. On one hand, it is de-facto a requirement for the type to be usable by other applications. On the other hand, it allows wrapping and changing the intended storage model. For example, a character may be intended to be owned by accounts, but with the store ability it can be frozen (cannot be shared - this transition is restricted).\n\nAdvanced Programmability\n\nIn previous chapters we've covered the basics of Move and Sui Storage Model. Now it's time to dive deeper into the advanced topics of Sui programmability.\n\nThis chapter introduces more complex concepts, practices and features of Move and Sui that are essential for building more sophisticated applications. It is intended for developers who are already familiar with the basics of Move and Sui, and are looking to expand their knowledge and skills.\n\nTransaction Context\n\nEvery transaction has the execution context. The context is a set of predefined variables that are available to the program during execution. For example, every transaction has a sender address, and the transaction context contains a variable that holds the sender address.\n\nThe transaction context is available to the program through the TxContext struct. The struct is defined in the sui::tx_context module and contains the following fields:\n\n// File: sui-framework/sources/tx_context.move\n/// Information about the transaction currently being executed.\n/// This cannot be constructed by a transaction--it is a privileged object created by\n/// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.\nstruct TxContext has drop {\n    /// The address of the user that signed the current transaction\n    sender: address,\n    /// Hash of the current transaction\n    tx_hash: vector<u8>,\n    /// The current epoch number\n    epoch: u64,\n    /// Timestamp that the epoch started at\n    epoch_timestamp_ms: u64,\n    /// Counter recording the number of fresh id's created while executing\n    /// this transaction. Always 0 at the start of a transaction\n    ids_created: u64\n}\n\n\nTransaction context cannot be constructed manually or directly modified. It is created by the system and passed to the function as a reference in a transaction. Any function called in a Transaction has access to the context and can pass it into the nested calls.\n\nTxContext has to be the last argument in the function signature.\n\nReading the Transaction Context\n\nWith only exception of the ids_created, all of the fields in the TxContext have getters. The getters are defined in the sui::tx_context module and are available to the program. The getters don't require &mut because they don't modify the context.\n\npublic fun some_action(ctx: &TxContext) {\n    let me = ctx.sender();\n    let epoch = ctx.epoch();\n    let digest = ctx.digest();\n    // ...\n}\n\nMutability\n\nThe TxContext is required to create new objects (or just UIDs) in the system. New UIDs are derived from the transaction digest, and for the digest to be unique, there needs to be a changing parameter. Sui uses the ids_created field for that. Every time a new UID is created, the ids_created field is incremented by one. This way, the digest is always unique.\n\nInternally, it is represented as the derive_id function:\n\n// File: sui-framework/sources/tx_context.move\nnative fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;\n\nGenerating unique addresses\n\nThe underlying derive_id function can also be utilized in your program to generate unique addresses. The function itself is not exposed, but a wrapper function fresh_object_address is available in the sui::tx_context module. It may be useful if you need to generate a unique identifier in your program.\n\n// File: sui-framework/sources/tx_context.move\n/// Create an `address` that has not been used. As it is an object address, it will never\n/// occur as the address for a user.\n/// In other words, the generated address is a globally unique object ID.\npublic fun fresh_object_address(ctx: &mut TxContext): address {\n    let ids_created = ctx.ids_created;\n    let id = derive_id(*&ctx.tx_hash, ids_created);\n    ctx.ids_created = ids_created + 1;\n    id\n}\n\nModule Initializer\n\nA common use case in many applications is to run certain code just once when the package is published. Imagine a simple store module that needs to create the main Store object upon its publication. In Sui, this is achieved by defining an init function within the module. This function will automatically be called when the module is published.\n\nAll of the modules' init functions are called during the publishing process. Currently, this behavior is limited to the publish command and does not extend to package upgrades.\n\nmodule book::shop {\n    /// The Capability which grants the Shop owner the right to manage\n    /// the shop.\n    public struct ShopOwnerCap has key, store { id: UID }\n\n    /// The singular Shop itself, created in the `init` function.\n    public struct Shop has key {\n        id: UID,\n        /* ... */\n    }\n\n    // Called only once, upon module publication. It must be\n    // private to prevent external invocation.\n    fun init(ctx: &mut TxContext) {\n        // Transfers the ShopOwnerCap to the sender (publisher).\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        // Shares the Shop object.\n        transfer::share_object(Shop {\n            id: object::new(ctx)\n        });\n    }\n}\n\n\nIn the same package, another module can have its own init function, encapsulating distinct logic.\n\n// In the same package as the `shop` module\nmodule book::bank {\n\n    public struct Bank has key {\n        id: UID,\n        /* ... */\n    }\n\n    fun init(ctx: &mut TxContext) {\n        transfer::share_object(Bank {\n            id: object::new(ctx)\n        });\n    }\n}\n\ninit features\n\nThe function is called on publish, if it is present in the module and follows the rules:\n\nThe function has to be named init, be private and have no return values.\nTakes one or two arguments: One Time Witness (optional) and TxContext. With `TxContext always being the last argument.\nfun init(ctx: &mut TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }\n\n\nTxContext can also be passed as immutable reference: &TxContext. However, practically speaking, it should always be &mut TxContext since the init function can't access the onchain state and to create new objects it requires the mutable reference to the context.\n\nfun init(ctx: &TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &TxContext) { /* ... */ }\n\nTrust and security\n\nWhile init function can be used to create sensitive objects once, it is important to know that the same object (eg. StoreOwnerCap from the first example) can still be created in another function. Especially given that new functions can be added to the module during an upgrade. So the init function is a good place to set up the initial state of the module, but it is not a security measure on its own.\n\nThere are ways to guarantee that the object was created only once, such as the One Time Witness. And there are ways to limit or disable the upgrade of the module, which we will cover in the Package Upgrades chapter.\n\nNext steps\n\nAs follows from the definition, the init function is guaranteed to be called only once when the module is published. So it is a good place to put the code that initializes module's objects and sets up the environment and configuration.\n\nFor example, if there's a Capability which is required for certain actions, it should be created in the init function. In the next chapter we will talk about the Capability pattern in more detail.\n\nPattern: Capability\n\nIn programming, a capability is a token that gives the owner the right to perform a specific action. It is a pattern that is used to control access to resources and operations. A simple example of a capability is a key to a door. If you have the key, you can open the door. If you don't have the key, you can't open the door. A more practical example is an Admin Capability which allows the owner to perform administrative operations, which regular users cannot.\n\nCapability is an Object\n\nIn the Sui Object Model, capabilities are represented as objects. An owner of an object can pass this object to a function to prove that they have the right to perform a specific action. Due to strict typing, the function taking a capability as an argument can only be called with the correct capability.\n\nThere's a convention to name capabilities with the Cap suffix, for example, AdminCap or KioskOwnerCap.\n\nmodule book::capability {\n    use std::string::String;\n    use sui::event;\n\n    /// The capability granting the application admin the right to create new\n    /// accounts in the system.\n    public struct AdminCap has key, store { id: UID }\n\n    /// The user account in the system.\n    public struct Account has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// A simple `Ping` event with no data.\n    public struct Ping has copy, drop { by: ID }\n\n    /// Creates a new account in the system. Requires the `AdminCap` capability\n    /// to be passed as the first argument.\n    public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n        Account {\n            id: object::new(ctx),\n            name,\n        }\n    }\n\n    /// Account, and any other objects, can also be used as a Capability in the\n    /// application. For example, to emit an event.\n    public fun send_ping(acc: &Account) {\n        event::emit(Ping {\n            by: acc.id.to_inner()\n        })\n    }\n\n    /// Updates the account name. Can only be called by the `Account` owner.\n    public fun update(account: &mut Account, name: String) {\n        account.name = name;\n    }\n}\n\nUsing init for Admin Capability\n\nA very common practice is to create a single AdminCap object on package publish. This way, the application can have a setup phase where the admin account prepares the state of the application.\n\nmodule book::admin_cap {\n    /// The capability granting the admin privileges in the system.\n    /// Created only once in the `init` function.\n    public struct AdminCap has key { id: UID }\n\n    /// Create the AdminCap object on package publish and transfer it to the\n    /// package owner.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            AdminCap { id: object::new(ctx) },\n            ctx.sender()\n        )\n    }\n}\n\nAddress check vs Capability\n\nUtilizing objects as capabilities is a relatively new concept in blockchain programming. And in other smart-contract languages, authorization is often performed by checking the address of the sender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities for better security, discoverability, and code organization.\n\nLet's look at how the new function that creates a user would look like if it was using the address check:\n\n/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n\n\nAnd now, let's see how the same function would look like with the capability:\n\n/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n\n\nUsing capabilities has several advantages over the address check:\n\nMigration of admin rights is easier with capabilities due to them being objects. In case of address, if the admin address changes, all the functions that check the address need to be updated - hence, require a package upgrade.\nFunction signatures are more descriptive with capabilities. It is clear that the new function requires the AdminCap to be passed as an argument. And this function can't be called without it.\nObject Capabilities don't require extra checks in the function body, and hence, decrease the chance of a developer mistake.\nAn owned Capability also serves in discovery. The owner of the AdminCap can see the object in their account (via a Wallet or Explorer), and know that they have the admin rights. This is less transparent with the address check.\n\nHowever, the address approach has its own advantages. For example, if an address is multisig, and transaction building gets more complex, it might be easier to check the address. Also, if there's a central object of the application that is used in every function, it can store the admin address, and this would simplify migration. The central object approach is also valuable for revokable capabilities, where the admin can revoke the capability from the user.\n\nEpoch and Time\n\nSui has two ways of accessing the current time: Epoch and Time. The former represents operational periods in the system and changed roughly every 24 hours. The latter represents the current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.\n\nEpoch\n\nEpochs are used to separate the system into operational periods. During an epoch the validator set is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial role in the consensus algorithm and are used to determine the current validator set. They are also used as measurement in the staking mechanism.\n\nEpoch can be read from the transaction context:\n\npublic fun current_epoch(ctx: &TxContext) {\n    let epoch = ctx.epoch();\n    // ...\n}\n\n\nIt is also possible to get the unix timestamp of the epoch start:\n\npublic fun current_epoch_start(ctx: &TxContext) {\n    let epoch_start = ctx.epoch_timestamp_ms();\n    // ...\n}\n\n\nNormally, epochs are used in staking and system operations, however, in custom scenarios they can be used to emulate 24h periods. They are critical if an application relies on the staking logic or needs to know the current validator set.\n\nTime\n\nFor a more precise time measurement, Sui provides the Clock object. It is a system object that is updated during checkpoints by the system, which stores the current time in milliseconds since the Unix Epoch. The Clock object is defined in the sui::clock module and has a reserved address 0x6.\n\nClock is a shared object, but it a transaction attempting to access it mutably will fail. This limitation allows parallel access to the Clock object, which is important for maintaining performance.\n\n// File: sui-framework/clock.move\n/// Singleton shared object that exposes time to Move calls.  This\n/// object is found at address 0x6, and can only be read (accessed\n/// via an immutable reference) by entry functions.\n///\n/// Entry Functions that attempt to accept `Clock` by mutable\n/// reference or value will fail to verify, and honest validators\n/// will not sign or execute transactions that use `Clock` as an\n/// input parameter, unless it is passed by immutable reference.\nstruct Clock has key {\n    id: UID,\n    /// The clock's timestamp, which is set automatically by a\n    /// system transaction every time consensus commits a\n    /// schedule, or by `sui::clock::increment_for_testing` during\n    /// testing.\n    timestamp_ms: u64,\n}\n\n\nThere is only one public function available in the Clock module - timestamp_ms. It returns the current time in milliseconds since the Unix Epoch.\n\nuse sui::clock::Clock;\n\n/// Clock needs to be passed as an immutable reference.\npublic fun current_time(clock: &Clock) {\n    let time = clock.timestamp_ms();\n    // ...\n}\n\nCollections\n\nCollection types are a fundamental part of any programming language. They are used to store a collection of data, such as a list of items. The vector type has already been covered in the vector section, and in this chapter we will cover the vector-based collection types offered by the Sui Framework.\n\nVector\n\nWhile we have previously covered the vector type in the vector section, it is worth going over it again in a new context. This time we will cover the usage of the vector type in objects and how it can be used in an application.\n\nmodule book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n\nVecSet\n\nVecSet is a collection type that stores a set of unique items. It is similar to a vector, but it does not allow duplicate items. This makes it useful for storing a collection of unique items, such as a list of unique IDs or addresses.\n\nmodule book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\nVecMap\n\nVecMap is a collection type that stores a map of key-value pairs. It is similar to a VecSet, but it allows you to associate a value with each item in the set. This makes it useful for storing a collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs and their associated data.\n\nKeys in a VecMap are unique, and each key can only be associated with a single value. If you try to insert a key-value pair with a key that already exists in the map, the old value will be replaced with the new value.\n\nmodule book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n\nLimitations\n\nStandard collection types are a great way to store typed data with guaranteed safety and consistency. However, they are limited by the type of data they can store - the type system won't allow you to store a wrong type in a collection; and they're limited in size - by the object size limit. They will work for relatively small-sized sets and lists, but for larger collections you may need to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion is not guaranteed, an attempt to compare a VecSet to another VecSet may not yield the expected results.\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type 'sui::vec_set::VecSet' may yield unexpected result\n\nlet mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and the two VecSet instances may have different orders of elements. And the comparison will fail even if the two VecSet instances contain the same elements.\n\nSummary\nVector is a native type that allows storing a list of items.\nVecSet is built on top of vector and allows storing sets of unique items.\nVecMap is used to store key-value pairs in a map-like structure.\nVector-based collections are strictly typed and limited by the object size limit and are best suited for small-sized sets and lists.\nNext Steps\n\nIn the next section we will cover Dynamic Fields - an important primitive that allows for Dynamic Collections - a way to store large collections of data in a more flexible, yet more expensive way.\n\nDynamic Fields\n\nSui Object model allows objects to be attached to other objects as dynamic fields. The behavior is similar to how a Map works in other programming languages. However, unlike a Map which in Move would be strictly typed (we have covered it in the Collections section), dynamic fields allow attaching objects of any type. A similar approach from the world of frontend development would be a JavaScript Object type which allows storing any type of data dynamically.\n\nThere's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic fields can be used to store large amounts of data that don't fit into the object limit size.\n\nDynamic Fields allow for a wide range of applications, from splitting data into smaller parts to avoid object size limit to attaching objects as a part of application logic.\n\nDefinition\n\nDynamic Fields are defined in the sui::dynamic_field module of the Sui Framework. They are attached to object's UID via a name, and can be accessed using that name. There can be only one field with a given name attached to an object.\n\nFile: sui-framework/sources/dynamic_field.move\n\n/// Internal object used for storing the field and value\npublic struct Field<Name: copy + drop + store, Value: store> has key {\n    /// Determined by the hash of the object ID, the field name\n    /// value and it's type, i.e. hash(parent.id || name || Name)\n    id: UID,\n    /// The value for the name of this field\n    name: Name,\n    /// The value bound to this field\n    value: Value,\n}\n\n\nAs the definition shows, dynamic fields are stored in an internal Field object, which has the UID generated in a deterministic way based on the object ID, the field name, and the field type. The Field object contains the field name and the value bound to it. The constraints on the Name and Value type parameters define the abilities that the key and value must have.\n\nUsage\n\nThe methods available for dynamic fields are straightforward: a field can be added with add, removed with remove, and read with borrow and borrow_mut. Additionally, the exists_ method can be used to check if a field exists (for stricter checks with type, there is an exists_with_type method).\n\nmodule book::dynamic_collection {\n    // a very common alias for `dynamic_field` is `df` since the\n    // module name is quite long\n    use sui::dynamic_field as df;\n    use std::string::String;\n\n    /// The object that we will attach dynamic fields to.\n    public struct Character has key {\n        id: UID\n    }\n\n    // List of different accessories that can be attached to a character.\n    // They must have the `store` ability.\n    public struct Hat has key, store { id: UID, color: u32 }\n    public struct Mustache has key, store { id: UID }\n\n    #[test]\n    fun test_character_and_accessories() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Attach a hat to the character's UID\n        df::add(\n            &mut character.id,\n            b\"hat_key\",\n            Hat { id: object::new(ctx), color: 0xFF0000 }\n        );\n\n        // Similarly, attach a mustache to the character's UID\n        df::add(\n            &mut character.id,\n            b\"mustache_key\",\n            Mustache { id: object::new(ctx) }\n        );\n\n        // Check that the hat and mustache are attached to the character\n        //\n        assert!(df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        // Modify the color of the hat\n        let hat: &mut Hat = df::borrow_mut(&mut character.id, b\"hat_key\");\n        hat.color = 0x00FF00;\n\n        // Remove the hat and mustache from the character\n        let hat: Hat = df::remove(&mut character.id, b\"hat_key\");\n        let mustache: Mustache = df::remove(&mut character.id, b\"mustache_key\");\n\n        // Check that the hat and mustache are no longer attached to the character\n        assert!(!df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(!df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        sui::test_utils::destroy(character);\n        sui::test_utils::destroy(mustache);\n        sui::test_utils::destroy(hat);\n    }\n}\n\n\nIn the example above, we define a Character object and two different types of accessories that could never be put together in a vector. However, dynamic fields allow us to store them together in a single object. Both objects are attached to the Character via a vector<u8> (bytestring literal), and can be accessed using their respective keys.\n\nAs you can see, when we attached the accessories to the Character, we passed them by value. In other words, both values were moved to a new scope, and their ownership was transferred to the Character object. If we changed the ownership of Character object, the accessories would have been moved with it.\n\nAnd the last important property of dynamic fields we should highlight is that they are accessed through their parent. This means that the Hat and Mustache objects are not directly accessible and follow the same rules as the parent object.\n\nForeign Types as Dynamic Fields\n\nDynamic fields allow objects to carry data of any type, including those defined in other modules. This is possible due to their generic nature and relatively weak constraints on the type parameters. Let's illustrate this by attaching a few different values to a Character object.\n\nlet mut character = Character { id: object::new(ctx) };\n\n// Attach a `String` via a `vector<u8>` name\ndf::add(&mut character.id, b\"string_key\", b\"Hello, World!\".to_string());\n\n// Attach a `u64` via a `u32` name\ndf::add(&mut character.id, 1000u32, 1_000_000_000u64);\n\n// Attach a `bool` via a `bool` name\ndf::add(&mut character.id, true, false);\n\n\nIn this example we showed how different types can be used for both name and the value of a dynamic field. The String is attached via a vector<u8> name, the u64 is attached via a u32 name, and the bool is attached via a bool name. Anything is possible with dynamic fields!\n\nOrphaned Dynamic Fields\n\nTo prevent orphaned dynamic fields, please, use Dynamic Collection Types such as Bag as they track the dynamic fields and won't allow unpacking if there are attached fields.\n\nThe object::delete() function, which is used to delete a UID, does not track the dynamic fields, and cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the dynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic fields are still stored in the blockchain, but they will never become accessible again.\n\nlet hat = Hat { id: object::new(ctx), color: 0xFF0000 };\nlet mut character = Character { id: object::new(ctx) };\n\n// Attach a `Hat` via a `vector<u8>` name\ndf::add(&mut character.id, b\"hat_key\", hat);\n\n// ! DO NOT do this in your code\n// ! Danger - deleting the parent object\nlet Character { id } = character;\nid.delete();\n\n// ...`Hat` is now stuck in a limbo, it will never be accessible again\n\n\nOrphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed. One way to avoid orphaned dynamic fields during unpacking on an object is to return the UID and store it somewhere temporarily until the dynamic fields are removed and handled properly.\n\nCustom Type as a Field Name\n\nIn the examples above, we used primitive types as field names since they have the required set of abilities. But dynamic fields get even more interesting when we use custom types as field names. This allows for a more structured way of storing data, and also allows for protecting the field names from being accessed by other modules.\n\n/// A custom type with fields in it.\npublic struct AccessoryKey has copy, drop, store { name: String }\n\n/// An empty key, can be attached only once.\npublic struct MetadataKey has copy, drop, store {}\n\n\nTwo field names that we defined above are AccessoryKey and MetadataKey. The AccessoryKey has a String field in it, hence it can be used multiple times with different name values. The MetadataKey is an empty key, and can be attached only once.\n\nlet mut character = Character { id: object::new(ctx) };\n\n// Attaching via an `AccessoryKey { name: b\"hat\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"hat\".to_string() },\n    Hat { id: object::new(ctx), color: 0xFF0000 }\n);\n// Attaching via an `AccessoryKey { name: b\"mustache\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"mustache\".to_string() },\n    Mustache { id: object::new(ctx) }\n);\n\n// Attaching via a `MetadataKey`\ndf::add(&mut character.id, MetadataKey {}, 42);\n\n\nAs you can see, custom types do work as field names but as long as they can be constructed by the module, in other words - if they are internal to the module and defined in it. This limitation on struct packing can open up new ways in the design of the application.\n\nThis approach is used in the Object Capability pattern, where an application can authorize a foreign object to perform operations in it while not exposing the capabilities to other modules.\n\nExposing UID\n\nMutable access to UID is a security risk. Exposing UID of your type as a mutable reference can lead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects the Transfer to Object and Dynamic Object Fields. Make sure to understand the implications before exposing the UID as a mutable reference.\n\nBecause dynamic fields are attached to UIDs, their usage in other modules depends on whether the UID can be accessed. By default struct visibility protects the id field and won't let other modules access it directly. However, if there's a public accessor method that returns a reference to UID, dynamic fields can be read in other modules.\n\n/// Exposes the UID of the character, so that other modules can read\n/// dynamic fields.\npublic fun uid(c: &Character): &UID {\n    &c.id\n}\n\n\nIn the example above, we show how to expose the UID of a Character object. This solution may work for some applications, however, it is important to remember that exposed UID allows reading any dynamic field attached to the object.\n\nIf you need to expose the UID only within the package, use a restrictive visibility, like public(package), or even better - use more specific accessor methods that would allow only reading specific fields.\n\n/// Only allow modules in the same package to access the UID.\npublic(package) fun uid_package(c: &Character): &UID {\n    &c.id\n}\n\n/// Allow borrowing dynamic fields from the character.\npublic fun borrow<Name: copy + store + drop, Value: store>(\n    c: &Character,\n    n: Name\n): &Value {\n    df::borrow(&c.id, n)\n}\n\nDynamic Fields vs Fields\n\nDynamic Fields are more expensive than regular fields, as they require additional storage and costs for accessing them. Their flexibility comes at a price, and it is important to understand the implications when making a decision between using dynamic fields and regular fields.\n\nLimits\n\nDynamic Fields are not subject to the object size limit, and can be used to store large amounts of data. However, they are still subject to the dynamic fields created limit, which is set to 1000 fields per transaction.\n\nApplications\n\nDynamic Fields can play a crucial role in applications of any complexity. They open up a variety of different use cases, from storing heterogeneous data to attaching objects as part of the application logic. They allow for certain upgradeability practices based on the ability to define them later and change the type of the field.\n\nNext Steps\n\nIn the next section we will cover Dynamic Object Fields and explain how they differ from dynamic fields, and what are the implications of using them.\n\nDynamic Object Fields\n\nThis section expands on the Dynamic Fields. Please, read it first to understand the basics of dynamic fields.\n\nAnother variation of dynamic fields is dynamic object fields, which have certain differences from regular dynamic fields. In this section, we will cover the specifics of dynamic object fields and explain how they differ from regular dynamic fields.\n\nGeneral recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields, especially if there's no need for direct discovery through the ID. The extra costs of dynamic object fields may not be justified by the benefits they provide.\n\nDefinition\n\nDynamic Object Fields are defined in the sui::dynamic_object_fields module in the Sui Framework. They are similar to dynamic fields in many ways, but unlike them, dynamic object fields have an extra constraint on the Value type. The Value must have a combination of key and store, not just store as in the case of dynamic fields.\n\nThey're less explicit in their framework definition, as the concept itself is more abstract:\n\nFile: sui-framework/sources/dynamic_object_fields.move\n\n/// Internal object used for storing the field and the name associated with the\n/// value. The separate type is necessary to prevent key collision with direct\n/// usage of dynamic_field\npublic struct Wrapper<Name> has copy, drop, store {\n    name: Name,\n}\n\n\nUnlike Field type in the Dynamic Fields section, the Wrapper type only stores the name of the field. The value is the object itself, and is not wrapped.\n\nThe constraints on the Value type become visible in the methods available for dynamic object fields. Here's the signature for the add function:\n\n/// Adds a dynamic object field to the object `object: &mut UID` at field\n/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object\n/// already has that field with that name.\npublic fun add<Name: copy + drop + store, Value: key + store>(\n    // we use &mut UID in several spots for access control\n    object: &mut UID,\n    name: Name,\n    value: Value,\n) { /* implementation omitted */ }\n\n\nThe rest of the methods which are identical to the ones in the Dynamic Fields section have the same constraints on the Value type. Let's list them for reference:\n\nadd - adds a dynamic object field to the object\nremove - removes a dynamic object field from the object\nborrow - borrows a dynamic object field from the object\nborrow_mut - borrows a mutable reference to a dynamic object field from the object\nexists_ - checks if a dynamic object field exists\nexists_with_type - checks if a dynamic object field exists with a specific type\n\nAdditionally, there is an id method which returns the ID of the Value object without specifying its type.\n\nUsage & Differences with Dynamic Fields\n\nThe main difference between dynamic fields and dynamic object fields is that the latter allows storing only objects as values. This means that you can't store primitive types like u64 or bool. It may be considered a limitation, if not for the fact that dynamic object fields are not wrapped into a separate object.\n\nThe relaxed requirement for wrapping keeps the object available for off-chain discovery via its ID. However, this property may not be outstanding if wrapped object indexing is implemented, making the dynamic object fields a redundant feature.\n\nmodule book::dynamic_object_field {\n    use std::string::String;\n\n    // there are two common aliases for the long module name: `dof` and\n    // `ofield`. Both are commonly used and met in different projects.\n    use sui::dynamic_object_field as dof;\n    use sui::dynamic_field as df;\n\n    /// The `Character` that we will use for the example\n    public struct Character has key { id: UID }\n\n    /// Metadata that doesn't have the `key` ability\n    public struct Metadata has store, drop { name: String }\n\n    /// Accessory that has the `key` and `store` abilities.\n    public struct Accessory has key, store { id: UID }\n\n    #[test]\n    fun equip_accessory() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Create an accessory and attach it to the character\n        let hat = Accessory { id: object::new(ctx) };\n\n        // Add the hat to the character. Just like with `dynamic_fields`\n        dof::add(&mut character.id, b\"hat_key\", hat);\n\n        // However for non-key structs we can only use `dynamic_field`\n        df::add(&mut character.id, b\"metadata_key\", Metadata {\n            name: b\"John\".to_string()\n        });\n\n        // Borrow the hat from the character\n        let hat_id = dof::id(&character.id, b\"hat_key\").extract(); // Option<ID>\n        let hat_ref: &Accessory = dof::borrow(&character.id, b\"hat_key\");\n        let hat_mut: &mut Accessory = dof::borrow_mut(&mut character.id, b\"hat_key\");\n        let hat: Accessory = dof::remove(&mut character.id, b\"hat_key\");\n\n        // Clean up, Metadata is an orphan now.\n        sui::test_utils::destroy(hat);\n        sui::test_utils::destroy(character);\n    }\n}\n\nPricing Differences\n\nDynamic Object Fields come a little more exensive than dynamic fields. Because of their internal structure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of adding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.\n\nNext Steps\n\nBoth dynamic field and dynamic object fields are powerful features which allow for innovative solutions in applications. However, they are relatively low-level and require careful handling to avoid orphaned fields. In the next section, we will introduce a higher-level abstraction - Dynamic Collections - which can help with managing dynamic fields and objects more effectively.\n\nDynamic Collections\n\nSui Framework offers a variety of collection types that build on the dynamic fields and dynamic object fields concepts. These collections are designed to be a safer and more understandable way to store and manage dynamic fields and objects.\n\nFor each collection type we will specify the primitive they use, and the specific features they offer.\n\nUnlike dynamic (object) fields which operate on UID, collection types have their own type and allow calling associated functions.\n\nCommon Concepts\n\nAll of the collection types share the same set of methods, which are:\n\nadd - adds a field to the collection\nremove - removes a field from the collection\nborrow - borrows a field from the collection\nborrow_mut - borrows a mutable reference to a field from the collection\ncontains - checks if a field exists in the collection\nlength - returns the number of fields in the collection\nis_empty - checks if the length is 0\n\nAll collection types support index syntax for borrow and borrow_mut methods. If you see square brackets in the examples, they are translated into borrow and borrow_mut calls.\n\nlet hat: &Hat = &bag[b\"key\"];\nlet hat_mut: &mut Hat = &mut bag[b\"key\"];\n\n// is equivalent to\nlet hat: &Hat = bag.borrow(b\"key\");\nlet hat_mut: &mut Hat = bag.borrow_mut(b\"key\");\n\n\nIn the examples we won't focus on these functions, but rather on the differences between the collection types.\n\nBag\n\nBag, as the name suggests, acts as a \"bag\" of heterogeneous values. It is a simple, non-generic type that can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and can't be destroyed if it's not empty.\n\n// File: sui-framework/sources/bag.move\npublic struct Bag has key, store {\n    /// the ID of this bag\n    id: UID,\n    /// the number of key-value pairs in the bag\n    size: u64,\n}\n\n\nDue to Bag storing any types, the extra methods it offers is:\n\ncontains_with_type - checks if a field exists with a specific type\n\nUsed as a struct field:\n\n/// Imported from the `sui::bag` module.\nuse sui::bag::{Self, Bag};\n\n/// An example of a `Bag` as a struct field.\npublic struct Carrier has key {\n    id: UID,\n    bag: Bag\n}\n\n\nUsing the Bag:\n\nlet mut bag = bag::new(ctx);\n\n// bag has the `length` function to get the number of elements\nassert!(bag.length() == 0, 0);\n\nbag.add(b\"my_key\", b\"my_value\".to_string());\n\n// length has changed to 1\nassert!(bag.length() == 1, 1);\n\n// in order: `borrow`, `borrow_mut` and `remove`\n// the value type must be specified\nlet field_ref: &String = &bag[b\"my_key\"];\nlet field_mut: &mut String = &mut bag[b\"my_key\"];\nlet field: String = bag.remove(b\"my_key\");\n\n// length is back to 0 - we can unpack\nbag.destroy_empty();\n\nObjectBag\n\nDefined in the sui::object_bag module. Identical to Bag, but uses dynamic object fields internally. Can only store objects as values.\n\nTable\n\nTable is a typed dynamic collection that has a fixed type for keys and values. It is defined in the sui::table module.\n\n// File: sui-framework/sources/table.move\npublic struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {\n    /// the ID of this table\n    id: UID,\n    /// the number of key-value pairs in the table\n    size: u64,\n}\n\n\nUsed as a struct field:\n\n/// Imported from the `sui::table` module.\nuse sui::table::{Self, Table};\n\n/// Some record type with `store`\npublic struct Record has store { /* ... */ }\n\n/// An example of a `Table` as a struct field.\npublic struct UserRegistry has key {\n    id: UID,\n    table: Table<address, Record>\n}\n\n\nUsing the Table:\n\n#[test] fun test_table() {\nlet ctx = &mut tx_context::dummy();\n\n// Table requires explicit type parameters for the key and value\n// ...but does it only once in initialization.\nlet mut table = table::new<address, String>(ctx);\n\n// table has the `length` function to get the number of elements\nassert!(table.length() == 0, 0);\n\ntable.add(@0xa11ce, b\"my_value\".to_string());\ntable.add(@0xb0b, b\"another_value\".to_string());\n\n// length has changed to 2\nassert!(table.length() == 2, 2);\n\n// in order: `borrow`, `borrow_mut` and `remove`\nlet addr_ref = &table[@0xa11ce];\nlet addr_mut = &mut table[@0xa11ce];\n\n// removing both values\nlet _addr = table.remove(@0xa11ce);\nlet _addr = table.remove(@0xb0b);\n\n// length is back to 0 - we can unpack\ntable.destroy_empty();\n\nObjectTable\n\nDefined in the sui::object_table module. Identical to Table, but uses dynamic object fields internally. Can only store objects as values.\n\nSummary\nBag - a simple collection that can store any type of data\nObjectBag - a collection that can store only objects\nTable - a typed dynamic collection that has a fixed type for keys and values\nObjectTable - same as Table, but can only store objects\nLinkedTable\n\nThis section is coming soon!\n\nOne Time Witness\n\nWhile regular Witness is a great way to statically prove the ownership of a type, there are cases where we need to ensure that a Witness is instantiated only once. And this is the purpose of the One Time Witness (OTW).\n\nDefinition\n\nThe OTW is a special type of Witness that can be used only once. It cannot be manually created and it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these rules:\n\nHas only drop ability.\nHas no fields.\nIs not a generic type.\nNamed after the module with all uppercase letters.\n\nHere is an example of an OTW:\n\nmodule book::one_time {\n    /// The OTW for the `book::one_time` module.\n    /// Only `drop`, no fields, no generics, all uppercase.\n    public struct ONE_TIME has drop {}\n\n    /// Receive the instance of `ONE_TIME` as the first argument.\n    fun init(otw: ONE_TIME, ctx: &mut TxContext) {\n        // do something with the OTW\n    }\n}\n\n\nThe OTW cannot be constructed manually, and any code attempting to do so will result in a compilation error. The OTW can be received as the first argument in the module initializer. And because the init function is called only once per module, the OTW is guaranteed to be instantiated only once.\n\nEnforcing the OTW\n\nTo check if a type is an OTW, sui::types module of the Sui Framework offers a special function is_one_time_witness that can be used to check if the type is an OTW.\n\nuse sui::types;\n\nconst ENotOneTimeWitness: u64 = 1;\n\n/// Takes an OTW as an argument, aborts if the type is not OTW.\npublic fun takes_witness<T: drop>(otw: T) {\n    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);\n}\n\nSummary\n\nThe OTW pattern is a great way to ensure that a type is used only once. Most of the developers should understand how to define and receive the OTW, while the OTW checks and enforcement is mostly needed in libraries and frameworks. For example, the sui::coin module requires an OTW in the coin::create_currency method, therefore enforcing that the coin::TreasuryCap is created only once.\n\nOTW is a powerful tool that lays the foundation for the Publisher object, which we will cover in the next section.\n\nPublisher Authority\n\nIn application design and development, it is often needed to prove publisher authority. This is especially important in the context of digital assets, where the publisher may enable or disable certain features for their assets. The Publisher Object is an object, defined in the Sui Framework, that allows the publisher to prove their authority over a type.\n\nDefinition\n\nThe Publisher object is defined in the sui::package module of the Sui Framework. It is a very simple, non-generic object that can be initialized once per module (and multiple times per package) and is used to prove the authority of the publisher over a type. To claim a Publisher object, the publisher must present a One Time Witness to the package::claim function.\n\n// File: sui-framework/sources/package.move\npublic struct Publisher has key, store {\n    id: UID,\n    package: String,\n    module_name: String,\n}\n\n\nIf you're not familiar with the One Time Witness, you can read more about it here.\n\nHere's a simple example of claiming a Publisher object in a module:\n\nmodule book::publisher {\n    /// Some type defined in the module.\n    public struct Book {}\n\n    /// The OTW for the module.\n    public struct PUBLISHER has drop {}\n\n    /// Uses the One Time Witness to claim the Publisher object.\n    fun init(otw: PUBLISHER, ctx: &mut TxContext) {\n        // Claim the Publisher object.\n        let publisher = sui::package::claim(otw, ctx);\n\n        // Usually it is transferred to the sender.\n        // It can also be stored in another object.\n        transfer::public_transfer(publisher, ctx.sender())\n    }\n}\n\nUsage\n\nThe Publisher object has two functions associated with it which are used to prove the publisher's authority over a type:\n\n// Checks if the type is from the same module, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_module<Book>(), 0);\n\n// Checks if the type is from the same package, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_package<Book>(), 0);\n\nPublisher as Admin Role\n\nFor small applications or simple use cases, the Publisher object can be used as an admin capability. While in the broader context, the Publisher object has control over system configurations, it can also be used to manage the application's state.\n\n/// Some action in the application gated by the Publisher object.\npublic fun admin_action(cap: &Publisher, /* app objects... */ param: u64) {\n    assert!(cap.from_module<Book>(), ENotAuthorized);\n\n    // perform application-specific action\n}\n\n\nHowever, Publisher misses some native properties of Capabilities, such as type safety and expressiveness. The signature for the admin_function is not very explicit, can be called by anyone else. And due to Publisher object being standard, there now is a risk of unauthorized access if the from_module check is not performed. So it's important to be cautious when using the Publisher object as an admin role.\n\nRole on Sui\n\nPublisher is required for certain features on Sui. Object Display can be created only by the Publisher, and TransferPolicy - an important component of the Kiosk system - also requires the Publisher object to prove ownership of the type.\n\nNext Steps\n\nIn the next chapter we will cover the first feature that requires the Publisher object - Object Display - a way to describe objects for clients, and standardize metadata. A must-have for user-friendly applications.\n\nObject Display\n\nObjects on Sui are explicit in their structure and behavior and can be displayed in an understandable way. However, to support richer metadata for clients, there's a standard and efficient way of \"describing\" them to the client - the Display object defined in the Sui Framework.\n\nBackground\n\nHistorically, there were different attempts to agree on a standard structure of an object so it can be displayed in a user interface. One of the approaches was to define certain fields in the object struct which, when present, would be used in the UI. This approach was not flexible enough and required developers to define the same fields in every object, and sometimes the fields did not make sense for the object.\n\n/// An attempt to standardize the object structure for display.\npublic struct CounterWithDisplay has key {\n    id: UID,\n    /// If this field is present it will be displayed in the UI as `name`.\n    name: String,\n    /// If this field is present it will be displayed in the UI as `description`.\n    description: String,\n    // ...\n    image: String,\n    /// Actual fields of the object.\n    counter: u64,\n    // ...\n}\n\n\nIf any of the fields contained static data, it would be duplicated in every object. And, since Move does not have interfaces, it is not possible to know if an object has a specific field without \"manually\" checking the object's type, which makes the client fetching more complex.\n\nObject Display\n\nTo address these issues, Sui introduces a standard way of describing an object for display. Instead of defining fields in the object struct, the display metadata is stored in a separate object, which is associated with the type. This way, the display metadata is not duplicated, and it is easy to extend and maintain.\n\nAnother important feature of Sui Display is the ability to define templates and use object fields in those templates. Not only it allows for a more flexible display, but it also frees the developer from the need to define the same fields with the same names and types in every object.\n\nThe Object Display is natively supported by the Sui Fullnode, and the client can fetch the display metadata for any object if the object type has a Display associated with it.\n\nmodule book::arena {\n    use std::string::String;\n    use sui::package;\n    use sui::display;\n\n    /// The One Time Witness to claim the `Publisher` object.\n    public struct ARENA has drop {}\n\n    /// Some object which will be displayed.\n    public struct Hero has key {\n        id: UID,\n        class: String,\n        level: u64,\n    }\n\n    /// In the module initializer we create the `Publisher` object, and then\n    /// the Display for the `Hero` type.\n    fun init(otw: ARENA, ctx: &mut TxContext) {\n        let publisher = package::claim(otw, ctx);\n        let mut display = display::new<Hero>(&publisher, ctx);\n\n        display.add(\n            b\"name\".to_string(),\n            b\"{class} (lvl. {level})\".to_string()\n        );\n\n        display.add(\n            b\"description\".to_string(),\n            b\"One of the greatest heroes of all time. Join us!\".to_string()\n        );\n\n        display.add(\n            b\"link\".to_string(),\n            b\"https://example.com/hero/{id}\".to_string()\n        );\n\n        display.add(\n            b\"image_url\".to_string(),\n            b\"https://example.com/hero/{class}.jpg\".to_string()\n        );\n\n        // Update the display with the new data.\n        // Must be called to apply changes.\n        display.update_version();\n\n        transfer::public_transfer(publisher, ctx.sender());\n        transfer::public_transfer(display, ctx.sender());\n    }\n}\n\nCreator Privilege\n\nWhile the objects can be owned by accounts and may be a subject to True Ownership, the Display can be owned by the creator of the object. This way, the creator can update the display metadata and apply the changes globally without the need to update every object. The creator can also transfer Display to another account or even build an application around the object with custom functionality to manage the metadata.\n\nStandard Fields\n\nThe fields that are supported most widely are:\n\nname - A name for the object. The name is displayed when users view the object.\ndescription - A description for the object. The description is displayed when users view the object.\nlink - A link to the object to use in an application.\nimage_url - A URL or a blob with the image for the object.\nthumbnail_url - A URL to a smaller image to use in wallets, explorers, and other products as a preview.\nproject_url - A link to a website associated with the object or creator.\ncreator - A string that indicates the object creator.\n\nPlease, refer to the Sui Documentation for the most up-to-date list of supported fields.\n\nWhile there's a standard set of fields, the Display object does not enforce them. The developer can define any fields they need, and the client can use them as they see fit. Some applications may require additional fields, and omit other, and the Display is flexible enough to support them.\n\nWorking with Display\n\nThe Display object is defined in the sui::display module. It is a generic struct that takes a phantom type as a parameter. The phantom type is used to associate the Display object with the type it describes. The fields of the Display object are a VecMap of key-value pairs, where the key is the field name and the value is the field value. The version field is used to version the display metadata, and is updated on the update_display call.\n\nFile: sui-framework/sources/display.move\n\nstruct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n\n\nThe Publisher object is required to a new Display, since it serves as the proof of ownership of type.\n\nTemplate Syntax\n\nCurrently, Display supports simple string interpolation and can use struct fields (and paths) in its templates. The syntax is trivial - {path} is replaced with the value of the field at the path. The path is a dot-separated list of field names, starting from the root object in case of nested fields.\n\n/// Some common metadata for objects.\npublic struct Metadata has store {\n    name: String,\n    description: String,\n    published_at: u64\n}\n\n/// The type with nested Metadata field.\npublic struct LittlePony has key, store {\n    id: UID,\n    image_url: String,\n    metadata: Metadata\n}\n\n\nThe Display for the type LittlePony above could be defined as follows:\n\n{\n  \"name\": \"Just a pony\",\n  \"image_url\": \"{image_url}\",\n  \"description\": \"{metadata.description}\"\n}\n\nMultiple Display Objects\n\nThere's no restriction to how many Display<T> objects can be created for a specific T. However, the most recently updated Display<T> will be used by the fullnode.\n\nFurther Reading\nSui Object Display is Sui Documentation\nPublisher - the representation of the creator\nEvents\n\nEvents are a way to notify off-chain listeners about on-chain events. They are used to emit additional information about the transaction that is not stored - and, hence, can't be accessed - on-chain. Events are emitted by the sui::event module located in the Sui Framework.\n\nAny custom type with the copy and drop abilities can be emitted as an event. Sui Verifier requires the type to be internal to the module.\n\n// File: sui-framework/sources/event.move\nmodule sui::event {\n    /// Emit a custom Move event, sending the data offchain.\n    ///\n    /// Used for creating custom indexes and tracking onchain\n    /// activity in a way that suits a specific application the most.\n    ///\n    /// The type `T` is the main way to index the event, and can contain\n    /// phantom parameters, eg `emit(MyEvent<phantom T>)`.\n    public native fun emit<T: copy + drop>(event: T);\n}\n\nEmitting Events\n\nEvents are emitted using the emit function in the sui::event module. The function takes a single argument - the event to be emitted. The event data is passed by value,\n\nmodule book::events {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n    use sui::event;\n\n    /// The item that can be purchased.\n    public struct Item has key { id: UID }\n\n    /// Event emitted when an item is purchased. Contains the ID of the item and\n    /// the price for which it was purchased.\n    public struct ItemPurchased has copy, drop {\n        item: ID,\n        price: u64\n    }\n\n    /// A marketplace function which performs the purchase of an item.\n    public fun purchase(coin: Coin<SUI>, ctx: &mut TxContext) {\n        let item = Item { id: object::new(ctx) };\n\n        // Create an instance of `ItemPurchased` and pass it to `event::emit`.\n        event::emit(ItemPurchased {\n            item: object::id(&item),\n            price: coin.value()\n        });\n\n        // Omitting the rest of the implementation to keep the example simple.\n        abort 0\n    }\n}\n\n\nThe Sui Verifier requires the type passed to the emit function to be internal to the module. So emitting a type from another module will result in a compilation error. Primitive types, although they match the copy and drop requirement, are not allowed to be emitted as events.\n\nEvent Structure\n\nEvents are a part of the transaction result and are stored in the transaction effects. As such, they natively have the sender field which is the address who sent the transaction. So adding a \"sender\" field to the event is not necessary. Similarly, event metadata contains the timestamp. But it is important to note that the timestamp is relative to the node and may vary a little from node to node.\n\nSui Framework\n\nSui Framework is a default dependency set in the Package Manifest. It depends on the Standard Library and provides Sui-specific features, including the interaction with the storage, and Sui-specific native types and modules.\n\nFor convenience, we grouped the modules in the Sui Framework into multiple categories. But they're still part of the same framework.\n\nCore\nModule\tDescription\tChapter\nsui::address\tAdds conversion methods to the address type\tAddress\nsui::transfer\tImplements the storage operations for Objects\tIt starts with an Object\nsui::tx_context\tContains the TxContext struct and methods to read it\tTransaction Context\nsui::object\tDefines the UID and ID type, required for creating objects\tIt starts with an Object\nsui::clock\tDefines the Clock type and its methods\tEpoch and Time\nsui::dynamic_field\tImplements methods to add, use and remove dynamic fields\tDynamic Fields\nsui::dynamic_object_field\tImplements methods to add, use and remove dynamic object fields\tDynamic Object Fields\nsui::event\tAllows emitting events for off-chain listeners\tEvents\nsui::package\tDefines the Publisher type and package upgrade methods\tPublisher, Package Upgrades\nsui::display\tImplements the Display object and ways to create and update it\tDisplay\nCollections\nModule\tDescription\tChapter\nsui::vec_set\tImplements a set type\tCollections\nsui::vec_map\tImplements a map with vector keys\tCollections\nsui::table\tImplements the Table type and methods to interact with it\tDynamic Collections\nsui::linked_table\tImplements the LinkedTable type and methods to interact with it\tDynamic Collections\nsui::bag\tImplements the Bag type and methods to interact with it\tDynamic Collections\nsui::object_table\tImplements the ObjectTable type and methods to interact with it\tDynamic Collections\nsui::object_bag\tImplements the ObjectBag type and methods to interact with it\tDynamic Collections\nUtilities\nModule\tDescription\tChapter\nsui::bcs\tImplements the BCS encoding and decoding functions\tBinary Canonical Serialization\nExported Addresses\n\nSui Framework exports two named addresses: sui = 0x2 and std = 0x1 from the std dependency.\n\n[addresses]\nsui = \"0x2\"\n\n# Exported from the MoveStdlib dependency\nstd = \"0x1\"\n\nImplicit Imports\n\nJust like with Standard Library, some of the modules and types are imported implicitly in the Sui Framework. This is the list of modules and types that are available without explicit use import:\n\nsui::object\nsui::object::ID\nsui::object::UID\nsui::tx_context\nsui::tx_context::TxContext\nsui::transfer\nSource Code\n\nThe source code of the Sui Framework is available in the Sui repository.\n\nBinary Canonical Serialization\n\nBinary Canonical Serialization (BCS) is a binary encoding format for structured data. It was originally designed in Diem, and became the standard serialization format for Move. BCS is simple, efficient, deterministic, and easy to implement in any programming language.\n\nThe full format specification is available in the BCS repository.\n\nFormat\n\nBCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit (empty value), fixed and variable-length sequences, and maps. The format is designed to be deterministic, meaning that the same data will always be serialized to the same bytes.\n\n\"BCS is not a self-describing format. As such, in order to deserialize a message, one must know the message type and layout ahead of time\" from the README\n\nIntegers are stored in little-endian format, and variable-length integers are encoded using a variable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations are stored as the index of the variant followed by the data, and maps are stored as an ordered sequence of key-value pairs.\n\nStructs are treated as a sequence of fields, and the fields are serialized in the order they are defined in the struct. The fields are serialized using the same rules as the top-level data.\n\nUsing BCS\n\nThe Sui Framework includes the sui::bcs module for encoding and decoding data. Encoding functions are native to the VM, and decoding functions are implemented in Move.\n\nEncoding\n\nTo encode data, use the bcs::to_bytes function, which converts data references into byte vectors. This function supports encoding any types, including structs.\n\n// File: move-stdlib/sources/bcs.move\npublic native fun to_bytes<T>(t: &T): vector<u8>;\n\n\nThe following example shows how to encode a struct using BCS. The to_bytes function can take any value and encode it as a vector of bytes.\n\nuse sui::bcs;\n\n// 0x01 - a single byte with value 1 (or 0 for false)\nlet bool_bytes = bcs::to_bytes(&true);\n// 0x2a - just a single byte\nlet u8_bytes = bcs::to_bytes(&42u8);\n// 0x000000000000002a - 8 bytes\nlet u64_bytes = bcs::to_bytes(&42u64);\n// address is a fixed sequence of 32 bytes\n// 0x0000000000000000000000000000000000000000000000000000000000000002\nlet addr = bcs::to_bytes(&@sui);\n\nEncoding a Struct\n\nStructs encode similarly to simple types. Here is how to encode a struct using BCS:\n\nlet data = CustomData {\n    num: 42,\n    string: b\"hello, world!\".to_string(),\n    value: true\n};\n\nlet struct_bytes = bcs::to_bytes(&data);\n\nlet mut custom_bytes = vector[];\ncustom_bytes.append(bcs::to_bytes(&42u8));\ncustom_bytes.append(bcs::to_bytes(&b\"hello, world!\".to_string()));\ncustom_bytes.append(bcs::to_bytes(&true));\n\n// struct is just a sequence of fields, so the bytes should be the same!\nassert!(&struct_bytes == &custom_bytes, 0);\n\nDecoding\n\nBecause BCS does not self-describe and Move is statically typed, decoding requires prior knowledge of the data type. The sui::bcs module provides various functions to assist with this process.\n\nWrapper API\n\nBCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the caller to peel off the data by calling different decoding functions, prefixed with peel_*. The data is split off the bytes, and the remainder bytes are kept in the wrapper until the into_remainder_bytes function is called.\n\nuse sui::bcs;\n\n// BCS instance should always be declared as mutable\nlet mut bcs = bcs::new(x\"010000000000000000\");\n\n// Same bytes can be read differently, for example: Option<u64>\nlet value: Option<u64> = bcs.peel_option_u64();\n\nassert!(value.is_some(), 0);\nassert!(value.borrow() == &0, 1);\n\nlet remainder = bcs.into_remainder_bytes();\n\nassert!(remainder.length() == 0, 2);\n\n\nThere is a common practice to use multiple variables in a single let statement during decoding. It makes code a little bit more readable and helps to avoid unnecessary copying of the data.\n\nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// mind the order!!!\n// handy way to peel multiple values\nlet (bool_value, u8_value, u64_value) = (\n    bcs.peel_bool(),\n    bcs.peel_u8(),\n    bcs.peel_u64()\n);\n\nDecoding Vectors\n\nWhile most of the primitive types have a dedicated decoding function, vectors need special handling, which depends on the type of the elements. For vectors, first you need to decode the length of the vector, and then decode each element in a loop.\n\nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// bcs.peel_vec_length() peels the length of the vector :)\nlet mut len = bcs.peel_vec_length();\nlet mut vec = vector[];\n\n// then iterate depending on the data type\nwhile (len > 0) {\n    vec.push_back(bcs.peel_u64()); // or any other type\n    len = len - 1;\n};\n\nassert!(vec.length() == 1, 0);\n\n\nFor most common scenarios, bcs module provides a basic set of functions for decoding vectors:\n\npeel_vec_address(): vector<address>\npeel_vec_bool(): vector<bool>\npeel_vec_u8(): vector<u8>\npeel_vec_u64(): vector<u64>\npeel_vec_u128(): vector<u128>\npeel_vec_vec_u8(): vector<vector<u8>> - vector of byte vectors\nDecoding Option\n\nOption is represented as a vector of either 0 or 1 element. To read an option, you would treat it like a vector and check its length (first byte - either 1 or 0).\n\nlet mut bcs = bcs::new(x\"00\");\nlet is_some = bcs.peel_bool();\n\nassert!(is_some == false, 0);\n\nlet mut bcs = bcs::new(x\"0101\");\nlet is_some = bcs.peel_bool();\nlet value = bcs.peel_u8();\n\nassert!(is_some == true, 1);\nassert!(value == 1, 2);\n\n\nIf you need to decode an option of a custom type, use the method in the code snippet above.\n\nThe most common scenarios, bcs module provides a basic set of functions for decoding Option's:\n\npeel_option_address(): Option<address>\npeel_option_bool(): Option<bool>\npeel_option_u8(): Option<u8>\npeel_option_u64(): Option<u64>\npeel_option_u128(): Option<u128>\nDecoding Structs\n\nStructs are decoded field by field, and there is no standard function to automatically decode bytes into a Move struct, and it would have been a violation of the Move's type system. Instead, you need to decode each field manually.\n\n// some bytes... \nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\nlet (age, is_active, name) = (\n    bcs.peel_u8(),\n    bcs.peel_bool(),\n    bcs.peel_vec_u8().to_string()\n);\n\nlet user = User { age, is_active, name };\n\nSummary\n\nBinary Canonical Serialization is an efficient binary format for structured data, ensuring consistent serialization across platforms. The Sui Framework provides comprehensive tools for working with BCS, allowing extensive functionality through built-in functions.\n\nMove 2024 Migration Guide\n\nMove 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is intended to help you understand the differences between the 2024 edition and the previous version of the Move language.\n\nThis guide provides a high-level overview of the changes in the new edition. For a more detailed and exhaustive list of changes, refer to the Sui Documentation.\n\nUsing the New Edition\n\nTo use the new edition, you need to specify the edition in the move file. The edition is specified in the move file using the edition keyword. Currently, the only available edition is 2024.beta.\n\nedition = \"2024.beta\";\n\nMigration Tool\n\nThe Move CLI has a migration tool that updates the code to the new edition. To use the migration tool, run the following command:\n\n$ sui move migrate\n\n\nThe migration tool will update the code to use the let mut syntax, the new public modifier for strucs, and the public(package) function visibility instead of friend declarations.\n\nMutable bindings with let mut\n\nMove 2024 introduces let mut syntax to declare mutable variables. The let mut syntax is used to declare a mutable variable that can be changed after it is declared.\n\nlet mut declaration is now required for mutable variables. Compiler will emit an error if you try to reassign a variable without the mut keyword.\n\n// Move 2020\nlet x: u64 = 10;\nx = 20;\n\n// Move 2024\nlet mut x: u64 = 10;\nx = 20;\n\n\nAdditionally, the mut keyword is used in tuple destructuring and function arguments to declare mutable variables.\n\n// takes by value and mutates\nfun takes_by_value_and_mutates(mut v: Value): Value {\n    v.field = 10;\n    v\n}\n\n// `mut` should be placed before the variable name\nfun destruct() {\n    let (x, y) = point::get_point();\n    let (mut x, y) = point::get_point();\n    let (mut x, mut y) = point::get_point();\n}\n\n// in struct unpack\nfun unpack() {\n    let Point { x, mut y } = point::get_point();\n    let Point { mut x, mut y } = point::get_point();\n}\n\nFriends are Deprecated\n\nIn Move 2024, the friend keyword is deprecated. Instead, you can use the public(package) visibility modifier to make functions visible to other modules in the same package.\n\n// Move 2020\nfriend book::friend_module;\npublic(friend) fun protected_function() {}\n\n// Move 2024\npublic(package) fun protected_function_2024() {}\n\nStruct Visibility\n\nIn Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier is public.\n\n// Move 2020\nstruct Book {}\n\n// Move 2024\npublic struct Book {}\n\nMethod Syntax\n\nIn the new edition, functions which have a struct as the first argument are associated with the struct. This means that the function can be called using the dot notation. Methods defined in the same module with the type are automatically exported.\n\nMethods are automatically exported if the type is defined in the same module as the method. It is impossible to export methods for types defined in other modules. However, you can create custom aliases for methods in the module scope.\n\npublic fun count(c: &Counter): u64 { /* ... */ }\n\nfun use_counter() {\n    // move 2020\n    let count = counter::count(&c);\n\n    // move 2024\n    let count = c.count();\n}\n\nMethods for Built-in Types\n\nIn Move 2024, some of the native and standard types received associated methods. For example, the vector type has a to_string method that converts the vector into a UTF8 string.\n\nfun aliases() {\n    // vector to string and ascii string\n    let str: String = b\"Hello, World!\".to_string();\n    let ascii: ascii::String = b\"Hello, World!\".to_ascii_string();\n\n    // address to bytes\n    let bytes = @0xa11ce.to_bytes();\n}\n\n\nFor the full list of built-in aliases, refer to the Standard Library and Sui Framework source code.\n\nBorrowing Operator\n\nSome of the built-in types support borrowing operators. The borrowing operator is used to get a reference to the element at the specified index. The borrowing operator is defined as [].\n\nfun play_vec() {\n    let v = vector[1,2,3,4];\n    let first = &v[0];         // calls vector::borrow(v, 0)\n    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)\n    let first_copy = v[0];     // calls *vector::borrow(v, 0)\n}\n\n\nTypes that support the borrowing operator are:\n\nvector\nsui::vec_map::VecMap\nsui::table::Table\nsui::bag::Bag\nsui::object_table::ObjectTable\nsui::object_bag::ObjectBag\nsui::linked_table::LinkedTable\n\nTo implement the borrowing operator for a custom type, you need to add a #[syntax(index)] attribute to the methods.\n\n#[syntax(index)]\npublic fun borrow(c: &List<T>, key: String): &T { /* ... */ }\n\n#[syntax(index)]\npublic fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }\n\nMethod Aliases\n\nIn Move 2024, methods can be associated with types. The alias can be defined for any type locally to the module; or publicly, if the type is defined in the same module.\n\n// my_module.move\n// Local: type is foreign to the module\nuse fun my_custom_function as vector.do_magic;\n\n// sui-framework/kiosk/kiosk.move\n// Exported: type is defined in the same module\npublic use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;\n\nUpgradeability Practices\n\nTo talk about best practices for upgradeability, we need to first understand what can be upgraded in a package. The base premise of upgradeability is that an upgrade should not break public compatibility with the previous version. The parts of the module which can be used in dependent packages should not change their static signature. This applies to modules - a module can not be removed from a package, public structs - they can be used in function signatures and public functions - they can be called from other packages.\n\n// module can not be removed from the package\nmodule book::upgradable {\n    // dependencies can be changed (if they are not used in public signatures)\n    use std::string::String;\n    use sui::event; // can be removed\n\n    // public structs can not be removed and can't be changed\n    public struct Book has key {\n        id: UID,\n        title: String,\n    }\n\n    // public structs can not be removed and can't be changed\n    public struct BookCreated has copy, drop {\n        /* ... */\n    }\n\n    // public functions can not be removed and their signature can never change\n    // but the implementation can be changed\n    public fun create_book(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n\n        // can be removed and changed\n        event::emit(BookCreated {\n            /* ... */\n        })\n    }\n\n    // package-visibility functions can be removed and changed\n    public(package) fun create_book_package(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // entry functions can be removed and changed as long they're not public\n    entry fun create_book_entry(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // private functions can be removed and changed\n    fun create_book_internal(ctx: &mut TxContext): Book {\n        abort 0\n    }\n}\n\nVersioning objects\n\nTo discard previous versions of the package, the objects can be versioned. As long as the object contains a version field, and the code which uses the object expects and asserts a specific version, the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can be used to update the version of the shared state, so that the new version of code can be used, and the old version aborts with a version mismatch.\n\nmodule book::versioned_state {\n\n    const EVersionMismatch: u64 = 0;\n\n    const VERSION: u8 = 1;\n\n    /// The shared state (can be owned too)\n    public struct SharedState has key {\n        id: UID,\n        version: u8,\n        /* ... */\n    }\n\n    public fun mutate(state: &mut SharedState) {\n        assert!(state.version == VERSION, EVersionMismatch);\n        // ...\n    }\n}\n\nVersioning configuration with dynamic fields\n\nThere's a common pattern in Sui which allows changing the stored configuration of an object while retaining the same object signature. This is done by keeping the base object simple and versioned and adding an actual configuration object as a dynamic field. Using this anchor pattern, the configuration can be changed with package upgrades while keeping the same base object signature.\n\nmodule book::versioned_config {\n    use sui::vec_map::VecMap;\n    use std::string::String;\n\n    /// The base object\n    public struct Config has key {\n        id: UID,\n        version: u16\n    }\n\n    /// The actual configuration\n    public struct ConfigV1 has store {\n        data: Bag,\n        metadata: VecMap<String, String>\n    }\n\n    // ...\n}\n\nModular architecture\n\nThis section is coming soon!\n\nBuilding against Limits\n\nTo guarantee the safety and security of the network, Sui has certain limits and restrictions. These limits are in place to prevent abuse and to ensure that the network remains stable and efficient. This guide provides an overview of these limits and restrictions, and how to build your application to work within them.\n\nThe limits are defined in the protocol configuration and are enforced by the network. If any of the limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of the protocol, can only be changed through a network upgrade.\n\nTransaction Size\n\nThe size of a transaction is limited to 128KB. This includes the size of the transaction payload, the size of the transaction signature, and the size of the transaction metadata. If a transaction exceeds this limit, it will be rejected by the network.\n\nObject Size\n\nThe size of an object is limited to 256KB. This includes the size of the object data. If an object exceeds this limit, it will be rejected by the network. While a single object cannot bypass this limit, for more extensive storage options, one could use a combination of a base object with other attached to it using dynamic fields (eg Bag).\n\nSingle Pure Argument Size\n\nThe size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit will result in execution failure. So in order to create a vector of more than ~500 addresses (given that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or in a Move function. Standard functions like vector::append() can join two vectors of ~16KB resulting in a ~32KB of data as a single value.\n\nMaximum Number of Objects created\n\nThe maximum number of objects that can be created in a single transaction is 2048. If a transaction attempts to create more than 2048 objects, it will be rejected by the network. This also affects dynamic fields, as both the key and the value are objects. So the maximum number of dynamic fields that can be created in a single transaction is 1024.\n\nMaximum Number of Dynamic Fields created\n\nThe maximum number of dynamic fields that can be created in a single object is 1024. If an object attempts to create more than 1024 dynamic fields, it will be rejected by the network.\n\nMaximum Number of Events\n\nThe maximum number of events that can be emitted in a single transaction is 1024. If a transaction attempts to emit more than 1024 events, it will be aborted.\n\nBetter error handling\n\nWhenever execution encounters an abort, transaction fails and abort code is returned to the caller. Move VM returns the module name that aborted the transaction and the abort code. This behavior is not fully transparent to the caller of the transaction, especially when a single function contains multiple calls to the same function which may abort. In this case, the caller will not know which call aborted the transaction, and it will be hard to debug the issue or provide meaningful error message to the user.\n\nmodule book::module_a {\n    use book::module_b;\n\n    public fun do_something() {\n        let field_1 = module_b::get_field(1); // may abort with 0\n        /* ... a lot of logic ... */\n        let field_2 = module_b::get_field(2); // may abort with 0\n        /* ... some more logic ... */\n        let field_3 = module_b::get_field(3); // may abort with 0\n    }\n}\n\n\nThe example above illustrates the case when a single function contains multiple calls which may abort. If the caller of the do_something function receives an abort code 0, it will be hard to understand which call to module_b::get_field aborted the transaction. To address this problem, there are common patterns that can be used to improve error handling.\n\nRule 1: Handle all possible scenarios\n\nIt is considered a good practice to provide a safe \"check\" function that returns a boolean value indicating whether an operation can be performed safely. If the module_b provides a function has_field that returns a boolean value indicating whether a field exists, the do_something function can be rewritten as follows:\n\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoField: u64 = 0;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoField);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoField);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoField);\n        let field_3 = module_b::get_field(3);\n    }\n}\n\n\nBy adding custom checks before each call to module_b::get_field, the developer of the module_a takes control over the error handling. And it allows implementing the second rule.\n\nRule 2: Abort with different codes\n\nThe second trick, once the abort codes are handled by the caller module, is to use different abort codes for different scenarios. This way, the caller module can provide a meaningful error message to the user. The module_a can be rewritten as follows:\n\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoFieldA: u64 = 0;\n    const ENoFieldB: u64 = 1;\n    const ENoFieldC: u64 = 2;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoFieldA);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoFieldB);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoFieldC);\n        let field_3 = module_b::get_field(3);\n    }\n}\n\n\nNow, the caller module can provide a meaningful error message to the user. If the caller receives an abort code 0, it can be translated to \"Field 1 does not exist\". If the caller receives an abort code 1, it can be translated to \"Field 2 does not exist\". And so on.\n\nRule 3: Return bool instead of assert\n\nA developer is often tempted to add a public function that would assert all the conditions and abort the execution. However, it is a better practice to create a function that returns a boolean value instead. This way, the caller module can handle the error and provide a meaningful error message to the user.\n\nmodule book::some_app_assert {\n\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert_is_authorized();\n        // ...\n    }\n\n    public fun do_b() {\n        assert_is_authorized();\n        // ...\n    }\n\n    /// Don't do this\n    public fun assert_is_authorized() {\n        assert!(/* some condition */ true, ENotAuthorized);\n    }\n}\n\n\nThis module can be rewritten as follows:\n\nmodule book::some_app {\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun do_b() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun is_authorized(): bool {\n        /* some condition */ true\n    }\n\n    // a private function can still be used to avoid code duplication for a case\n    // when the same condition with the same abort code is used in multiple places\n    fun assert_is_authorized() {\n        assert!(is_authorized(), ENotAuthorized);\n    }\n}\n\n\nUtilizing these three rules will make the error handling more transparent to the caller of the transaction, and it will allow other developers to use custom abort codes in their modules.\n\nCoding Conventions\nNaming\nModule\nModule names should be in snake_case.\nModule names should be descriptive and should not be too long.\nmodule book::conventions { /* ... */ }\nmodule book::common_pracices { /* ... */ }\n\nConstant\nConstants should be in SCREAMING_SNAKE_CASE.\nError constants should be in EPascalCase\nconst MAX_PRICE: u64 = 1000;\nconst EInvalidInput: u64 = 0;\n\nFunction\nFunction names should be in snake_case.\nFunction names should be descriptive.\npublic fun add(a: u64, b: u64): u64 { a + b }\npublic fun create_if_not_exists() { /* ... */ }\n\nStruct\nStruct names should be in PascalCase.\nStruct fields should be in snake_case.\nCapabilities should be suffixed with Cap.\npublic struct Hero has key {\n    id: UID\n    value: u64,\n    another_value: u64,\n}\n\npublic struct AdminCap has key { id: UID }\n\nStruct Method\nStruct methods should be in snake_case.\nIf there's multiple structs with the same method, the method should be prefixed with the struct name. In this case, an alias can be added to the method using use fun.\npublic fun value(h: &Hero): u64 { h.value }\n\npublic use fun hero_health as Hero.health;\npublic fun hero_health(h: &Hero): u64 { h.another_value }\n\npublic use fun boar_health as Boar.health;\npublic fun boar_health(b: &Boar): u64 { b.another_value }\n\nAppendix A: Glossary\nFast Path - term used to describe a transaction that does not involve shared objects, and can be executed without the need for consensus.\nParallel Execution - term used to describe the ability of the Sui runtime to execute transactions in parallel, including the ones that involve shared objects.\nInternal Type - type that is defined within the module. Fields of this type can not be accessed from outside the module, and, in case of \"key\"-only abilities, can not be used in public_* transfer functions.\nAbilities\nkey - ability that allows the struct to be used as a key in the storage. On Sui, the key ability marks an object and requires the first field to be a id: UID.\nstore - ability that allows the struct to be stored inside other objects. This ability relaxes restrictions applied to internal structs, allowing public_* transfer functions to accept them as arguments. It also enables the object to be stored as a dynamic field.\ncopy - ability that allows the struct to be copied. On Sui, the copy ability conflicts with the key ability, and can not be used together with it.\ndrop - ability that allows the struct to be ignored or discarded. On Sui, the drop ability cannot be used together with the key ability, as objects are not allowed to be ignored.\nAppendix B: Reserved Addresses\n\nReserved addresses are special addresses that have a specific purpose on Sui. They stay the same between environments and are used for specific native operations.\n\n0x1 - address of the Standard Library (alias std)\n0x2 - address of the Sui Framework (alias sui)\n0x5 - address of the SuiSystem object\n0x6 - address of the system Clock object\n0x8 - address of the system Random object\n0x403 - address of the DenyList system object\nAppendix C: Publications\n\nThis section lists publications related to Move and Sui.\n\nThe Move Borrow Checker by Sam Blackshear, John Mitchell, Todd Nowacki, Shaz Qadeer.\nResources: A Safe Language Abstraction for Money by Sam Blackshear, David L. Dill, Shaz Qadeer, Clark W. Barrett, John C. Mitchell, Oded Padon, Yoni Zohar.\nRobust Safety for Move by Marco Patrignani, Sam Blackshear\nAppendix D: Contributing\n\nTo contribute to this book, please, submit a pull request to the GitHub repository. The repository contains the source files for the book, written in mdBook format.\n\nAppendix E: Acknowledgements\n\nThe Rust Book has been a great inspiration for this book. I am personally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as I have learned a lot from it. This book is a small tribute to their work and an attempt to bring a similar learning experience to the Move community."
    },
    {
      "title": "The Move Reference - The Move Reference",
      "url": "https://move-book.com/reference/",
      "html": "The Move Reference\nGetting Started\n1. Modules\nBasic Concepts\n2. Primitive Types\n2.1. Integers\n2.2. Bool\n2.3. Address\n2.4. Vector\n2.5. References\n2.6. Tuples and Unit\n3. Local Variables and Scopes\n4. Equality\n5. Abort and Assert\n6. Control Flow\n6.1. Conditional Expressions\n6.2. Loops\n6.3. Labeled Control FLow\n7. Functions\n8. Structs\n9. Constants\n10. Generics\n11. Type Abilities\n12. Uses and Aliases\nAdvanced Concepts\n13. Method Syntax\n14. Index Syntax Methods\nTooling\n15. Packages\n16. Unit Tests\nReference\n17. Coding Conventions\nDeprecated\n18. Friends\nGo to Book\nThe Move Reference\n  \nThe Move Reference\n\nWelcome to Move, a next generation language for secure asset programming. Its primary use case is in blockchain environments, where Move programs are used to construct state changes. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.\n\nMove takes its cue from Rust by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency."
    },
    {
      "title": "E - Acknowledgements - The Move Book",
      "url": "https://move-book.com/appendix/acknowledgements.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAppendix E: Acknowledgements\n\nThe Rust Book has been a great inspiration for this book. I am personally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as I have learned a lot from it. This book is a small tribute to their work and an attempt to bring a similar learning experience to the Move community."
    },
    {
      "title": "D - Contributing - The Move Book",
      "url": "https://move-book.com/appendix/contributing.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAppendix D: Contributing\n\nTo contribute to this book, please, submit a pull request to the GitHub repository. The repository contains the source files for the book, written in mdBook format."
    },
    {
      "title": "B - Reserved Addresses - The Move Book",
      "url": "https://move-book.com/appendix/reserved-addresses.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAppendix B: Reserved Addresses\n\nReserved addresses are special addresses that have a specific purpose on Sui. They stay the same between environments and are used for specific native operations.\n\n0x1 - address of the Standard Library (alias std)\n0x2 - address of the Sui Framework (alias sui)\n0x5 - address of the SuiSystem object\n0x6 - address of the system Clock object\n0x8 - address of the system Random object\n0x403 - address of the DenyList system object"
    },
    {
      "title": "C - Publications - The Move Book",
      "url": "https://move-book.com/appendix/publications.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAppendix C: Publications\n\nThis section lists publications related to Move and Sui.\n\nThe Move Borrow Checker by Sam Blackshear, John Mitchell, Todd Nowacki, Shaz Qadeer.\nResources: A Safe Language Abstraction for Money by Sam Blackshear, David L. Dill, Shaz Qadeer, Clark W. Barrett, John C. Mitchell, Oded Padon, Yoni Zohar.\nRobust Safety for Move by Marco Patrignani, Sam Blackshear"
    },
    {
      "title": "A - Glossary - The Move Book",
      "url": "https://move-book.com/appendix/glossary.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAppendix A: Glossary\nFast Path - term used to describe a transaction that does not involve shared objects, and can be executed without the need for consensus.\nParallel Execution - term used to describe the ability of the Sui runtime to execute transactions in parallel, including the ones that involve shared objects.\nInternal Type - type that is defined within the module. Fields of this type can not be accessed from outside the module, and, in case of \"key\"-only abilities, can not be used in public_* transfer functions.\nAbilities\nkey - ability that allows the struct to be used as a key in the storage. On Sui, the key ability marks an object and requires the first field to be a id: UID.\nstore - ability that allows the struct to be stored inside other objects. This ability relaxes restrictions applied to internal structs, allowing public_* transfer functions to accept them as arguments. It also enables the object to be stored as a dynamic field.\ncopy - ability that allows the struct to be copied. On Sui, the copy ability conflicts with the key ability, and can not be used together with it.\ndrop - ability that allows the struct to be ignored or discarded. On Sui, the drop ability cannot be used together with the key ability, as objects are not allowed to be ignored."
    },
    {
      "title": "Coding Conventions - The Move Book",
      "url": "https://move-book.com/guides/coding-conventions.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nCoding Conventions\nNaming\nModule\nModule names should be in snake_case.\nModule names should be descriptive and should not be too long.\nmodule book::conventions { /* ... */ }\nmodule book::common_pracices { /* ... */ }\n\nConstant\nConstants should be in SCREAMING_SNAKE_CASE.\nError constants should be in EPascalCase\nconst MAX_PRICE: u64 = 1000;\nconst EInvalidInput: u64 = 0;\n\nFunction\nFunction names should be in snake_case.\nFunction names should be descriptive.\npublic fun add(a: u64, b: u64): u64 { a + b }\npublic fun create_if_not_exists() { /* ... */ }\n\nStruct\nStruct names should be in PascalCase.\nStruct fields should be in snake_case.\nCapabilities should be suffixed with Cap.\npublic struct Hero has key {\n    id: UID\n    value: u64,\n    another_value: u64,\n}\n\npublic struct AdminCap has key { id: UID }\n\nStruct Method\nStruct methods should be in snake_case.\nIf there's multiple structs with the same method, the method should be prefixed with the struct name. In this case, an alias can be added to the method using use fun.\npublic fun value(h: &Hero): u64 { h.value }\n\npublic use fun hero_health as Hero.health;\npublic fun hero_health(h: &Hero): u64 { h.another_value }\n\npublic use fun boar_health as Boar.health;\npublic fun boar_health(b: &Boar): u64 { b.another_value }\n"
    },
    {
      "title": "Better error handling - The Move Book",
      "url": "https://move-book.com/guides/better-error-handling.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nBetter error handling\n\nWhenever execution encounters an abort, transaction fails and abort code is returned to the caller. Move VM returns the module name that aborted the transaction and the abort code. This behavior is not fully transparent to the caller of the transaction, especially when a single function contains multiple calls to the same function which may abort. In this case, the caller will not know which call aborted the transaction, and it will be hard to debug the issue or provide meaningful error message to the user.\n\nmodule book::module_a {\n    use book::module_b;\n\n    public fun do_something() {\n        let field_1 = module_b::get_field(1); // may abort with 0\n        /* ... a lot of logic ... */\n        let field_2 = module_b::get_field(2); // may abort with 0\n        /* ... some more logic ... */\n        let field_3 = module_b::get_field(3); // may abort with 0\n    }\n}\n\n\nThe example above illustrates the case when a single function contains multiple calls which may abort. If the caller of the do_something function receives an abort code 0, it will be hard to understand which call to module_b::get_field aborted the transaction. To address this problem, there are common patterns that can be used to improve error handling.\n\nRule 1: Handle all possible scenarios\n\nIt is considered a good practice to provide a safe \"check\" function that returns a boolean value indicating whether an operation can be performed safely. If the module_b provides a function has_field that returns a boolean value indicating whether a field exists, the do_something function can be rewritten as follows:\n\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoField: u64 = 0;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoField);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoField);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoField);\n        let field_3 = module_b::get_field(3);\n    }\n}\n\n\nBy adding custom checks before each call to module_b::get_field, the developer of the module_a takes control over the error handling. And it allows implementing the second rule.\n\nRule 2: Abort with different codes\n\nThe second trick, once the abort codes are handled by the caller module, is to use different abort codes for different scenarios. This way, the caller module can provide a meaningful error message to the user. The module_a can be rewritten as follows:\n\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoFieldA: u64 = 0;\n    const ENoFieldB: u64 = 1;\n    const ENoFieldC: u64 = 2;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoFieldA);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoFieldB);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoFieldC);\n        let field_3 = module_b::get_field(3);\n    }\n}\n\n\nNow, the caller module can provide a meaningful error message to the user. If the caller receives an abort code 0, it can be translated to \"Field 1 does not exist\". If the caller receives an abort code 1, it can be translated to \"Field 2 does not exist\". And so on.\n\nRule 3: Return bool instead of assert\n\nA developer is often tempted to add a public function that would assert all the conditions and abort the execution. However, it is a better practice to create a function that returns a boolean value instead. This way, the caller module can handle the error and provide a meaningful error message to the user.\n\nmodule book::some_app_assert {\n\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert_is_authorized();\n        // ...\n    }\n\n    public fun do_b() {\n        assert_is_authorized();\n        // ...\n    }\n\n    /// Don't do this\n    public fun assert_is_authorized() {\n        assert!(/* some condition */ true, ENotAuthorized);\n    }\n}\n\n\nThis module can be rewritten as follows:\n\nmodule book::some_app {\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun do_b() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun is_authorized(): bool {\n        /* some condition */ true\n    }\n\n    // a private function can still be used to avoid code duplication for a case\n    // when the same condition with the same abort code is used in multiple places\n    fun assert_is_authorized() {\n        assert!(is_authorized(), ENotAuthorized);\n    }\n}\n\n\nUtilizing these three rules will make the error handling more transparent to the caller of the transaction, and it will allow other developers to use custom abort codes in their modules."
    },
    {
      "title": "Building against Limits - The Move Book",
      "url": "https://move-book.com/guides/building-against-limits.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nBuilding against Limits\n\nTo guarantee the safety and security of the network, Sui has certain limits and restrictions. These limits are in place to prevent abuse and to ensure that the network remains stable and efficient. This guide provides an overview of these limits and restrictions, and how to build your application to work within them.\n\nThe limits are defined in the protocol configuration and are enforced by the network. If any of the limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of the protocol, can only be changed through a network upgrade.\n\nTransaction Size\n\nThe size of a transaction is limited to 128KB. This includes the size of the transaction payload, the size of the transaction signature, and the size of the transaction metadata. If a transaction exceeds this limit, it will be rejected by the network.\n\nObject Size\n\nThe size of an object is limited to 256KB. This includes the size of the object data. If an object exceeds this limit, it will be rejected by the network. While a single object cannot bypass this limit, for more extensive storage options, one could use a combination of a base object with other attached to it using dynamic fields (eg Bag).\n\nSingle Pure Argument Size\n\nThe size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit will result in execution failure. So in order to create a vector of more than ~500 addresses (given that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or in a Move function. Standard functions like vector::append() can join two vectors of ~16KB resulting in a ~32KB of data as a single value.\n\nMaximum Number of Objects created\n\nThe maximum number of objects that can be created in a single transaction is 2048. If a transaction attempts to create more than 2048 objects, it will be rejected by the network. This also affects dynamic fields, as both the key and the value are objects. So the maximum number of dynamic fields that can be created in a single transaction is 1024.\n\nMaximum Number of Dynamic Fields created\n\nThe maximum number of dynamic fields that can be created in a single object is 1024. If an object attempts to create more than 1024 dynamic fields, it will be rejected by the network.\n\nMaximum Number of Events\n\nThe maximum number of events that can be emitted in a single transaction is 1024. If a transaction attempts to emit more than 1024 events, it will be aborted."
    },
    {
      "title": "Upgradability Practices - The Move Book",
      "url": "https://move-book.com/guides/upgradeability-practices.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nUpgradeability Practices\n\nTo talk about best practices for upgradeability, we need to first understand what can be upgraded in a package. The base premise of upgradeability is that an upgrade should not break public compatibility with the previous version. The parts of the module which can be used in dependent packages should not change their static signature. This applies to modules - a module can not be removed from a package, public structs - they can be used in function signatures and public functions - they can be called from other packages.\n\n// module can not be removed from the package\nmodule book::upgradable {\n    // dependencies can be changed (if they are not used in public signatures)\n    use std::string::String;\n    use sui::event; // can be removed\n\n    // public structs can not be removed and can't be changed\n    public struct Book has key {\n        id: UID,\n        title: String,\n    }\n\n    // public structs can not be removed and can't be changed\n    public struct BookCreated has copy, drop {\n        /* ... */\n    }\n\n    // public functions can not be removed and their signature can never change\n    // but the implementation can be changed\n    public fun create_book(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n\n        // can be removed and changed\n        event::emit(BookCreated {\n            /* ... */\n        })\n    }\n\n    // package-visibility functions can be removed and changed\n    public(package) fun create_book_package(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // entry functions can be removed and changed as long they're not public\n    entry fun create_book_entry(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // private functions can be removed and changed\n    fun create_book_internal(ctx: &mut TxContext): Book {\n        abort 0\n    }\n}\n\nVersioning objects\n\nTo discard previous versions of the package, the objects can be versioned. As long as the object contains a version field, and the code which uses the object expects and asserts a specific version, the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can be used to update the version of the shared state, so that the new version of code can be used, and the old version aborts with a version mismatch.\n\nmodule book::versioned_state {\n\n    const EVersionMismatch: u64 = 0;\n\n    const VERSION: u8 = 1;\n\n    /// The shared state (can be owned too)\n    public struct SharedState has key {\n        id: UID,\n        version: u8,\n        /* ... */\n    }\n\n    public fun mutate(state: &mut SharedState) {\n        assert!(state.version == VERSION, EVersionMismatch);\n        // ...\n    }\n}\n\nVersioning configuration with dynamic fields\n\nThere's a common pattern in Sui which allows changing the stored configuration of an object while retaining the same object signature. This is done by keeping the base object simple and versioned and adding an actual configuration object as a dynamic field. Using this anchor pattern, the configuration can be changed with package upgrades while keeping the same base object signature.\n\nmodule book::versioned_config {\n    use sui::vec_map::VecMap;\n    use std::string::String;\n\n    /// The base object\n    public struct Config has key {\n        id: UID,\n        version: u16\n    }\n\n    /// The actual configuration\n    public struct ConfigV1 has store {\n        data: Bag,\n        metadata: VecMap<String, String>\n    }\n\n    // ...\n}\n\nModular architecture\n\nThis section is coming soon!"
    },
    {
      "title": "2024 Migration Guide - The Move Book",
      "url": "https://move-book.com/guides/2024-migration-guide.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nMove 2024 Migration Guide\n\nMove 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is intended to help you understand the differences between the 2024 edition and the previous version of the Move language.\n\nThis guide provides a high-level overview of the changes in the new edition. For a more detailed and exhaustive list of changes, refer to the Sui Documentation.\n\nUsing the New Edition\n\nTo use the new edition, you need to specify the edition in the move file. The edition is specified in the move file using the edition keyword. Currently, the only available edition is 2024.beta.\n\nedition = \"2024.beta\";\n\nMigration Tool\n\nThe Move CLI has a migration tool that updates the code to the new edition. To use the migration tool, run the following command:\n\n$ sui move migrate\n\n\nThe migration tool will update the code to use the let mut syntax, the new public modifier for strucs, and the public(package) function visibility instead of friend declarations.\n\nMutable bindings with let mut\n\nMove 2024 introduces let mut syntax to declare mutable variables. The let mut syntax is used to declare a mutable variable that can be changed after it is declared.\n\nlet mut declaration is now required for mutable variables. Compiler will emit an error if you try to reassign a variable without the mut keyword.\n\n// Move 2020\nlet x: u64 = 10;\nx = 20;\n\n// Move 2024\nlet mut x: u64 = 10;\nx = 20;\n\n\nAdditionally, the mut keyword is used in tuple destructuring and function arguments to declare mutable variables.\n\n// takes by value and mutates\nfun takes_by_value_and_mutates(mut v: Value): Value {\n    v.field = 10;\n    v\n}\n\n// `mut` should be placed before the variable name\nfun destruct() {\n    let (x, y) = point::get_point();\n    let (mut x, y) = point::get_point();\n    let (mut x, mut y) = point::get_point();\n}\n\n// in struct unpack\nfun unpack() {\n    let Point { x, mut y } = point::get_point();\n    let Point { mut x, mut y } = point::get_point();\n}\n\nFriends are Deprecated\n\nIn Move 2024, the friend keyword is deprecated. Instead, you can use the public(package) visibility modifier to make functions visible to other modules in the same package.\n\n// Move 2020\nfriend book::friend_module;\npublic(friend) fun protected_function() {}\n\n// Move 2024\npublic(package) fun protected_function_2024() {}\n\nStruct Visibility\n\nIn Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier is public.\n\n// Move 2020\nstruct Book {}\n\n// Move 2024\npublic struct Book {}\n\nMethod Syntax\n\nIn the new edition, functions which have a struct as the first argument are associated with the struct. This means that the function can be called using the dot notation. Methods defined in the same module with the type are automatically exported.\n\nMethods are automatically exported if the type is defined in the same module as the method. It is impossible to export methods for types defined in other modules. However, you can create custom aliases for methods in the module scope.\n\npublic fun count(c: &Counter): u64 { /* ... */ }\n\nfun use_counter() {\n    // move 2020\n    let count = counter::count(&c);\n\n    // move 2024\n    let count = c.count();\n}\n\nMethods for Built-in Types\n\nIn Move 2024, some of the native and standard types received associated methods. For example, the vector type has a to_string method that converts the vector into a UTF8 string.\n\nfun aliases() {\n    // vector to string and ascii string\n    let str: String = b\"Hello, World!\".to_string();\n    let ascii: ascii::String = b\"Hello, World!\".to_ascii_string();\n\n    // address to bytes\n    let bytes = @0xa11ce.to_bytes();\n}\n\n\nFor the full list of built-in aliases, refer to the Standard Library and Sui Framework source code.\n\nBorrowing Operator\n\nSome of the built-in types support borrowing operators. The borrowing operator is used to get a reference to the element at the specified index. The borrowing operator is defined as [].\n\nfun play_vec() {\n    let v = vector[1,2,3,4];\n    let first = &v[0];         // calls vector::borrow(v, 0)\n    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)\n    let first_copy = v[0];     // calls *vector::borrow(v, 0)\n}\n\n\nTypes that support the borrowing operator are:\n\nvector\nsui::vec_map::VecMap\nsui::table::Table\nsui::bag::Bag\nsui::object_table::ObjectTable\nsui::object_bag::ObjectBag\nsui::linked_table::LinkedTable\n\nTo implement the borrowing operator for a custom type, you need to add a #[syntax(index)] attribute to the methods.\n\n#[syntax(index)]\npublic fun borrow(c: &List<T>, key: String): &T { /* ... */ }\n\n#[syntax(index)]\npublic fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }\n\nMethod Aliases\n\nIn Move 2024, methods can be associated with types. The alias can be defined for any type locally to the module; or publicly, if the type is defined in the same module.\n\n// my_module.move\n// Local: type is foreign to the module\nuse fun my_custom_function as vector.do_magic;\n\n// sui-framework/kiosk/kiosk.move\n// Exported: type is defined in the same module\npublic use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;\n"
    },
    {
      "title": "BCS - The Move Book",
      "url": "https://move-book.com/programmability/bcs.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nBinary Canonical Serialization\n\nBinary Canonical Serialization (BCS) is a binary encoding format for structured data. It was originally designed in Diem, and became the standard serialization format for Move. BCS is simple, efficient, deterministic, and easy to implement in any programming language.\n\nThe full format specification is available in the BCS repository.\n\nFormat\n\nBCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit (empty value), fixed and variable-length sequences, and maps. The format is designed to be deterministic, meaning that the same data will always be serialized to the same bytes.\n\n\"BCS is not a self-describing format. As such, in order to deserialize a message, one must know the message type and layout ahead of time\" from the README\n\nIntegers are stored in little-endian format, and variable-length integers are encoded using a variable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations are stored as the index of the variant followed by the data, and maps are stored as an ordered sequence of key-value pairs.\n\nStructs are treated as a sequence of fields, and the fields are serialized in the order they are defined in the struct. The fields are serialized using the same rules as the top-level data.\n\nUsing BCS\n\nThe Sui Framework includes the sui::bcs module for encoding and decoding data. Encoding functions are native to the VM, and decoding functions are implemented in Move.\n\nEncoding\n\nTo encode data, use the bcs::to_bytes function, which converts data references into byte vectors. This function supports encoding any types, including structs.\n\n// File: move-stdlib/sources/bcs.move\npublic native fun to_bytes<T>(t: &T): vector<u8>;\n\n\nThe following example shows how to encode a struct using BCS. The to_bytes function can take any value and encode it as a vector of bytes.\n\nuse sui::bcs;\n\n// 0x01 - a single byte with value 1 (or 0 for false)\nlet bool_bytes = bcs::to_bytes(&true);\n// 0x2a - just a single byte\nlet u8_bytes = bcs::to_bytes(&42u8);\n// 0x000000000000002a - 8 bytes\nlet u64_bytes = bcs::to_bytes(&42u64);\n// address is a fixed sequence of 32 bytes\n// 0x0000000000000000000000000000000000000000000000000000000000000002\nlet addr = bcs::to_bytes(&@sui);\n\nEncoding a Struct\n\nStructs encode similarly to simple types. Here is how to encode a struct using BCS:\n\nlet data = CustomData {\n    num: 42,\n    string: b\"hello, world!\".to_string(),\n    value: true\n};\n\nlet struct_bytes = bcs::to_bytes(&data);\n\nlet mut custom_bytes = vector[];\ncustom_bytes.append(bcs::to_bytes(&42u8));\ncustom_bytes.append(bcs::to_bytes(&b\"hello, world!\".to_string()));\ncustom_bytes.append(bcs::to_bytes(&true));\n\n// struct is just a sequence of fields, so the bytes should be the same!\nassert!(&struct_bytes == &custom_bytes, 0);\n\nDecoding\n\nBecause BCS does not self-describe and Move is statically typed, decoding requires prior knowledge of the data type. The sui::bcs module provides various functions to assist with this process.\n\nWrapper API\n\nBCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the caller to peel off the data by calling different decoding functions, prefixed with peel_*. The data is split off the bytes, and the remainder bytes are kept in the wrapper until the into_remainder_bytes function is called.\n\nuse sui::bcs;\n\n// BCS instance should always be declared as mutable\nlet mut bcs = bcs::new(x\"010000000000000000\");\n\n// Same bytes can be read differently, for example: Option<u64>\nlet value: Option<u64> = bcs.peel_option_u64();\n\nassert!(value.is_some(), 0);\nassert!(value.borrow() == &0, 1);\n\nlet remainder = bcs.into_remainder_bytes();\n\nassert!(remainder.length() == 0, 2);\n\n\nThere is a common practice to use multiple variables in a single let statement during decoding. It makes code a little bit more readable and helps to avoid unnecessary copying of the data.\n\nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// mind the order!!!\n// handy way to peel multiple values\nlet (bool_value, u8_value, u64_value) = (\n    bcs.peel_bool(),\n    bcs.peel_u8(),\n    bcs.peel_u64()\n);\n\nDecoding Vectors\n\nWhile most of the primitive types have a dedicated decoding function, vectors need special handling, which depends on the type of the elements. For vectors, first you need to decode the length of the vector, and then decode each element in a loop.\n\nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\n// bcs.peel_vec_length() peels the length of the vector :)\nlet mut len = bcs.peel_vec_length();\nlet mut vec = vector[];\n\n// then iterate depending on the data type\nwhile (len > 0) {\n    vec.push_back(bcs.peel_u64()); // or any other type\n    len = len - 1;\n};\n\nassert!(vec.length() == 1, 0);\n\n\nFor most common scenarios, bcs module provides a basic set of functions for decoding vectors:\n\npeel_vec_address(): vector<address>\npeel_vec_bool(): vector<bool>\npeel_vec_u8(): vector<u8>\npeel_vec_u64(): vector<u64>\npeel_vec_u128(): vector<u128>\npeel_vec_vec_u8(): vector<vector<u8>> - vector of byte vectors\nDecoding Option\n\nOption is represented as a vector of either 0 or 1 element. To read an option, you would treat it like a vector and check its length (first byte - either 1 or 0).\n\nlet mut bcs = bcs::new(x\"00\");\nlet is_some = bcs.peel_bool();\n\nassert!(is_some == false, 0);\n\nlet mut bcs = bcs::new(x\"0101\");\nlet is_some = bcs.peel_bool();\nlet value = bcs.peel_u8();\n\nassert!(is_some == true, 1);\nassert!(value == 1, 2);\n\n\nIf you need to decode an option of a custom type, use the method in the code snippet above.\n\nThe most common scenarios, bcs module provides a basic set of functions for decoding Option's:\n\npeel_option_address(): Option<address>\npeel_option_bool(): Option<bool>\npeel_option_u8(): Option<u8>\npeel_option_u64(): Option<u64>\npeel_option_u128(): Option<u128>\nDecoding Structs\n\nStructs are decoded field by field, and there is no standard function to automatically decode bytes into a Move struct, and it would have been a violation of the Move's type system. Instead, you need to decode each field manually.\n\n// some bytes... \nlet mut bcs = bcs::new(x\"0101010F0000000000F00000000000\");\n\nlet (age, is_active, name) = (\n    bcs.peel_u8(),\n    bcs.peel_bool(),\n    bcs.peel_vec_u8().to_string()\n);\n\nlet user = User { age, is_active, name };\n\nSummary\n\nBinary Canonical Serialization is an efficient binary format for structured data, ensuring consistent serialization across platforms. The Sui Framework provides comprehensive tools for working with BCS, allowing extensive functionality through built-in functions."
    },
    {
      "title": "Sui Framework - The Move Book",
      "url": "https://move-book.com/programmability/sui-framework.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nSui Framework\n\nSui Framework is a default dependency set in the Package Manifest. It depends on the Standard Library and provides Sui-specific features, including the interaction with the storage, and Sui-specific native types and modules.\n\nFor convenience, we grouped the modules in the Sui Framework into multiple categories. But they're still part of the same framework.\n\nCore\nModule\tDescription\tChapter\nsui::address\tAdds conversion methods to the address type\tAddress\nsui::transfer\tImplements the storage operations for Objects\tIt starts with an Object\nsui::tx_context\tContains the TxContext struct and methods to read it\tTransaction Context\nsui::object\tDefines the UID and ID type, required for creating objects\tIt starts with an Object\nsui::clock\tDefines the Clock type and its methods\tEpoch and Time\nsui::dynamic_field\tImplements methods to add, use and remove dynamic fields\tDynamic Fields\nsui::dynamic_object_field\tImplements methods to add, use and remove dynamic object fields\tDynamic Object Fields\nsui::event\tAllows emitting events for off-chain listeners\tEvents\nsui::package\tDefines the Publisher type and package upgrade methods\tPublisher, Package Upgrades\nsui::display\tImplements the Display object and ways to create and update it\tDisplay\nCollections\nModule\tDescription\tChapter\nsui::vec_set\tImplements a set type\tCollections\nsui::vec_map\tImplements a map with vector keys\tCollections\nsui::table\tImplements the Table type and methods to interact with it\tDynamic Collections\nsui::linked_table\tImplements the LinkedTable type and methods to interact with it\tDynamic Collections\nsui::bag\tImplements the Bag type and methods to interact with it\tDynamic Collections\nsui::object_table\tImplements the ObjectTable type and methods to interact with it\tDynamic Collections\nsui::object_bag\tImplements the ObjectBag type and methods to interact with it\tDynamic Collections\nUtilities\nModule\tDescription\tChapter\nsui::bcs\tImplements the BCS encoding and decoding functions\tBinary Canonical Serialization\nExported Addresses\n\nSui Framework exports two named addresses: sui = 0x2 and std = 0x1 from the std dependency.\n\n[addresses]\nsui = \"0x2\"\n\n# Exported from the MoveStdlib dependency\nstd = \"0x1\"\n\nImplicit Imports\n\nJust like with Standard Library, some of the modules and types are imported implicitly in the Sui Framework. This is the list of modules and types that are available without explicit use import:\n\nsui::object\nsui::object::ID\nsui::object::UID\nsui::tx_context\nsui::tx_context::TxContext\nsui::transfer\nSource Code\n\nThe source code of the Sui Framework is available in the Sui repository."
    },
    {
      "title": "Events - The Move Book",
      "url": "https://move-book.com/programmability/events.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nEvents\n\nEvents are a way to notify off-chain listeners about on-chain events. They are used to emit additional information about the transaction that is not stored - and, hence, can't be accessed - on-chain. Events are emitted by the sui::event module located in the Sui Framework.\n\nAny custom type with the copy and drop abilities can be emitted as an event. Sui Verifier requires the type to be internal to the module.\n\n// File: sui-framework/sources/event.move\nmodule sui::event {\n    /// Emit a custom Move event, sending the data offchain.\n    ///\n    /// Used for creating custom indexes and tracking onchain\n    /// activity in a way that suits a specific application the most.\n    ///\n    /// The type `T` is the main way to index the event, and can contain\n    /// phantom parameters, eg `emit(MyEvent<phantom T>)`.\n    public native fun emit<T: copy + drop>(event: T);\n}\n\nEmitting Events\n\nEvents are emitted using the emit function in the sui::event module. The function takes a single argument - the event to be emitted. The event data is passed by value,\n\nmodule book::events {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n    use sui::event;\n\n    /// The item that can be purchased.\n    public struct Item has key { id: UID }\n\n    /// Event emitted when an item is purchased. Contains the ID of the item and\n    /// the price for which it was purchased.\n    public struct ItemPurchased has copy, drop {\n        item: ID,\n        price: u64\n    }\n\n    /// A marketplace function which performs the purchase of an item.\n    public fun purchase(coin: Coin<SUI>, ctx: &mut TxContext) {\n        let item = Item { id: object::new(ctx) };\n\n        // Create an instance of `ItemPurchased` and pass it to `event::emit`.\n        event::emit(ItemPurchased {\n            item: object::id(&item),\n            price: coin.value()\n        });\n\n        // Omitting the rest of the implementation to keep the example simple.\n        abort 0\n    }\n}\n\n\nThe Sui Verifier requires the type passed to the emit function to be internal to the module. So emitting a type from another module will result in a compilation error. Primitive types, although they match the copy and drop requirement, are not allowed to be emitted as events.\n\nEvent Structure\n\nEvents are a part of the transaction result and are stored in the transaction effects. As such, they natively have the sender field which is the address who sent the transaction. So adding a \"sender\" field to the event is not necessary. Similarly, event metadata contains the timestamp. But it is important to note that the timestamp is relative to the node and may vary a little from node to node."
    },
    {
      "title": "Display - The Move Book",
      "url": "https://move-book.com/programmability/display.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nObject Display\n\nObjects on Sui are explicit in their structure and behavior and can be displayed in an understandable way. However, to support richer metadata for clients, there's a standard and efficient way of \"describing\" them to the client - the Display object defined in the Sui Framework.\n\nBackground\n\nHistorically, there were different attempts to agree on a standard structure of an object so it can be displayed in a user interface. One of the approaches was to define certain fields in the object struct which, when present, would be used in the UI. This approach was not flexible enough and required developers to define the same fields in every object, and sometimes the fields did not make sense for the object.\n\n/// An attempt to standardize the object structure for display.\npublic struct CounterWithDisplay has key {\n    id: UID,\n    /// If this field is present it will be displayed in the UI as `name`.\n    name: String,\n    /// If this field is present it will be displayed in the UI as `description`.\n    description: String,\n    // ...\n    image: String,\n    /// Actual fields of the object.\n    counter: u64,\n    // ...\n}\n\n\nIf any of the fields contained static data, it would be duplicated in every object. And, since Move does not have interfaces, it is not possible to know if an object has a specific field without \"manually\" checking the object's type, which makes the client fetching more complex.\n\nObject Display\n\nTo address these issues, Sui introduces a standard way of describing an object for display. Instead of defining fields in the object struct, the display metadata is stored in a separate object, which is associated with the type. This way, the display metadata is not duplicated, and it is easy to extend and maintain.\n\nAnother important feature of Sui Display is the ability to define templates and use object fields in those templates. Not only it allows for a more flexible display, but it also frees the developer from the need to define the same fields with the same names and types in every object.\n\nThe Object Display is natively supported by the Sui Fullnode, and the client can fetch the display metadata for any object if the object type has a Display associated with it.\n\nmodule book::arena {\n    use std::string::String;\n    use sui::package;\n    use sui::display;\n\n    /// The One Time Witness to claim the `Publisher` object.\n    public struct ARENA has drop {}\n\n    /// Some object which will be displayed.\n    public struct Hero has key {\n        id: UID,\n        class: String,\n        level: u64,\n    }\n\n    /// In the module initializer we create the `Publisher` object, and then\n    /// the Display for the `Hero` type.\n    fun init(otw: ARENA, ctx: &mut TxContext) {\n        let publisher = package::claim(otw, ctx);\n        let mut display = display::new<Hero>(&publisher, ctx);\n\n        display.add(\n            b\"name\".to_string(),\n            b\"{class} (lvl. {level})\".to_string()\n        );\n\n        display.add(\n            b\"description\".to_string(),\n            b\"One of the greatest heroes of all time. Join us!\".to_string()\n        );\n\n        display.add(\n            b\"link\".to_string(),\n            b\"https://example.com/hero/{id}\".to_string()\n        );\n\n        display.add(\n            b\"image_url\".to_string(),\n            b\"https://example.com/hero/{class}.jpg\".to_string()\n        );\n\n        // Update the display with the new data.\n        // Must be called to apply changes.\n        display.update_version();\n\n        transfer::public_transfer(publisher, ctx.sender());\n        transfer::public_transfer(display, ctx.sender());\n    }\n}\n\nCreator Privilege\n\nWhile the objects can be owned by accounts and may be a subject to True Ownership, the Display can be owned by the creator of the object. This way, the creator can update the display metadata and apply the changes globally without the need to update every object. The creator can also transfer Display to another account or even build an application around the object with custom functionality to manage the metadata.\n\nStandard Fields\n\nThe fields that are supported most widely are:\n\nname - A name for the object. The name is displayed when users view the object.\ndescription - A description for the object. The description is displayed when users view the object.\nlink - A link to the object to use in an application.\nimage_url - A URL or a blob with the image for the object.\nthumbnail_url - A URL to a smaller image to use in wallets, explorers, and other products as a preview.\nproject_url - A link to a website associated with the object or creator.\ncreator - A string that indicates the object creator.\n\nPlease, refer to the Sui Documentation for the most up-to-date list of supported fields.\n\nWhile there's a standard set of fields, the Display object does not enforce them. The developer can define any fields they need, and the client can use them as they see fit. Some applications may require additional fields, and omit other, and the Display is flexible enough to support them.\n\nWorking with Display\n\nThe Display object is defined in the sui::display module. It is a generic struct that takes a phantom type as a parameter. The phantom type is used to associate the Display object with the type it describes. The fields of the Display object are a VecMap of key-value pairs, where the key is the field name and the value is the field value. The version field is used to version the display metadata, and is updated on the update_display call.\n\nFile: sui-framework/sources/display.move\n\nstruct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n\n\nThe Publisher object is required to a new Display, since it serves as the proof of ownership of type.\n\nTemplate Syntax\n\nCurrently, Display supports simple string interpolation and can use struct fields (and paths) in its templates. The syntax is trivial - {path} is replaced with the value of the field at the path. The path is a dot-separated list of field names, starting from the root object in case of nested fields.\n\n/// Some common metadata for objects.\npublic struct Metadata has store {\n    name: String,\n    description: String,\n    published_at: u64\n}\n\n/// The type with nested Metadata field.\npublic struct LittlePony has key, store {\n    id: UID,\n    image_url: String,\n    metadata: Metadata\n}\n\n\nThe Display for the type LittlePony above could be defined as follows:\n\n{\n  \"name\": \"Just a pony\",\n  \"image_url\": \"{image_url}\",\n  \"description\": \"{metadata.description}\"\n}\n\nMultiple Display Objects\n\nThere's no restriction to how many Display<T> objects can be created for a specific T. However, the most recently updated Display<T> will be used by the fullnode.\n\nFurther Reading\nSui Object Display is Sui Documentation\nPublisher - the representation of the creator"
    },
    {
      "title": "Publisher Authority - The Move Book",
      "url": "https://move-book.com/programmability/publisher.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nPublisher Authority\n\nIn application design and development, it is often needed to prove publisher authority. This is especially important in the context of digital assets, where the publisher may enable or disable certain features for their assets. The Publisher Object is an object, defined in the Sui Framework, that allows the publisher to prove their authority over a type.\n\nDefinition\n\nThe Publisher object is defined in the sui::package module of the Sui Framework. It is a very simple, non-generic object that can be initialized once per module (and multiple times per package) and is used to prove the authority of the publisher over a type. To claim a Publisher object, the publisher must present a One Time Witness to the package::claim function.\n\n// File: sui-framework/sources/package.move\npublic struct Publisher has key, store {\n    id: UID,\n    package: String,\n    module_name: String,\n}\n\n\nIf you're not familiar with the One Time Witness, you can read more about it here.\n\nHere's a simple example of claiming a Publisher object in a module:\n\nmodule book::publisher {\n    /// Some type defined in the module.\n    public struct Book {}\n\n    /// The OTW for the module.\n    public struct PUBLISHER has drop {}\n\n    /// Uses the One Time Witness to claim the Publisher object.\n    fun init(otw: PUBLISHER, ctx: &mut TxContext) {\n        // Claim the Publisher object.\n        let publisher = sui::package::claim(otw, ctx);\n\n        // Usually it is transferred to the sender.\n        // It can also be stored in another object.\n        transfer::public_transfer(publisher, ctx.sender())\n    }\n}\n\nUsage\n\nThe Publisher object has two functions associated with it which are used to prove the publisher's authority over a type:\n\n// Checks if the type is from the same module, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_module<Book>(), 0);\n\n// Checks if the type is from the same package, hence the `Publisher` has the\n// authority over it.\nassert!(publisher.from_package<Book>(), 0);\n\nPublisher as Admin Role\n\nFor small applications or simple use cases, the Publisher object can be used as an admin capability. While in the broader context, the Publisher object has control over system configurations, it can also be used to manage the application's state.\n\n/// Some action in the application gated by the Publisher object.\npublic fun admin_action(cap: &Publisher, /* app objects... */ param: u64) {\n    assert!(cap.from_module<Book>(), ENotAuthorized);\n\n    // perform application-specific action\n}\n\n\nHowever, Publisher misses some native properties of Capabilities, such as type safety and expressiveness. The signature for the admin_function is not very explicit, can be called by anyone else. And due to Publisher object being standard, there now is a risk of unauthorized access if the from_module check is not performed. So it's important to be cautious when using the Publisher object as an admin role.\n\nRole on Sui\n\nPublisher is required for certain features on Sui. Object Display can be created only by the Publisher, and TransferPolicy - an important component of the Kiosk system - also requires the Publisher object to prove ownership of the type.\n\nNext Steps\n\nIn the next chapter we will cover the first feature that requires the Publisher object - Object Display - a way to describe objects for clients, and standardize metadata. A must-have for user-friendly applications."
    },
    {
      "title": "One Time Witness - The Move Book",
      "url": "https://move-book.com/programmability/one-time-witness.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nOne Time Witness\n\nWhile regular Witness is a great way to statically prove the ownership of a type, there are cases where we need to ensure that a Witness is instantiated only once. And this is the purpose of the One Time Witness (OTW).\n\nDefinition\n\nThe OTW is a special type of Witness that can be used only once. It cannot be manually created and it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these rules:\n\nHas only drop ability.\nHas no fields.\nIs not a generic type.\nNamed after the module with all uppercase letters.\n\nHere is an example of an OTW:\n\nmodule book::one_time {\n    /// The OTW for the `book::one_time` module.\n    /// Only `drop`, no fields, no generics, all uppercase.\n    public struct ONE_TIME has drop {}\n\n    /// Receive the instance of `ONE_TIME` as the first argument.\n    fun init(otw: ONE_TIME, ctx: &mut TxContext) {\n        // do something with the OTW\n    }\n}\n\n\nThe OTW cannot be constructed manually, and any code attempting to do so will result in a compilation error. The OTW can be received as the first argument in the module initializer. And because the init function is called only once per module, the OTW is guaranteed to be instantiated only once.\n\nEnforcing the OTW\n\nTo check if a type is an OTW, sui::types module of the Sui Framework offers a special function is_one_time_witness that can be used to check if the type is an OTW.\n\nuse sui::types;\n\nconst ENotOneTimeWitness: u64 = 1;\n\n/// Takes an OTW as an argument, aborts if the type is not OTW.\npublic fun takes_witness<T: drop>(otw: T) {\n    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);\n}\n\nSummary\n\nThe OTW pattern is a great way to ensure that a type is used only once. Most of the developers should understand how to define and receive the OTW, while the OTW checks and enforcement is mostly needed in libraries and frameworks. For example, the sui::coin module requires an OTW in the coin::create_currency method, therefore enforcing that the coin::TreasuryCap is created only once.\n\nOTW is a powerful tool that lays the foundation for the Publisher object, which we will cover in the next section."
    },
    {
      "title": "Dynamic Fields - The Move Book",
      "url": "https://move-book.com/programmability/dynamic-fields.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nDynamic Fields\n\nSui Object model allows objects to be attached to other objects as dynamic fields. The behavior is similar to how a Map works in other programming languages. However, unlike a Map which in Move would be strictly typed (we have covered it in the Collections section), dynamic fields allow attaching objects of any type. A similar approach from the world of frontend development would be a JavaScript Object type which allows storing any type of data dynamically.\n\nThere's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic fields can be used to store large amounts of data that don't fit into the object limit size.\n\nDynamic Fields allow for a wide range of applications, from splitting data into smaller parts to avoid object size limit to attaching objects as a part of application logic.\n\nDefinition\n\nDynamic Fields are defined in the sui::dynamic_field module of the Sui Framework. They are attached to object's UID via a name, and can be accessed using that name. There can be only one field with a given name attached to an object.\n\nFile: sui-framework/sources/dynamic_field.move\n\n/// Internal object used for storing the field and value\npublic struct Field<Name: copy + drop + store, Value: store> has key {\n    /// Determined by the hash of the object ID, the field name\n    /// value and it's type, i.e. hash(parent.id || name || Name)\n    id: UID,\n    /// The value for the name of this field\n    name: Name,\n    /// The value bound to this field\n    value: Value,\n}\n\n\nAs the definition shows, dynamic fields are stored in an internal Field object, which has the UID generated in a deterministic way based on the object ID, the field name, and the field type. The Field object contains the field name and the value bound to it. The constraints on the Name and Value type parameters define the abilities that the key and value must have.\n\nUsage\n\nThe methods available for dynamic fields are straightforward: a field can be added with add, removed with remove, and read with borrow and borrow_mut. Additionally, the exists_ method can be used to check if a field exists (for stricter checks with type, there is an exists_with_type method).\n\nmodule book::dynamic_collection {\n    // a very common alias for `dynamic_field` is `df` since the\n    // module name is quite long\n    use sui::dynamic_field as df;\n    use std::string::String;\n\n    /// The object that we will attach dynamic fields to.\n    public struct Character has key {\n        id: UID\n    }\n\n    // List of different accessories that can be attached to a character.\n    // They must have the `store` ability.\n    public struct Hat has key, store { id: UID, color: u32 }\n    public struct Mustache has key, store { id: UID }\n\n    #[test]\n    fun test_character_and_accessories() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Attach a hat to the character's UID\n        df::add(\n            &mut character.id,\n            b\"hat_key\",\n            Hat { id: object::new(ctx), color: 0xFF0000 }\n        );\n\n        // Similarly, attach a mustache to the character's UID\n        df::add(\n            &mut character.id,\n            b\"mustache_key\",\n            Mustache { id: object::new(ctx) }\n        );\n\n        // Check that the hat and mustache are attached to the character\n        //\n        assert!(df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        // Modify the color of the hat\n        let hat: &mut Hat = df::borrow_mut(&mut character.id, b\"hat_key\");\n        hat.color = 0x00FF00;\n\n        // Remove the hat and mustache from the character\n        let hat: Hat = df::remove(&mut character.id, b\"hat_key\");\n        let mustache: Mustache = df::remove(&mut character.id, b\"mustache_key\");\n\n        // Check that the hat and mustache are no longer attached to the character\n        assert!(!df::exists_(&character.id, b\"hat_key\"), 0);\n        assert!(!df::exists_(&character.id, b\"mustache_key\"), 1);\n\n        sui::test_utils::destroy(character);\n        sui::test_utils::destroy(mustache);\n        sui::test_utils::destroy(hat);\n    }\n}\n\n\nIn the example above, we define a Character object and two different types of accessories that could never be put together in a vector. However, dynamic fields allow us to store them together in a single object. Both objects are attached to the Character via a vector<u8> (bytestring literal), and can be accessed using their respective keys.\n\nAs you can see, when we attached the accessories to the Character, we passed them by value. In other words, both values were moved to a new scope, and their ownership was transferred to the Character object. If we changed the ownership of Character object, the accessories would have been moved with it.\n\nAnd the last important property of dynamic fields we should highlight is that they are accessed through their parent. This means that the Hat and Mustache objects are not directly accessible and follow the same rules as the parent object.\n\nForeign Types as Dynamic Fields\n\nDynamic fields allow objects to carry data of any type, including those defined in other modules. This is possible due to their generic nature and relatively weak constraints on the type parameters. Let's illustrate this by attaching a few different values to a Character object.\n\nlet mut character = Character { id: object::new(ctx) };\n\n// Attach a `String` via a `vector<u8>` name\ndf::add(&mut character.id, b\"string_key\", b\"Hello, World!\".to_string());\n\n// Attach a `u64` via a `u32` name\ndf::add(&mut character.id, 1000u32, 1_000_000_000u64);\n\n// Attach a `bool` via a `bool` name\ndf::add(&mut character.id, true, false);\n\n\nIn this example we showed how different types can be used for both name and the value of a dynamic field. The String is attached via a vector<u8> name, the u64 is attached via a u32 name, and the bool is attached via a bool name. Anything is possible with dynamic fields!\n\nOrphaned Dynamic Fields\n\nTo prevent orphaned dynamic fields, please, use Dynamic Collection Types such as Bag as they track the dynamic fields and won't allow unpacking if there are attached fields.\n\nThe object::delete() function, which is used to delete a UID, does not track the dynamic fields, and cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the dynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic fields are still stored in the blockchain, but they will never become accessible again.\n\nlet hat = Hat { id: object::new(ctx), color: 0xFF0000 };\nlet mut character = Character { id: object::new(ctx) };\n\n// Attach a `Hat` via a `vector<u8>` name\ndf::add(&mut character.id, b\"hat_key\", hat);\n\n// ! DO NOT do this in your code\n// ! Danger - deleting the parent object\nlet Character { id } = character;\nid.delete();\n\n// ...`Hat` is now stuck in a limbo, it will never be accessible again\n\n\nOrphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed. One way to avoid orphaned dynamic fields during unpacking on an object is to return the UID and store it somewhere temporarily until the dynamic fields are removed and handled properly.\n\nCustom Type as a Field Name\n\nIn the examples above, we used primitive types as field names since they have the required set of abilities. But dynamic fields get even more interesting when we use custom types as field names. This allows for a more structured way of storing data, and also allows for protecting the field names from being accessed by other modules.\n\n/// A custom type with fields in it.\npublic struct AccessoryKey has copy, drop, store { name: String }\n\n/// An empty key, can be attached only once.\npublic struct MetadataKey has copy, drop, store {}\n\n\nTwo field names that we defined above are AccessoryKey and MetadataKey. The AccessoryKey has a String field in it, hence it can be used multiple times with different name values. The MetadataKey is an empty key, and can be attached only once.\n\nlet mut character = Character { id: object::new(ctx) };\n\n// Attaching via an `AccessoryKey { name: b\"hat\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"hat\".to_string() },\n    Hat { id: object::new(ctx), color: 0xFF0000 }\n);\n// Attaching via an `AccessoryKey { name: b\"mustache\" }`\ndf::add(\n    &mut character.id,\n    AccessoryKey { name: b\"mustache\".to_string() },\n    Mustache { id: object::new(ctx) }\n);\n\n// Attaching via a `MetadataKey`\ndf::add(&mut character.id, MetadataKey {}, 42);\n\n\nAs you can see, custom types do work as field names but as long as they can be constructed by the module, in other words - if they are internal to the module and defined in it. This limitation on struct packing can open up new ways in the design of the application.\n\nThis approach is used in the Object Capability pattern, where an application can authorize a foreign object to perform operations in it while not exposing the capabilities to other modules.\n\nExposing UID\n\nMutable access to UID is a security risk. Exposing UID of your type as a mutable reference can lead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects the Transfer to Object and Dynamic Object Fields. Make sure to understand the implications before exposing the UID as a mutable reference.\n\nBecause dynamic fields are attached to UIDs, their usage in other modules depends on whether the UID can be accessed. By default struct visibility protects the id field and won't let other modules access it directly. However, if there's a public accessor method that returns a reference to UID, dynamic fields can be read in other modules.\n\n/// Exposes the UID of the character, so that other modules can read\n/// dynamic fields.\npublic fun uid(c: &Character): &UID {\n    &c.id\n}\n\n\nIn the example above, we show how to expose the UID of a Character object. This solution may work for some applications, however, it is important to remember that exposed UID allows reading any dynamic field attached to the object.\n\nIf you need to expose the UID only within the package, use a restrictive visibility, like public(package), or even better - use more specific accessor methods that would allow only reading specific fields.\n\n/// Only allow modules in the same package to access the UID.\npublic(package) fun uid_package(c: &Character): &UID {\n    &c.id\n}\n\n/// Allow borrowing dynamic fields from the character.\npublic fun borrow<Name: copy + store + drop, Value: store>(\n    c: &Character,\n    n: Name\n): &Value {\n    df::borrow(&c.id, n)\n}\n\nDynamic Fields vs Fields\n\nDynamic Fields are more expensive than regular fields, as they require additional storage and costs for accessing them. Their flexibility comes at a price, and it is important to understand the implications when making a decision between using dynamic fields and regular fields.\n\nLimits\n\nDynamic Fields are not subject to the object size limit, and can be used to store large amounts of data. However, they are still subject to the dynamic fields created limit, which is set to 1000 fields per transaction.\n\nApplications\n\nDynamic Fields can play a crucial role in applications of any complexity. They open up a variety of different use cases, from storing heterogeneous data to attaching objects as part of the application logic. They allow for certain upgradeability practices based on the ability to define them later and change the type of the field.\n\nNext Steps\n\nIn the next section we will cover Dynamic Object Fields and explain how they differ from dynamic fields, and what are the implications of using them."
    },
    {
      "title": "Dynamic Collections - The Move Book",
      "url": "https://move-book.com/programmability/dynamic-collections.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nDynamic Collections\n\nSui Framework offers a variety of collection types that build on the dynamic fields and dynamic object fields concepts. These collections are designed to be a safer and more understandable way to store and manage dynamic fields and objects.\n\nFor each collection type we will specify the primitive they use, and the specific features they offer.\n\nUnlike dynamic (object) fields which operate on UID, collection types have their own type and allow calling associated functions.\n\nCommon Concepts\n\nAll of the collection types share the same set of methods, which are:\n\nadd - adds a field to the collection\nremove - removes a field from the collection\nborrow - borrows a field from the collection\nborrow_mut - borrows a mutable reference to a field from the collection\ncontains - checks if a field exists in the collection\nlength - returns the number of fields in the collection\nis_empty - checks if the length is 0\n\nAll collection types support index syntax for borrow and borrow_mut methods. If you see square brackets in the examples, they are translated into borrow and borrow_mut calls.\n\nlet hat: &Hat = &bag[b\"key\"];\nlet hat_mut: &mut Hat = &mut bag[b\"key\"];\n\n// is equivalent to\nlet hat: &Hat = bag.borrow(b\"key\");\nlet hat_mut: &mut Hat = bag.borrow_mut(b\"key\");\n\n\nIn the examples we won't focus on these functions, but rather on the differences between the collection types.\n\nBag\n\nBag, as the name suggests, acts as a \"bag\" of heterogeneous values. It is a simple, non-generic type that can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and can't be destroyed if it's not empty.\n\n// File: sui-framework/sources/bag.move\npublic struct Bag has key, store {\n    /// the ID of this bag\n    id: UID,\n    /// the number of key-value pairs in the bag\n    size: u64,\n}\n\n\nDue to Bag storing any types, the extra methods it offers is:\n\ncontains_with_type - checks if a field exists with a specific type\n\nUsed as a struct field:\n\n/// Imported from the `sui::bag` module.\nuse sui::bag::{Self, Bag};\n\n/// An example of a `Bag` as a struct field.\npublic struct Carrier has key {\n    id: UID,\n    bag: Bag\n}\n\n\nUsing the Bag:\n\nlet mut bag = bag::new(ctx);\n\n// bag has the `length` function to get the number of elements\nassert!(bag.length() == 0, 0);\n\nbag.add(b\"my_key\", b\"my_value\".to_string());\n\n// length has changed to 1\nassert!(bag.length() == 1, 1);\n\n// in order: `borrow`, `borrow_mut` and `remove`\n// the value type must be specified\nlet field_ref: &String = &bag[b\"my_key\"];\nlet field_mut: &mut String = &mut bag[b\"my_key\"];\nlet field: String = bag.remove(b\"my_key\");\n\n// length is back to 0 - we can unpack\nbag.destroy_empty();\n\nObjectBag\n\nDefined in the sui::object_bag module. Identical to Bag, but uses dynamic object fields internally. Can only store objects as values.\n\nTable\n\nTable is a typed dynamic collection that has a fixed type for keys and values. It is defined in the sui::table module.\n\n// File: sui-framework/sources/table.move\npublic struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {\n    /// the ID of this table\n    id: UID,\n    /// the number of key-value pairs in the table\n    size: u64,\n}\n\n\nUsed as a struct field:\n\n/// Imported from the `sui::table` module.\nuse sui::table::{Self, Table};\n\n/// Some record type with `store`\npublic struct Record has store { /* ... */ }\n\n/// An example of a `Table` as a struct field.\npublic struct UserRegistry has key {\n    id: UID,\n    table: Table<address, Record>\n}\n\n\nUsing the Table:\n\n#[test] fun test_table() {\nlet ctx = &mut tx_context::dummy();\n\n// Table requires explicit type parameters for the key and value\n// ...but does it only once in initialization.\nlet mut table = table::new<address, String>(ctx);\n\n// table has the `length` function to get the number of elements\nassert!(table.length() == 0, 0);\n\ntable.add(@0xa11ce, b\"my_value\".to_string());\ntable.add(@0xb0b, b\"another_value\".to_string());\n\n// length has changed to 2\nassert!(table.length() == 2, 2);\n\n// in order: `borrow`, `borrow_mut` and `remove`\nlet addr_ref = &table[@0xa11ce];\nlet addr_mut = &mut table[@0xa11ce];\n\n// removing both values\nlet _addr = table.remove(@0xa11ce);\nlet _addr = table.remove(@0xb0b);\n\n// length is back to 0 - we can unpack\ntable.destroy_empty();\n\nObjectTable\n\nDefined in the sui::object_table module. Identical to Table, but uses dynamic object fields internally. Can only store objects as values.\n\nSummary\nBag - a simple collection that can store any type of data\nObjectBag - a collection that can store only objects\nTable - a typed dynamic collection that has a fixed type for keys and values\nObjectTable - same as Table, but can only store objects\nLinkedTable\n\nThis section is coming soon!"
    },
    {
      "title": "Dynamic Object Fields - The Move Book",
      "url": "https://move-book.com/programmability/dynamic-object-fields.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nDynamic Object Fields\n\nThis section expands on the Dynamic Fields. Please, read it first to understand the basics of dynamic fields.\n\nAnother variation of dynamic fields is dynamic object fields, which have certain differences from regular dynamic fields. In this section, we will cover the specifics of dynamic object fields and explain how they differ from regular dynamic fields.\n\nGeneral recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields, especially if there's no need for direct discovery through the ID. The extra costs of dynamic object fields may not be justified by the benefits they provide.\n\nDefinition\n\nDynamic Object Fields are defined in the sui::dynamic_object_fields module in the Sui Framework. They are similar to dynamic fields in many ways, but unlike them, dynamic object fields have an extra constraint on the Value type. The Value must have a combination of key and store, not just store as in the case of dynamic fields.\n\nThey're less explicit in their framework definition, as the concept itself is more abstract:\n\nFile: sui-framework/sources/dynamic_object_fields.move\n\n/// Internal object used for storing the field and the name associated with the\n/// value. The separate type is necessary to prevent key collision with direct\n/// usage of dynamic_field\npublic struct Wrapper<Name> has copy, drop, store {\n    name: Name,\n}\n\n\nUnlike Field type in the Dynamic Fields section, the Wrapper type only stores the name of the field. The value is the object itself, and is not wrapped.\n\nThe constraints on the Value type become visible in the methods available for dynamic object fields. Here's the signature for the add function:\n\n/// Adds a dynamic object field to the object `object: &mut UID` at field\n/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object\n/// already has that field with that name.\npublic fun add<Name: copy + drop + store, Value: key + store>(\n    // we use &mut UID in several spots for access control\n    object: &mut UID,\n    name: Name,\n    value: Value,\n) { /* implementation omitted */ }\n\n\nThe rest of the methods which are identical to the ones in the Dynamic Fields section have the same constraints on the Value type. Let's list them for reference:\n\nadd - adds a dynamic object field to the object\nremove - removes a dynamic object field from the object\nborrow - borrows a dynamic object field from the object\nborrow_mut - borrows a mutable reference to a dynamic object field from the object\nexists_ - checks if a dynamic object field exists\nexists_with_type - checks if a dynamic object field exists with a specific type\n\nAdditionally, there is an id method which returns the ID of the Value object without specifying its type.\n\nUsage & Differences with Dynamic Fields\n\nThe main difference between dynamic fields and dynamic object fields is that the latter allows storing only objects as values. This means that you can't store primitive types like u64 or bool. It may be considered a limitation, if not for the fact that dynamic object fields are not wrapped into a separate object.\n\nThe relaxed requirement for wrapping keeps the object available for off-chain discovery via its ID. However, this property may not be outstanding if wrapped object indexing is implemented, making the dynamic object fields a redundant feature.\n\nmodule book::dynamic_object_field {\n    use std::string::String;\n\n    // there are two common aliases for the long module name: `dof` and\n    // `ofield`. Both are commonly used and met in different projects.\n    use sui::dynamic_object_field as dof;\n    use sui::dynamic_field as df;\n\n    /// The `Character` that we will use for the example\n    public struct Character has key { id: UID }\n\n    /// Metadata that doesn't have the `key` ability\n    public struct Metadata has store, drop { name: String }\n\n    /// Accessory that has the `key` and `store` abilities.\n    public struct Accessory has key, store { id: UID }\n\n    #[test]\n    fun equip_accessory() {\n        let ctx = &mut tx_context::dummy();\n        let mut character = Character { id: object::new(ctx) };\n\n        // Create an accessory and attach it to the character\n        let hat = Accessory { id: object::new(ctx) };\n\n        // Add the hat to the character. Just like with `dynamic_fields`\n        dof::add(&mut character.id, b\"hat_key\", hat);\n\n        // However for non-key structs we can only use `dynamic_field`\n        df::add(&mut character.id, b\"metadata_key\", Metadata {\n            name: b\"John\".to_string()\n        });\n\n        // Borrow the hat from the character\n        let hat_id = dof::id(&character.id, b\"hat_key\").extract(); // Option<ID>\n        let hat_ref: &Accessory = dof::borrow(&character.id, b\"hat_key\");\n        let hat_mut: &mut Accessory = dof::borrow_mut(&mut character.id, b\"hat_key\");\n        let hat: Accessory = dof::remove(&mut character.id, b\"hat_key\");\n\n        // Clean up, Metadata is an orphan now.\n        sui::test_utils::destroy(hat);\n        sui::test_utils::destroy(character);\n    }\n}\n\nPricing Differences\n\nDynamic Object Fields come a little more exensive than dynamic fields. Because of their internal structure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of adding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.\n\nNext Steps\n\nBoth dynamic field and dynamic object fields are powerful features which allow for innovative solutions in applications. However, they are relatively low-level and require careful handling to avoid orphaned fields. In the next section, we will introduce a higher-level abstraction - Dynamic Collections - which can help with managing dynamic fields and objects more effectively."
    },
    {
      "title": "Collections - The Move Book",
      "url": "https://move-book.com/programmability/collections.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nCollections\n\nCollection types are a fundamental part of any programming language. They are used to store a collection of data, such as a list of items. The vector type has already been covered in the vector section, and in this chapter we will cover the vector-based collection types offered by the Sui Framework.\n\nVector\n\nWhile we have previously covered the vector type in the vector section, it is worth going over it again in a new context. This time we will cover the usage of the vector type in objects and how it can be used in an application.\n\nmodule book::collections_vector {\n    use std::string::String;\n\n    /// The Book that can be sold by a `BookStore`\n    public struct Book has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// The BookStore that sells `Book`s\n    public struct BookStore has key, store {\n        id: UID,\n        books: vector<Book>\n    }\n}\n\nVecSet\n\nVecSet is a collection type that stores a set of unique items. It is similar to a vector, but it does not allow duplicate items. This makes it useful for storing a collection of unique items, such as a list of unique IDs or addresses.\n\nmodule book::collections_vec_set {\n    use sui::vec_set::{Self, VecSet};\n\n    public struct App has drop {\n        /// `VecSet` used in the struct definition\n        subscribers: VecSet<address>\n    }\n\n    #[test]\n    fun vec_set_playground() {\n        let set = vec_set::empty<u8>(); // create an empty set\n        let mut set = vec_set::singleton(1); // create a set with a single item\n\n        set.insert(2); // add an item to the set\n        set.insert(3);\n\n        assert!(set.contains(&1), 0); // check if an item is in the set\n        assert!(set.size() == 3, 1); // get the number of items in the set\n        assert!(!set.is_empty(), 2); // check if the set is empty\n\n        set.remove(&2); // remove an item from the set\n    }\n}\n\n\nVecSet will fail on attempt to insert a an item that already exists in the set.\n\nVecMap\n\nVecMap is a collection type that stores a map of key-value pairs. It is similar to a VecSet, but it allows you to associate a value with each item in the set. This makes it useful for storing a collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs and their associated data.\n\nKeys in a VecMap are unique, and each key can only be associated with a single value. If you try to insert a key-value pair with a key that already exists in the map, the old value will be replaced with the new value.\n\nmodule book::collections {\n    use std::string::String;\n    use sui::vec_map::{Self, VecMap};\n\n    public struct Metadata has drop {\n        name: String,\n        /// `VecMap` used in the struct definition\n        attributes: VecMap<String, String>\n    }\n\n    #[test]\n    fun vec_map_playground() {\n        let mut map = vec_map::empty(); // create an empty map\n\n        map.insert(2, b\"two\".to_string()); // add a key-value pair to the map\n        map.insert(3, b\"three\".to_string());\n\n        assert!(map.contains(&2), 0); // check if a key is in the map\n\n        map.remove(&2); // remove a key-value pair from the map\n    }\n}\n\nLimitations\n\nStandard collection types are a great way to store typed data with guaranteed safety and consistency. However, they are limited by the type of data they can store - the type system won't allow you to store a wrong type in a collection; and they're limited in size - by the object size limit. They will work for relatively small-sized sets and lists, but for larger collections you may need to use a different approach.\n\nAnother limitations on collection types is inability to compare them. Because the order of insertion is not guaranteed, an attempt to compare a VecSet to another VecSet may not yield the expected results.\n\nThis behavior is caught by the linter and will emit a warning: Comparing collections of type 'sui::vec_set::VecSet' may yield unexpected result\n\nlet mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert!(set1 == set2, 0);\n\n\nIn the example above, the comparison will fail because the order of insertion is not guaranteed, and the two VecSet instances may have different orders of elements. And the comparison will fail even if the two VecSet instances contain the same elements.\n\nSummary\nVector is a native type that allows storing a list of items.\nVecSet is built on top of vector and allows storing sets of unique items.\nVecMap is used to store key-value pairs in a map-like structure.\nVector-based collections are strictly typed and limited by the object size limit and are best suited for small-sized sets and lists.\nNext Steps\n\nIn the next section we will cover Dynamic Fields - an important primitive that allows for Dynamic Collections - a way to store large collections of data in a more flexible, yet more expensive way."
    },
    {
      "title": "Epoch and Time - The Move Book",
      "url": "https://move-book.com/programmability/epoch-and-time.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nEpoch and Time\n\nSui has two ways of accessing the current time: Epoch and Time. The former represents operational periods in the system and changed roughly every 24 hours. The latter represents the current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.\n\nEpoch\n\nEpochs are used to separate the system into operational periods. During an epoch the validator set is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial role in the consensus algorithm and are used to determine the current validator set. They are also used as measurement in the staking mechanism.\n\nEpoch can be read from the transaction context:\n\npublic fun current_epoch(ctx: &TxContext) {\n    let epoch = ctx.epoch();\n    // ...\n}\n\n\nIt is also possible to get the unix timestamp of the epoch start:\n\npublic fun current_epoch_start(ctx: &TxContext) {\n    let epoch_start = ctx.epoch_timestamp_ms();\n    // ...\n}\n\n\nNormally, epochs are used in staking and system operations, however, in custom scenarios they can be used to emulate 24h periods. They are critical if an application relies on the staking logic or needs to know the current validator set.\n\nTime\n\nFor a more precise time measurement, Sui provides the Clock object. It is a system object that is updated during checkpoints by the system, which stores the current time in milliseconds since the Unix Epoch. The Clock object is defined in the sui::clock module and has a reserved address 0x6.\n\nClock is a shared object, but it a transaction attempting to access it mutably will fail. This limitation allows parallel access to the Clock object, which is important for maintaining performance.\n\n// File: sui-framework/clock.move\n/// Singleton shared object that exposes time to Move calls.  This\n/// object is found at address 0x6, and can only be read (accessed\n/// via an immutable reference) by entry functions.\n///\n/// Entry Functions that attempt to accept `Clock` by mutable\n/// reference or value will fail to verify, and honest validators\n/// will not sign or execute transactions that use `Clock` as an\n/// input parameter, unless it is passed by immutable reference.\nstruct Clock has key {\n    id: UID,\n    /// The clock's timestamp, which is set automatically by a\n    /// system transaction every time consensus commits a\n    /// schedule, or by `sui::clock::increment_for_testing` during\n    /// testing.\n    timestamp_ms: u64,\n}\n\n\nThere is only one public function available in the Clock module - timestamp_ms. It returns the current time in milliseconds since the Unix Epoch.\n\nuse sui::clock::Clock;\n\n/// Clock needs to be passed as an immutable reference.\npublic fun current_time(clock: &Clock) {\n    let time = clock.timestamp_ms();\n    // ...\n}\n"
    },
    {
      "title": "Pattern: Capability - The Move Book",
      "url": "https://move-book.com/programmability/capability.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nPattern: Capability\n\nIn programming, a capability is a token that gives the owner the right to perform a specific action. It is a pattern that is used to control access to resources and operations. A simple example of a capability is a key to a door. If you have the key, you can open the door. If you don't have the key, you can't open the door. A more practical example is an Admin Capability which allows the owner to perform administrative operations, which regular users cannot.\n\nCapability is an Object\n\nIn the Sui Object Model, capabilities are represented as objects. An owner of an object can pass this object to a function to prove that they have the right to perform a specific action. Due to strict typing, the function taking a capability as an argument can only be called with the correct capability.\n\nThere's a convention to name capabilities with the Cap suffix, for example, AdminCap or KioskOwnerCap.\n\nmodule book::capability {\n    use std::string::String;\n    use sui::event;\n\n    /// The capability granting the application admin the right to create new\n    /// accounts in the system.\n    public struct AdminCap has key, store { id: UID }\n\n    /// The user account in the system.\n    public struct Account has key, store {\n        id: UID,\n        name: String\n    }\n\n    /// A simple `Ping` event with no data.\n    public struct Ping has copy, drop { by: ID }\n\n    /// Creates a new account in the system. Requires the `AdminCap` capability\n    /// to be passed as the first argument.\n    public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n        Account {\n            id: object::new(ctx),\n            name,\n        }\n    }\n\n    /// Account, and any other objects, can also be used as a Capability in the\n    /// application. For example, to emit an event.\n    public fun send_ping(acc: &Account) {\n        event::emit(Ping {\n            by: acc.id.to_inner()\n        })\n    }\n\n    /// Updates the account name. Can only be called by the `Account` owner.\n    public fun update(account: &mut Account, name: String) {\n        account.name = name;\n    }\n}\n\nUsing init for Admin Capability\n\nA very common practice is to create a single AdminCap object on package publish. This way, the application can have a setup phase where the admin account prepares the state of the application.\n\nmodule book::admin_cap {\n    /// The capability granting the admin privileges in the system.\n    /// Created only once in the `init` function.\n    public struct AdminCap has key { id: UID }\n\n    /// Create the AdminCap object on package publish and transfer it to the\n    /// package owner.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            AdminCap { id: object::new(ctx) },\n            ctx.sender()\n        )\n    }\n}\n\nAddress check vs Capability\n\nUtilizing objects as capabilities is a relatively new concept in blockchain programming. And in other smart-contract languages, authorization is often performed by checking the address of the sender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities for better security, discoverability, and code organization.\n\nLet's look at how the new function that creates a user would look like if it was using the address check:\n\n/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n\n\nAnd now, let's see how the same function would look like with the capability:\n\n/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n\n\nUsing capabilities has several advantages over the address check:\n\nMigration of admin rights is easier with capabilities due to them being objects. In case of address, if the admin address changes, all the functions that check the address need to be updated - hence, require a package upgrade.\nFunction signatures are more descriptive with capabilities. It is clear that the new function requires the AdminCap to be passed as an argument. And this function can't be called without it.\nObject Capabilities don't require extra checks in the function body, and hence, decrease the chance of a developer mistake.\nAn owned Capability also serves in discovery. The owner of the AdminCap can see the object in their account (via a Wallet or Explorer), and know that they have the admin rights. This is less transparent with the address check.\n\nHowever, the address approach has its own advantages. For example, if an address is multisig, and transaction building gets more complex, it might be easier to check the address. Also, if there's a central object of the application that is used in every function, it can store the admin address, and this would simplify migration. The central object approach is also valuable for revokable capabilities, where the admin can revoke the capability from the user."
    },
    {
      "title": "Module Initializer - The Move Book",
      "url": "https://move-book.com/programmability/module-initializer.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nModule Initializer\n\nA common use case in many applications is to run certain code just once when the package is published. Imagine a simple store module that needs to create the main Store object upon its publication. In Sui, this is achieved by defining an init function within the module. This function will automatically be called when the module is published.\n\nAll of the modules' init functions are called during the publishing process. Currently, this behavior is limited to the publish command and does not extend to package upgrades.\n\nmodule book::shop {\n    /// The Capability which grants the Shop owner the right to manage\n    /// the shop.\n    public struct ShopOwnerCap has key, store { id: UID }\n\n    /// The singular Shop itself, created in the `init` function.\n    public struct Shop has key {\n        id: UID,\n        /* ... */\n    }\n\n    // Called only once, upon module publication. It must be\n    // private to prevent external invocation.\n    fun init(ctx: &mut TxContext) {\n        // Transfers the ShopOwnerCap to the sender (publisher).\n        transfer::transfer(ShopOwnerCap {\n            id: object::new(ctx)\n        }, ctx.sender());\n\n        // Shares the Shop object.\n        transfer::share_object(Shop {\n            id: object::new(ctx)\n        });\n    }\n}\n\n\nIn the same package, another module can have its own init function, encapsulating distinct logic.\n\n// In the same package as the `shop` module\nmodule book::bank {\n\n    public struct Bank has key {\n        id: UID,\n        /* ... */\n    }\n\n    fun init(ctx: &mut TxContext) {\n        transfer::share_object(Bank {\n            id: object::new(ctx)\n        });\n    }\n}\n\ninit features\n\nThe function is called on publish, if it is present in the module and follows the rules:\n\nThe function has to be named init, be private and have no return values.\nTakes one or two arguments: One Time Witness (optional) and TxContext. With `TxContext always being the last argument.\nfun init(ctx: &mut TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }\n\n\nTxContext can also be passed as immutable reference: &TxContext. However, practically speaking, it should always be &mut TxContext since the init function can't access the onchain state and to create new objects it requires the mutable reference to the context.\n\nfun init(ctx: &TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &TxContext) { /* ... */ }\n\nTrust and security\n\nWhile init function can be used to create sensitive objects once, it is important to know that the same object (eg. StoreOwnerCap from the first example) can still be created in another function. Especially given that new functions can be added to the module during an upgrade. So the init function is a good place to set up the initial state of the module, but it is not a security measure on its own.\n\nThere are ways to guarantee that the object was created only once, such as the One Time Witness. And there are ways to limit or disable the upgrade of the module, which we will cover in the Package Upgrades chapter.\n\nNext steps\n\nAs follows from the definition, the init function is guaranteed to be called only once when the module is published. So it is a good place to put the code that initializes module's objects and sets up the environment and configuration.\n\nFor example, if there's a Capability which is required for certain actions, it should be created in the init function. In the next chapter we will talk about the Capability pattern in more detail."
    },
    {
      "title": "Advanced Programmability - The Move Book",
      "url": "https://move-book.com/programmability/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAdvanced Programmability\n\nIn previous chapters we've covered the basics of Move and Sui Storage Model. Now it's time to dive deeper into the advanced topics of Sui programmability.\n\nThis chapter introduces more complex concepts, practices and features of Move and Sui that are essential for building more sophisticated applications. It is intended for developers who are already familiar with the basics of Move and Sui, and are looking to expand their knowledge and skills."
    },
    {
      "title": "Transaction Context - The Move Book",
      "url": "https://move-book.com/programmability/transaction-context.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nTransaction Context\n\nEvery transaction has the execution context. The context is a set of predefined variables that are available to the program during execution. For example, every transaction has a sender address, and the transaction context contains a variable that holds the sender address.\n\nThe transaction context is available to the program through the TxContext struct. The struct is defined in the sui::tx_context module and contains the following fields:\n\n// File: sui-framework/sources/tx_context.move\n/// Information about the transaction currently being executed.\n/// This cannot be constructed by a transaction--it is a privileged object created by\n/// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.\nstruct TxContext has drop {\n    /// The address of the user that signed the current transaction\n    sender: address,\n    /// Hash of the current transaction\n    tx_hash: vector<u8>,\n    /// The current epoch number\n    epoch: u64,\n    /// Timestamp that the epoch started at\n    epoch_timestamp_ms: u64,\n    /// Counter recording the number of fresh id's created while executing\n    /// this transaction. Always 0 at the start of a transaction\n    ids_created: u64\n}\n\n\nTransaction context cannot be constructed manually or directly modified. It is created by the system and passed to the function as a reference in a transaction. Any function called in a Transaction has access to the context and can pass it into the nested calls.\n\nTxContext has to be the last argument in the function signature.\n\nReading the Transaction Context\n\nWith only exception of the ids_created, all of the fields in the TxContext have getters. The getters are defined in the sui::tx_context module and are available to the program. The getters don't require &mut because they don't modify the context.\n\npublic fun some_action(ctx: &TxContext) {\n    let me = ctx.sender();\n    let epoch = ctx.epoch();\n    let digest = ctx.digest();\n    // ...\n}\n\nMutability\n\nThe TxContext is required to create new objects (or just UIDs) in the system. New UIDs are derived from the transaction digest, and for the digest to be unique, there needs to be a changing parameter. Sui uses the ids_created field for that. Every time a new UID is created, the ids_created field is incremented by one. This way, the digest is always unique.\n\nInternally, it is represented as the derive_id function:\n\n// File: sui-framework/sources/tx_context.move\nnative fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;\n\nGenerating unique addresses\n\nThe underlying derive_id function can also be utilized in your program to generate unique addresses. The function itself is not exposed, but a wrapper function fresh_object_address is available in the sui::tx_context module. It may be useful if you need to generate a unique identifier in your program.\n\n// File: sui-framework/sources/tx_context.move\n/// Create an `address` that has not been used. As it is an object address, it will never\n/// occur as the address for a user.\n/// In other words, the generated address is a globally unique object ID.\npublic fun fresh_object_address(ctx: &mut TxContext): address {\n    let ids_created = ctx.ids_created;\n    let id = derive_id(*&ctx.tx_hash, ids_created);\n    ctx.ids_created = ids_created + 1;\n    id\n}\n"
    },
    {
      "title": "Restricted and Public Transfer - The Move Book",
      "url": "https://move-book.com/storage/transfer-restrictions.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nRestricted and Public Transfer\n\nStorage Operations that we described in the previous sections are restricted by default - they can only be called in the module defining the object. In other terms, the type must be internal to the module to be used in storage operations. This restriction is implemented in the Sui Verifier and is enforced at the bytecode level.\n\nHowever, to allow objects to be transferred and stored in other modules, these restrictions can be relaxed. The sui::transfer module offers a set of public_* functions that allow calling storage operations in other modules. The functions are prefixed with public_ and are available to all modules and transactions.\n\nPublic Storage Operations\n\nThe sui::transfer module provides the following public functions. They are almost identical to the ones we already covered, but can be called from any module.\n\n// File: sui-framework/sources/transfer.move\n/// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(object: T, to: address) {}\n\n/// Public version of the `share_object` function.\npublic fun public_share_object<T: key + store>(object: T) {}\n\n/// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(object: T) {}\n\n\nTo illustrate the usage of these functions, consider the following example: module A defines an ObjectK with key and ObjectKS with key + store abilities, and module B tries to implement a transfer function for these objects.\n\nIn this example we use transfer::transfer, but the behaviour is identical for share_object and freeze_object functions.\n\n/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`\n/// abilities respectively\nmodule book::transfer_a {\n    public struct ObjectX has key { id: UID }\n    public struct ObjectKS has key, store { id: UID }\n}\n\n/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts\n/// to implement different `transfer` functions for them\nmodule book::transfer_b {\n    // types are not internal to this module\n    use book::transfer_a::{ObjectK, ObjectKS};\n\n    // Fails! ObjectX is not `store`, and ObjectX is not internal to this module\n    public fun transfer_k(k: ObjectK, to: address) {\n        sui::transfer::transfer(k, to);\n    }\n\n    // Fails! ObjectKS has `store` but the function is not public\n    public fun transfer_ks(ks: ObjectKS, to: address) {\n        sui::transfer::transfer(ks, to);\n    }\n\n    // Fails! ObjectK is not `store`, `public_transfer` requires `store`\n    public fun public_transfer_k(k: ObjectK) {\n        sui::transfer::public_transfer(k);\n    }\n\n    // Works! ObjectKS has `store` and the function is public\n    public fun public_transfer_ks(y: ObjectKS, to: address) {\n        sui::transfer::public_transfer(y, to);\n    }\n}\n\n\nTo expand on the example above:\n\n transfer_x fails because ObjectK is not internal to module transfer_b\n transfer_y fails because ObjectKS is not internal to module transfer_b\n public_transfer_x fails because ObjectK does not have the store ability\n public_transfer_y works because ObjectKS has the store ability and the transfer is public\nImplications of store\n\nThe decision on whether to add the store ability to a type should be made carefully. On one hand, it is de-facto a requirement for the type to be usable by other applications. On the other hand, it allows wrapping and changing the intended storage model. For example, a character may be intended to be owned by accounts, but with the store ability it can be frozen (cannot be shared - this transition is restricted)."
    },
    {
      "title": "UID and ID - The Move Book",
      "url": "https://move-book.com/storage/uid-and-id.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nUID and ID\n\nThe UID type is defined in the sui::object module and is a wrapper around an ID which, in turn, wraps the address type. The UIDs on Sui are guaranteed to be unique, and can't be reused after the object was deleted.\n\n// File: sui-framework/sources/object.move\n/// UID is a unique identifier of an object\npublic struct UID has store {\n    id: ID\n}\n\n/// ID is a wrapper around an address\npublic struct ID has store, drop {\n    bytes: address\n}\n\nFresh UID generation:\nUID is derived from the tx_hash and an index which is incremented for each new UID.\nThe derive_id function is implemented in the sui::tx_context module, and that is why TxContext is required for UID generation.\nSui Verifier will not allow using a UID that wasn't created in the same function. That prevents UIDs from being pre-generated and reused after the object was unpacked.\n\nNew UID is created with the object::new(ctx) function. It takes a mutable reference to TxContext, and returns a new UID.\n\nlet ctx = &mut tx_context::dummy();\nlet uid = object::new(ctx);\n\n\nOn Sui, UID acts as a representation of an object, and allows defining behaviors and features of an object. One of the key-features - Dynamic Fields - is possible because of the UID type being explicit. Additionally, it allows the Transfer To Object (TTO) which we will explain later in this chapter.\n\nUID lifecycle\n\nThe UID type is created with the object::new(ctx) function, and it is destroyed with the object::delete(uid) function. The object::delete consumes the UID by value, and it is impossible to delete it unless the value was unpacked from an Object.\n\nlet ctx = &mut tx_context::dummy();\n\nlet char = Character {\n    id: object::new(ctx)\n};\n\nlet Character { id } = char;\nid.delete();\n\nKeeping the UID\n\nThe UID does not need to be deleted immediately after the object struct is unpacked. Sometimes it may carry Dynamic Fields or objects transferred to it via Transfer To Object. In such cases, the UID may be kept and stored in a separate object.\n\nProof of Deletion\n\nThe ability to return the UID of an object may be utilized in pattern called proof of deletion. It is a rarely used technique, but it may be useful in some cases, for example, the creator or an application may incentivize the deletion of an object by exchanging the deleted IDs for some reward.\n\nIn framework development this method could be used ignore / bypass certain restrictions on \"taking\" the object. If there's a container that enforces certain logic on transfers, like Kiosk does, there could be a special scenario of skipping the checks by providing a proof of deletion.\n\nThis is one of the open topics for exploration and research, and it may be used in various ways.\n\nID\n\nWhen talking about UIDs we should also mention the ID type. It is a wrapper around the address type, and is used to represent an address-pointer. Usually, ID is used to point at an object, however, there's no restriction, and no guarantee that the ID points to an existing object.\n\nID can be received as a transaction argument in a Transaction Block. Alternatively, ID can be created from an address value using to_id() function.\n\nfresh_object_address\n\nTxContext provides the fresh_object_address function which can be utilized to create unique addresses and IDs - it may be useful in some application that assign unique identifiers to user actions - for example, an order_id in a marketplace."
    },
    {
      "title": "Ability: Store - The Move Book",
      "url": "https://move-book.com/storage/store-ability.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAbility: Store\n\nNow that you have an understanding of top-level storage functions which are enabled by the key ability, we can talk about the last ability in the list - store.\n\nDefinition\n\nThe store is a special ability that allows a type to be stored in objects. This ability is required for the type to be used as a field in a struct that has the key ability. Another way to put it is that the store ability allows the value to be wrapped in an object.\n\nThe store ability also relaxes restrictions on transfer operations. We talk about it more in the Restricted and Public Transfer section.\n\nExample\n\nIn previous sections we already used types with the store ability: all objects must have a UID field, which we used in examples; we also used the String type as a part of the Config struct. The String type also has the store ability.\n\n/// This type has the `store` ability.\npublic struct Storable has store {}\n\n/// Config contains a `Storable` field which must have the `store` ability.\npublic struct Config has key, store {\n    id: UID,\n    stores: Storable,\n}\n\n/// MegaConfig contains a `Config` field which has the `store` ability.\npublic struct MegaConfig has key {\n    id: UID,\n    config: Config, // there it is!\n}\n\nTypes with the store Ability\n\nAll native types (except for references) in Move have the store ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the store ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference."
    },
    {
      "title": "Storage Functions - The Move Book",
      "url": "https://move-book.com/storage/storage-functions.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nStorage Functions\n\nThe module that defines main storage operations is sui::transfer. It is implicitly imported in all packages that depend on the Sui Framework, so, like other implicitly imported modules (e.g. std::option or std::vector), it does not require adding a use statement.\n\nOverview\n\nThe transfer module provides functions to perform all three storage operations matching ownership types which we explained before:\n\nOn this page we will only talk about so-called restricted storage operations, later we will cover public ones, after the store ability is introduced.\n\nTransfer - send an object to an address, put it into account owned state;\nShare - put an object into a shared state, so it is available to everyone;\nFreeze - put an object into immutable state, so it becomes a public constant and can never change.\n\nThe transfer module is a go-to for most of the storage operations, except a special case with Dynamic Fields awaits us in the next chapter.\n\nOwnership and References: A Quick Recap\n\nIn the Ownership and Scope and References chapters, we covered the basics of ownership and references in Move. It is important that you understand these concepts when using storage functions. Here is a quick recap of the most important points:\n\nThe move semantics in Move means that the value is moved from one scope to another. In other words, if an instance of a type is passed to a function by value, it is moved to the function scope and can't be accessed in the caller scope anymore.\nTo maintain the ownership of the value, you can pass it by reference. Either by immutable reference &T or mutable reference &mut T. Then the value is borrowed and can be accessed in the caller scope, however the owner stays the same.\n/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n\nTransfer\n\nThe transfer::transfer function is a public function used to transfer an object to another address. Its signature is as follows, only accepts a type with the key ability and an address of the recipient. Please, note that the object is passed into the function by value, therefore it is moved to the function scope and then moved to the recipient address:\n\n// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n\n\nIn the next example, you can see how it can be used in a module that defines and sends an object to the transaction sender.\n\nmodule book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// Init function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n\n\nWhen the module is published, the init function will get called, and the AdminCap object which we created there will be transferred to the transaction sender. The ctx.sender() function returns the sender address for the current transaction.\n\nOnce the AdminCap has been transferred to the sender, for example, to 0xa11ce, the sender, and only the sender, will be able to access the object. The object is now account owned.\n\nAccount owned objects are a subject to true ownership - only the account owner can access them. This is a fundamental concept in the Sui storage model.\n\nLet's extend the example with a function that uses AdminCap to authorize a mint of a new object and its transfer to another address:\n\n/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = object::new(ctx);\n    transfer::transfer(gift, recipient);\n}\n\n\nThe mint_and_transfer function is a public function that \"could\" be called by anyone, but it requires an AdminCap object to be passed as the first argument by reference. Without it, the function will not be callable. This is a simple way to restrict access to privileged functions called Capability. Because the AdminCap object is account owned, only 0xa11ce will be able to call the mint_and_transfer function.\n\nThe Gifts sent to recipients will also be account owned, each gift being unique and owned exclusively by the recipient.\n\nA quick recap:\n\ntransfer function is used to send an object to an address;\nThe object becomes account owned and can only be accessed by the recipient;\nFunctions can be gated by requiring an object to be passed as an argument, creating a capability.\nFreeze\n\nThe transfer::freeze function is public function used to put an object into an immutable state. Once an object is frozen, it can never be changed, and it can be accessed by anyone by immutable reference.\n\nThe function signature is as follows, only accepts a type with the key ability. Just like all other storage functions, it takes the object by value:\n\n// File: sui-framework/sources/transfer.move\npublic fun freeze_object<T: key>(obj: T);\n\n\nLet's expand on the previous example and add a function that allows the admin to create a Config object and freeze it:\n\n/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n\n\nConfig is an object that has a message field, and the create_and_freeze function creates a new Config and freezes it. Once the object is frozen, it can be accessed by anyone by immutable reference. The message function is a public function that returns the message from the Config object. Config is now publicly available by its ID, and the message can be read by anyone.\n\nFunction definitions are not connected to the object's state. It is possible to define a function that takes a mutable reference to an object that is used as frozen. However, it won't be callable on a frozen object.\n\nThe message function can be called on an immutable Config object, however, two functions below are not callable on a frozen object:\n\n// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n\n\nTo summarize:\n\nfreeze_object function is used to put an object into an immutable state;\nOnce an object is frozen, it can never be changed, deleted or transferred, and it can be accessed by anyone by immutable reference;\nOwned -> Frozen\n\nSince the transfer::freeze signature accepts any type with the key ability, it can take an object that was created in the same scope, but it can also take an object that was owned by an account. This means that the freeze_object function can be used to freeze an object that was transferred to the sender. For security concerns, we would not want to freeze the AdminCap object - it would be a security risk to allow access to it to anyone. However, we can freeze the Gift object that was minted and transferred to the recipient:\n\nSingle Owner -> Immutable conversion is possible!\n\n/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n\nShare\n\nThe transfer::share function is a public function used to put an object into a shared state. Once an object is shared, it can be accessed by anyone by a mutable reference (hence, immutable too). The function signature is as follows, only accepts a type with the key ability:\n\n// File: sui-framework/sources/transfer.move\npublic fun share_object<T: key>(obj: T);\n\n\nOnce an object is shared, it is publicly available as a mutable reference.\n\nSpecial Case: Shared Object Deletion\n\nWhile the shared object can't normally be taken by value, there is one special case where it can - if the function that takes it deletes the object. This is a special case in the Sui storage model, and it is used to allow the deletion of shared objects. To show how it works, we will create a function that creates and shares a Config object and then another one that deletes it:\n\n/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n\n\nThe create_and_share function creates a new Config object and shares it. The object is now publicly available as a mutable reference. Let's create a function that deletes the shared object:\n\n/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n\n\nThe delete_config function takes the Config object by value and deletes it, and Sui Verifier would allow this call. However, if the function returned the Config object back or attempted to freeze or transfer it, the Sui Verifier would reject the transaction.\n\n// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n\n\nTo summarize:\n\nshare_object function is used to put an object into a shared state;\nOnce an object is shared, it can be accessed by anyone by a mutable reference;\nShared objects can be deleted, but they can't be transferred or frozen.\nNext Steps\n\nNow that you know main features of the transfer module, you can start building more complex applications on Sui that involve storage operations. In the next chapter, we will cover the Store Ability which allows storing data inside objects and relaxes transfer restrictions which we barely touched on here. And after that we will cover the UID and ID types which are the most important types in the Sui storage model."
    },
    {
      "title": "Ability: Key - The Move Book",
      "url": "https://move-book.com/storage/key-ability.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nThe Key Ability\n\nIn the Basic Syntax chapter we already covered two out of four abilities - Drop and Copy. They affect the behaviour of the value in a scope and are not directly related to storage. It is time to cover the key ability, which allows the struct to be stored.\n\nHistorically, the key ability was created to mark the type as a key in the storage. A type with the key ability could be stored at top-level in the storage, and could be directly owned by an account or address. With the introduction of the Object Model, the key ability naturally became the defining ability for the object.\n\nObject Definition\n\nA struct with the key ability is considered an object and can be used in the storage functions. The Sui Verifier will require the first field of the struct to be named id and have the type UID.\n\npublic struct Object has key {\n    id: UID, // required\n    name: String,\n}\n\n/// Creates a new Object with a Unique ID\npublic fun new(name: String, ctx: &mut TxContext): Object {\n    Object {\n        id: object::new(ctx), // creates a new UID\n        name,\n    }\n}\n\n\nA struct with the key ability is still a struct, and can have any number of fields and associated functions. There is no special handling or syntax for packing, accessing or unpacking the struct.\n\nHowever, because the first field of an object struct must be of type UID - a non-copyable and non-droppable type (we will get to it very soon!), the struct transitively cannot have drop and copy abilities. Thus, the object is non-discardable by design.\n\nTypes with the key Ability\n\nDue to the UID requirement for types with key, none of the native types in Move can have the key ability, nor can any of the Standard Library types. The key ability is only present in the Sui Framework and custom types.\n\nNext Steps\n\nKey ability defines the object in Move, and objects are intended to be stored. In the next section we present the sui::transfer module, which provides native storage functions for objects.\n\nFurther reading\nType Abilities in the Move Reference."
    },
    {
      "title": "Using Objects - The Move Book",
      "url": "https://move-book.com/storage/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nUsing Objects\n\nIn the Object Model chapter we briefly explained the evolution of the Move language from an account-based model to an object-based model. In this chapter, we will dive deeper into the object model and explore how to use objects in your Sui applications. If you haven't read the Object Model chapter yet, we recommend you do so before continuing with this chapter."
    },
    {
      "title": "Fast Path & Consensus - The Move Book",
      "url": "https://move-book.com/object/fast-path-and-consensus.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nFast Path & Consensus\n\nThe Object Model allows for variable transaction execution paths, depending on the object's ownership type. The transaction execution path determines how the transaction is processed and validated by the network. In this section, we'll explore the different transaction execution paths in Sui and how they interact with the consensus mechanism.\n\nConcurrency Challenge\n\nAt its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may try to modify or access the same data simultaneously in a decentralized environment. This requires a system for sequencing and validating transactions to support the network's consistency. Sui addresses this challenge through a consensus mechanism, ensuring all nodes agree on the transactions' sequence and state.\n\nConsider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same asset. The network must resolve this conflict to prevent double-spending, ensuring that at most one transaction succeeds while the other is rightfully rejected.\n\nFast Path\n\nHowever, not all transactions require the same level of validation and consensus. For example, if Alice wants to transfer an object that she owns to Bob, the network can process this transaction without sequencing it with respect to all other transactions in the network, as only Alice has the authority to access the object. This is known as the fast path execution, where transactions accessing account-owned objects are processed quickly without the need for extensive consensus. No concurrent data access -> simpler challenge -> fast path.\n\nAnother ownership model that allows for fast path execution is the immutable state. Since immutable objects cannot change, transactions involving them can be processed quickly without the need to sequence them.\n\nConsensus Path\n\nTransactions that do access shared state - on Sui it is represented with shared objects - require sequencing to ensure that the state is updated and consistented across all nodes. This is known as the execution through consensus, where transactions accessing shared objects are subject to the agreement process to maintain network consistency.\n\nObjects owned by Objects\n\nLastly, it is important to mention that objects owned by other objects are subject to the same rules as the parent object. If the parent object is shared, the child object is also transitively shared. If the parent object is immutable, the child object is also immutable.\n\nSummary\nFast Path: Transactions involving account-owned objects or immutable shared state are processed quickly without the need for extensive consensus.\nConsensus Path: Transactions involving shared objects require sequencing and consensus to ensure network integrity.\nObjects owned by Objects: Child objects inherit the ownership model of the parent object."
    },
    {
      "title": "Ownership - The Move Book",
      "url": "https://move-book.com/object/ownership.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nOwnership\n\nSui introduces four distinct ownership types for objects: single owner, shared state, immutable shared state, and object-owner. Each model offers unique characteristics and suits different use cases, enhancing flexibility and control in object management.\n\nAccount Owner (or Single Owner)\n\nThe account owner, also known as the single owner model, is the foundational ownership type in Sui. Here, an object is owned by a single account, granting that account exclusive control over the object within the behaviors associated with its type. This model embodies the concept of true ownership, where the account possesses complete authority over the object, making it inaccessible to others for modification or transfer. This level of ownership clarity is a significant advantage over other blockchain systems, where ownership definitions can be more ambiguous, and smart contracts may have the ability to alter or transfer assets without the owner's consent.\n\nShared State\n\nSingle owner model has its limitations: for example, it is very tricky to implement a marketplace for digital assets without a shared state. For a generic marketplace scenario, imagine that Alice owns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come and buy the asset directly from the marketplace. The reason why this is tricky is that it is impossible to write a smart contract that would \"lock\" the asset in Alice's account and take it out when Bob buys it. First, it will be a violation of the single owner model, and second, it requires a shared access to the asset.\n\nTo facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this model, an object can be shared with the network. Shared objects can be read and modified by any account on the network, and the rules of interaction are defined by the implementation of the object. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other scenarios where multiple accounts need access to the same state.\n\nImmutable (Frozen) State\n\nSui also offers the frozen object model, where an object becomes permanently read-only. These immutable objects, while readable, cannot be modified or moved, providing a stable and constant state accessible to all network participants. Frozen objects are ideal for public data, reference materials, and other use cases where the state permanence is desirable.\n\nObject Owner\n\nThe last ownership model in Sui is the object owner. In this model, an object is owned by another object. This feature allows creating complex relationships between objects, store large heterogenious collections, and implementing extensible and modular systems. Practically speaking, since the transactions are initiated by accounts, the transaction still accesses the parent object, but it can then access the child objects through the parent object.\n\nA use case we love to mention is a game character. Alice can own the Hero object from a game, and the Hero can own items: also represented as objects, like a \"Map\", or a \"Compass\". Alice may take the \"Map\" from the \"Hero\" object, and then send it to Bob, or sell it on a marketplace. With object owner, it becomes very natural to imagine how the assets can be structured and managed in relation to each other.\n\nSummary\nSingle Owner: Objects are owned by a single account, granting exclusive control over the object.\nShared State: Objects can be shared with the network, allowing multiple accounts to read and modify the object.\nImmutable State: Objects become permanently read-only, providing a stable and constant state.\nObject Owner: Objects can own other objects, enabling complex relationships and modular systems.\nNext Steps\n\nIn the next section we will talk about transaction execution paths in Sui, and how the ownership models affect the transaction execution."
    },
    {
      "title": "What is an Object? - The Move Book",
      "url": "https://move-book.com/object/object-model.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nWhat is an Object?\n\nThe Object Model in Sui can be viewed as a high-level abstraction representing digital assets as objects. These objects have their own type and associated behaviors, a unique identifier, and support native storage operations like transfer and share. Designed to be intuitive and easy to use, the Object Model enables a wide range of use cases to be implemented with ease.\n\nObjects in Sui have the following properties:\n\nType: Every object has a type, defining the structure and behavior of the object. Objects of different types cannot be mixed or used interchangeably, ensuring objects are used correctly according to their type system.\n\nUnique ID: Each object has a unique identifier, distinguishing it from other objects. This ID is generated upon the object's creation and is immutable. It's used to track and identify objects within the system.\n\nOwner: Every object is associated with an owner, who has control over the object. Ownership on Sui can be exclusive to an account, shared across the network, or frozen, allowing read-only access without modification or transfer capabilities. We will discuss ownership in more detail in the following sections.\n\nData: Objects encapsulate their data, simplifying management and manipulation. The data structure and operations are defined by the object's type.\n\nVersion: The transition from accounts to objects is facilitated by object versioning. Traditionally, blockchains use a nonce to prevent replay attacks. In Sui, the object's version acts as a nonce, preventing replay attacks for each object.\n\nDigest: Every object has a digest, which is a hash of the object's data. The digest is used to cryptographically verify the integrity of the object's data and ensures that it has not been tampered with. The digest is calculated when the object is created and is updated whenever the object's data changes.\n\nSummary\nObjects in Sui are high-level abstractions representing digital assets.\nObjects have a type, unique ID, owner, data, version, and digest.\nThe Object Model simplifies asset management and enables a wide range of use cases.\nFurther reading\nObject Model in Sui Documentation."
    },
    {
      "title": "Evolution of Move - The Move Book",
      "url": "https://move-book.com/object/evolution-of-move.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nEvolution of Move\n\nWhile Move was created to manage digital assets, its initial storage model was bulky and not well-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had to create a new \"empty\" resource, and then Alice could transfer asset X to Bob. This process was not intuitive and presented implementation challenges, partly due to the restrictive design of Diem. Another drawback of the original design was the lack of built-in support for a \"transfer\" operation, requiring every module to implement its own storage transfer logic. Additionally, managing heterogeneous collections of assets in a single account was particularly challenging.\n\nSui addressed these challenges by redesigning the storage and ownership model of objects to more closely resemble real-world object interactions. With a native concept of ownership and transfer, Alice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different assets without any preparatory steps. These improvements laid the foundation for the Object Model in Sui.\n\nSummary\nMove's initial storage model was not well-suited for managing digital assets, requiring complex and restrictive transfer operations.\nSui introduced the Object Model, which provides a native concept of ownership, simplifying asset management and enabling heterogeneous collections.\nFurther reading\nWhy We Created Sui Move by Sam Blackshear"
    },
    {
      "title": "Language for Digital Assets - The Move Book",
      "url": "https://move-book.com/object/digital-assets.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nMove - Language for Digital Assets\n\nSmart-contract programming languages have historically focused on defining and managing digital assets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with digital currency tokens, establishing a blueprint for creating and managing digital currencies on the blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant evolution, popularising the concept of non-fungible tokens (NFTs), which represent unique, indivisible assets. These standards laid the groundwork for the complex digital assets we see today.\n\nHowever, Ethereum's programming model lacked a native representation of assets. In other words, externally, a Smart Contract behaved like an asset, but the language itself did not have a way to inherently represent assets. From the start, Move aimed to provide a first-class abstraction for assets, opening up new avenues for thinking about and programming assets.\n\nIt is important to highlight which properties are essential for an asset:\n\nOwnership: Every asset is associated with an owner(s), mirroring the straightforward concept of ownership in the physical world—just as you own a car, you can own a digital asset. Move enforces ownership in such a way that once an asset is moved, the previous owner completely loses any control over it. This mechanism ensures a clear and secure change of ownership.\n\nNon-copyable: In the real world, unique items cannot be duplicated effortlessly. Move applies this principle to digital assets, ensuring they cannot be arbitrarily copied within the program. This property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring the intrinsic value of physical assets.\n\nNon-discardable: Just as you cannot accidentally lose a house or a car without a trace, Move ensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly transferred or destroyed. This property guarantees the deliberate handling of digital assets, preventing accidental loss and ensuring accountability in asset management.\n\nMove managed to encapsulate these properties in its design, becoming an ideal language for digital assets.\n\nSummary\nMove was designed to provide a first-class abstraction for digital assets, enabling developers to create and manage assets natively.\nEssential properties of digital assets include ownership, non-copyability, and non-discardability, which Move enforces in its design.\nMove's asset model mirrors real-world asset management, ensuring secure and accountable asset ownership and transfer.\nFurther reading\nMove: A Language With Programmable Resources (pdf) by Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou*"
    },
    {
      "title": "Object Model - The Move Book",
      "url": "https://move-book.com/object/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nObject Model\n\nThis chapter describes the Object Model of Sui. It focuses on the theory and concepts behind the Object Model, preparing you for a practical dive into Sui Storage operations and resource ownership. For convenience and easier lookup, we split the chapter into several sections, each covering a specific aspect of the Object Model.\n\nIn no way should this chapter be considered a comprehensive guide to the Object Model. It is only a high-level overview of the concepts and principles behind the Object Model.\n\nFor a more detailed description, refer to the Sui Documentation."
    },
    {
      "title": "Testing - The Move Book",
      "url": "https://move-book.com/move-basics/testing.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nTesting\n\nA crucial part of any software development, and even more - blockchain development, is testing. Here, we will cover the basics of testing in Move and how to write and organize tests for your Move code.\n\nThe #[test] attribute\n\nTests in Move are functions marked with the #[test] attribute. This attribute tells the compiler that the function is a test function, and it should be run when the tests are executed. Test functions are regular functions, but they must take no any arguments and have no return value. They are excluded from the bytecode, and are never published.\n\nmodule book::testing {\n    // Test attribute is placed before the `fun` keyword. Can be both above or\n    // right before the `fun` keyword: `#[test] fun my_test() { ... }`\n    // The name of the test would be `book::testing::simple_test`.\n    #[test]\n    fun simple_test() {\n        let sum = 2 + 2;\n        assert!(sum == 4, 1);\n    }\n\n    // The name of the test would be `book::testing::more_advanced_test`.\n    #[test] fun more_advanced_test() {\n        let sum = 2 + 2 + 2;\n        assert!(sum == 4, 1);\n    }\n}\n\nRunning Tests\n\nTo run tests, you can use the sui move test command. This command will first build the package in the test mode and then run all the tests found in the package. During test mode, modules from both sources/ and tests/ directories are processed, and the tests are executed.\n\n$ sui move test\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n\nTest Fail Cases with #[expected_failure]\n\nTests for fail cases can be marked with #[expected_failure]. This attribute placed on a #[test] function tells the compiler that the test is expected to fail. This is useful when you want to test that a function fails when a certain condition is met.\n\nThis attribute can only be placed on a #[test] function.\n\nThe attribute can take an argument for abort code, which is the expected abort code when the test fails. If the test fails with a different abort code, the test will fail. If the execution did not abort, the test will also fail.\n\nmodule book::testing_failure {\n\n    const EInvalidArgument: u64 = 0;\n\n    #[test]\n    #[expected_failure(abort_code = 0)]\n    fun test_fail() {\n        abort 0 // aborts with 0\n    }\n\n    // attributes can be grouped together\n    #[test, expected_failure(abort_code = EInvalidArgument)]\n    fun test_fail_1() {\n        abort 1 // aborts with 0\n    }\n}\n\n\nThe abort_code argument can use constants defined in the tests module as well as imported from other modules. This is the only case where constants can be used and \"accessed\" in other modules.\n\nUtilities with #[test_only]\n\nIn some cases, it is helpful to give the test environment access to some of the internal functions or features. It simplifies the testing process and allows for more thorough testing. However, it is important to remember that these functions should not be included in the final package. This is where the #[test_only] attribute comes in handy.\n\nmodule book::testing {\n    // Public function which uses the `secret` function.\n    public fun multiply_by_secret(x: u64): u64 {\n        x * secret()\n    }\n\n    /// Private function which is not available to the public.\n    fun secret(): u64 { 100 }\n\n    #[test_only]\n    /// This function is only available for testing purposes in tests and other\n    /// test-only functions. Mind the visibility - for `#[test_only]` it is\n    /// common to use `public` visibility.\n    public fun secret_for_testing(): u64 {\n        secret()\n    }\n\n    #[test]\n    // In the test environment we have access to the `secret_for_testing` function.\n    fun test_multiply_by_secret() {\n        let expected = secret_for_testing() * 2;\n        assert!(multiply_by_secret(2) == expected, 1);\n    }\n}\n\n\nFunctions marked with the #[test_only] will be available to the test environment, and to the other modules if their visibility is set so.\n\nFurther Reading\nUnit Testing in the Move Reference."
    },
    {
      "title": "Type Reflection - The Move Book",
      "url": "https://move-book.com/move-basics/type-reflection.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nType Reflection\n\nIn programming languages reflection is the ability of a program to examine and modify its own structure and behavior. In Move, there's a limited form of reflection that allows you to inspect the type of a value at runtime. This is useful when you need to store type information in a homogeneous collection, or when you need to check if a type belongs to a package.\n\nType reflection is implemented in the Standard Library module std::type_name. Expressed very roughly, it gives a single function get<T>() which returns the name of the type T.\n\nIn practice\n\nThe module is pretty straightforward, and operations allowed on the result are limited to getting a string representation and extracting the module and address of the type.\n\nmodule book::type_reflection {\n    use std::ascii::String;\n    use std::type_name::{Self, TypeName};\n\n    /// A function that returns the name of the type `T` and its module and address.\n    public fun do_i_know_you<T>(): (String, String, String) {\n        let type_name: TypeName = type_name::get<T>();\n\n        // there's a way to borrow\n        let str: &String = type_name.borrow_string();\n\n        let module_name: String = type_name.get_module();\n        let address_str: String = type_name.get_address();\n\n        // and a way to consume the value\n        let str = type_name.into_string();\n\n        (str, module_name, address_str)\n    }\n\n    #[test_only]\n    public struct MyType {}\n\n    #[test]\n    fun test_type_reflection() {\n        let (type_name, module_name, _address_str) = do_i_know_you<MyType>();\n\n        //\n        assert!(module_name == b\"type_reflection\".to_ascii_string(), 1);\n    }\n}\n\nFurther reading\n\nType reflection is an important part of the language, and it is a crucial part of some of the more advanced patterns."
    },
    {
      "title": "Generics - The Move Book",
      "url": "https://move-book.com/move-basics/generics.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nGenerics\n\nGenerics are a way to define a type or function that can work with any type. This is useful when you want to write a function which can be used with different types, or when you want to define a type that can hold any other type. Generics are the foundation of many advanced features in Move, such as collections, abstract implementations, and more.\n\nIn the Standard Library\n\nIn this chapter we already mentioned the vector type, which is a generic type that can hold any other type. Another example of a generic type in the standard library is the Option type, which is used to represent a value that may or may not be present.\n\nGeneric Syntax\n\nTo define a generic type or function, a type signature needs to have a list of generic parameters enclosed in angle brackets (< and >). The generic parameters are separated by commas.\n\n/// Container for any type `T`.\npublic struct Container<T> has drop {\n    value: T,\n}\n\n/// Function that creates a new `Container` with a generic value `T`.\npublic fun new<T>(value: T): Container<T> {\n    Container { value }\n}\n\n\nIn the example above, Container is a generic type with a single type parameter T, the value field of the container stores the T. The new function is a generic function with a single type parameter T, and it returns a Container with the given value. Generic types must be initialed with a concrete type, and generic functions must be called with a concrete type.\n\n#[test]\nfun test_container() {\n    // these three lines are equivalent\n    let container: Container<u8> = new(10); // type inference\n    let container = new<u8>(10); // create a new `Container` with a `u8` value\n    let container = new(10u8);\n\n    assert!(container.value == 10, 0x0);\n\n    // Value can be ignored only if it has the `drop` ability.\n    let Container { value: _ } = container;\n}\n\n\nIn the test function test_generic we demonstrate three equivalent ways to create a new Container with a u8 value. Because numeric types need to be inferred, we specify the type of the number literal.\n\nMultiple Type Parameters\n\nYou can define a type or function with multiple type parameters. The type parameters are then separated by commas.\n\n/// A pair of values of any type `T` and `U`.\npublic struct Pair<T, U> {\n    first: T,\n    second: U,\n}\n\n/// Function that creates a new `Pair` with two generic values `T` and `U`.\npublic fun new_pair<T, U>(first: T, second: U): Pair<T, U> {\n    Pair { first, second }\n}\n\n\nIn the example above, Pair is a generic type with two type parameters T and U, and the new_pair function is a generic function with two type parameters T and U. The function returns a Pair with the given values. The order of the type parameters is important, and it should match the order of the type parameters in the type signature.\n\n#[test]\nfun test_generic() {\n    // these three lines are equivalent\n    let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference\n    let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values\n    let pair_3 = new_pair(10u8, true);\n\n    assert!(pair_1.first == 10, 0x0);\n    assert!(pair_1.second, 0x0);\n\n    // Unpacking is identical.\n    let Pair { first: _, second: _ } = pair_1;\n    let Pair { first: _, second: _ } = pair_2;\n    let Pair { first: _, second: _ } = pair_3;\n\n}\n\n\nIf we added another instance where we swapped type parameters in the new_pair function, and tried to compare two types, we'd see that the type signatures are different, and cannot be compared.\n\n#[test]\nfun test_swap_type_params() {\n    let pair1: Pair<u8, bool> = new_pair(10u8, true);\n    let pair2: Pair<bool, u8> = new_pair(true, 10u8);\n\n    // this line will not compile\n    // assert!(pair1 == pair2, 0x0);\n\n    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool\n    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8\n\n    assert!(pf1 == ps2, 0x0); // 10 == 10\n    assert!(ps1 == pf2, 0x0); // true == true\n}\n\n\nTypes for variables pair1 and pair2 are different, and the comparison will not compile.\n\nWhy Generics?\n\nIn the examples above we focused on instantiating generic types and calling generic functions to create instances of these types. However, the real power of generics is the ability to define shared behavior for the base, generic type, and then use it independently of the concrete types. This is especially useful when working with collections, abstract implementations, and other advanced features in Move.\n\n/// A user record with name, age, and some generic metadata\npublic struct User<T> {\n    name: String,\n    age: u8,\n    /// Varies depending on application.\n    metadata: T,\n}\n\n\nIn the example above, User is a generic type with a single type parameter T, with shared fields name and age, and the generic metadata field which can store any type. No matter what the metadata is, all of the instances of User will have the same fields and methods.\n\n/// Updates the name of the user.\npublic fun update_name<T>(user: &mut User<T>, name: String) {\n    user.name = name;\n}\n\n/// Updates the age of the user.\npublic fun update_age<T>(user: &mut User<T>, age: u8) {\n    user.age = age;\n}\n\nPhantom Type Parameters\n\nIn some cases, you may want to define a generic type with a type parameter that is not used in the fields or methods of the type. This is called a phantom type parameter. Phantom type parameters are useful when you want to define a type that can hold any other type, but you want to enforce some constraints on the type parameter.\n\n/// A generic type with a phantom type parameter.\npublic struct Coin<phantom T> {\n    value: u64\n}\n\n\nThe Coin type here does not contain any fields or methods that use the type parameter T. It is used to differentiate between different types of coins, and to enforce some constraints on the type parameter T.\n\npublic struct USD {}\npublic struct EUR {}\n\n#[test]\nfun test_phantom_type() {\n    let coin1: Coin<USD> = Coin { value: 10 };\n    let coin2: Coin<EUR> = Coin { value: 20 };\n\n    // Unpacking is identical because the phantom type parameter is not used.\n    let Coin { value: _ } = coin1;\n    let Coin { value: _ } = coin2;\n}\n\n\nIn the example above, we demonstrate how to create two different instances of Coin with different phantom type parameters USD and EUR. The type parameter T is not used in the fields or methods of the Coin type, but it is used to differentiate between different types of coins. It will make sure that the USD and EUR coins are not mixed up.\n\nConstraints on Type Parameters\n\nType parameters can be constrained to have certain abilities. This is useful when you need the inner type to allow certain behavior, such as copy or drop. The syntax for constraining a type parameter is T: <ability> + <ability>.\n\n/// A generic type with a type parameter that has the `drop` ability.\npublic struct Droppable<T: drop> {\n    value: T,\n}\n\n/// A generic struct with a type parameter that has the `copy` and `drop` abilities.\npublic struct CopyableDroppable<T: copy + drop> {\n    value: T, // T must have the `copy` and `drop` abilities\n}\n\n\nMove Compiler will enforce that the type parameter T has the specified abilities. If the type parameter does not have the specified abilities, the code will not compile.\n\n/// Type without any abilities.\npublic struct NoAbilities {}\n\n#[test]\nfun test_constraints() {\n    // Fails - `NoAbilities` does not have the `drop` ability\n    // let droppable = Droppable<NoAbilities> { value: 10 };\n\n    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities\n    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };\n}\n\nFurther Reading\nGenerics in the Move Reference."
    },
    {
      "title": "References - The Move Book",
      "url": "https://move-book.com/move-basics/references.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Book\nThe Move Book\n  \nReferences\n\nIn the Ownership and Scope section, we explained that when a value is passed to a function, it is moved to the function's scope. This means that the function becomes the owner of the value, and the original scope (owner) can no longer use it. This is an important concept in Move, as it ensures that the value is not used in multiple places at the same time. However, there are use cases when we want to pass a value to a function but retain the ownership. This is where references come into play.\n\nTo illustrate this, let's consider a simple example - an application for a metro (subway) pass. We will look at 4 different scenarios:\n\nCard can be purchased at the kiosk for a fixed price\nCard can be shown to inspectors to prove that the passenger has a valid pass\nCard can be used at the turnstile to enter the metro, and spend a ride\nCard can be recycled once it's empty\nLayout\n\nThe initial layout of the metro pass application is simple. We define the Card type and the USES constant that represents the number of rides for a single card. We also add an error constant for the case when the card is empty.\n\nmodule book::metro_pass {\n    /// Error code for when the card is empty.\n    const ENoUses: u64 = 0;\n\n    /// Number of uses for a metro pass card.\n    const USES: u8 = 3;\n\n    /// A metro pass card\n    public struct Card { uses: u8 }\n\n    /// Purchase a metro pass card.\n    public fun purchase(/* pass a Coin */): Card {\n        Card { uses: USES }\n    }\n}\n\nReference\n\nReferences are a way to show a value to a function without giving up the ownership. In our case, when we show the Card to the inspector, we don't want to give up the ownership of it, and we don't allow them to spend the rides. We just want to allow reading the value of the Card and prove its ownership.\n\nTo do so, in the function signature, we use the & symbol to indicate that we are passing a reference to the value, not the value itself.\n\n    /// Show the metro pass card to the inspector.\n    public fun is_valid(card: &Card): bool {\n        card.uses > 0\n    }\n\n\nNow the function can't take the ownership of the card, and it can't spend the rides. But it can read its value. Worth noting, that a signature like this makes it impossible to call the function without a Card at all. This is an important property which allows the Capability Pattern which we will cover in the next chapters.\n\nMutable Reference\n\nIn some cases, we want to allow the function to change the value of the Card. For example, when we use the Card at the turnstile, we want to spend a ride. To implement it, we use the &mut keyword in the function signature.\n\n    /// Use the metro pass card at the turnstile to enter the metro.\n    public fun enter_metro(card: &mut Card) {\n        assert!(card.uses > 0, ENoUses);\n        card.uses = card.uses - 1;\n    }\n\n\nAs you can see in the function body, the &mut reference allows mutating the value, and the function can spend the rides.\n\nPassing by Value\n\nLastly, let's give an illustration of what happens when we pass the value itself to the function. In this case, the function takes the ownership of the value, and the original scope can no longer use it. The owner of the Card can recycle it, and, hence, lose the ownership.\n\n    /// Recycle the metro pass card.\n    public fun recycle(card: Card) {\n        assert!(card.uses == 0, ENoUses);\n        let Card { uses: _ } = card;\n    }\n\n\nIn the recycle function, the Card is taken by value and can be unpacked and destroyed. The original scope can't use it anymore.\n\nFull Example\n\nTo illustrate the full flow of the application, let's put all the pieces together in a test.\n\n    #[test]\n    fun test_card_2024() {\n        // declaring variable as mutable because we modify it\n        let mut card = purchase();\n\n        card.enter_metro(); // modify the card but don't move it\n        assert!(card.is_valid(), 0); // read the card!\n\n        card.enter_metro(); // modify the card but don't move it\n        card.enter_metro(); // modify the card but don't move it\n\n        card.recycle(); // move the card out of the scope\n    }\n"
    },
    {
      "title": "Ability: Copy - The Move Book",
      "url": "https://move-book.com/move-basics/copy-ability.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAbilities: Copy\n\nIn Move, the copy ability on a type indicates that the instance or the value of the type can be copied. While this behavior may feel very natural when working with numbers or other simple types, it is not the default for custom types in Move. This is because Move is designed to express digital assets and resources, and inability to copy is a key element of the resource model.\n\nHowever, Move type system allows you to define custom types with the copy ability.\n\npublic struct Copyable has copy {}\n\n\nIn the example above, we define a custom type Copyable with the copy ability. This means that instances of Copyable can be copied, both implicitly and explicitly.\n\nlet a = Copyable {};\nlet b = a;   // `a` is copied to `b`\nlet c = *&b; // explicit copy via dereference operator\n\nlet Copyable {} = a; // doesn't have `drop`\nlet Copyable {} = b; // doesn't have `drop`\nlet Copyable {} = c; // doesn't have `drop`\n\n\nIn the example above, a is copied to b implicitly, and then explicitly copied to c using the dereference operator. If Copyable did not have the copy ability, the code would not compile, and the Move compiler would raise an error.\n\nCopying and Drop\n\nThe copy ability is closely related to drop ability. If a type has the copy ability, very likely that it should have drop too. This is because the drop ability is required to clean up the resources when the instance is no longer needed. If a type has only copy, then managing its instances gets more complicated, as the values cannot be ignored.\n\npublic struct Value has copy, drop {}\n\n\nAll of the primitive types in Move behave as if they have the copy and drop abilities. This means that they can be copied and dropped, and the Move compiler will handle the memory management for them.\n\nTypes with the copy Ability\n\nAll native types in Move have the copy ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the copy ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference."
    },
    {
      "title": "Ownership and Scope - The Move Book",
      "url": "https://move-book.com/move-basics/ownership-and-scope.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nOwnership and Scope\n\nEvery variable in Move has a scope and an owner. The scope is the range of code where the variable is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the variable is dropped. This is a fundamental concept in Move, and it is important to understand how it works.\n\nOwnership\n\nA variable defined in a function scope is owned by this scope. The runtime goes through the function scope and executes every expression and statement. Once the function scope end, the variables defined in it are dropped or deallocated.\n\nmodule book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function\n    } // a is dropped here\n\n    #[test]\n    fun test_owner() {\n        owner();\n        // a is not valid here\n    }\n}\n\n\nIn the example above, the variable a is owned by the owner function, and the variable b is owned by the other function. When each of these functions are called, the variables are defined, and when the function ends, the variables are discarded.\n\nReturning a Value\n\nIf we changed the owner function to return the variable a, then the ownership of a would be transferred to the caller of the function.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a defined here\n        a // scope ends, a is returned\n    }\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        // a is valid here\n    } // a is dropped here\n}\n\nPassing by Value\n\nAdditionally, if we passed the variable a to another function, the ownership of a would be transferred to this function. When performing this operation, we move the value from one scope to another. This is also called move semantics.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 10;\n        a\n    } // a is returned\n\n    public fun take_ownership(v: u8) {\n        // v is owned by `take_ownership`\n    } // v is dropped here\n\n    #[test]\n    fun test_owner() {\n        let a = owner();\n        take_ownership(a);\n        // a is not valid here\n    }\n}\n\nScopes with Blocks\n\nFunction has a main scope, and it can also have sub-scopes via the use of blocks. A block is a sequence of statements and expressions, and it has its own scope. Variables defined in a block are owned by this block, and when the block ends, the variables are dropped.\n\nmodule book::ownership {\n    public fun owner() {\n        let a = 1; // a is owned by the `owner` function's scope\n        {\n            let b = 2; // b is owned by the block\n            {\n                let c = 3; // c is owned by the block\n            }; // c is dropped here\n        }; // b is dropped here\n        // a = b; // error: b is not valid here\n        // a = c; // error: c is not valid here\n    } // a is dropped here\n}\n\n\nHowever, shall we use the return value of a block, the ownership of the variable is transferred to the caller of the block.\n\nmodule book::ownership {\n    public fun owner(): u8 {\n        let a = 1; // a is owned by the `owner` function's scope\n        let b = {\n            let c = 2; // c is owned by the block\n            c // c is returned\n        }; // c is dropped here\n        a + b // both a and b are valid here\n    }\n}\n\nCopyable Types\n\nSome types in Move are copyable, which means that they can be copied without transferring the ownership. This is useful for types that are small and cheap to copy, such as integers and booleans. Move compiler will automatically copy these types when they are passed to a function or returned from a function, or when they're moved to a scope and then accessed in their original scope.\n\nFurther reading\nLocal Variables and Scopes in the Move Reference."
    },
    {
      "title": "Visibility Modifiers - The Move Book",
      "url": "https://move-book.com/move-basics/visibility.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nVisibility Modifiers\n\nEvery module member has a visibility. By default, all module members are private - meaning they are only accessible within the module they are defined in. However, you can add a visibility modifier to make a module member public - visible outside the module, or public(package) - visible in the modules within the same package, or entry - can be called from a transaction but can't be called from other modules.\n\nInternal Visibility\n\nA function or a struct defined in a module which has no visibility modifier is private to the module. It can't be called from other modules.\n\nmodule book::internal_visibility {\n    // This function can be called from other functions in the same module\n    fun internal() { /* ... */ }\n\n    // Same module -> can call internal()\n    fun call_internal() {\n        internal();\n    }\n}\n\nmodule book::try_calling_internal {\n    use book::internal_visibility;\n\n    // Different module -> can't call internal()\n    fun try_calling_internal() {\n        internal_visibility::internal();\n    }\n}\n\nPublic Visibility\n\nA struct or a function can be made public by adding the public keyword before the fun or struct keyword.\n\nmodule book::public_visibility {\n    // This function can be called from other modules\n    public fun public() { /* ... */ }\n}\n\n\nA public function can be imported and called from other modules. The following code will compile:\n\nmodule book::try_calling_public {\n    use book::public_visibility;\n\n    // Different module -> can call public()\n    fun try_calling_public() {\n        public_visibility::public();\n    }\n}\n\nPackage Visibility\n\nMove 2024 introduces the package visibility modifier. A function with package visibility can be called from any module within the same package. It can't be called from other packages.\n\nmodule book::package_visibility {\n    public(package) fun package_only() { /* ... */ }\n}\n\n\nA package function can be called from any module within the same package:\n\nmodule book::try_calling_package {\n    use book::package_visibility;\n\n    // Same package `book` -> can call package_only()\n    fun try_calling_package() {\n        package_visibility::package_only();\n    }\n}\n"
    },
    {
      "title": "Struct Methods - The Move Book",
      "url": "https://move-book.com/move-basics/struct-methods.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nStruct Methods\n\nMove Compiler supports receiver syntax, which allows defining methods which can be called on instances of a struct. This is similar to the method syntax in other programming languages. It is a convenient way to define functions which operate on the fields of a struct.\n\nMethod syntax\n\nIf the first argument of a function is a struct internal to the module, then the function can be called using the . operator. If the function uses a struct from another module, then method won't be associated with the struct by default. In this case, the function can be called using the standard function call syntax.\n\nWhen a module is imported, the methods are automatically associated with the struct.\n\nmodule book::hero {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    /// A method which casts a spell, consuming mana.\n    public fun heal_spell(hero: &mut Hero) {\n        hero.health = hero.health + 10;\n        hero.mana = hero.mana - 10;\n    }\n\n    /// A method which returns the health of the hero.\n    public fun health(hero: &Hero): u8 { hero.health }\n\n    /// A method which returns the mana of the hero.\n    public fun mana(hero: &Hero): u8 { hero.mana }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_methods() {\n        let mut hero = new();\n        hero.heal_spell();\n\n        assert!(hero.health() == 110, 1);\n        assert!(hero.mana() == 90, 2);\n    }\n}\n\nMethod Aliases\n\nFor modules that define multiple structs and their methods, it is possible to define method aliases to avoid name conflicts, or to provide a better-named method for a struct.\n\nThe syntax for aliases is:\n\n// for local method association\nuse fun function_path as Type.method_name;\n\n// exported alias\npublic use fun function_path as Type.method_name;\n\n\nPublic aliases are only allowed for structs defined in the same module. If a struct is defined in another module, an alias can still be created but cannot be made public.\n\nIn the example below, we changed the hero module and added another type - Villain. Both Hero and Villain have similar field names and methods. And to avoid name conflicts, we prefixed methods with hero_ and villain_ respectively. However, we can create aliases for these methods so that they can be called on the instances of the structs without the prefix.\n\nmodule book::hero_and_villain {\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n    }\n\n    /// A struct representing a villain.\n    public struct Villain has drop {\n        health: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new_hero(): Hero { Hero { health: 100 } }\n\n    /// Create a new Villain.\n    public fun new_villain(): Villain { Villain { health: 100 } }\n\n    // Alias for the `hero_health` method. Will be imported automatically when\n    // the module is imported.\n    public use fun hero_health as Hero.health;\n\n    public fun hero_health(hero: &Hero): u8 { hero.health }\n\n    // Alias for the `villain_health` method. Will be imported automatically\n    // when the module is imported.\n    public use fun villain_health as Villain.health;\n\n    public fun villain_health(villain: &Villain): u8 { villain.health }\n\n    #[test]\n    // Test the methods of the `Hero` and `Villain` structs.\n    fun test_associated_methods() {\n        let hero = new_hero();\n        assert!(hero.health() == 100, 1);\n\n        let villain = new_villain();\n        assert!(villain.health() == 100, 3);\n    }\n}\n\n\nAs you can see, in the test function, we called the health method on the instances of Hero and Villain without the prefix. The compiler will automatically associate the methods with the structs.\n\nAliasing an external module's method\n\nIt is also possible to associate a function defined in another module with a struct from the current module. Following the same approach, we can create an alias for the method defined in another module. Let's use the bcs::to_bytes method from the Standard Library and associate it with the Hero struct. It will allow serializing the Hero struct to a vector of bytes.\n\n// TODO: better example (external module...)\nmodule book::hero_to_bytes {\n    // Alias for the `bcs::to_bytes` method. Imported aliases should be defined\n    // in the top of the module.\n    // public use fun bcs::to_bytes as Hero.to_bytes;\n\n    /// A struct representing a hero.\n    public struct Hero has drop {\n        health: u8,\n        mana: u8,\n    }\n\n    /// Create a new Hero.\n    public fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n    #[test]\n    // Test the methods of the `Hero` struct.\n    fun test_hero_serialize() {\n        // let mut hero = new();\n        // let serialized = hero.to_bytes();\n        // assert!(serialized.length() == 3, 1);\n    }\n}\n\nFurther reading\nMethod Syntax in the Move Reference."
    },
    {
      "title": "Function - The Move Book",
      "url": "https://move-book.com/move-basics/function.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nFunction\n\nFunctions are the building blocks of Move programs. They are called from user transactions and from other functions and group executable code into reusable units. Functions can take arguments and return a value. They are declared with the fun keyword at the module level. Just like any other module member, by default they're private and can only be accessed from within the module.\n\nmodule book::math {\n    /// Function takes two arguments of type `u64` and returns their sum.\n    /// The `public` visibility modifier makes the function accessible from\n    /// outside the module.\n    public fun add(a: u64, b: u64): u64 {\n        a + b\n    }\n\n    #[test]\n    fun test_add() {\n        let sum = add(1, 2);\n        assert!(sum == 3, 0);\n    }\n}\n\n\nIn this example, we define a function add that takes two arguments of type u64 and returns their sum. The function is called from the test_add function, which is a test function located in the same module. In the test we compare the result of the add function with the expected value and abort the execution if the result is different.\n\nFunction declaration\n\nThere's a convention to call functions in Move with the snake_case naming convention. This means that the function name should be all lowercase with words separated by underscores. For example, do_something, add, get_balance, is_authorized, and so on.\n\nA function is declared with the fun keyword followed by the function name (a valid Move identifier), a list of arguments in parentheses, and a return type. The function body is a block of code that contains a sequence of statements and expressions. The last expression in the function body is the return value of the function.\n\nfun return_nothing() {\n    // empty expression, function returns `()`\n}\n\nAccessing functions\n\nJust like any other module member, functions can be imported and accessed via a path. The path consists of the module path and the function name separated by ::. For example, if you have a function called add in the math module in the book package, the path to it will be book::math::add, or, if the module is imported, math::add.\n\nmodule book::use_math {\n    use book::math;\n\n    fun call_add() {\n        // function is called via the path\n        let sum = math::add(1, 2);\n    }\n}\n\nMultiple return values\n\nMove functions can return multiple values, which is useful when you need to return more than one value from a function. The return type of the function is a tuple of types. The return value is a tuple of expressions.\n\nfun get_name_and_age(): (vector<u8>, u8) {\n    (b\"John\", 25)\n}\n\n\nResult of a function call with tuple return has to be unpacked into variables via let (tuple) syntax:\n\n// Tuple must be destructured to access its elements.\n// Name and age are declared as immutable variables.\nlet (name, age) = get_name_and_age();\nassert!(name == b\"John\", 0);\nassert!(age == 25, 0);\n\n\nIf any of the declared values need to be declared as mutable, the mut keyword is placed before the variable name:\n\n// declare name as mutable, age as immutable\nlet (mut name, age) = get_name_and_age();\n\n\nIf some of the arguments are not used, they can be ignored with the _ symbol:\n\n// ignore the name, only use the age\nlet (_, age) = get_name_and_age();\n\nFurther reading\nFunctions in the Move Reference."
    },
    {
      "title": "Assert and Abort - The Move Book",
      "url": "https://move-book.com/move-basics/assert-and-abort.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAssert and Abort\n\nA transaction can either succeed or fail. Successful execution applies all the changes made to objects and on-chain data, and the transaction is committed to the blockchain. If a transaction aborts, and changes are not applied. The abort keyword is used to abort a transaction and revert the changes made so far.\n\nIt is important to note that there is no catch mechanism in Move. If a transaction aborts, the changes made so far are reverted, and the transaction is considered failed.\n\nAbort\n\nThe abort keyword is used to abort the execution of a transaction. It is used in combination with an abort code, which will be returned to the caller of the transaction. The abort code is an integer of type u64 and can be any value.\n\nlet user_has_access = true;\n\n// abort with a predefined constant if `user_has_access` is false\nif (!user_has_access) {\n    abort 0\n};\n\n// there's an alternative syntax using parenthesis`\nif (user_has_access) {\n   abort(1)\n};\n\n\nThe code above will, of course, abort with abort code 1.\n\nassert!\n\nThe assert! macro is a built-in macro that can be used to assert a condition. If the condition is false, the transaction will abort with the given abort code. The assert! macro is a convenient way to abort a transaction if a condition is not met. The macro shortens the code otherwise written with an if expression + abort.\n\n// aborts if `user_has_access` is `false` with abort code 0\nassert!(user_has_access, 0);\n\n// expands into:\nif (!user_has_access) {\n    abort 0\n};\n\nError constants\n\nTo make error codes more descriptive, it is a good practice to define error constants. Error constants are defined as const declarations and are usually prefixed with E followed by a camel case name. Error constants are no different from other constants and don't have special handling. So their addition is purely a practice for better code readability.\n\n/// Error code for when the user has no access.\nconst ENoAccess: u64 = 0;\n/// Trying to access a field that does not exist.\nconst ENoField: u64 = 1;\n\n/// Updates a record.\npublic fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {\n    // asserts are way more readable now\n    assert!(user_has_access, ENoAccess);\n    assert!(field_exists, ENoField);\n\n    /* ... */\n}\n\nFurther reading\nAbort and Assert in the Move Reference.\nWe suggest reading the Better Error Handling guide to learn about best practices for error handling in Move."
    },
    {
      "title": "Constants - The Move Book",
      "url": "https://move-book.com/move-basics/constants.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nConstants\n\nConstants are immutable values that are defined at the module level. They often serve as a way to give names to static values that are used throughout a module. For example, if there's a default price for a product, you might define a constant for it. Constants are stored in the module's bytecode, and each time they are used, the value is copied.\n\nmodule book::shop_price {\n    use sui::coin::Coin;\n    use sui::sui::SUI;\n\n    /// The price of an item in the shop.\n    const ITEM_PRICE: u64 = 100;\n    /// The owner of the shop, an address.\n    const SHOP_OWNER: address = @0xa11ce;\n\n    /// An item sold in the shop.\n    public struct Item { /* ... */ }\n\n    /// Purchase an item from the shop.\n    public fun purchase(coin: Coin<SUI>): Item {\n        assert!(coin.value() == ITEM_PRICE, 0);\n\n        transfer::public_transfer(coin, SHOP_OWNER);\n\n        Item { /* ... */ }\n    }\n}\n\nNaming Convention\n\nConstants must start with a capital letter - this is enforced at the compiler level. For constants used as a value, there's a convention to use uppercase letters and underscores to separate words. It's a way to make constants stand out from other identifiers in the code. One exception is made for error constants, which are written in ECamelCase.\n\n/// Price of the item used at the shop.\nconst ITEM_PRICE: u64 = 100;\n\n/// Error constant.\nconst EItemNotFound: u64 = 1;\n\nConstants are Immutable\n\nConstants can't be changed and assigned new values. They are part of the package bytecode, and inherently immutable.\n\nmodule book::immutable_constants {\n    const ITEM_PRICE: u64 = 100;\n\n    // emits an error\n    fun change_price() {\n        ITEM_PRICE = 200;\n    }\n}\n\nUsing Config Pattern\n\nA common use case for an application is to define a set of constants that are used throughout the codebase. But due to constants being private to the module, they can't be accessed from other modules. One way to solve this is to define a \"config\" module that exports the constants.\n\nmodule book::config {\n    const ITEM_PRICE: u64 = 100;\n    const TAX_RATE: u64 = 10;\n    const SHIPPING_COST: u64 = 5;\n\n    /// Returns the price of an item.\n    public fun item_price(): u64 { ITEM_PRICE }\n    /// Returns the tax rate.\n    public fun tax_rate(): u64 { TAX_RATE }\n    /// Returns the shipping cost.\n    public fun shipping_cost(): u64 { SHIPPING_COST }\n}\n\n\nThis way other modules can import and read the constants, and the update process is simplified. If the constants need to be changed, only the config module needs to be updated during the package upgrade.\n\nLinks\nConstants in the Move Reference\nCoding conventions for constants"
    },
    {
      "title": "Control Flow - The Move Book",
      "url": "https://move-book.com/move-basics/control-flow.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nControl Flow\n\nControl flow statements are used to control the flow of execution in a program. They are used to make decisions, to repeat a block of code, and to exit a block of code early. Move has the following control flow statements (explained in detail below):\n\nif and if-else - making decisions on whether to execute a block of code\nloop and while loops - repeating a block of code\nbreak and continue statements - exiting a loop early\nreturn statement - exiting a function early\nConditional Statements\n\nThe if expression is used to make decisions in a program. It evaluates a boolean expression and executes a block of code if the expression is true. Paired with else, it can execute a different block of code if the expression is false.\n\nThe syntax for the if expression is:\n\nif (<bool_expression>) <expression>;\nif (<bool_expression>) <expression> else <expression>;\n\n\nJust like any other expression, if requires a semicolon, if there are other expressions following it. The else keyword is optional, except for the case when the resulting value is assigned to a variable. We will cover this below.\n\n    #[test]\n    fun test_if() {\n        let x = 5;\n\n        // `x > 0` is a boolean expression.\n        if (x > 0) {\n            std::debug::print(&b\"X is bigger than 0\".to_string())\n        };\n    }\n\n\nLet's see how we can use if and else to assign a value to a variable:\n\n    #[test]\n    fun test_if_else() {\n        let x = 5;\n        let y = if (x > 0) {\n            1\n        } else {\n            0\n        };\n\n        assert!(y == 1, 0);\n    }\n\n\nHere we assign the value of the if expression to the variable y. If x is greater than 0, y will be assigned the value 1, otherwise 0. The else block is necessary, because both branches must return a value of the same type. If we omit the else block, the compiler will throw an error.\n\nConditional expressions are one of the most important control flow statements in Move. They can use either user provided input or some already stored data to make decisions. In particular, they are used in the assert! macro to check if a condition is true, and if not, to abort execution. We will get to it very soon!\n\nRepeating Statements with Loops\n\nLoops are used to execute a block of code multiple times. Move has two built-in types of loops: loop and while. In many cases they can be used interchangeably, but usually while is used when the number of iterations is known in advance, and loop is used when the number of iterations is not known in advance or there are multiple exit points.\n\nLoops are helpful when dealing with collections, such as vectors, or when we want to repeat a block of code until a certain condition is met. However, it is important to be careful with loops, as they can lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.\n\nThe while loop\n\nThe while statement is used to execute a block of code as long as a boolean expression is true. Just like we've seen with if, the boolean expression is evaluated before each iteration of the loop. Just like conditional statements, the while loop is an expression and requires a semicolon if there are other expressions following it.\n\nThe syntax for the while loop is:\n\nwhile (<bool_expression>) { <expressions>; };\n\n\nHere is an example of a while loop with a very simple condition:\n\n    // This function iterates over the `x` variable until it reaches 10, the\n    // return value is the number of iterations it took to reach 10.\n    //\n    // If `x` is 0, then the function will return 10.\n    // If `x` is 5, then the function will return 5.\n    fun while_loop(mut x: u8): u8 {\n        let mut y = 0;\n\n        // This will loop until `x` is 10.\n        // And will never run if `x` is 10 or more.\n        while (x < 10) {\n            y = y + 1;\n            x = x + 1;\n        };\n\n        y\n    }\n\n    #[test]\n    fun test_while() {\n        assert!(while_loop(0) == 10, 0); // 10 times\n        assert!(while_loop(5) == 5, 0);  // 5 times\n        assert!(while_loop(10) == 0, 0); // loop never executed\n    }\n\nInfinite loop\n\nNow let's imagine a scenario where the boolean expression is always true. For example, if we literally passed true to the while condition. As you might expect, this would create an infinite loop, and this is almost what the loop statement works like.\n\n    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_while() {\n        let mut x = 0;\n\n        // This will loop forever.\n        while (true) {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n\n\nAn infinite while, or while without a condition, is a loop. The syntax for it is simple:\n\nloop { <expressions>; };\n\n\nLet's rewrite the previous example using loop instead of while:\n\n    #[test, expected_failure(out_of_gas, location=Self)]\n    fun test_infinite_loop() {\n        let mut x = 0;\n\n        // This will loop forever.\n        loop {\n            x = x + 1;\n        };\n\n        // This line will never be executed.\n        assert!(x == 5, 0);\n    }\n\n\nInfinite loops on their own are not very useful in Move, since every operation in Move costs gas, and an infinite loop will lead to gas exhaustion. However, they can be used in combination with break and continue statements to create more complex loops.\n\nExiting a Loop Early\n\nAs we already mentioned, infinite loops are rather useless on their own. And that's where we introduce the break and continue statements. They are used to exit a loop early, and to skip the rest of the current iteration, respectively.\n\nSyntax for the break statement is (without a semicolon):\n\nbreak\n\n\nThe break statement is used to stop the execution of a loop and exit it early. It is often used in combination with a conditional statement to exit the loop when a certain condition is met. To illustrate this point, let's turn the infinite loop from the previous example into something that looks and behaves more like a while loop:\n\n    #[test]\n    fun test_break_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 5.\n        loop {\n            x = x + 1;\n\n            // If `x` is 5, then exit the loop.\n            if (x == 5) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 5, 0);\n    }\n\n\nAlmost identical to the while loop, right? The break statement is used to exit the loop when x is 5. If we remove the break statement, the loop will run forever, just like the previous example.\n\nSkipping an Iteration\n\nThe continue statement is used to skip the rest of the current iteration and start the next one. Similarly to break, it is used in combination with a conditional statement to skip the rest of the iteration when a certain condition is met.\n\nSyntax for the continue statement is (without a semicolon):\n\ncontinue\n\n\nThe example below skips odd numbers and prints only even numbers from 0 to 10:\n\n    #[test]\n    fun test_continue_loop() {\n        let mut x = 0;\n\n        // This will loop until `x` is 10.\n        loop {\n            x = x + 1;\n\n            // If `x` is odd, then skip the rest of the iteration.\n            if (x % 2 == 1) {\n                continue // Skip the rest of the iteration.\n            };\n\n            std::debug::print(&x);\n\n            // If `x` is 10, then exit the loop.\n            if (x == 10) {\n                break // Exit the loop.\n            }\n        };\n\n        assert!(x == 10, 0); // 10\n    }\n\n\nbreak and continue statements can be used in both while and loop loops.\n\nEarly Return\n\nThe return statement is used to exit a function early and return a value. It is often used in combination with a conditional statement to exit the function when a certain condition is met. The syntax for the return statement is:\n\nreturn <expression>\n\n\nHere is an example of a function that returns a value when a certain condition is met:\n\n    /// This function returns `true` if `x` is greater than 0 and not 5,\n    /// otherwise it returns `false`.\n    fun is_positive(x: u8): bool {\n        if (x == 5) {\n            return false\n        };\n\n        if (x > 0) {\n            return true\n        };\n\n        false\n    }\n\n    #[test]\n    fun test_return() {\n        assert!(is_positive(5) == false, 0);\n        assert!(is_positive(0) == false, 0);\n        assert!(is_positive(1) == true, 0);\n    }\n\n\nUnlike in other languages, the return statement is not required for the last expression in a function. The last expression in a function block is automatically returned. However, the return statement is useful when we want to exit a function early if a certain condition is met."
    },
    {
      "title": "String - The Move Book",
      "url": "https://move-book.com/move-basics/string.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nString\n\nWhile Move does not have a built-in type to represent strings, it does have two standard implementations for strings in the Standard Library. The std::string module defines a String type and methods for UTF-8 encoded strings, and the second module, std::ascii, provides an ASCII String type and its methods.\n\nSui execution environment automatically converts bytevector into String in transaction inputs. So in many cases, String does not to be constructed in the Transaction Block.\n\nStrings are bytes\n\nNo matter which type of string you use, it is important to know that strings are just bytes. The wrappers provided by the string and ascii modules are just that: wrappers. They do provide safety checks and methods to work with strings, but at the end of the day, they are just vectors of bytes.\n\nmodule book::custom_string {\n    /// Anyone can implement a custom string-like type by wrapping a vector.\n    public struct MyString {\n        bytes: vector<u8>,\n    }\n\n    /// Implement a `from_bytes` function to convert a vector of bytes to a string.\n    public fun from_bytes(bytes: vector<u8>): MyString {\n        MyString { bytes }\n    }\n\n    /// Implement a `bytes` function to convert a string to a vector of bytes.\n    public fun bytes(self: &MyString): &vector<u8> {\n        &self.bytes\n    }\n}\n\nWorking with UTF-8 Strings\n\nWhile there are two types of strings in the standard library, the string module should be considered the default. It has native implementations of many common operations, and hence is more efficient than the ascii module, which is fully implemented in Move.\n\nDefinition\n\nThe String type in the std::string module is defined as follows:\n\n// File: move-stdlib/sources/string.move\n/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\npublic struct String has copy, drop, store {\n    bytes: vector<u8>,\n}\n\nCreating a String\n\nTo create a new UTF-8 String instance, you can use the string::utf8 method. The Standard Library provides an alias .to_string() on the vector<u8> for convenience.\n\n// the module is `std::string` and the type is `String`\nuse std::string::{Self, String};\n\n// strings are normally created using the `utf8` function\n// type declaration is not necessary, we put it here for clarity\nlet hello: String = string::utf8(b\"Hello\");\n\n// The `.to_string()` alias on the `vector<u8>` is more convenient\nlet hello = b\"Hello\".to_string();\n\nCommon Operations\n\nUTF8 String provides a number of methods to work with strings. The most common operations on strings are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the bytes() method can be used to get the underlying byte vector.\n\nlet mut str = b\"Hello,\".to_string();\nlet another = b\" World!\".to_string();\n\n// append(String) adds the content to the end of the string\nstr.append(another);\n\n// `sub_string(start, end)` copies a slice of the string\nstr.sub_string(0, 5); // \"Hello\"\n\n// `length()` returns the number of bytes in the string\nstr.length(); // 12 (bytes)\n\n// methods can also be chained! Get a length of a substring\nstr.sub_string(0, 5).length(); // 5 (bytes)\n\n// whether the string is empty\nstr.is_empty(); // false\n\n// get the underlying byte vector for custom operations\nlet bytes: &vector<u8> = str.bytes();\n\nSafe UTF-8 Operations\n\nThe default utf8 method may abort if the bytes passed into it are not valid UTF-8. If you are not sure that the bytes you are passing are valid, you should use the try_utf8 method instead. It returns an Option<String>, which contains no value if the bytes are not valid UTF-8, and a string otherwise.\n\nHint: the name that starts with try_* indicates that the function returns an Option with the expected result or none if the operation fails. It is a common naming convention borrowed from Rust.\n\n// this is a valid UTF-8 string\nlet hello = b\"Hello\".try_to_string();\n\nassert!(hello.is_some(), 0); // abort if the value is not valid UTF-8\n\n// this is not a valid UTF-8 string\nlet invalid = b\"\\xFF\".try_to_string();\n\nassert!(invalid.is_none(), 0); // abort if the value is valid UTF-8\n\nUTF-8 Limitations\n\nThe string module does not provide a way to access individual characters in a string. This is because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to 4 bytes. Similarly, the length() method returns the number of bytes in the string, not the number of characters.\n\nHowever, methods like sub_string and insert check character boundaries and will abort when the index is in the middle of a character.\n\nASCII Strings\n\nThis section is coming soon!"
    },
    {
      "title": "Vector - The Move Book",
      "url": "https://move-book.com/move-basics/vector.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nVector\n\nVectors are a native way to store collections of elements in Move. They are similar to arrays in other programming languages, but with a few differences. In this section, we introduce the vector type and its operations.\n\nVector syntax\n\nThe vector type is defined using the vector keyword followed by the type of the elements in angle brackets. The type of the elements can be any valid Move type, including other vectors. Move has a vector literal syntax that allows you to create vectors using the vector keyword followed by square brackets containing the elements (or no elements for an empty vector).\n\n// An empty vector of bool elements.\nlet empty: vector<bool> = vector[];\n\n// A vector of u8 elements.\nlet v: vector<u8> = vector[10, 20, 30];\n\n// A vector of vector<u8> elements.\nlet vv: vector<vector<u8>> = vector[\n    vector[10, 20],\n    vector[30, 40]\n];\n\n\nThe vector type is a built-in type in Move, and does not need to be imported from a module. However, vector operations are defined in the std::vector module, and you need to import the module to use them.\n\nVector operations\n\nThe standard library provides methods to manipulate vectors. The following are some of the most commonly used operations:\n\npush_back: Adds an element to the end of the vector.\npop_back: Removes the last element from the vector.\nlength: Returns the number of elements in the vector.\nis_empty: Returns true if the vector is empty.\nremove: Removes an element at a given index.\nlet mut v = vector[10u8, 20, 30];\n\nassert!(v.length() == 3, 0);\nassert!(!v.is_empty(), 1);\n\nv.push_back(40);\nlet last_value = v.pop_back();\n\nassert!(last_value == 40, 2);\n\nDestroying a Vector of non-droppable types\n\nA vector of non-droppable types cannot be discarded. If you define a vector of types without drop ability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an explicit call to destroy_empty function.\n\n    /// A struct without `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    fun test_destroy_empty() {\n        // Initialize a vector of `NoDrop` elements.\n        let v = vector<NoDrop>[];\n\n        // While we know that `v` is empty, we still need to call\n        // the explicit `destroy_empty` function to discard the vector.\n        v.destroy_empty();\n    }\n\nFurther reading\nVector in the Move Reference."
    },
    {
      "title": "Option - The Move Book",
      "url": "https://move-book.com/move-basics/option.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nOption\n\nOption is a type that represents an optional value which may or may not exist. The concept of Option in Move is borrowed from Rust, and it is a very useful primitive in Move. Option is defined in the Standard Library, and is defined as follows:\n\nFile: move-stdlib/source/option.move\n\n// File: move-stdlib/source/option.move\n/// Abstraction of a value that may or may not be present.\nstruct Option<Element> has copy, drop, store {\n    vec: vector<Element>\n}\n\n\nThe 'std::option' module is implicitly imported in every module, and you don't need to add an import.\n\nThe Option is a generic type which takes a type parameter Element. It has a single field vec which is a vector of Element. Vector can have length 0 or 1, and this is used to represent the presence or absence of a value.\n\nOption type has two variants: Some and None. Some variant contains a value and None variant represents the absence of a value. The Option type is used to represent the absence of a value in a type-safe way, and it is used to avoid the need for empty or undefined values.\n\nIn Practice\n\nTo showcase why Option type is necessary, let's look at an example. Consider an application which takes a user input and stores it in a variable. Some fields are required, and some are optional. For example, a user's middle name is optional. While we could use an empty string to represent the absence of a middle name, it would require extra checks to differentiate between an empty string and a missing middle name. Instead, we can use the Option type to represent the middle name.\n\nmodule book::user_registry {\n    use std::string::String;\n\n    /// A struct representing a user record.\n    public struct User has drop {\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    }\n\n    /// Create a new `User` struct with the given fields.\n    public fun register(\n        first_name: String,\n        middle_name: Option<String>,\n        last_name: String,\n    ): User {\n        User { first_name, middle_name, last_name }\n    }\n}\n\n\nIn the example above, the middle_name field is of type Option<String>. This means that the middle_name field can either contain a String value or be empty. This makes it clear that the middle name is optional, and it avoids the need for extra checks to differentiate between an empty string and a missing middle name.\n\nUsing Option\n\nTo use the Option type, you need to import the std::option module and use the Option type. You can then create an Option value using the some or none methods.\n\n// `option::some` creates an `Option` value with a value.\nlet mut opt = option::some(b\"Alice\");\n\n// `option.is_some()` returns true if option contains a value.\nassert!(opt.is_some(), 1);\n\n// internal value can be `borrow`ed and `borrow_mut`ed.\nassert!(opt.borrow() == &b\"Alice\", 0);\n\n// `option.extract` takes the value out of the option, leaving the option empty.\nlet inner = opt.extract();\n\n// `option.is_none()` returns true if option is None.\nassert!(opt.is_none(), 2);\n"
    },
    {
      "title": "Standard Library - The Move Book",
      "url": "https://move-book.com/move-basics/standard-library.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nStandard Library\n\nThe Move Standard Library provides functionality for native types and operations. It is a standard collection of modules which do not interact with the storage, but provide basic tools for working and manipulating the data. It is the only dependency of the Sui Framework, and is imported together with it.\n\nMost Common Modules\n\nIn this book we go into detail about most of the modules in the Standard Library, however, it is also helpful to give an overview of the features, so that you can get a sense of what is available and which module implements it.\n\nModule\tDescription\tChapter\nstd::string\tProvides basic string operations\tString\nstd::ascii\tProvides basic ASCII operations\tString\nstd::option\tImplements an Option<T>\tOption\nstd::vector\tNative operations on the vector type\tVector\nstd::bcs\tContains the bcs::to_bytes() function\tBCS\nstd::address\tContains a single address::length function\tAddress\nstd::type_name\tAllows runtime type reflection\tType Reflection\nstd::hash\tHashing functions: sha2_256 and sha3_256\tCryptography and Hashing\nstd::debug\tContains debugging functions, which are available in only in test mode\tDebugging\nstd::bit_vector\tProvides operations on bit vectors\t-\nstd::fixed_point32\tProvides the FixedPoint32 type\t-\nExported Addresses\n\nStandard Library exports one named address - std = 0x1.\n\n[addresses]\nstd = \"0x1\"\n\nImplicit Imports\n\nSome of the modules are imported implicitly, and are available in the module without explicit use import. For Standard Library, these modules and types are:\n\nstd::vector\nstd::option\nstd::option::Option\nImporting std without Sui Framework\n\nThe Move Standard Library can be imported to the package directly. However, std alone is not enough to build a meaningful application, as it does not provide any storage capabilities, and can't interact with the on-chain state.\n\nMoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n\nSource Code\n\nThe source code of the Move Standard Library is available in the Sui repository."
    },
    {
      "title": "Importing Modules - The Move Book",
      "url": "https://move-book.com/move-basics/importing-modules.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nImporting Modules\n\nMove achieves high modularity and code reuse by allowing module imports. Modules within the same package can import each other, and a new package can depend on already existing packages and use their modules too. This section will cover the basics of importing modules and how to use them in your own code.\n\nImporting a Module\n\nModules defined in the same package can import each other. The use keyword is followed by the module path, which consists of the package address (or alias) and the module name separated by ::.\n\n// File: sources/module_one.move\nmodule book::module_one {\n    /// Struct defined in the same module.\n    public struct Character has drop {}\n\n    /// Simple function that creates a new `Character` instance.\n    public fun new(): Character { Character {} }\n}\n\n\nAnother module defined in the same package can import the first module using the use keyword.\n\n// File: sources/module_two.move\nmodule book::module_two {\n    use book::module_one; // importing module_one from the same package\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_and_ignore() {\n        let _ = module_one::new();\n    }\n}\n\nImporting Members\n\nYou can also import specific members from a module. This is useful when you only need a single function or a single type from a module. The syntax is the same as for importing a module, but you add the member name after the module path.\n\nmodule book::more_imports {\n    use book::module_one::new;       // imports the `new` function from the `module_one` module\n    use book::module_one::Character; // importing the `Character` struct from the `module_one` module\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n\nGrouping Imports\n\nImports can be grouped into a single use statement using the curly braces {}. This is useful when you need to import multiple members from the same module. Move allows grouping imports from the same module and from the same package.\n\nmodule book::grouped_imports {\n    // imports the `new` function and the `Character` struct from\n    /// the `module_one` module\n    use book::module_one::{new, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        new()\n    }\n}\n\n\nSingle function imports are less common in Move, since the function names can overlap and cause confusion. A recommended practice is to import the entire module and use the module path to access the function. Types have unique names and should be imported individually.\n\nTo import members and the module itself in the group import, you can use the Self keyword. The Self keyword refers to the module itself and can be used to import the module and its members.\n\nmodule book::self_imports {\n    // imports the `Character` struct, and the `module_one` module\n    use book::module_one::{Self, Character};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create_character(): Character {\n        module_one::new()\n    }\n}\n\nResolving Name Conflicts\n\nWhen importing multiple members from different modules, it is possible to have name conflicts. For example, if you import two modules that both have a function with the same name, you will need to use the module path to access the function. It is also possible to have modules with the same name in different packages. To resolve the conflict and avoid ambiguity, Move offers the as keyword to rename the imported member.\n\nmodule book::conflict_resolution {\n    // `as` can be placed after any import, including group imports\n    use book::module_one::{Self as mod, Character as Char};\n\n    /// Calls the `new` function from the `module_one` module.\n    public fun create(): Char {\n        mod::new()\n    }\n}\n\nAdding an External Dependency\n\nEvery new package generated via the sui binary features a Move.toml file with a single dependency on the Sui Framework package. The Sui Framework depends on the Standard Library package. And both of these packages are available in default configuration. Package dependencies are defined in the Package Manifest as follows:\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nLocal = { local = \"../my_other_package\" }\n\n\nThe dependencies section contains a list of package dependencies. The key is the name of the package, and the value is either a git import table or a local path. The git import contains the URL of the package, the subdirectory where the package is located, and the revision of the package. The local path is a relative path to the package directory.\n\nIf a dependency is added to the Move.toml file, the compiler will automatically fetch (and later refetch) the dependencies when building the package.\n\nImporting a Module from Another Package\n\nNormally, packages define their addresses in the [addresses] section, so you can use the alias instead of the address. For example, instead of 0x2::coin module, you would use sui::coin. The sui alias is defined in the Sui Framework package. Similarly, the std alias is defined in the Standard Library package and can be used to access the standard library modules.\n\nTo import a module from another package, you use the use keyword followed by the module path. The module path consists of the package address (or alias) and the module name separated by ::.\n\nmodule book::imports {\n    use std::string; // std = 0x1, string is a module in the standard library\n    use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework\n}\n"
    },
    {
      "title": "Ability: Drop - The Move Book",
      "url": "https://move-book.com/move-basics/drop-ability.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAbilities: Drop\nDrop ability\n\nThe drop ability - the simplest of them - allows the instance of a struct to be ignored or discarded. In many programming languages this behavior is considered default. However, in Move, a struct without the drop ability is not allowed to be ignored. This is a safety feature of the Move language, which ensures that all assets are properly handled. An attempt to ignore a struct without the drop ability will result in a compilation error.\n\nmodule book::drop_ability {\n\n    /// This struct has the `drop` ability.\n    public struct IgnoreMe has drop {\n        a: u8,\n        b: u8,\n    }\n\n    /// This struct does not have the `drop` ability.\n    public struct NoDrop {}\n\n    #[test]\n    // Create an instance of the `IgnoreMe` struct and ignore it.\n    // Even though we constructed the instance, we don't need to unpack it.\n    fun test_ignore() {\n        let no_drop = NoDrop {};\n        let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack\n\n        // The value must be unpacked for the code to compile.\n        let NoDrop {} = no_drop; // OK\n    }\n}\n\n\nThe drop ability is often used on custom collection types to eliminate the need for special handling of the collection when it is no longer needed. For example, a vector type has the drop ability, which allows the vector to be ignored when it is no longer needed. However, the biggest feature of Move's type system is the ability to not have drop. This ensures that the assets are properly handled and not ignored.\n\nA struct with a single drop ability is called a Witness. We explain the concept of a Witness in the Witness and Abstract Implementation section.\n\nTypes with the drop Ability\n\nAll native types in Move have the drop ability. This includes:\n\nbool\nunsigned integers\nvector\naddress\n\nAll of the types defined in the standard library have the drop ability as well. This includes:\n\nOption\nString\nTypeName\nFurther reading\nType Abilities in the Move Reference."
    },
    {
      "title": "Abilities: Introduction - The Move Book",
      "url": "https://move-book.com/move-basics/abilities-introduction.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAbilities: Introduction\n\nMove has a unique type system which allows customizing type abilities. In the previous section, we introduced the struct definition and how to use it. However, the instances of the Artist and Record structs had to be unpacked for the code to compile. This is default behavior of a struct without abilities.\n\nThroughout the book you will see chapters with name Ability: <name>, where <name> is the name of the ability. These chapters will cover the ability in detail, how it works, and how to use it in Move.\n\nWhat are Abilities?\n\nAbilities are a way to allow certain behaviors for a type. They are a part of the struct declaration and define which behaviours are allowed for the instances of the struct.\n\nAbilities syntax\n\nAbilities are set in the struct definition using the has keyword followed by a list of abilities. The abilities are separated by commas. Move supports 4 abilities: copy, drop, key, and store, each of them is used to define a specific behaviour for the struct instances.\n\n/// This struct has the `copy` and `drop` abilities.\nstruct VeryAble has copy, drop {\n    // field: Type1,\n    // field2: Type2,\n    // ...\n}\n\nOverview\n\nA quick overview of the abilities:\n\nAll of the built-in types, except references, have copy, drop and store abilities. References have copy and drop.\n\ncopy - allows the struct to be copied. Explained in the Ability: Copy chapter.\ndrop - allows the struct to be dropped or discarded. Explained in the Ability: Drop chapter.\nkey - allows the struct to be used as a key in a storage. Explained in the Ability: Key chapter.\nstore - allows the struct to be stored in structs with the key ability. Explained in the Ability: Store chapter.\n\nWhile it is important to mention them here, we will go in detail about each ability in the following chapters and give a proper context on how to use them.\n\nNo abilities\n\nA struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a struct a Hot Potato. It is a joke, but it is also a good way to remember that a struct without abilities is like a hot potato - it can only be passed around and requires special handling. Hot Potato is one of the most powerful patterns in Move, we go in detail about it in the Hot Potato chapter.\n\nFurther reading\nType Abilities in the Move Reference."
    },
    {
      "title": "Struct - The Move Book",
      "url": "https://move-book.com/move-basics/struct.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nCustom Types with Struct\n\nMove's type system shines when it comes to defining custom types. User defined types can be custom tailored to the specific needs of the application. Not just on the data level, but also in its behavior. In this section we introduce the struct definition and how to use it.\n\nStruct\n\nTo define a custom type, you can use the struct keyword followed by the name of the type. After the name, you can define the fields of the struct. Each field is defined with the field_name: field_type syntax. Field definitions must be separated by commas. The fields can be of any type, including other structs.\n\nMove does not support recursive structs, meaning a struct cannot contain itself as a field.\n\n/// A struct representing an artist.\npublic struct Artist {\n    /// The name of the artist.\n    name: String,\n}\n\n/// A struct representing a music record.\npublic struct Record {\n    /// The title of the record.\n    title: String,\n    /// The artist of the record. Uses the `Artist` type.\n    artist: Artist,\n    /// The year the record was released.\n    year: u16,\n    /// Whether the record is a debut album.\n    is_debut: bool,\n    /// The edition of the record.\n    edition: Option<u16>,\n}\n\n\nIn the example above, we define a Record struct with five fields. The title field is of type String, the artist field is of type Artist, the year field is of type u16, the is_debut field is of type bool, and the edition field is of type Option<u16>. The edition field is of type Option<u16> to represent that the edition is optional.\n\nStructs are private by default, meaning they cannot be imported and used outside of the module they are defined in. Their fields are also private and can't be accessed from outside the module. See visibility for more information on different visibility modifiers.\n\nFields of a struct are private and can only be accessed by the module defining the struct. Reading and writing the fields of a struct in other modules is only possible if the module defining the struct provides public functions to access the fields.\n\nCreate and use an instance\n\nWe described how struct definition works. Now let's see how to initialize a struct and use it. A struct can be initialized using the struct_name { field1: value1, field2: value2, ... } syntax. The fields can be initialized in any order, and all of the fields must be set.\n\nlet mut artist = Artist {\n    name: b\"The Beatles\".to_string()\n};\n\n\nIn the example above, we create an instance of the Artist struct and set the name field to a string \"The Beatles\".\n\nTo access the fields of a struct, you can use the . operator followed by the field name.\n\n// Access the `name` field of the `Artist` struct.\nlet artist_name = artist.name;\n\n// Access a field of the `Artist` struct.\nassert!(artist.name == string::utf8(b\"The Beatles\"), 0);\n\n// Mutate the `name` field of the `Artist` struct.\nartist.name = string::utf8(b\"Led Zeppelin\");\n\n// Check that the `name` field has been mutated.\nassert!(artist.name == string::utf8(b\"Led Zeppelin\"), 1);\n\n\nOnly module defining the struct can access its fields (both mutably and immutably). So the above code should be in the same module as the Artist struct.\n\nUnpacking a struct\n\nStructs are non-discardable by default, meaning that the initiated struct value must be used: either stored or unpacked. Unpacking a struct means deconstructing it into its fields. This is done using the let keyword followed by the struct name and the field names.\n\n// Unpack the `Artist` struct and create a new variable `name`\n// with the value of the `name` field.\nlet Artist { name } = artist;\n\n\nIn the example above we unpack the Artist struct and create a new variable name with the value of the name field. Because the variable is not used, the compiler will raise a warning. To suppress the warning, you can use the underscore _ to indicate that the variable is intentionally unused.\n\n// Unpack the `Artist` struct and ignore the `name` field.\nlet Artist { name: _ } = artist;\n\nFurther reading\nStructs in the Move Reference."
    },
    {
      "title": "Expression - The Move Book",
      "url": "https://move-book.com/move-basics/expression.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nExpression\n\nIn programming languages expression is a unit of code which returns a value, in Move, almost everything is an expression, - with the sole exception of let statement which is a declaration. In this section, we cover the types of expressions and introduce the concept of scope.\n\nExpressions are sequenced with semicolons ;. If there's \"no expression\" after the semicolon, the compiler will insert a unit () - an empty expression.\n\nLiterals\n\nIn the Primitive Types section, we introduced the basic types of Move. And to illustrate them, we used literals. A literal is a notation for representing a fixed value in the source code. Literals are used to initialize variables and to pass arguments to functions. Move has the following literals:\n\ntrue and false for boolean values\n0, 1, 123123 or other numeric for integer values\n0x0, 0x1, 0x123 or other hexadecimal for integer values\nb\"bytes_vector\" for byte vector values\nx\"0A\" HEX literal for byte values\nlet b = true;     // true is a literal\nlet n = 1000;     // 1000 is a literal\nlet h = 0x0A;     // 0x0A is a literal\nlet v = b\"hello\"; // b'hello' is a byte vector literal\nlet x = x\"0A\";    // x'0A' is a byte vector literal\nlet c = vector[1, 2, 3]; // vector[] is a vector literal\n\nOperators\n\nArithmetic, logical, and bitwise operators are used to perform operations on values. The result of an operation is a value, so operators are also expressions.\n\nlet sum = 1 + 2;   // 1 + 2 is an expression\nlet sum = (1 + 2); // the same expression with parentheses\nlet is_true = true && false; // true && false is an expression\nlet is_true = (true && false); // the same expression with parentheses\n\nBlocks\n\nA block is a sequence of statements and expressions, and it returns the value of the last expression in the block. A block is written as a pair of curly braces {}. A block is an expression, so it can be used anywhere an expression is expected.\n\n// block with an empty expression, however, the compiler will\n// insert an empty expression automatically: `let none = { () }`\n// let none = {};\n\n// block with let statements and an expression.\nlet sum = {\n    let a = 1;\n    let b = 2;\n    a + b // last expression is the value of the block\n};\n\n// block is an expression, so it can be used in an expression and\n// doesn't have to be assigned to a variable.\n{\n    let a = 1;\n    let b = 2;\n    a + b; // not returned - semicolon.\n    // compiler automatically inserts an empty expression `()`\n};\n\nFunction Calls\n\nWe go into detail about functions in the Functions section. However, we already used function calls in the previous sections, so it's worth mentioning them here. A function call is an expression that calls a function and returns the value of the last expression in the function body.\n\nfun add(a: u8, b: u8): u8 {\n    a + b\n}\n\n#[test]\nfun some_other() {\n    let sum = add(1, 2); // add(1, 2) is an expression with type u8\n}\n\nControl Flow Expressions\n\nControl flow expressions are used to control the flow of the program. They are also expressions, so they return a value. We cover control flow expressions in the Control Flow section. Here's a very brief overview:\n\n// if is an expression, so it returns a value; if there are 2 branches,\n// the types of the branches must match.\nif (bool_expr) expr1 else expr2;\n\n// while is an expression, but it returns `()`.\nwhile (bool_expr) { expr; };\n\n// loop is an expression, but returns `()` as well.\nloop { expr; break };\n"
    },
    {
      "title": "Address Type - The Move Book",
      "url": "https://move-book.com/move-basics/address.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAddress Type\n\nTo represent addresses, Move uses a special type called address. It is a 32 byte value that can be used to represent any address on the blockchain. Addresses are used in two syntax forms: hexadecimal addresses prefixed with 0x and named addresses.\n\n// address literal\nlet value: address = @0x1;\n\n// named address registered in Move.toml\nlet value = @std;\nlet other = @sui;\n\n\nAn address literal starts with the @ symbol followed by a hexadecimal number or an identifier. The hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the Move.toml file and replaced with the corresponding address by the compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.\n\nConversion\n\nSui Framework offers a set of helper functions to work with addresses. Given that the address type is a 32 byte value, it can be converted to a u256 type and vice versa. It can also be converted to and from a vector<u8> type.\n\nExample: Convert an address to a u256 type and back.\n\nuse sui::address;\n\nlet addr_as_u256: u256 = address::to_u256(@0x1);\nlet addr = address::from_u256(addr_as_u256);\n\n\nExample: Convert an address to a vector<u8> type and back.\n\nuse sui::address;\n\nlet addr_as_u8: vector<u8> = address::to_bytes(@0x1);\nlet addr = address::from_bytes(addr_as_u8);\n\n\nExample: Convert an address into a string.\n\nuse sui::address;\nuse std::string::String;\n\nlet addr_as_string: String = address::to_string(@0x1);\n\nFurther reading\nAddress in the Move Reference."
    },
    {
      "title": "Primitive Types - The Move Book",
      "url": "https://move-book.com/move-basics/primitive-types.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nPrimitive Types\n\nFor simple values, Move has a number of built-in primitive types. They're the base that makes up all other types. The primitive types are:\n\nBooleans\nUnsigned Integers\nAddress - covered in the next section\n\nHowever, before we get to the types, let's first look at how to declare and assign variables in Move.\n\nVariables and assignment\n\nVariables are declared using the let keyword. They are immutable by default, but can be made mutable using the let mut keyword. The syntax for the let mut statement is:\n\nlet <variable_name>[: <type>]  = <expression>;\nlet mut <variable_name>[: <type>] = <expression>;\n\n\nWhere:\n\n<variable_name> - the name of the variable\n<type> - the type of the variable, optional\n<expression> - the value to be assigned to the variable\nlet x: bool = true;\nlet mut y: u8 = 42;\n\n\nA mutable variable can be reassigned using the = operator.\n\ny = 43;\n\n\nVariables can also be shadowed by re-declaring.\n\nlet x: u8 = 42;\nlet x: u8 = 43;\n\nBooleans\n\nThe bool type represents a boolean value - yes or no, true or false. It has two possible values: true and false which are keywords in Move. For booleans, there's no need to explicitly specify the type - the compiler can infer it from the value.\n\nlet x = true;\nlet y = false;\n\n\nBooleans are often used to store flags and to control the flow of the program. Please, refer to the Control Flow section for more information.\n\nInteger Types\n\nMove supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:\n\nu8 - 8-bit\nu16 - 16-bit\nu32 - 32-bit\nu64 - 64-bit\nu128 - 128-bit\nu256 - 256-bit\nlet x: u8 = 42;\nlet y: u16 = 42;\n// ...\nlet z: u256 = 42;\n\n\nUnlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer the type from the value, usually defaulting to u64. However, sometimes the compiler is unable to infer the type and will require an explicit type annotation. It can either be provided during assignment or by using a type suffix.\n\n// Both are equivalent\nlet x: u8 = 42;\nlet x = 42u8;\n\nOperations\n\nMove supports the standard arithmetic operations for integers: addition, subtraction, multiplication, division, and remainder. The syntax for these operations is:\n\nSyntax\tOperation\tAborts If\n+\taddition\tResult is too large for the integer type\n-\tsubtraction\tResult is less than zero\n*\tmultiplication\tResult is too large for the integer type\n%\tmodular division\tThe divisor is 0\n/\ttruncating division\tThe divisor is 0\n\nThe type of the operands must match, otherwise, the compiler will raise an error. The result of the operation will be of the same type as the operands. To perform operations on different types, the operands need to be cast to the same type.\n\nCasting with as\n\nMove supports explicit casting between integer types. The syntax for it is:\n\n(<expression> as <type>)\n\n\nNote, that it requires parentheses around the expression to prevent ambiguity.\n\nlet x: u8 = 42;\nlet y: u16 = (x as u16);\n\n\nA more complex example, preventing overflow:\n\nlet x: u8 = 255;\nlet y: u8 = 255;\nlet z: u16 = (x as u16) + ((y as u16) * 2);\n\nOverflow\n\nMove does not support overflow / underflow, an operation that results in a value outside the range of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.\n\nlet x = 255u8;\nlet y = 1u8;\n\n// This will raise an error\nlet z = x + y;\n\nFurther reading\nBool in the Move Reference.\nInteger in the Move Reference."
    },
    {
      "title": "Comments - The Move Book",
      "url": "https://move-book.com/move-basics/comments.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nComments\n\nComments are a way to add notes or document your code. They are ignored by the compiler and don't result in the Move bytecode. You can use comments to explain what your code does, to add notes to yourself or other developers, to temporarily remove a part of your code, or to generate documentation. There are three types of comments in Move: line comment, block comment, and doc comment.\n\nLine comment\nmodule book::comments_line {\n    fun some_function() {\n        // this is a comment line\n    }\n}\n\n\nYou can use double slash // to comment out the rest of the line. Everything after // will be ignored by the compiler.\n\nmodule book::comments_line_2 {\n    // let's add a note to everything!\n    fun some_function_with_numbers() {\n        let a = 10;\n        // let b = 10 this line is commented and won't be executed\n        let b = 5; // here comment is placed after code\n        a + b; // result is 15, not 10!\n    }\n}\n\nBlock comment\n\nBlock comments are used to comment out a block of code. They start with /* and end with */. Everything between /* and */ will be ignored by the compiler. You can use block comments to comment out a single line or multiple lines. You can even use them to comment out a part of a line.\n\nmodule book::comments_block {\n    fun /* you can comment everywhere */ go_wild() {\n        /* here\n           there\n           everywhere */ let a = 10;\n        let b = /* even here */ 10; /* and again */\n        a + b;\n    }\n    /* you can use it to remove certain expressions or definitions\n    fun empty_commented_out() {\n\n    }\n    */\n}\n\n\nThis example is a bit extreme, but it shows how you can use block comments to comment out a part of a line.\n\nDoc comment\n\nDocumentation comments are special comments that are used to generate documentation for your code. They are similar to block comments, but they start with three slashes /// and are placed before the definition of the item they document.\n\n/// Module has documentation!\nmodule book::comments_doc {\n\n    /// This is a 0x0 address constant!\n    const AN_ADDRESS: address = @0x0;\n\n    /// This is a struct!\n    public struct AStruct {\n        /// This is a field of a struct!\n        a_field: u8,\n    }\n\n    /// This function does something!\n    /// And it's documented!\n    fun do_something() {}\n}\n"
    },
    {
      "title": "Module - The Move Book",
      "url": "https://move-book.com/move-basics/module.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nModule\n\nModule is the base unit of code organization in Move. Modules are used to group and isolate code, and all of the members of the module are private to the module by default. In this section you will learn how to define a module, how to declare its members and how to access them from other modules.\n\nModule declaration\n\nModules are declared using the module keyword followed by the package address, module name and the module body inside the curly braces {}. The module name should be in snake_case - all lowercase letters with underscores between words. Modules names must be unique in the package.\n\nUsually, a single file in the sources/ folder contains a single module. The file name should match the module name - for example, a donut_shop module should be stored in the donut_shop.move file. You can read more about coding conventions in the Coding Conventions section.\n\nmodule book::my_module {\n    // module body\n}\n\n\nStructs, functions, constants and imports all part of the module:\n\nStructs\nFunctions\nConstants\nImports\nStruct Methods\nAddress / Named address\n\nModule address can be specified as both: an address literal (does not require the @ prefix) or a named address specified in the Package Manifest. In the example below, both are identical because there's a book = \"0x0\" record in the [addresses] section of the Move.toml.\n\nmodule 0x0::address_literal { /* ... */ }\nmodule book::named_address { /* ... */ }\n\n\nAddresses section in the Move.toml:\n\n# Move.toml\n[addresses]\nbook = \"0x0\"\n\nModule members\n\nModule members are declared inside the module body. To illustrate that, let's define a simple module with a struct, a function and a constant:\n\nmodule book::my_module_with_members {\n    // import\n    use book::my_module;\n\n    // a constant\n    const CONST: u8 = 0;\n\n    // a struct\n    public struct Struct {}\n\n    // method alias\n    public use fun function as Struct.struct_fun;\n\n    // function\n    fun function(_: &Struct) { /* function body */ }\n}\n\nFurther reading\nModules in the Move Reference."
    },
    {
      "title": "Move Basics - The Move Book",
      "url": "https://move-book.com/move-basics/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nMove Basics\n\nThis chapter is all about the basic syntax of the Move language. It covers the basics of the language, such as types, modules, functions, and control flow. It focuses on the language without a storage model or a blockchain, and explains the essential concepts of the language. To learn features specific to Sui, such as storage functions and abilities, refer to the Using Objects chapter, however, it is recommended to start with this chapter first."
    },
    {
      "title": "Transaction - The Move Book",
      "url": "https://move-book.com/concepts/what-is-a-transaction.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nTransaction\n\nTransaction is a fundamental concept in the blockchain world. It is a way to interact with a blockchain. Transactions are used to change the state of the blockchain, and they are the only way to do so. In Move, transactions are used to call functions in a package, deploy new packages, and upgrade existing ones.\n\nTransaction Structure\n\nEvery transaction explicitly specifies the objects it operates on!\n\nTransactions consist of:\n\na sender - the account that signs the transaction;\na list (or a chain) of commands - the operations to be executed;\ncommand inputs - the arguments for the commands: either pure - simple values like numbers or strings, or object - objects that the transaction will access;\na gas object - the Coin object used to pay for the transaction;\ngas price and budget - the cost of the transaction;\nCommands\n\nSui transactions may consist of multiple commands. Each command is a single built-in command (like publishing a package) or a call to a function in an already published package. The commands are executed in the order they are listed in the transaction, and they can use the results of the previous commands, forming a chain. Transaction either succeeds or fails as a whole.\n\nSchematically, a transaction looks like this (in pseudo-code):\n\nInputs:\n- sender = 0xa11ce\n\nCommands:\n- payment = SplitCoins(Gas, [ 1000 ])\n- item = MoveCall(0xAAA::market::purchase, [ payment ])\n- TransferObjects(item, sender)\n\n\nIn this example, the transaction consists of three commands:\n\nSplitCoins - a built-in command that splits a new coin from the passed object, in this case, the Gas object;\nMoveCall - a command that calls a function purchase in a package 0xAAA, module market with the given arguments - the payment object;\nTransferObjects - a built-in command that transfers the object to the recipient.\nTransaction Effects\n\nTransaction effects are the changes that a transaction makes to the blockchain state. More specifically, a transaction can change the state in the following ways:\n\nuse the gas object to pay for the transaction;\ncreate, update, or delete objects;\nemit events;\n\nThe result of the executed transaction consists of different parts:\n\nTransaction Digest - the hash of the transaction which is used to identify the transaction;\nTransaction Data - the inputs, commands and gas object used in the transaction;\nTransaction Effects - the status and the \"effects\" of the transaction, more specifically: the status of the transaction, updates to objects and their new versions, the gas object used, the gas cost of the transaction, and the events emitted by the transaction;\nEvents - the custom events emitted by the transaction;\nObject Changes - the changes made to the objects, including the change of ownership;\nBalance Changes - the changes made to the aggregate balances of the account involved in the transaction;"
    },
    {
      "title": "Account - The Move Book",
      "url": "https://move-book.com/concepts/what-is-an-account.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAccount\n\nAn account is a way to identify a user. An account is generated from a private key, and is identified by an address. An account can own objects, and can send transactions. Every transaction has a sender, and the sender is identified by an address.\n\nSui supports multiple cryptographic algorithms for account generation. The two supported curves are ed25519, secp256k1, and there is also a special way of generating an account - zklogin. The cryptographic agility - the unique feature of Sui - allows for flexibility in the account generation.\n\nFurther Reading\nCryptography in Sui in the Sui Blog\nKeys and Addresses in the Sui Docs\nSignatures in the Sui Docs"
    },
    {
      "title": "Address - The Move Book",
      "url": "https://move-book.com/concepts/address.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nAddress\n\nAddress is a unique identifier of a location on the blockchain. It is used to identify packages, accounts, and objects. Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed with 0x. Addresses are case insensitive.\n\n0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1\n\n\nThe address above is an example of a valid address. It is 64 characters long (32 bytes) and prefixed with 0x.\n\nSui also has reserved addresses that are used to identify standard packages and objects. Reserved addresses are typically simple values that are easy to remember and type. For example, the address of the Standard Library is 0x1. Addresses, shorter than 32 bytes, are padded with zeros to the left.\n\n0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001\n\n\nHere are some examples of reserved addresses:\n\n0x1 - address of the Sui Standard Library (alias std)\n0x2 - address of the Sui Framework (alias sui)\n0x6 - address of the system Clock object\n\nYou can find all reserved addresses in the Appendix B.\n\nFurther reading\nAddress type in Move"
    },
    {
      "title": "Manifest - The Move Book",
      "url": "https://move-book.com/concepts/manifest.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nPackage Manifest\n\nThe Move.toml is a manifest file that describes the package and its dependencies. It is written in TOML format and contains multiple sections, the most important of which are [package], [dependencies] and [addresses].\n\n[package]\nname = \"my_project\"\nversion = \"0.0.0\"\nedition = \"2024\"\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n[addresses]\nstd =  \"0x1\"\nalice = \"0xA11CE\"\n\n[dev-addresses]\nalice = \"0xB0B\"\n\nSections\nPackage\n\nThe [package] section is used to describe the package. None of the fields in this section are published on chain, but they are used in tooling and release management; they also specify the Move edition for the compiler.\n\nname - the name of the package when it is imported;\nversion - the version of the package, can be used in release management;\nedition - the edition of the Move language; currently, the only valid value is 2024.\nDependencies\n\nThe [dependencies] section is used to specify the dependencies of the project. Each dependency is specified as a key-value pair, where the key is the name of the dependency, and the value is the dependency specification. The dependency specification can be a git repository URL or a path to the local directory.\n\n# git repository\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\n# local directory\nMyPackage = { local = \"../my-package\" }\n\n\nPackages also import addresses from other packages. For example, the Sui dependency adds the std and sui addresses to the project. These addresses can be used in the code as aliases for the addresses.\n\nResolving version conflicts with override\n\nSometimes dependencies have conflicting versions of the same package. For example, if you have two dependencies that use different versions of the Sui package, you can override the dependency in the [dependencies] section. To do so, add the override field to the dependency. The version of the dependency specified in the [dependencies] section will be used instead of the one specified in the dependency itself.\n\n[dependencies]\nSui = { override = true, git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n\nDev-dependencies\n\nIt is possible to add [dev-dependencies] section to the manifest. It is used to override dependencies in the dev and test modes. For example, if you want to use a different version of the Sui package in the dev mode, you can add a custom dependency specification to the [dev-dependencies] section.\n\nAddresses\n\nThe [addresses] section is used to add aliases for the addresses. Any address can be specified in this section, and then used in the code as an alias. For example, if you add alice = \"0xA11CE\" to this section, you can use alice as 0xA11CE in the code.\n\nDev-addresses\n\nThe [dev-addresses] section is the same as [addresses], but only works for the test and dev modes. Important to note that it is impossible to introduce new aliases in this section, only override the existing ones. So in the example above, if you add alice = \"0xB0B\" to this section, the alice address will be 0xB0B in the test and dev modes, and 0xA11CE in the regular build.\n\nTOML styles\n\nThe TOML format supports two styles for tables: inline and multiline. The examples above are using the inline style, but it is also possible to use the multiline style. You wouldn't want to use it for the [package] section, but it can be useful for the dependencies.\n\n# Inline style\n[dependencies]\nSui = { override = true, git = \"\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nMyPackage = { local = \"../my-package\" }\n\n# Multiline style\n[dependencies.Sui]\noverride = true\ngit = \"https://github.com/MystenLabs/sui.git\"\nsubdir = \"crates/sui-framework/packages/sui-framework\"\nrev = \"framework/testnet\"\n\n[dependencies.MyPackage]\nlocal = \"../my-package\"\n\nFurther Reading\nPackages in the Move Reference."
    },
    {
      "title": "Package - The Move Book",
      "url": "https://move-book.com/concepts/packages.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nPackage\n\nMove is a language for writing smart contracts - programs that are stored and run on the blockchain. A single program is organized into a package. A package is published on the blockchain and is identified by an address. A published package can be interacted with by sending transactions calling its functions. It can also act as a dependency for other packages.\n\nTo create a new package, use the sui move new command. To learn more about the command, run sui move new --help.\n\nPackage consists of modules - separate scopes that contain functions, types, and other items.\n\npackage 0x...\n    module a\n        struct A1\n        fun hello_world()\n    module b\n        struct B1\n        fun hello_package()\n\nPackage Structure\n\nLocally, a package is a directory with a Move.toml file and a sources directory. The Move.toml file - called the \"package manifest\" - contains metadata about the package, and the sources directory contains the source code for the modules. Package usually looks like this:\n\nsources/\n    my_module.move\n    another_module.move\n    ...\ntests/\n    ...\nexamples/\n    using_my_module.move\nMove.toml\n\n\nThe tests directory is optional and contains tests for the package. Code placed into the tests directory is not published on-chain and is only availably in tests. The examples directory can be used for code examples, and is also not published on-chain.\n\nPublished Package\n\nDuring development, package doesn't have an address and it needs to be set to 0x0. Once a package is published, it gets a single unique address on the blockchain containing its modules' bytecode. A published package becomes immutable and can be interacted with by sending transactions.\n\n0x...\n    my_module: <bytecode>\n    another_module: <bytecode>\n\nLinks\nPackage Manifest\nAddress\nPackages in the Move Reference."
    },
    {
      "title": "Concepts - The Move Book",
      "url": "https://move-book.com/concepts/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nConcepts\n\nIn this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a package, how to interact with it, what is an account and a transaction, and how data is stored on Sui. While this chapter is not a complete reference, and you should refer to the Sui Documentation for that, it will give you a good understanding of the basic concepts required to write Move programs on Sui."
    },
    {
      "title": "Hello, Sui! - The Move Book",
      "url": "https://move-book.com/your-first-move/hello-sui.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nHello, Sui!\n\nIn the previous section we created a new package and demonstrated the basic flow of creating, building, and testing a Move package. In this section, we will write a simple application that uses the storage model and can be interacted with. To do this, we will create a simple todo list application.\n\nCreate a New Package\n\nFollowing the same flow as in Hello, World!, we will create a new package called todo_list.\n\n$ sui move new todo_list\n\nAdd the code\n\nTo speed things up and focus on the application logic, we will provide the code for the todo list application. Replace the contents of the sources/todo_list.move file with the following code:\n\nNote: while the contents may seem overwhelming at first, we will break it down in the following sections. Try to focus on what's at hand right now.\n\n/// Module: todo_list\nmodule todo_list::todo_list {\n    use std::string::String;\n\n    /// List of todos. Can be managed by the owner and shared with others.\n    public struct TodoList has key, store {\n        id: UID,\n        items: vector<String>\n    }\n\n    /// Create a new todo list.\n    public fun new(ctx: &mut TxContext): TodoList {\n        let list = TodoList {\n            id: object::new(ctx),\n            items: vector[]\n        };\n\n        (list)\n    }\n\n    /// Add a new todo item to the list.\n    public fun add(list: &mut TodoList, item: String) {\n        list.items.push_back(item);\n    }\n\n    /// Remove a todo item from the list by index.\n    public fun remove(list: &mut TodoList, index: u64): String {\n        list.items.remove(index)\n    }\n\n    /// Delete the list and the capability to manage it.\n    public fun delete(list: TodoList) {\n        let TodoList { id, items: _ } = list;\n        id.delete();\n    }\n\n    /// Get the number of items in the list.\n    public fun length(list: &TodoList): u64 {\n        list.items.length()\n    }\n}\n\nBuild the package\n\nTo make sure that we did everything correctly, let's build the package by running the sui move build command. If everything is correct, you should see the output similar to the following:\n\n$ sui move build\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\n\n\nIf there are no errors following this output, you have successfully built the package. If there are errors, make sure that:\n\nThe code is copied correctly\nThe file name and the package name is correct\n\nThere are not many other reasons for the code to fail at this stage. But if you are still having issues, try looking up the structure of the package in this location.\n\nSet up an account\n\nTo publish and interact with the package, we need to set up an account. For the sake of simplicity and demonstration purposes, we will use sui devnet environment.\n\nIf you already have an account set up, you can skip this step.\n\nIf you are doing it for the first time, you will need to create a new account. To do this, run the sui client command, then the CLI will prompt you with multiple questions. The answers are marked below with >:\n\n$ sui client\nConfig file [\"/path/to/home/.sui/sui_config/client.yaml\"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?\n> y\nSui Full node server URL (Defaults to Sui Testnet if not specified) :\n>\nSelect key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):\n> 0\n\n\nAfter you have answered the questions, the CLI will generate a new keypair and save it to the configuration file. You can now use this account to interact with the network.\n\nTo check that we have the account set up correctly, run the sui client active-address command:\n\n$ sui client active-address\n0x....\n\n\nThe command will output the address of your account, it starts with 0x followed by 64 characters.\n\nRequesting Coins\n\nIn devnet and testnet environments, the CLI provides a way to request coins to your account, so you can interact with the network. To request coins, run the sui client faucet command:\n\n$ sui client faucet\nRequest successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.\n\n\nAfter waiting a little bit, you can check that the Coin object was sent to your account by running the sui client balance command:\n\n$ sui client balance\n╭────────────────────────────────────────╮\n│ Balance of coins owned by this address │\n├────────────────────────────────────────┤\n│ ╭──────────────────────────────────╮   │\n│ │ coin  balance (raw)  balance     │   │\n│ ├──────────────────────────────────┤   │\n│ │ Sui   1000000000    1.00 SUI     │   │\n│ ╰──────────────────────────────────╯   │\n╰────────────────────────────────────────╯\n\n\nAlternatively, you can query objects owned by your account, by running the sui client objects command. The actual output will be different, because the object ID is unique, and so is digest, but the structure will be similar:\n\n$ sui client objects\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │\n│ │ version    │  4                                                                   │ │\n│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                            │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n\n\nNow that we have the account set up and the coins in the account, we can interact with the network. We will start by publishing the package to the network.\n\nPublish\n\nTo publish the package to the network, we will use the sui client publish command. The command will automatically build the package and use its bytecode to publish in a single transaction.\n\nWe are using the --gas-budget argument during publishing. It specifies how much gas we are willing to spend on the transaction. We won't touch on this topic in this section, but it's important to know that every transaction in Sui costs gas, and the gas is paid in SUI coins.\n\nThe gas-budget is specified in MISTs. 1 SUI equals 10^9 MISTs. For the sake of demonstration, we will use 100,000,000 MISTs, which is 0.1 SUI.\n\n# run this from the `todo_list` folder\n$ sui client publish --gas-budget 100000000\n\n# alternatively, you can specify path to the package\n$ sui client publish --gas-budget 100000000 todo_list\n\n\nThe output of the publish command is rather lengthy, so we will show and explain it in parts.\n\n$ sui client publish --gas-budget 100000000\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\nSuccessfully verified dependencies on-chain against source.\nTransaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW\n\n\nAs you can see, when we run the publish command, the CLI first builds the package, then verifies the dependencies on-chain, and finally publishes the package. The output of the command is the transaction digest, which is a unique identifier of the transaction and can be used to query the transaction status.\n\nTransaction Data\n\nThe section titled TransactionData contains the information about the transaction we just sent. It features fields like sender, which is your address, the gas_budget set with the --gas-budget argument, and the Coin we used for payment. It also prints the Commands that were run by the CLI. In this example, the commands Publish and TransferObject were run - the latter transfers a special object UpgradeCap to the sender.\n\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │\n│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │\n│ Gas Budget: 100000000 MIST                                                                                   │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │\n│  │ Version: 7                                                                                                │\n│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\" │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │\n│ │ Commands                                                                │                                  │\n│ ├─────────────────────────────────────────────────────────────────────────┤                                  │\n│ │ 0  Publish:                                                             │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Dependencies:                                                        │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │\n│ │  └                                                                      │                                  │\n│ │                                                                         │                                  │\n│ │ 1  TransferObjects:                                                     │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Arguments:                                                           │                                  │\n│ │  │   Result 0                                                           │                                  │\n│ │  │ Address: Input  0                                                    │                                  │\n│ │  └                                                                      │                                  │\n│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nTransaction Effects\n\nTransaction Effects contains the status of the transaction, the changes that the transaction made to the state of the network and the objects involved in the transaction.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 411                                                                               │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │\n│  │ Owner: Immutable                                                                               │\n│  │ Version: 1                                                                                     │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 10404400 MIST                                                                    │\n│    Computation Cost: 1000000 MIST                                                                 │\n│    Storage Rebate: 978120 MIST                                                                    │\n│    Non-refundable Storage Fee: 9880 MIST                                                          │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │\n│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nEvents\n\nIf there were any events emitted, you would see them in this section. Our package does not use events, so the section is empty.\n\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n\nObject Changes\n\nThese are the changes to objects that transaction has made. In our case, we have created a new UpgradeCap object which is a special object that allows the sender to upgrade the package in the future, mutated the Gas object, and published a new package. Packages are also objects on Sui.\n\n╭──────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                   │\n├──────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::package::UpgradeCap                                                          │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │\n│  └──                                                                                             │\n│ Mutated Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │\n│  └──                                                                                             │\n│ Published Objects:                                                                               │\n│  ┌──                                                                                             │\n│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │\n│  │ Version: 1                                                                                    │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │\n│  │ Modules: todo_list                                                                            │\n│  └──                                                                                             │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nBalance Changes\n\nThis last section contains changes to SUI Coins, in our case, we have spent around 0.015 SUI, which in MIST is 10,500,000. You can see it under the amount field in the output.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Balance Changes                                                                                   │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: -10426280                                                                              │\n│  └──                                                                                              │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n\nAlternative Output\n\nIt is possible to specify the --json flag during publishing to get the output in JSON format. This is useful if you want to parse the output programmatically or store it for later use.\n\n$ sui client publish --gas-budget 100000000 --json\n\nUsing the Results\n\nAfter the package is published on chain, we can interact with it. To do this, we need to find the address (object ID) of the package. It's under the Published Objects section of the Object Changes output. The address is unique for each package, so you will need to copy it from the output.\n\nIn this example, the address is:\n\n0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\n\n\nNow that we have the address, we can interact with the package. In the next section, we will show how to interact with the package by sending transactions.\n\nSending Transactions\n\nTo demonstrate the interaction with the todo_list package, we will send a transaction to create a new list and add an item to it. Transactions are sent via the sui client ptb command, it allows using the Transaction Blocks at full capacity. The command may look big and complex, but we go through it step by step.\n\nPrepare the Variables\n\nBefore we construct the command, let's store the values we will use in the transaction. Replace the 0x4.... with the address of the package you have published. And MY_ADDRESS variable will be automatically set to your address from the CLI output.\n\n$ export PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\n$ export MY_ADDRESS=$(sui client active-address)\n\nBuilding the Transaction in CLI\n\nNow to building an actual transaction. The transaction will consist of two parts: we will call the new function in the todo_list package to create a new list, and then we will transfer the list object to our account. The transaction will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--assign sender @$MY_ADDRESS \\\n--move-call $PACKAGE_ID::todo_list::new \\\n--assign list \\\n--transfer-objects \"[list]\" sender\n\n\nIn this command, we are using the ptb subcommand to build a transaction. Parameters that follow it define the actual commands and actions that the transaction will perform. The first two calls we make are utility calls to set the sender address to the command inputs and set the gas budget for the transaction.\n\n# sets the gas budget for the transaction\n--gas-budget 100000000 \\n\n# registers a variable \"sender=@...\"\n--assign sender @$MY_ADDRESS \\n\n\n\nThen we perform the actual call to a function in the package. We use the --move-call followed by the package ID, the module name, and the function name. In this case, we are calling the new function in the todo_list package.\n\n# calls the \"new\" function in the \"todo_list\" package under the $PACKAGE_ID address\n--move-call $PACKAGE_ID::todo_list::new\n\n\nThe function that we defined actually returns a value, which we want need to store. We use the --assign command to give a name to the returned value. In this case, we are calling it list. And then we transfer the object to our account.\n\n--move-call $PACKAGE_ID::todo_list::new \\\n# assigns the result of the \"new\" function to the \"list\" variable (from the previous step)\n--assign list \\\n# transfers the object to the sender\n--transfer-objects \"[list]\" sender\n\n\nOnce the command is constructed, you can run it in the terminal. If everything is correct, you should see the output similar to the one we had in previous sections. The output will contain the transaction digest, the transaction data, and the transaction effects.\n\nSpoiler: Full transaction output\n\nThe section that we want to focus on is the \"Object Changes\". More specifically, the \"Created Objects\" part of it. It contains the object ID, the type and the version of the TodoList that you have created. We will use this object ID to interact with the list.\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                        │\n├───────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                      │\n│  ┌──                                                                                                  │\n│  │ ObjectID: 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                       │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │\n│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │\n│  │ Version: 22                                                                                        │\n│  │ Digest: HyWdUpjuhjLY38dLpg6KPHQ3bt4BqQAbdF5gB8HQdEqG                                               │\n│  └──                                                                                                  │\n│ Mutated Objects:                                                                                      │\n│  ┌──                                                                                                  │\n│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │\n│  │ Version: 22                                                                                        │\n│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                               │\n│  └──                                                                                                  │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\nIn this example the object ID is 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553. And the owner should be your account address. We achieved this by transferring the object to the sender in the last command of the transaction.\n\nAnother way to test that you have successfully created the list is to check the account objects.\n\n$ sui client objects\n\n\nIt should have an object that looks similar to this:\n\n╭  ...                                                                                  ╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │\n│ │ version    │  22                                                                  │ │\n│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │\n│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n|  ...                                                                                  |\n\nPassing Objects to Functions\n\nThe TodoList that we created in the previous step is an object that you can interact with as its owner. You can call functions defined in the todo_list module on this object. To demonstrate this, we will add an item to the list. First, we will add just one item, and in the second transaction we will add 3 and remove another one.\n\nDouble check that you have variables set up from the previous step, and then add one more variable for the list object.\n\n$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\n\n\nNow we can construct the transaction to add an item to the list. The command will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish the Hello, Sui chapter'\"\n\n\nIn this command, we are calling the add function in the todo_list package. The function takes two arguments: the list object and the item to add. The item is a string, so we need to wrap it in single quotes. The command will add the item to the list.\n\nIf everything is correct, you should see the output similar to the one we had in previous sections. Now you can check the list object to see if the item was added.\n\n$ sui client object $LIST_ID\n\n\nThe output should contain the item that you have added.\n\n╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │\n│ version       │  24                                                                                                               │\n│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │\n│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │\n│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │\n│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │\n│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │\n│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │\n│ storageRebate │  1558000                                                                                                          │\n│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │\n│               │ │ dataType          │  moveObject                                                                               │ │\n│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │\n│               │ │ hasPublicTransfer │  true                                                                                     │ │\n│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │\n│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │\n│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │\n│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │\n│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │\n│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │\n│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │\n│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │\n│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │\n╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\nA JSON representation of the object can be obtained by adding the --json flag to the command.\n\n$ sui client object $LIST_ID --json\n\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"24\",\n  \"digest\": \"FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1\",\n  \"storageRebate\": \"1558000\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\"Finish the Hello, Sui chapter\"]\n    }\n  }\n}\n\nChaining Commands\n\nYou can chain multiple commands in a single transaction. This shows the power of Transaction Blocks! Using the same list object, we will add three more items and remove one. The command will look like this:\n\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish Concepts chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Read the Move Basics chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Learn about Object Model'\" \\\n--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0\n\n\nIf previous commands were successful, this one should not be any different. You can check the list object to see if the items were added and removed. The JSON representation is a bit more readable!\n\nsui client object $LIST_ID --json\n\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"25\",\n  \"digest\": \"EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY\",\n  \"storageRebate\": \"1922800\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\n        \"Finish Concepts chapter\",\n        \"Read the Move Basics chapter\",\n        \"Learn about Object Model\"\n      ]\n    }\n  }\n}\n\n\nCommands don't have to be in the same package or operate on the same object. Within a single transaction block, you can interact with multiple packages and objects. This is a powerful feature that allows you to build complex interactions on-chain!\n\nConclusion\n\nIn this guide, we have shown how to publish a package on the Move blockchain and interact with it using the Sui CLI. We have demonstrated how to create a new list object, add items to it, and remove them. We have also shown how to chain multiple commands in a single transaction block. This guide should give you a good starting point for building your own applications on the Sui blockchain!"
    },
    {
      "title": "Hello, World! - The Move Book",
      "url": "https://move-book.com/your-first-move/hello-world.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nHello, World!\n\nIn this chapter, you will learn how to create a new package, write a simple module, compile it, and run tests with the Move CLI. Make sure you have installed Sui and set up your IDE environment. Run the command below to test if Sui has been installed correctly.\n\n# It should print the client version. E.g. sui-client 1.22.0-036299745.\nsui client --version\n\n\nMove CLI is a command-line interface for the Move language; it is built into the Sui binary and provides a set of commands to manage packages, compile and test code.\n\nThe structure of the chapter is as follows:\n\nCreate a New Package\nDirectory Structure\nCompiling the Package\nRunning Tests\nCreate a New Package\n\nTo create a new program, we will use the sui move new command followed by the name of the application. Our first program will be called hello_world.\n\nNote: In this and other chapters, if you see code blocks with lines starting with $ (dollar sign), it means that the following command should be run in a terminal. The sign should not be included. It's a common way of showing commands in terminal environments.\n\n$ sui move new hello_world\n\n\nThe sui move command gives access to the Move CLI - a built-in compiler, test runner and a utility for all things Move. The new command followed by the name of the package will create a new package in a new folder. In our case, the folder name is \"hello_world\".\n\nWe can view the contents of the folder to see that the package was created successfully.\n\n$ ls -l hello_world\nMove.toml\nsources\ntests\n\nDirectory Structure\n\nMove CLI will create a scaffold of the application and pre-create the directory structure and all necessary files. Let's see what's inside.\n\nhello_world\n├── Move.toml\n├── sources\n│   └── hello_world.move\n└── tests\n    └── hello_world_tests.move\n\nManifest\n\nThe Move.toml file, known as the package manifest, contains definitions and configuration settings for the package. It is used by the Move Compiler to manage package metadata, fetch dependencies, and register named addresses. We will explain it in detail in the Concepts chapter.\n\nBy default, the package features one named address - the name of the package.\n\n[addresses]\nhello_world = \"0x0\"\n\nSources\n\nThe sources/ directory contains the source files. Move source files have .move extension, and are typically named after the module defined in the file. For example, in our case, the file name is hello_world.move and the Move CLI has already placed commented out code inside:\n\n/*\n/// Module: hello_world\nmodule hello_world::hello_world {\n\n}\n*/\n\n\nThe /* and */ are the comment delimiters in Move. Everything in between is ignored by the compiler and can be used for documentation or notes. We explain all ways to comment the code in the Basic Syntax.\n\nThe commented out code is a module definition, it starts with the keyword module followed by a named address (or an address literal), and the module name. The module name is a unique identifier for the module and has to be unique within the package. The module name is used to reference the module from other modules or transactions.\n\nTests\n\nThe tests/ directory contains package tests. The compiler excludes these files in the regular build process but uses them in test and dev modes. The tests are written in Move and are marked with the #[test] attribute. Tests can be grouped in a separate module (then it's usually called module_name_tests.move), or inside the module they're testing.\n\nModules, imports, constants and functions can be annotated with #[test_only]. This attribute is used to exclude modules, functions or imports from the build process. This is useful when you want to add helpers for your tests without including them in the code that will be published on chain.\n\nThe hello_world_tests.move file contains a commented out test module template:\n\n/*\n#[test_only]\nmodule hello_world::hello_world_tests {\n    // uncomment this line to import the module\n    // use hello_world::hello_world;\n\n    const ENotImplemented: u64 = 0;\n\n    #[test]\n    fun test_hello_world() {\n        // pass\n    }\n\n    #[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]\n    fun test_hello_world_fail() {\n        abort ENotImplemented\n    }\n}\n*/\n\nOther Folders\n\nAdditionally, Move CLI supports the examples/ folder. The files there are treated similarly to the ones placed under the tests/ folder - they're only built in the test and dev modes. They are to be examples of how to use the package or how to integrate it with other packages. The most popular use case is for documentation purposes and library packages.\n\nCompiling the Package\n\nMove is a compiled language, and as such, it requires the compilation of source files into Move Bytecode. It contains only necessary information about the module, its members, and types, and excludes comments and some identifiers (for example, for constants).\n\nTo demonstrate these features, let's replace the contents of the sources/hello_world.move file with the following:\n\n/// The module `hello_world` under named address `hello_world`.\n/// The named address is set in the `Move.toml`.\nmodule hello_world::hello_world {\n    // Imports the `String` type from the Standard Library\n    use std::string::String;\n\n    /// Returns the \"Hello, World!\" as a `String`.\n    public fun hello_world(): String {\n        b\"Hello, World!\".to_string()\n    }\n}\n\n\nDuring compilation, the code is built, but not run. A compiled package only includes functions that can be called by other modules or in a transaction. We will explain these concepts in the Concepts chapter. But now, let's see what happens when we run the sui move build.\n\n# run from the `hello_world` folder\n$ sui move build\n\n# alternatively, if you didn't `cd` into it\n$ sui move build --path hello_world\n\n\nIt should output the following message on your console.\n\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\n\n\nDuring the compilation, Move Compiler automatically creates a build folder where it places all fetched and compiled dependencies as well as the bytecode for the modules of the current package.\n\nIf you're using a versioning system, such as Git, build folder should be ignored. For example, you should use a .gitignore file and add build to it.\n\nRunning Tests\n\nBefore we get to testing, we should add a test. Move Compiler supports tests written in Move and provides the execution environment. The tests can be placed in both the source files and in the tests/ folder. Tests are marked with the #[test] attribute and are automatically discovered by the compiler. We explain tests in depth in the Testing section.\n\nReplace the contents of the tests/hello_world_tests.move with the following content:\n\n#[test_only]\nmodule hello_world::hello_world_tests {\n    use hello_world::hello_world;\n\n    #[test]\n    fun test_hello_world() {\n        assert!(hello_world::hello_world() == b\"Hello, World!\".to_string(), 0);\n    }\n}\n\n\nHere we import the hello_world module, and call its hello_world function to test that the output is indeed the string \"Hello, World!\". Now, that we have tests in place, let's compile the package in the test mode and run tests. Move CLI has the test command for this:\n\n$ sui move test\n\n\nThe output should be similar to the following:\n\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\nRunning Move unit tests\n[ PASS    ] 0x0::hello_world_tests::test_hello_world\nTest result: OK. Total tests: 1; passed: 1; failed: 0\n\n\nIf you're running the tests outside of the package folder, you can specify the path to the package:\n\n$ sui move test --path hello_world\n\n\nYou can also run a single or multiple tests at once by specifying a string. All the tests names containing the string will be run:\n\n$ sui move test test_hello\n\nNext Steps\n\nIn this section, we explained the basics of a Move package: its structure, the manifest, the build, and test flows. On the next page, we will write an application and see how the code is structured and what the language can do.\n\nFurther Reading\nPackage Manifest section\nPackage in The Move Reference"
    },
    {
      "title": "Move 2024 - The Move Book",
      "url": "https://move-book.com/before-we-begin/move-2024.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nMove 2024\n\nMove 2024 is the new edition of the Move language maintained by Mysten Labs. All of the examples in this book are written in Move 2024. If you're used to the pre-2024 version of Move, please, refer to the Move 2024 Migration Guide to learn about the changes and improvements in the new edition."
    },
    {
      "title": "Set up your IDE - The Move Book",
      "url": "https://move-book.com/before-we-begin/ide-support.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nSet up your IDE\n\nThere are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide basic features like syntax highlighting and error messages, though they differ in their additional features. Whatever IDE you choose, you'll need to use the terminal to run the Move CLI.\n\nIntelliJ Plugin does not support Move 2024 edition, some syntax won't get highlighted.\n\nVSCode\nVSCode is a free and open source IDE from Microsoft.\nMove (Extension) is a language server extension for Move maintained by MystenLabs.\nMove Syntax a simple syntax highlighting extension for Move by Damir Shamanaev.\nIntelliJ IDEA\nIntelliJ IDEA is a commercial IDE from JetBrains.\nMove Language Plugin provides a Move language extension for IntelliJ IDEA by Pontem Network.\nEmacs\nEmacs is a free and open source text editor.\nmove-mode is a Move mode for Emacs by Ashok Menon.\nGithub Codespaces\n\nThe Web-based IDE from Github can be run right in the browser and provides almost a full-featured VSCode experience.\n\nGithub Codespaces\nMove Syntax is also available in the extensions marketplace."
    },
    {
      "title": "Install Sui - The Move Book",
      "url": "https://move-book.com/before-we-begin/install-sui.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nInstall Sui\n\nMove is a compiled language, so you need to install a compiler to be able to write and run Move programs. The compiler is included into the Sui binary, which can be installed or downloaded using one of the methods below.\n\nDownload Binary\n\nYou can download the latest Sui binary from the releases page. The binary is available for macOS, Linux and Windows. For education purposes and development, we recommend using the mainnet version.\n\nInstall using Homebrew (MacOS)\n\nYou can install Sui using the Homebrew package manager.\n\nbrew install sui\n\nInstall using Chocolatey (Windows)\n\nYou can install Sui using the Chocolatey package manager for Windows.\n\nchoco install sui\n\nBuild using Cargo (MacOS, Linux)\n\nYou can install and build Sui locally by using the Cargo package manager (requires Rust)\n\ncargo install --git https://github.com/MystenLabs/sui.git --bin sui --branch mainnet\n\n\nMake sure that your system has the latest Rust versions with the command below.\n\nrustup update stable\n\nTroubleshooting\n\nFor troubleshooting the installation process, please refer to the Install Sui Guide."
    },
    {
      "title": "Before we begin - The Move Book",
      "url": "https://move-book.com/before-we-begin/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nBefore we begin\n\nMove requires an environment to run and develop applications, and in this small chapter we will cover the prerequisites for the Move language: how to set up your IDE, how to install the compiler and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you can skip this chapter and proceed to the next one."
    },
    {
      "title": "Foreword - The Move Book",
      "url": "https://move-book.com/foreword.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nForeword\n\nThis book is dedicated to Move, a smart contract language that captures the essence of safe programming with digital assets. Move is designed around the following values:\n\nSecure by default: Insecure languages are a serious barrier both to accessible smart contract development and to mainstream adoption of digital assets. The first duty of a smart contract language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing access control checks, arithmetic overflow, ...) by construction. Any changes to Move should preserve or enhance its existing security guarantees.\n\nExpressive by nature: Move must enable programmers to write any smart contract they can imagine. But we care as much about the way it feels to write Move as we do about what Move allows you to do - the language should be rich enough that the features needed for a task are available, and minimal enough that the choice is obvious. The Move toolchain should be a productivity enhancer and a thought partner.\n\nIntuitive for all: Smart contracts are only one part of a useful application. Move should understand the broader context of its usage and design with both the smart contract developer and the application developer in mind. It should be easy for developers to learn how to read Move-managed state, build Move powered transactions, and write new Move code.\n\nThe core technical elements of Move are:\n\nSafe, familiar, and flexible abstractions for digital assets via programmable objects.\nA rich ability system (inspired by linear types) that gives programmers extreme control of how values are created, destroyed, stored, copied, and transferred.\nA module system with strong encapsulation features to enable code reuse while maintaining this control.\nDynamic fields for creating hierarchical relationships between objects.\nProgrammable transaction blocks (PTBs) to enable atomic client-side composition of Move-powered APIs.\n\nMove was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered chains in production with several more in the works. Move is an embedded language with a platform-agnostic core, which means it takes on a slightly different personality in each chain that uses it.\n\nCreating a new programming language and bootstrapping a community around it is an ambitious, long term project. A language has to be an order of magnitude better than alternatives in relevant ways to have a chance, but even then the quality of the community matters more than the technical fundamentals. Move is a young language, but it's off to a good start in terms of both differentiation and community. A small, but fanatical group of smart contract programmers and core contributors united by the Move values are pushing the boundaries of what smart contracts can do, the applications they can enable, and who can (safely) write them. If that inspires you, read on!\n\n— Sam Blackshear, creator of Move"
    },
    {
      "title": "The Move Book - The Move Book",
      "url": "https://move-book.com/index.html",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nThe Move Book\n\nThis is the Move Book - a comprehensive guide to the Move programming language and the Sui blockchain. The book is intended for developers who are interested in learning about Move and building on Sui.\n\nThe book is in active development and a work in progress. If you have any feedback or suggestions, feel free to open an issue or a pull request on the GitHub repository.\n\nIf you're looking for The Move Reference, you can find it here."
    },
    {
      "title": "The Move Book - The Move Book",
      "url": "https://move-book.com/",
      "html": "1. The Move Book\n2. Foreword\n3. Before we begin\n3.1. Install Sui\n3.2. Set up your IDE\n3.3. Move 2024\n4. Hello, World!\n5. Hello, Sui!\n6. Concepts\n6.1. Package\n6.2. Manifest\n6.3. Address\n6.4. Account\n6.5. Transaction\n7. Move Basics\n7.1. Module\n7.2. Comments\n7.3. Primitive Types\n7.4. Address Type\n7.5. Expression\n7.6. Struct\n7.7. Abilities: Introduction\n7.8. Ability: Drop\n7.9. Importing Modules\n7.10. Standard Library\n7.11. Vector\n7.12. Option\n7.13. String\n7.14. Control Flow\n7.15. Constants\n7.16. Assert and Abort\n7.17. Function\n7.18. Struct Methods\n7.19. Visibility Modifiers\n7.20. Ownership and Scope\n7.21. Ability: Copy\n7.22. References\n7.23. Generics\n7.24. Type Reflection\n7.25. Testing\n8. Object Model\n8.1. Language for Digital Assets\n8.2. Evolution of Move\n8.3. What is an Object?\n8.4. Ownership\n8.5. Fast Path & Consensus\n9. Using Objects\n9.1. Ability: Key\n9.2. Storage Functions\n9.3. Ability: Store\n9.4. UID and ID\n9.5. Restricted and Public Transfer\n9.6. Transfer to Object?\n10. Advanced Programmability\n10.1. Transaction Context\n10.2. Module Initializer\n10.3. Pattern: Capability\n10.4. Epoch and Time\n10.5. Collections\n10.6. Dynamic Fields\n10.7. Dynamic Object Fields\n10.8. Dynamic Collections\n10.9. Pattern: Witness\n10.10. One Time Witness\n10.11. Publisher Authority\n10.12. Display\n10.13. Events\n10.14. Balance & Coin\n10.15. Sui Framework\n10.16. Pattern: Hot Potato\n10.17. Pattern: Request\n10.18. Pattern: Object Capability\n10.19. Package Upgrades\n10.20. Transaction Blocks\n10.21. Authorization Patterns\n10.22. Cryptography and Hashing\n10.23. Randomness\n10.24. BCS\nGuides\n11. 2024 Migration Guide\n12. Upgradability Practices\n13. Building against Limits\n14. Better error handling\n15. Open-sourcing Libraries\n16. Creating an NFT Collection\n17. Tests with Objects\n18. Coding Conventions\nAppendix\n19. A - Glossary\n20. B - Reserved Addresses\n21. C - Publications\n22. D - Contributing\n23. E - Acknowledgements\nGo to Reference\nThe Move Book\n  \nThe Move Book\n\nThis is the Move Book - a comprehensive guide to the Move programming language and the Sui blockchain. The book is intended for developers who are interested in learning about Move and building on Sui.\n\nThe book is in active development and a work in progress. If you have any feedback or suggestions, feel free to open an issue or a pull request on the GitHub repository.\n\nIf you're looking for The Move Reference, you can find it here."
    }
  ]