[
    {
      "title": "The Move Book",
      "url": "https://move-language.github.io/move/print.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n \nIntroduction\n\nWelcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.\n\nMove takes its cue from Rust by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.\n\nWho is Move for?\n\nMove was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.\n\nThe early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.\n\nHobbyists\n\nUnderstanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.\n\nCore Contributor\n\nBeyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to contribute directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.\n\nWho Move is currently not targeting\n\nCurrently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.\n\nWhere Do I Start?\n\nBegin with understanding modules and scripts and then work through the Move Tutorial.\n\nModules and Scripts\n\nMove has two different types of programs: Modules and Scripts. Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's global storage, and module functions define the rules for updating storage. Modules themselves are also stored in global storage. Scripts are executable entrypoints similar to a main function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage.\n\nA Move source file (or compilation unit) may contain multiple modules and scripts. However, publishing a module or executing a script are separate VM operations.\n\nSyntax\nScripts\n\nA script has the following structure:\n\nscript {\n    <use>*\n    <constants>*\n    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>\n}\n\n\nA script block must start with all of its use declarations, followed by any constants and (finally) the main function declaration. The main function can have any name (i.e., it need not be called main), is the only function in a script block, can have any number of arguments, and must not return a value. Here is an example with each of these components:\n\nscript {\n    // Import the debug module published at the named account address std.\n    use std::debug;\n\n    const ONE: u64 = 1;\n\n    fun main(x: u64) {\n        let sum = x + ONE;\n        debug::print(&sum)\n    }\n}\n\n\nScripts have very limited power—they cannot declare friends, struct types or access global storage. Their primary purpose is to invoke module functions.\n\nModules\n\nA module has the following syntax:\n\nmodule <address>::<identifier> {\n    (<use> | <friend> | <type> | <function> | <constant>)*\n}\n\n\nwhere <address> is a valid named or literal address.\n\nFor example:\n\nmodule 0x42::test {\n    struct Example has copy, drop { i: u64 }\n\n    use std::debug;\n    friend 0x42::another_test;\n\n    const ONE: u64 = 1;\n\n    public fun print(x: u64) {\n        let sum = x + ONE;\n        let example = Example { i: sum };\n        debug::print(&sum)\n    }\n}\n\n\nThe module 0x42::test part specifies that the module test will be published under the account address 0x42 in global storage.\n\nModules can also be declared using named addresses. For example:\n\nmodule test_addr::test {\n    struct Example has copy, drop { a: address }\n\n    use std::debug;\n    friend test_addr::another_test;\n\n    public fun print() {\n        let example = Example { a: @test_addr };\n        debug::print(&example)\n    }\n}\n\n\nBecause named addresses only exist at the source language level and during compilation, named addresses will be fully substituted for their value at the bytecode level. For example if we had the following code:\n\nscript {\n    fun example() {\n        my_addr::m::foo(@my_addr);\n    }\n}\n\n\nand we compiled it with my_addr set to 0xC0FFEE, then it would be equivalent to the following operationally:\n\nscript {\n    fun example() {\n        0xC0FFEE::m::foo(@0xC0FFEE);\n    }\n}\n\n\nHowever at the source level, these are not equivalent—the function m::foo must be accessed through the my_addr named address, and not through the numerical value assigned to that address.\n\nModule names can start with letters a to z or letters A to Z. After the first character, module names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nmodule my_module {}\nmodule foo_bar_42 {}\n\n\nTypically, module names start with an lowercase letter. A module named my_module should be stored in a source file named my_module.move.\n\nAll elements inside a module block can appear in any order. Fundamentally, a module is a collection of types and functions. The use keyword is used to import types from other modules. The friend keyword specifies a list of trusted modules. The const keyword defines private constants that can be used in the functions of a module.\n\nMove Tutorial\n\nPlease refer to the Move Tutorial.\n\nIntegers\n\nMove supports six unsigned integer types: u8, u16, u32, u64, u128, and u256. Values of these types range from 0 to a maximum that depends on the size of the type.\n\nType\tValue Range\nUnsigned 8-bit integer, u8\t0 to 28 - 1\nUnsigned 16-bit integer, u16\t0 to 216 - 1\nUnsigned 32-bit integer, u32\t0 to 232 - 1\nUnsigned 64-bit integer, u64\t0 to 264 - 1\nUnsigned 128-bit integer, u128\t0 to 2128 - 1\nUnsigned 256-bit integer, u256\t0 to 2256 - 1\nLiterals\n\nLiteral values for these types are specified either as a sequence of digits (e.g.,112) or as hex literals, e.g., 0xFF. The type of the literal can optionally be added as a suffix, e.g., 112u8. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be u64.\n\nNumber literals can be separated by underscores for grouping and readability. (e.g.,1_234_5678, 1_000u128, 0xAB_CD_12_35).\n\nIf a literal is too large for its specified (or inferred) size range, an error is reported.\n\nExamples\n// literals with explicit annotations;\nlet explicit_u8 = 1u8;\nlet explicit_u16 = 1u16;\nlet explicit_u32 = 1u32;\nlet explicit_u64 = 2u64;\nlet explicit_u128 = 3u128;\nlet explicit_u256 = 1u256;\nlet explicit_u64_underscored = 154_322_973u64;\n\n// literals with simple inference\nlet simple_u8: u8 = 1;\nlet simple_u16: u16 = 1;\nlet simple_u32: u32 = 1;\nlet simple_u64: u64 = 2;\nlet simple_u128: u128 = 3;\nlet simple_u256: u256 = 1;\n\n// literals with more complex inference\nlet complex_u8 = 1; // inferred: u8\n// right hand argument to shift must be u8\nlet _unused = 10 << complex_u8;\n\nlet x: u8 = 38;\nlet complex_u8 = 2; // inferred: u8\n// arguments to `+` must have the same type\nlet _unused = x + complex_u8;\n\nlet complex_u128 = 133_876; // inferred: u128\n// inferred from function argument type\nfunction_that_takes_u128(complex_u128);\n\n// literals can be written in hex\nlet hex_u8: u8 = 0x1;\nlet hex_u16: u16 = 0x1BAE;\nlet hex_u32: u32 = 0xDEAD80;\nlet hex_u64: u64 = 0xCAFE;\nlet hex_u128: u128 = 0xDEADBEEF;\nlet hex_u256: u256 = 0x1123_456A_BCDE_F;\n\nOperations\nArithmetic\n\nEach of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) must be of the same type. If you need to operate over values of different types, you will need to first perform a cast. Similarly, if you expect the result of the operation to be too large for the integer type, perform a cast to a larger size before performing the operation.\n\nAll arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).\n\nSyntax\tOperation\tAborts If\n+\taddition\tResult is too large for the integer type\n-\tsubtraction\tResult is less than zero\n*\tmultiplication\tResult is too large for the integer type\n%\tmodular division\tThe divisor is 0\n/\ttruncating division\tThe divisor is 0\nBitwise\n\nThe integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.\n\nBitwise operations do not abort.\n\nSyntax\tOperation\tDescription\n&\tbitwise and\tPerforms a boolean and for each bit pairwise\n|\tbitwise or\tPerforms a boolean or for each bit pairwise\n^\tbitwise xor\tPerforms a boolean exclusive or for each bit pairwise\nBit Shifts\n\nSimilar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must always be a u8 and need not match the left side operand (the number you are shifting).\n\nBit shifts can abort if the number of bits to shift by is greater than or equal to 8, 16, 32, 64, 128 or 256 for u8, u16, u32, u64, u128 and u256 respectively.\n\nSyntax\tOperation\tAborts if\n<<\tshift left\tNumber of bits to shift by is greater than the size of the integer type\n>>\tshift right\tNumber of bits to shift by is greater than the size of the integer type\nComparisons\n\nInteger types are the only types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to cast one of them first.\n\nComparison operations do not abort.\n\nSyntax\tOperation\n<\tless than\n>\tgreater than\n<=\tless than or equal to\n>=\tgreater than or equal to\nEquality\n\nLike all types with drop in Move, all integer types support the \"equal\" and \"not equal\" operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to cast one of them first.\n\nEquality operations do not abort.\n\nSyntax\tOperation\n==\tequal\n!=\tnot equal\n\nFor more details see the section on equality\n\nCasting\n\nInteger types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.\n\nCasts do not truncate. Casting will abort if the result is too large for the specified type\n\nSyntax\tOperation\tAborts if\n(e as T)\tCast integer expression e into an integer type T\te is too large to represent as a T\n\nHere, the type of e must be 8, 16, 32, 64, 128 or 256 and T must be u8, u16, u32, u64, u128 oe u256.\n\nFor example:\n\n(x as u8)\n(y as u16)\n(873u16 as u32)\n(2u8 as u64)\n(1 + 3 as u128)\n(4/2 + 12345 as u256)\nOwnership\n\nAs with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy.\n\nBool\n\nbool is Move's primitive type for boolean true and false values.\n\nLiterals\n\nLiterals for bool are either true or false.\n\nOperations\nLogical\n\nbool supports three logical operations:\n\nSyntax\tDescription\tEquivalent Expression\n&&\tshort-circuiting logical and\tp && q is equivalent to if (p) q else false\n||\tshort-circuiting logical or\tp || q is equivalent to if (p) true else q\n!\tlogical negation\t!p is equivalent to if (p) false else true\nControl Flow\n\nbool values are used in several of Move's control-flow constructs:\n\nif (bool) { ... }\nwhile (bool) { .. }\nassert!(bool, u64)\nOwnership\n\nAs with the other scalar values built-in to the language, boolean values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy.\n\nAddress\n\naddress is a built-in type in Move that is used to represent locations (sometimes called accounts) in global storage. An address value is a 128-bit (16 byte) identifier. At a given address, two things can be stored: Modules and Resources.\n\nAlthough an address is a 128 bit integer under the hood, Move addresses are intentionally opaque---they cannot be created from integers, they do not support arithmetic operations, and they cannot be modified. Even though there might be interesting programs that would use such a feature (e.g., pointer arithmetic in C fills a similar niche), Move does not allow this dynamic behavior because it has been designed from the ground up to support static verification.\n\nYou can use runtime address values (values of type address) to access resources at that address. You cannot access modules at runtime via address values.\n\nAddresses and Their Syntax\n\nAddresses come in two flavors, named or numerical. The syntax for a named address follows the same rules for any named identifier in Move. The syntax of a numerical address is not restricted to hex-encoded values, and any valid u128 numerical value can be used as an address value, e.g., 42, 0xCAFE, and 2021 are all valid numerical address literals.\n\nTo distinguish when an address is being used in an expression context or not, the syntax when using an address differs depending on the context where it's used:\n\nWhen an address is used as an expression the address must be prefixed by the @ character, i.e., @<numerical_value> or @<named_address_identifier>.\nOutside of expression contexts, the address may be written without the leading @ character, i.e., <numerical_value> or <named_address_identifier>.\n\nIn general, you can think of @ as an operator that takes an address from being a namespace item to being an expression item.\n\nNamed Addresses\n\nNamed addresses are a feature that allow identifiers to be used in place of numerical values in any spot where addresses are used, and not just at the value level. Named addresses are declared and bound as top level elements (outside of modules and scripts) in Move Packages, or passed as arguments to the Move compiler.\n\nNamed addresses only exist at the source language level and will be fully substituted for their value at the bytecode level. Because of this, modules and module members must be accessed through the module's named address and not through the numerical value assigned to the named address during compilation, e.g., use my_addr::foo is not equivalent to use 0x2::foo even if the Move program is compiled with my_addr set to 0x2. This distinction is discussed in more detail in the section on Modules and Scripts.\n\nExamples\nlet a1: address = @0x1; // shorthand for 0x00000000000000000000000000000001\nlet a2: address = @0x42; // shorthand for 0x00000000000000000000000000000042\nlet a3: address = @0xDEADBEEF; // shorthand for 0x000000000000000000000000DEADBEEF\nlet a4: address = @0x0000000000000000000000000000000A;\nlet a5: address = @std; // Assigns `a5` the value of the named address `std`\nlet a6: address = @66;\nlet a7: address = @0x42;\n\nmodule 66::some_module {   // Not in expression context, so no @ needed\n    use 0x1::other_module; // Not in expression context so no @ needed\n    use std::vector;       // Can use a named address as a namespace item when using other modules\n    ...\n}\n\nmodule std::other_module {  // Can use a named address as a namespace item to declare a module\n    ...\n}\n\nGlobal Storage Operations\n\nThe primary purpose of address values are to interact with the global storage operations.\n\naddress values are used with the exists, borrow_global, borrow_global_mut, and move_from operations.\n\nThe only global storage operation that does not use address is move_to, which uses signer.\n\nOwnership\n\nAs with the other scalar values built-in to the language, address values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy.\n\nVector\n\nvector<T> is the only primitive collection type provided by Move. A vector<T> is a homogenous collection of T's that can grow or shrink by pushing/popping values off the \"end\".\n\nA vector<T> can be instantiated with any type T. For example, vector<u64>, vector<address>, vector<0x42::MyModule::MyResource>, and vector<vector<u8>> are all valid vector types.\n\nLiterals\nGeneral vector Literals\n\nVectors of any type can be created with vector literals.\n\nSyntax\tType\tDescription\nvector[]\tvector[]: vector<T> where T is any single, non-reference type\tAn empty vector\nvector[e1, ..., en]\tvector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0\tA vector with n elements (of length n)\n\nIn these cases, the type of the vector is inferred, either from the element type or from the vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be specified explicitly:\n\nvector<T>[]: vector<T>\nvector<T>[e1, ..., en]: vector<T>\n\nExample Vector Literals\n(vector[]: vector<bool>);\n(vector[0u8, 1u8, 2u8]: vector<u8>);\n(vector<u128>[]: vector<u128>);\n(vector<address>[@0x42, @0x100]: vector<address>);\n\nvector<u8> literals\n\nA common use-case for vectors in Move is to represent \"byte arrays\", which are represented with vector<u8>. These values are often used for cryptographic purposes, such as a public key or a hash result. These values are so common that specific syntax is provided to make the values more readable, as opposed to having to use vector[] where each individual u8 value is specified in numeric form.\n\nThere are currently two supported types of vector<u8> literals, byte strings and hex strings.\n\nByte Strings\n\nByte strings are quoted string literals prefixed by a b, e.g. b\"Hello!\\n\".\n\nThese are ASCII encoded strings that allow for escape sequences. Currently, the supported escape sequences are:\n\nEscape Sequence\tDescription\n\\n\tNew line (or Line feed)\n\\r\tCarriage return\n\\t\tTab\n\\\\\tBackslash\n\\0\tNull\n\\\"\tQuote\n\\xHH\tHex escape, inserts the hex byte sequence HH\nHex Strings\n\nHex strings are quoted string literals prefixed by a x, e.g. x\"48656C6C6F210A\".\n\nEach byte pair, ranging from 00 to FF, is interpreted as hex encoded u8 value. So each byte pair corresponds to a single entry in the resulting vector<u8>.\n\nExample String Literals\nscript {\nfun byte_and_hex_strings() {\n    assert!(b\"\" == x\"\", 0);\n    assert!(b\"Hello!\\n\" == x\"48656C6C6F210A\", 1);\n    assert!(b\"\\x48\\x65\\x6C\\x6C\\x6F\\x21\\x0A\" == x\"48656C6C6F210A\", 2);\n    assert!(\n        b\"\\\"Hello\\tworld!\\\"\\n \\r \\\\Null=\\0\" ==\n            x\"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00\",\n        3\n    );\n}\n}\n\nOperations\n\nvector supports the following operations via the std::vector module in the Move standard library:\n\nFunction\tDescription\tAborts?\nvector::empty<T>(): vector<T>\tCreate an empty vector that can store values of type T\tNever\nvector::singleton<T>(t: T): vector<T>\tCreate a vector of size 1 containing t\tNever\nvector::push_back<T>(v: &mut vector<T>, t: T)\tAdd t to the end of v\tNever\nvector::pop_back<T>(v: &mut vector<T>): T\tRemove and return the last element in v\tIf v is empty\nvector::borrow<T>(v: &vector<T>, i: u64): &T\tReturn an immutable reference to the T at index i\tIf i is not in bounds\nvector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T\tReturn a mutable reference to the T at index i\tIf i is not in bounds\nvector::destroy_empty<T>(v: vector<T>)\tDelete v\tIf v is not empty\nvector::append<T>(v1: &mut vector<T>, v2: vector<T>)\tAdd the elements in v2 to the end of v1\tNever\nvector::contains<T>(v: &vector<T>, e: &T): bool\tReturn true if e is in the vector v. Otherwise, returns false\tNever\nvector::swap<T>(v: &mut vector<T>, i: u64, j: u64)\tSwaps the elements at the ith and jth indices in the vector v\tIf i or j is out of bounds\nvector::reverse<T>(v: &mut vector<T>)\tReverses the order of the elements in the vector v in place\tNever\nvector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)\tReturn (true, i) if e is in the vector v at index i. Otherwise, returns (false, 0)\tNever\nvector::remove<T>(v: &mut vector<T>, i: u64): T\tRemove the ith element of the vector v, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector\tIf i is out of bounds\nvector::swap_remove<T>(v: &mut vector<T>, i: u64): T\tSwap the ith element of the vector v with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector\tIf i is out of bounds\n\nMore operations may be added over time.\n\nExample\nuse std::vector;\n\nlet v = vector::empty<u64>();\nvector::push_back(&mut v, 5);\nvector::push_back(&mut v, 6);\n\nassert!(*vector::borrow(&v, 0) == 5, 42);\nassert!(*vector::borrow(&v, 1) == 6, 42);\nassert!(vector::pop_back(&mut v) == 6, 42);\nassert!(vector::pop_back(&mut v) == 5, 42);\n\nDestroying and copying vectors\n\nSome behaviors of vector<T> depend on the abilities of the element type, T. For example, vectors containing elements that do not have drop cannot be implicitly discarded like v in the example above--they must be explicitly destroyed with vector::destroy_empty.\n\nNote that vector::destroy_empty will abort at runtime unless vec contains zero elements:\n\nfun destroy_any_vector<T>(vec: vector<T>) {\n    vector::destroy_empty(vec) // deleting this line will cause a compiler error\n}\n\n\nBut no error would occur for dropping a vector that contains elements with drop:\n\nfun destroy_droppable_vector<T: drop>(vec: vector<T>) {\n    // valid!\n    // nothing needs to be done explicitly to destroy the vector\n}\n\n\nSimilarly, vectors cannot be copied unless the element type has copy. In other words, a vector<T> has copy if and only if T has copy. However, even copyable vectors are never implicitly copied:\n\nlet x = vector::singleton<u64>(10);\nlet y = copy x; // compiler error without the copy!\n\n\nCopies of large vectors can be expensive, so the compiler requires explicit copy's to make it easier to see where they are happening.\n\nFor more details see the sections on type abilities and generics.\n\nOwnership\n\nAs mentioned above, vector values can be copied only if the elements can be copied. In that case, the copy must be explicit via a copy or a dereference *.\n\nSigner\n\nsigner is a built-in Move resource type. A signer is a capability that allows the holder to act on behalf of a particular address. You can think of the native implementation as being:\n\nstruct signer has drop { a: address }\n\n\nA signer is somewhat similar to a Unix UID in that it represents a user authenticated by code outside of Move (e.g., by checking a cryptographic signature or password).\n\nComparison to address\n\nA Move program can create any address value without special permission using address literals:\n\nlet a1 = @0x1;\nlet a2 = @0x2;\n// ... and so on for every other possible address\n\n\nHowever, signer values are special because they cannot be created via literals or instructions--only by the Move VM. Before the VM runs a script with parameters of type signer, it will automatically create signer values and pass them into the script:\n\nscript {\n    use std::signer;\n    fun main(s: signer) {\n        assert!(signer::address_of(&s) == @0x42, 0);\n    }\n}\n\n\nThis script will abort with code 0 if the script is sent from any address other than 0x42.\n\nA transaction script can have an arbitrary number of signers as long as the signers are a prefix to any other arguments. In other words, all of the signer arguments must come first:\n\nscript {\n    use std::signer;\n    fun main(s1: signer, s2: signer, x: u64, y: u8) {\n        // ...\n    }\n}\n\n\nThis is useful for implementing multi-signer scripts that atomically act with the authority of multiple parties. For example, an extension of the script above could perform an atomic currency swap between s1 and s2.\n\nsigner Operators\n\nThe std::signer standard library module provides two utility functions over signer values:\n\nFunction\tDescription\nsigner::address_of(&signer): address\tReturn the address wrapped by this &signer.\nsigner::borrow_address(&signer): &address\tReturn a reference to the address wrapped by this &signer.\n\nIn addition, the move_to<T>(&signer, T) global storage operator requires a &signer argument to publish a resource T under signer.address's account. This ensures that only an authenticated user can elect to publish a resource under their address.\n\nOwnership\n\nUnlike simple scalar values, signer values are not copyable, meaning they cannot be copied (from any operation whether it be through an explicit copy instruction or through a dereference *.\n\nReferences\n\nMove has two types of references: immutable & and mutable &mut. Immutable references are read only, and cannot modify the underlying value (or any of its fields). Mutable references allow for modifications via a write through that reference. Move's type system enforces an ownership discipline that prevents reference errors.\n\nFor more details on the rules of references, see Structs and Resources\n\nReference Operators\n\nMove provides operators for creating and extending references as well as converting a mutable reference to an immutable one. Here and elsewhere, we use the notation e: T for \"expression e has type T\".\n\nSyntax\tType\tDescription\n&e\t&T where e: T and T is a non-reference type\tCreate an immutable reference to e\n&mut e\t&mut T where e: T and T is a non-reference type\tCreate a mutable reference to e.\n&e.f\t&T where e.f: T\tCreate an immutable reference to field f of struct e.\n&mut e.f\t&mut T where e.f: T\tCreate a mutable reference to field f of structe.\nfreeze(e)\t&T where e: &mut T\tConvert the mutable reference e into an immutable reference.\n\nThe &e.f and &mut e.f operators can be used both to create a new reference into a struct or to extend an existing reference:\n\nlet s = S { f: 10 };\nlet f_ref1: &u64 = &s.f; // works\nlet s_ref: &S = &s;\nlet f_ref2: &u64 = &s_ref.f // also works\n\n\nA reference expression with multiple fields works as long as both structs are in the same module:\n\nstruct A { b: B }\nstruct B { c : u64 }\nfun f(a: &A): &u64 {\n  &a.b.c\n}\n\n\nFinally, note that references to references are not allowed:\n\nlet x = 7;\nlet y: &u64 = &x;\nlet z: &&u64 = &y; // will not compile\n\nReading and Writing Through References\n\nBoth mutable and immutable references can be read to produce a copy of the referenced value.\n\nOnly mutable references can be written. A write *x = v discards the value previously stored in x and updates it with v.\n\nBoth operations use the C-like * syntax. However, note that a read is an expression, whereas a write is a mutation that must occur on the left hand side of an equals.\n\nSyntax\tType\tDescription\n*e\tT where e is &T or &mut T\tRead the value pointed to by e\n*e1 = e2\t() where e1: &mut T and e2: T\tUpdate the value in e1 with e2.\n\nIn order for a reference to be read, the underlying type must have the copy ability as reading the reference creates a new copy of the value. This rule prevents the copying of resource values:\n\nfun copy_resource_via_ref_bad(c: Coin) {\n    let c_ref = &c;\n    let counterfeit: Coin = *c_ref; // not allowed!\n    pay(c);\n    pay(counterfeit);\n}\n\n\nDually: in order for a reference to be written to, the underlying type must have the drop ability as writing to the reference will discard (or \"drop\") the old value. This rule prevents the destruction of resource values:\n\nfun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {\n    let ref = &mut ten_coins;\n    *ref = c; // not allowed--would destroy 10 coins!\n}\n\nfreeze inference\n\nA mutable reference can be used in a context where an immutable reference is expected:\n\nlet x = 7;\nlet y: &u64 = &mut x;\n\n\nThis works because the under the hood, the compiler inserts freeze instructions where they are needed. Here are a few more examples of freeze inference in action:\n\nfun takes_immut_returns_immut(x: &u64): &u64 { x }\n\n// freeze inference on return value\nfun takes_mut_returns_immut(x: &mut u64): &u64 { x }\n\nfun expression_examples() {\n    let x = 0;\n    let y = 0;\n    takes_immut_returns_immut(&x); // no inference\n    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)\n    takes_mut_returns_immut(&mut x); // no inference\n\n    assert!(&x == &mut y, 42); // inferred freeze(&mut y)\n}\n\nfun assignment_examples() {\n    let x = 0;\n    let y = 0;\n    let imm_ref: &u64 = &x;\n\n    imm_ref = &x; // no inference\n    imm_ref = &mut y; // inferred freeze(&mut y)\n}\n\nSubtyping\n\nWith this freeze inference, the Move type checker can view &mut T as a subtype of &T. As shown above, this means that anywhere for any expression where a &T value is used, a &mut T value can also be used. This terminology is used in error messages to concisely indicate that a &mut T was needed where a &T was supplied. For example\n\naddress 0x42 {\nmodule example {\n    fun read_and_assign(store: &mut u64, new_value: &u64) {\n        *store = *new_value\n    }\n\n    fun subtype_examples() {\n        let x: &u64 = &0;\n        let y: &mut u64 = &mut 1;\n\n        x = &mut 1; // valid\n        y = &2; // invalid!\n\n        read_and_assign(y, x); // valid\n        read_and_assign(x, y); // invalid!\n    }\n}\n}\n\n\nwill yield the following error messages\n\nerror:\n\n    ┌── example.move:12:9 ───\n    │\n 12 │         y = &2; // invalid!\n    │         ^ Invalid assignment to local 'y'\n    ·\n 12 │         y = &2; // invalid!\n    │             -- The type: '&{integer}'\n    ·\n  9 │         let y: &mut u64 = &mut 1;\n    │                -------- Is not a subtype of: '&mut u64'\n    │\n\nerror:\n\n    ┌── example.move:15:9 ───\n    │\n 15 │         read_and_assign(x, y); // invalid!\n    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'\n    ·\n  8 │         let x: &u64 = &0;\n    │                ---- The type: '&u64'\n    ·\n  3 │     fun read_and_assign(store: &mut u64, new_value: &u64) {\n    │                                -------- Is not a subtype of: '&mut u64'\n    │\n\n\nThe only other types currently that has subtyping are tuples\n\nOwnership\n\nBoth mutable and immutable references can always be copied and extended even if there are existing copies or extensions of the same reference:\n\nfun reference_copies(s: &mut S) {\n  let s_copy1 = s; // ok\n  let s_extension = &mut s.f; // also ok\n  let s_copy2 = s; // still ok\n  ...\n}\n\n\nThis might be surprising for programmers familiar with Rust's ownership system, which would reject the code above. Move's type system is more permissive in its treatment of copies, but equally strict in ensuring unique ownership of mutable references before writes.\n\nReferences Cannot Be Stored\n\nReferences and tuples are the only types that cannot be stored as a field value of structs, which also means that they cannot exist in global storage. All references created during program execution will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is also true for values of types without the store ability, but note that references and tuples go a step further by never being allowed in structs in the first place.\n\nThis is another difference between Move and Rust, which allows references to be stored inside of structs.\n\nCurrently, Move cannot support this because references cannot be serialized, but every Move value must be serializable. This requirement comes from Move's persistent global storage, which needs to serialize values to persist them across program executions. Structs can be written to global storage, and thus they must be serializable.\n\nOne could imagine a fancier, more expressive, type system that would allow references to be stored in structs and ban those structs from existing in global storage. We could perhaps allow references inside of structs that do not have the store ability, but that would not completely solve the problem: Move has a fairly complex system for tracking static reference safety, and this aspect of the type system would also have to be extended to support storing references inside of structs. In short, Move's type system (particularly the aspects around reference safety) would have to expand to support stored references. But it is something we are keeping an eye on as the language evolves.\n\nTuples and Unit\n\nMove does not fully support tuples as one might expect coming from another language with them as a first-class value. However, in order to support multiple return values, Move has tuple-like expressions. These expressions do not result in a concrete value at runtime (there are no tuples in the bytecode), and as a result they are very limited: they can only appear in expressions (usually in the return position for a function); they cannot be bound to local variables; they cannot be stored in structs; and tuple types cannot be used to instantiate generics.\n\nSimilarly, unit () is a type created by the Move source language in order to be expression based. The unit value () does not result in any runtime value. We can consider unit() to be an empty tuple, and any restrictions that apply to tuples also apply to unit.\n\nIt might feel weird to have tuples in the language at all given these restrictions. But one of the most common use cases for tuples in other languages is for functions to allow functions to return multiple values. Some languages work around this by forcing the users to write structs that contain the multiple return values. However in Move, you cannot put references inside of structs. This required Move to support multiple return values. These multiple return values are all pushed on the stack at the bytecode level. At the source level, these multiple return values are represented using tuples.\n\nLiterals\n\nTuples are created by a comma separated list of expressions inside of parentheses.\n\nSyntax\tType\tDescription\n()\t(): ()\tUnit, the empty tuple, or the tuple of arity 0\n(e1, ..., en)\t(e1, ..., en): (T1, ..., Tn) where e_i: Ti s.t. 0 < i <= n and n > 0\tA n-tuple, a tuple of arity n, a tuple with n elements\n\nNote that (e) does not have type (e): (t), in other words there is no tuple with one element. If there is only a single element inside of the parentheses, the parentheses are only used for disambiguation and do not carry any other special meaning.\n\nSometimes, tuples with two elements are called \"pairs\" and tuples with three elements are called \"triples.\"\n\nExamples\naddress 0x42 {\nmodule example {\n    // all 3 of these functions are equivalent\n\n    // when no return type is provided, it is assumed to be `()`\n    fun returns_unit_1() { }\n\n    // there is an implicit () value in empty expression blocks\n    fun returns_unit_2(): () { }\n\n    // explicit version of `returns_unit_1` and `returns_unit_2`\n    fun returns_unit_3(): () { () }\n\n\n    fun returns_3_values(): (u64, bool, address) {\n        (0, false, @0x42)\n    }\n    fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n        (x, 0, 1, b\"foobar\")\n    }\n}\n}\n\nOperations\n\nThe only operation that can be done on tuples currently is destructuring.\n\nDestructuring\n\nFor tuples of any size, they can be destructured in either a let binding or in an assignment.\n\nFor example:\n\naddress 0x42 {\nmodule example {\n    // all 3 of these functions are equivalent\n    fun returns_unit() {}\n    fun returns_2_values(): (bool, bool) { (true, false) }\n    fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b\"foobar\") }\n\n    fun examples(cond: bool) {\n        let () = ();\n        let (x, y): (u8, u64) = (0, 1);\n        let (a, b, c, d) = (@0x0, 0, false, b\"\");\n\n        () = ();\n        (x, y) = if (cond) (1, 2) else (3, 4);\n        (a, b, c, d) = (@0x1, 1, true, b\"1\");\n    }\n\n    fun examples_with_function_calls() {\n        let () = returns_unit();\n        let (x, y): (bool, bool) = returns_2_values();\n        let (a, b, c, d) = returns_4_values(&0);\n\n        () = returns_unit();\n        (x, y) = returns_2_values();\n        (a, b, c, d) = returns_4_values(&1);\n    }\n}\n}\n\n\nFor more details, see Move Variables.\n\nSubtyping\n\nAlong with references, tuples are the only types that have subtyping in Move. Tuples do have subtyping only in the sense that subtype with references (in a covariant way).\n\nFor example:\n\nlet x: &u64 = &0;\nlet y: &mut u64 = &mut 1;\n\n// (&u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (a, b): (&u64, &u64) = (x, y);\n\n// (&mut u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (c, d): (&u64, &u64) = (y, y);\n\n// error! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)\n// since &u64 is NOT a subtype of &mut u64\nlet (e, f): (&mut u64, &mut u64) = (x, y);\n\nOwnership\n\nAs mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored into local variables because of this (but it is likely that this feature will come soon). As such, tuples can only be moved currently, as copying them would require putting them into a local variable first.\n\nLocal Variables and Scope\n\nLocal variables in Move are lexically (statically) scoped. New variables are introduced with the keyword let, which will shadow any previous local with the same name. Locals are mutable and can be updated both directly and via a mutable reference.\n\nDeclaring Local Variables\nlet bindings\n\nMove programs use let to bind variable names to values:\n\nlet x = 1;\nlet y = x + x:\n\n\nlet can also be used without binding a value to the local.\n\nlet x;\n\n\nThe local can then be assigned a value later.\n\nlet x;\nif (cond) {\n  x = 1\n} else {\n  x = 0\n}\n\n\nThis can be very helpful when trying to extract a value from a loop when a default value cannot be provided.\n\nlet x;\nlet cond = true;\nlet i = 0;\nloop {\n    (x, cond) = foo(i);\n    if (!cond) break;\n    i = i + 1;\n}\n\nVariables must be assigned before use\n\nMove's type system prevents a local variable from being used before it has been assigned.\n\nlet x;\nx + x // ERROR!\n\nlet x;\nif (cond) x = 0;\nx + x // ERROR!\n\nlet x;\nwhile (cond) x = 0;\nx + x // ERROR!\n\nValid variable names\n\nVariable names can contain underscores _, letters a to z, letters A to Z, and digits 0 to 9. Variable names must start with either an underscore _ or a letter a through z. They cannot start with uppercase letters.\n\n// all valid\nlet x = e;\nlet _x = e;\nlet _A = e;\nlet x0 = e;\nlet xA = e;\nlet foobar_123 = e;\n\n// all invalid\nlet X = e; // ERROR!\nlet Foo = e; // ERROR!\n\nType annotations\n\nThe type of a local variable can almost always be inferred by Move's type system. However, Move allows explicit type annotations that can be useful for readability, clarity, or debuggability. The syntax for adding a type annotation is:\n\nlet x: T = e; // \"Variable x of type T is initialized to expression e\"\n\n\nSome examples of explicit type annotations:\n\naddress 0x42 {\nmodule example {\n\n    struct S { f: u64, g: u64 }\n\n    fun annotated() {\n        let u: u8 = 0;\n        let b: vector<u8> = b\"hello\";\n        let a: address = @0x0;\n        let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n        let S { f, g: f2 }: S = S { f: 0, g: 1 };\n    }\n}\n}\n\n\nNote that the type annotations must always be to the right of the pattern:\n\nlet (x: &u64, y: &mut u64) = (&0, &mut 1); // ERROR! should be let (x, y): ... =\n\nWhen annotations are necessary\n\nIn some cases, a local type annotation is required if the type system cannot infer the type. This commonly occurs when the type argument for a generic type cannot be inferred. For example:\n\nlet _v1 = vector::empty(); // ERROR!\n//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\nlet v2: vector<u64> = vector::empty(); // no error\n\n\nIn a rarer case, the type system might not be able to infer a type for divergent code (where all the following code is unreachable). Both return and abort are expressions and can have any type. A loop has type () if it has a break, but if there is no break out of the loop, it could have any type. If these types cannot be inferred, a type annotation is required. For example, this code:\n\nlet a: u8 = return ();\nlet b: bool = abort 0;\nlet c: signer = loop ();\n\nlet x = return (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet y = abort 0; // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet z = loop (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\n\n\nAdding type annotations to this code will expose other errors about dead code or unused local variables, but the example is still helpful for understanding this problem.\n\nMultiple declarations with tuples\n\nlet can introduce more than one local at a time using tuples. The locals declared inside the parenthesis are initialized to the corresponding values from the tuple.\n\nlet () = ();\nlet (x0, x1) = (0, 1);\nlet (y0, y1, y2) = (0, 1, 2);\nlet (z0, z1, z2, z3) = (0, 1, 2, 3);\n\n\nThe type of the expression must match the arity of the tuple pattern exactly.\n\nlet (x, y) = (0, 1, 2); // ERROR!\nlet (x, y, z, q) = (0, 1, 2); // ERROR!\n\n\nYou cannot declare more than one local with the same name in a single let.\n\nlet (x, x) = 0; // ERROR!\n\nMultiple declarations with structs\n\nlet can also introduce more than one local at a time when destructuring (or matching against) a struct. In this form, the let creates a set of local variables that are initialized to the values of the fields from a struct. The syntax looks like this:\n\nstruct T { f1: u64, f2: u64 }\n\nlet T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n\n\nHere is a more complicated example:\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };\n        assert!(f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };\n        assert!(f1 + f2 == 2, 42);\n    }\n}\n}\n\n\nFields of structs can serve double duty, identifying the field to bind and the name of the variable. This is sometimes referred to as punning.\n\nlet X { f } = e;\n\n\nis equivalent to:\n\nlet X { f: f } = e;\n\n\nAs shown with tuples, you cannot declare more than one local with the same name in a single let.\n\nlet Y { x1: x, x2: x } = e; // ERROR!\n\nDestructuring against references\n\nIn the examples above for structs, the bound value in the let was moved, destroying the struct value and binding its fields.\n\nstruct T { f1: u64, f2: u64 }\n\nlet T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n\n\nIn this scenario the struct value T { f1: 1, f2: 2 } no longer exists after the let.\n\nIf you wish instead to not move and destroy the struct value, you can borrow each of its fields. For example:\n\nlet t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &t;\n// local1: &u64\n// local2: &u64\n\n\nAnd similarly with mutable references:\n\nlet t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &mut t;\n// local1: &mut u64\n// local2: &mut u64\n\n\nThis behavior can also work with nested structs.\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let y = Y { x1: new_x(), x2: new_x() };\n\n        let Y { x1: X { f }, x2 } = &y;\n        assert!(*f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;\n        *f1 = *f1 + 1;\n        *f2 = *f2 + 1;\n        assert!(*f1 + *f2 == 4, 42);\n    }\n}\n}\n\nIgnoring Values\n\nIn let bindings, it is often helpful to ignore some values. Local variables that start with _ will be ignored and not introduce a new variable\n\nfun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}\n\nlet (x1, _, z1) = three();\nlet (x2, _y, z2) = three();\nassert!(x1 + z1 == x2 + z2, 42);\n\n\nThis can be necessary at times as the compiler will error on unused local variables\n\nlet (x1, y, z1) = three(); // ERROR!\n//       ^ unused local 'y'\n\nGeneral let grammar\n\nAll of the different structures in let can be combined! With that we arrive at this general grammar for let statements:\n\nlet-binding → let pattern-or-list type-annotationopt initializeropt > pattern-or-list → pattern | ( pattern-list ) > pattern-list → pattern ,opt | pattern , pattern-list > type-annotation → : type initializer → = expression\n\nThe general term for the item that introduces the bindings is a pattern. The pattern serves to both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as follows:\n\npattern → local-variable | struct-type { field-binding-list } > field-binding-list → field-binding ,opt | field-binding , field-binding-list > field-binding → field | field : pattern\n\nA few concrete examples with this grammar applied:\n\n    let (x, y): (u64, u64) = (0, 1);\n//       ^                           local-variable\n//       ^                           pattern\n//          ^                        local-variable\n//          ^                        pattern\n//          ^                        pattern-list\n//       ^^^^                        pattern-list\n//      ^^^^^^                       pattern-or-list\n//            ^^^^^^^^^^^^           type-annotation\n//                         ^^^^^^^^  initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\n    let Foo { f, g: x } = Foo { f: 0, g: 1 };\n//      ^^^                                    struct-type\n//            ^                                field\n//            ^                                field-binding\n//               ^                             field\n//                  ^                          local-variable\n//                  ^                          pattern\n//               ^^^^                          field-binding\n//            ^^^^^^^                          field-binding-list\n//      ^^^^^^^^^^^^^^^                        pattern\n//      ^^^^^^^^^^^^^^^                        pattern-or-list\n//                      ^^^^^^^^^^^^^^^^^^^^   initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\nMutations\nAssignments\n\nAfter the local is introduced (either by let or as a function parameter), the local can be modified via an assignment:\n\nx = e\n\n\nUnlike let bindings, assignments are expressions. In some languages, assignments return the value that was assigned, but in Move, the type of any assignment is always ().\n\n(x = e: ())\n\n\nPractically, assignments being expressions means that they can be used without adding a new expression block with braces ({...}).\n\nlet x = 0;\nif (cond) x = 1 else x = 2;\n\n\nThe assignment uses the same pattern syntax scheme as let bindings:\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    // This example will complain about unused variables and assignments.\n    fun example() {\n       let (x, _, z) = (0, 1, 3);\n       let (x, y, f, g);\n\n       (X { f }, X { f: x }) = (new_x(), new_x());\n       assert!(f + x == 2, 42);\n\n       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);\n    }\n}\n}\n\n\nNote that a local variable can only have one type, so the type of the local cannot change between assignments.\n\nlet x;\nx = 0;\nx = false; // ERROR!\n\nMutating through a reference\n\nIn addition to directly modifying a local with assignment, a local can be modified via a mutable reference &mut.\n\nlet x = 0;\nlet r = &mut x;\n*r = 1;\nassert!(x == 1, 42);\n\n\nThis is particularly useful if either:\n\n(1) You want to modify different variables depending on some condition.\n\nlet x = 0;\nlet y = 1;\nlet r = if (cond) &mut x else &mut y;\n*r = *r + 1;\n\n\n(2) You want another function to modify your local value.\n\nlet x = 0;\nmodify_ref(&mut x);\n\n\nThis sort of modification is how you modify structs and vectors!\n\nlet v = vector::empty();\nvector::push_back(&mut v, 100);\nassert!(*vector::borrow(&v, 0) == 100, 42);\n\n\nFor more details, see Move references.\n\nScopes\n\nAny local declared with let is available for any subsequent expression, within that scope. Scopes are declared with expression blocks, {...}.\n\nLocals cannot be used outside of the declared scope.\n\nlet x = 0;\n{\n    let y = 1;\n};\nx + y // ERROR!\n//  ^ unbound local 'y'\n\n\nBut, locals from an outer scope can be used in a nested scope.\n\n{\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}\n\n\nLocals can be mutated in any scope where they are accessible. That mutation survives with the local, regardless of the scope that performed the mutation.\n\nlet x = 0;\nx = x + 1;\nassert!(x == 1, 42);\n{\n    x = x + 1;\n    assert!(x == 2, 42);\n};\nassert!(x == 2, 42);\n\nExpression Blocks\n\nAn expression block is a series of statements separated by semicolons (;). The resulting value of an expression block is the value of the last expression in the block.\n\n{ let x = 1; let y = 1; x + y }\n\n\nIn this example, the result of the block is x + y.\n\nA statement can be either a let declaration or an expression. Remember that assignments (x = e) are expressions of type ().\n\n{ let x; let y = 1; x = 1; x + y }\n\n\nFunction calls are another common expression of type (). Function calls that modify data are commonly used as statements.\n\n{ let v = vector::empty(); vector::push_back(&mut v, 1); v }\n\n\nThis is not just limited to () types---any expression can be used as a statement in a sequence!\n\n{\n    let x = 0;\n    x + 1; // value is discarded\n    x + 2; // value is discarded\n    b\"hello\"; // value is discarded\n}\n\n\nBut! If the expression contains a resource (a value without the drop ability), you will get an error. This is because Move's type system guarantees that any value that is dropped has the drop ability. (Ownership must be transferred or the value must be explicitly destroyed within its declaring module.)\n\n{\n    let x = 0;\n    Coin { value: x }; // ERROR!\n//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability\n    x\n}\n\n\nIf a final expression is not present in a block---that is, if there is a trailing semicolon ;, there is an implicit unit () value. Similarly, if the expression block is empty, there is an implicit unit () value.\n\n// Both are equivalent\n{ x = x + 1; 1 / x; }\n{ x = x + 1; 1 / x; () }\n\n// Both are equivalent\n{ }\n{ () }\n\n\nAn expression block is itself an expression and can be used anyplace an expression is used. (Note: The body of a function is also an expression block, but the function body cannot be replaced by another expression.)\n\nlet my_vector: vector<vector<u8>> = {\n    let v = vector::empty();\n    vector::push_back(&mut v, b\"hello\");\n    vector::push_back(&mut v, b\"goodbye\");\n    v\n};\n\n\n(The type annotation is not needed in this example and only added for clarity.)\n\nShadowing\n\nIf a let introduces a local variable with a name already in scope, that previous variable can no longer be accessed for the rest of this scope. This is called shadowing.\n\nlet x = 0;\nassert!(x == 0, 42);\n\nlet x = 1; // x is shadowed\nassert!(x == 1, 42);\n\n\nWhen a local is shadowed, it does not need to retain the same type as before.\n\nlet x = 0;\nassert!(x == 0, 42);\n\nlet x = b\"hello\"; // x is shadowed\nassert!(x == b\"hello\", 42);\n\n\nAfter a local is shadowed, the value stored in the local still exists, but will no longer be accessible. This is important to keep in mind with values of types without the drop ability, as ownership of the value must be transferred by the end of the function.\n\naddress 0x42 {\n    module example {\n        struct Coin has store { value: u64 }\n\n        fun unused_resource(): Coin {\n            let x = Coin { value: 0 }; // ERROR!\n//              ^ This local still contains a value without the `drop` ability\n            x.value = 1;\n            let x = Coin { value: 10 };\n            x\n//          ^ Invalid return\n        }\n    }\n}\n\n\nWhen a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is gone once that scope ends.\n\nlet x = 0;\n{\n    let x = 1;\n    assert!(x == 1, 42);\n};\nassert!(x == 0, 42);\n\n\nRemember, locals can change type when they are shadowed.\n\nlet x = 0;\n{\n    let x = b\"hello\";\n    assert!(x = b\"hello\", 42);\n};\nassert!(x == 0, 42);\n\nMove and Copy\n\nAll local variables in Move can be used in two ways, either by move or copy. If one or the other is not specified, the Move compiler is able to infer whether a copy or a move should be used. This means that in all of the examples above, a move or a copy would be inserted by the compiler. A local variable cannot be used without the use of move or copy.\n\ncopy will likely feel the most familiar coming from other programming languages, as it creates a new copy of the value inside of the variable to use in that expression. With copy, the local variable can be used more than once.\n\nlet x = 0;\nlet y = copy x + 1;\nlet z = copy x + 2;\n\n\nAny value with the copy ability can be copied in this way.\n\nmove takes the value out of the local variable without copying the data. After a move occurs, the local variable is unavailable.\n\nlet x = 1;\nlet y = move x + 1;\n//      ------ Local was moved here\nlet z = move x + 2; // Error!\n//      ^^^^^^ Invalid usage of local 'x'\ny + z\n\nSafety\n\nMove's type system will prevent a value from being used after it is moved. This is the same safety check described in let declaration that prevents local variables from being used before it is assigned a value.\n\nInference\n\nAs mentioned above, the Move compiler will infer a copy or move if one is not indicated. The algorithm for doing so is quite simple:\n\nAny scalar value with the copy ability is given a copy.\nAny reference (both mutable &mut and immutable &) is given a copy.\nExcept under special circumstances where it is made a move for predictable borrow checker errors.\nAny other value is given a move.\nThis means that even though other values might be have the copy ability, it must be done explicitly by the programmer.\nThis is to prevent accidental copies of large data structures.\n\nFor example:\n\nlet s = b\"hello\";\nlet foo = Foo { f: 0 };\nlet coin = Coin { value: 0 };\n\nlet s2 = s; // move\nlet foo2 = foo; // move\nlet coin2 = coin; // move\n\nlet x = 0;\nlet b = false;\nlet addr = @0x42;\nlet x_ref = &x;\nlet coin_ref = &mut coin2;\n\nlet x2 = x; // copy\nlet b2 = b; // copy\nlet addr2 = @0x42; // copy\nlet x_ref2 = x_ref; // copy\nlet coin_ref2 = coin_ref; // copy\n\nEquality\n\nMove supports two equality operations == and !=\n\nOperations\nSyntax\tOperation\tDescription\n==\tequal\tReturns true if the two operands have the same value, false otherwise\n!=\tnot equal\tReturns true if the two operands have different values, false otherwise\nTyping\n\nBoth the equal (==) and not-equal (!=) operations only work if both operands are the same type\n\n0 == 0; // `true`\n1u128 == 2u128; // `false`\nb\"hello\" != x\"00\"; // `true`\n\n\nEquality and non-equality also work over user defined types!\n\naddress 0x42 {\nmodule example {\n    struct S has copy, drop { f: u64, s: vector<u8> }\n\n    fun always_true(): bool {\n        let s = S { f: 0, s: b\"\" };\n        // parens are not needed but added for clarity in this example\n        (copy s) == s\n    }\n\n    fun always_false(): bool {\n        let s = S { f: 0, s: b\"\" };\n        // parens are not needed but added for clarity in this example\n        (copy s) != s\n    }\n}\n}\n\n\nIf the operands have different types, there is a type checking error\n\n1u8 == 1u128; // ERROR!\n//     ^^^^^ expected an argument of type 'u8'\nb\"\" != 0; // ERROR!\n//     ^ expected an argument of type 'vector<u8>'\n\nTyping with references\n\nWhen comparing references, the type of the reference (immutable or mutable) does not matter. This means that you can compare an immutable & reference with a mutable one &mut of the same underlying type.\n\nlet i = &0;\nlet m = &mut 1;\n\ni == m; // `false`\nm == i; // `false`\nm == m; // `true`\ni == i; // `true`\n\n\nThe above is equivalent to applying an explicit freeze to each mutable reference where needed\n\nlet i = &0;\nlet m = &mut 1;\n\ni == freeze(m); // `false`\nfreeze(m) == i; // `false`\nm == m; // `true`\ni == i; // `true`\n\n\nBut again, the underlying type must be the same type\n\nlet i = &0;\nlet s = &b\"\";\n\ni == s; // ERROR!\n//   ^ expected an argument of type '&u64'\n\nRestrictions\n\nBoth == and != consume the value when comparing them. As a result, the type system enforces that the type must have drop. Recall that without the drop ability, ownership must be transferred by the end of the function, and such values can only be explicitly destroyed within their declaring module. If these were used directly with either equality == or non-equality !=, the value would be destroyed which would break drop ability safety guarantees!\n\naddress 0x42 {\nmodule example {\n    struct Coin has store { value: u64 }\n    fun invalid(c1: Coin, c2: Coin) {\n        c1 == c2 // ERROR!\n//      ^^    ^^ These resources would be destroyed!\n    }\n}\n}\n\n\nBut, a programmer can always borrow the value first instead of directly comparing the value, and reference types have the drop ability. For example\n\naddress 0x42 {\nmodule example {\n    struct Coin as store { value: u64 }\n    fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {\n        let are_equal = &c1 == &c2; // valid\n        if (are_equal) (c2, c1) else (c1, c2)\n    }\n}\n}\n\nAvoid Extra Copies\n\nWhile a programmer can compare any value whose type has drop, a programmer should often compare by reference to avoid expensive copies.\n\nlet v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(copy v1 == copy v2, 42);\n//     ^^^^       ^^^^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(copy s1 == copy s2, 42);\n//     ^^^^       ^^^^\nuse_two_foos(s1, s2);\n\n\nThis code is perfectly acceptable (assuming Foo has drop), just not efficient. The highlighted copies can be removed and replaced with borrows\n\nlet v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(&v1 == &v2, 42);\n//     ^      ^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(&s1 == &s2, 42);\n//     ^      ^\nuse_two_foos(s1, s2);\n\n\nThe efficiency of the == itself remains the same, but the copys are removed and thus the program is more efficient.\n\nAbort and Assert\n\nreturn and abort are two control flow constructs that end execution, one for the current function and one for the entire transaction.\n\nMore information on return can be found in the linked section\n\nabort\n\nabort is an expression that takes one argument: an abort code of type u64. For example:\n\nabort 42\n\n\nThe abort expression halts execution the current function and reverts all changes made to global state by the current transaction. There is no mechanism for \"catching\" or otherwise handling an abort.\n\nLuckily, in Move transactions are all or nothing, meaning any changes to global storage are made all at once only if the transaction succeeds. Because of this transactional commitment of changes, after an abort there is no need to worry about backing out changes. While this approach is lacking in flexibility, it is incredibly simple and predictable.\n\nSimilar to return, abort is useful for exiting control flow when some condition cannot be met.\n\nIn this example, the function will pop two items off of the vector, but will abort early if the vector does not have two items\n\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    if (vector::length(v) < 2) abort 42;\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nThis is even more useful deep inside a control-flow construct. For example, this function checks that all numbers in the vector are less than the specified bound. And aborts otherwise\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        if (cur > bound) abort 42;\n        i = i + 1;\n    }\n}\n\nassert\n\nassert is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a condition of type bool and a code of type u64\n\nassert!(condition: bool, code: u64)\n\n\nSince the operation is a macro, it must be invoked with the !. This is to convey that the arguments to assert are call-by-expression. In other words, assert is not a normal function and does not exist at the bytecode level. It is replaced inside the compiler with\n\nif (condition) () else abort code\n\n\nassert is more commonly used than just abort by itself. The abort examples above can be rewritten using assert\n\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    assert!(vector::length(v) >= 2, 42); // Now uses 'assert'\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nand\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        assert!(cur <= bound, 42); // Now uses 'assert'\n        i = i + 1;\n    }\n}\n\n\nNote that because the operation is replaced with this if-else, the argument for the code is not always evaluated. For example:\n\nassert!(true, 1 / 0)\n\n\nWill not result in an arithmetic error, it is equivalent to\n\nif (true) () else (1 / 0)\n\n\nSo the arithmetic expression is never evaluated!\n\nAbort codes in the Move VM\n\nWhen using abort, it is important to understand how the u64 code will be used by the VM.\n\nNormally, after successful execution, the Move VM produces a change-set for the changes made to global storage (added/removed resources, updates to existing resources, etc).\n\nIf an abort is reached, the VM will instead indicate an error. Included in that error will be two pieces of information:\n\nThe module that produced the abort (address and name)\nThe abort code.\n\nFor example\n\naddress 0x2 {\nmodule example {\n    public fun aborts() {\n        abort 42\n    }\n}\n}\n\nscript {\n    fun always_aborts() {\n        0x2::example::aborts()\n    }\n}\n\n\nIf a transaction, such as the script always_aborts above, calls 0x2::example::aborts, the VM would produce an error that indicated the module 0x2::example and the code 42.\n\nThis can be useful for having multiple aborts being grouped together inside a module.\n\nIn this example, the module has two separate error codes used in multiple functions\n\naddress 0x42 {\nmodule example {\n\n    use std::vector;\n\n    const EMPTY_VECTOR: u64 = 0;\n    const INDEX_OUT_OF_BOUNDS: u64 = 1;\n\n    // move i to j, move j to k, move k to i\n    public fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {\n        let n = vector::length(v);\n        assert!(n > 0, EMPTY_VECTOR);\n        assert!(i < n, INDEX_OUT_OF_BOUNDS);\n        assert!(j < n, INDEX_OUT_OF_BOUNDS);\n        assert!(k < n, INDEX_OUT_OF_BOUNDS);\n\n        vector::swap(v, i, k);\n        vector::swap(v, j, k);\n    }\n\n    public fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {\n        let n = vector::length(v);\n        assert!(n > 0, EMPTY_VECTOR);\n        assert!(i < n, INDEX_OUT_OF_BOUNDS);\n        assert!(j < n, INDEX_OUT_OF_BOUNDS);\n        assert!(i > j, INDEX_OUT_OF_BOUNDS);\n\n        (vector::remove<T>(v, i), vector::remove<T>(v, j))\n    }\n}\n}\n\nThe type of abort\n\nThe abort i expression can have any type! This is because both constructs break from the normal control flow, so they never need to evaluate to the value of that type.\n\nThe following are not useful, but they will type check\n\nlet y: address = abort 0;\n\n\nThis behavior can be helpful in situations where you have a branching instruction that produces a value on some branches, but not all. For example:\n\nlet b =\n    if (x == 0) false\n    else if (x == 1) true\n    else abort 42;\n//       ^^^^^^^^ `abort 42` has type `bool`\n\nConditionals\n\nAn if expression specifies that some code should only be evaluated if a certain condition is true. For example:\n\nif (x > 5) x = x - 5\n\n\nThe condition must be an expression of type bool.\n\nAn if expression can optionally include an else clause to specify another expression to evaluate when the condition is false.\n\nif (y <= 10) y = y + 1 else y = 10\n\n\nEither the \"true\" branch or the \"false\" branch will be evaluated, but not both. Either branch can be a single expression or an expression block.\n\nThe conditional expressions may produce values so that the if expression has a result.\n\nlet z = if (x < 100) x else 100;\n\n\nThe expressions in the true and false branches must have compatible types. For example:\n\n// x and y must be u64 integers\nlet maximum: u64 = if (x > y) x else y;\n\n// ERROR! branches different types\nlet z = if (maximum < 10) 10u8 else 100u64;\n\n// ERROR! branches different types, as default false-branch is () not u64\nif (maximum >= 10) maximum;\n\n\nIf the else clause is not specified, the false branch defaults to the unit value. The following are equivalent:\n\nif (condition) true_branch // implied default: else ()\nif (condition) true_branch else ()\n\n\nCommonly, if expressions are used in conjunction with expression blocks.\n\nlet maximum = if (x > y) x else y;\nif (maximum < 10) {\n    x = x + 10;\n    y = y + 10;\n} else if (x >= 10 && y >= 10) {\n    x = x - 10;\n    y = y - 10;\n}\n\nGrammar for Conditionals\n\nif-expression → if ( expression ) expression else-clauseopt else-clause → else expression\n\nWhile and Loop\n\nMove offers two constructs for looping: while and loop.\n\nwhile loops\n\nThe while construct repeats the body (an expression of type unit) until the condition (an expression of type bool) evaluates to false.\n\nHere is an example of simple while loop that computes the sum of the numbers from 1 to n:\n\nfun sum(n: u64): u64 {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum = sum + i;\n        i = i + 1\n    };\n\n    sum\n}\n\n\nInfinite loops are allowed:\n\nfun foo() {\n    while (true) { }\n}\n\nbreak\n\nThe break expression can be used to exit a loop before the condition evaluates to false. For example, this loop uses break to find the smallest factor of n that's greater than 1:\n\nfun smallest_factor(n: u64): u64 {\n    // assuming the input is not 0 or 1\n    let i = 2;\n    while (i <= n) {\n        if (n % i == 0) break;\n        i = i + 1\n    };\n\n    i\n}\n\n\nThe break expression cannot be used outside of a loop.\n\ncontinue\n\nThe continue expression skips the rest of the loop and continues to the next iteration. This loop uses continue to compute the sum of 1, 2, ..., n, except when the number is divisible by 10:\n\nfun sum_intermediate(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        i = i + 1;\n        if (i % 10 == 0) continue;\n        sum = sum + i;\n    };\n\n    sum\n}\n\n\nThe continue expression cannot be used outside of a loop.\n\nThe type of break and continue\n\nbreak and continue, much like return and abort, can have any type. The following examples illustrate where this flexible typing can be helpful:\n\nfun pop_smallest_while_not_equal(\n    v1: vector<u64>,\n    v2: vector<u64>,\n): vector<u64> {\n    let result = vector::empty();\n    while (!vector::is_empty(&v1) && !vector::is_empty(&v2)) {\n        let u1 = *vector::borrow(&v1, vector::length(&v1) - 1);\n        let u2 = *vector::borrow(&v2, vector::length(&v2) - 1);\n        let popped =\n            if (u1 < u2) vector::pop_back(&mut v1)\n            else if (u2 < u1) vector::pop_back(&mut v2)\n            else break; // Here, `break` has type `u64`\n        vector::push_back(&mut result, popped);\n    };\n\n    result\n}\n\nfun pick(\n    indexes: vector<u64>,\n    v1: &vector<address>,\n    v2: &vector<address>\n): vector<address> {\n    let len1 = vector::length(v1);\n    let len2 = vector::length(v2);\n    let result = vector::empty();\n    while (!vector::is_empty(&indexes)) {\n        let index = vector::pop_back(&mut indexes);\n        let chosen_vector =\n            if (index < len1) v1\n            else if (index < len2) v2\n            else continue; // Here, `continue` has type `&vector<address>`\n        vector::push_back(&mut result, *vector::borrow(chosen_vector, index))\n    };\n\n    result\n}\n\nThe loop expression\n\nThe loop expression repeats the loop body (an expression with type ()) until it hits a break\n\nWithout a break, the loop will continue forever\n\nfun foo() {\n    let i = 0;\n    loop { i = i + 1 }\n}\n\n\nHere is an example that uses loop to write the sum function:\n\nfun sum(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    loop {\n        i = i + 1;\n        if (i > n) break;\n        sum = sum + i\n    };\n\n    sum\n}\n\n\nAs you might expect, continue can also be used inside a loop. Here is sum_intermediate from above rewritten using loop instead of while\n\nfun sum_intermediate(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    loop {\n        i = i + 1;\n        if (i % 10 == 0) continue;\n        if (i > n) break;\n        sum = sum + i\n    };\n\n    sum\n}\n\nThe type of while and loop\n\nMove loops are typed expressions. A while expression always has type ().\n\nlet () = while (i < 10) { i = i + 1 };\n\n\nIf a loop contains a break, the expression has type unit ()\n\n(loop { if (i < 10) i = i + 1 else break }: ());\nlet () = loop { if (i < 10) i = i + 1 else break };\n\n\nIf loop does not have a break, loop can have any type much like return, abort, break, and continue.\n\n(loop (): u64);\n(loop (): address);\n(loop (): &vector<vector<u8>>);\n\nFunctions\n\nFunction syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.\n\nDeclaration\n\nFunctions are declared with the fun keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.\n\nfun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <acquires [identifier],*> <function_body>\n\n\nFor example\n\nfun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n\nVisibility\n\nModule functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.\n\naddress 0x42 {\nmodule m {\n    fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\n\nTo allow access from other modules or from scripts, the function must be declared public or public(friend).\n\npublic visibility\n\nA public function can be called by any function defined in any module or script. As shown in the following example, a public function can be called by:\n\nother functions defined in the same module,\nfunctions defined in another module, or\nthe function defined in a script.\naddress 0x42 {\nmodule m {\n    public fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n\npublic(friend) visibility\n\nThe public(friend) visibility modifier is a more restricted form of the public modifier to give more control about where a function can be used. A public(friend) function can be called by:\n\nother functions defined in the same module, or\nfunctions defined in modules which are explicitly specified in the friend list (see Friends on how to specify the friend list).\n\nNote that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a public(friend) function.\n\naddress 0x42 {\nmodule m {\n    friend 0x42::n;  // friend declaration\n    public(friend) fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'\n    }\n}\n\nentry modifier\n\nThe entry modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-entry function will be called from a Move program already in execution.\n\nEssentially, entry functions are the \"main\" functions of a module, and they specify where Move programs start executing.\n\nNote though, an entry function can still be called by other Move functions. So while they can serve as the start of a Move program, they aren't restricted to that case.\n\nFor example:\n\naddress 0x42 {\nmodule m {\n    public entry fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid!\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n\nmodule other {\n    public entry fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n\n\nEven internal functions can be marked as entry! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)\n\naddress 0x42 {\nmodule m {\n    entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\nmodule other {\n    public entry fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\nName\n\nFunction names can start with letters a to z or letters A to Z. After the first character, function names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nfun FOO() {}\nfun bar_42() {}\nfun _bAZ19() {}\n    ^^^^^^ Invalid function name '_bAZ19'. Function names cannot start with '_'\n\nType Parameters\n\nAfter the name, functions can have type parameters\n\nfun id<T>(x: T): T { x }\nfun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }\n\n\nFor more details, see Move generics.\n\nParameters\n\nFunctions parameters are declared with a local variable name followed by a type annotation\n\nfun add(x: u64, y: u64): u64 { x + y }\n\n\nWe read this as x has type u64\n\nA function does not have to have any parameters at all.\n\nfun useless() { }\n\n\nThis is very common for functions that create new or empty data structures\n\naddress 0x42 {\nmodule example {\n  struct Counter { count: u64 }\n\n  fun new_counter(): Counter {\n      Counter { count: 0 }\n  }\n\n}\n}\n\nAcquires\n\nWhen a function accesses a resource using move_from, borrow_global, or borrow_global_mut, the function must indicate that it acquires that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.\n\naddress 0x42 {\nmodule example {\n\n    struct Balance has key { value: u64 }\n\n    public fun add_balance(s: &signer, value: u64) {\n        move_to(s, Balance { value })\n    }\n\n    public fun extract_balance(addr: address): u64 acquires Balance {\n        let Balance { value } = move_from(addr); // acquires needed\n        value\n    }\n}\n}\n\n\nacquires annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.\n\naddress 0x42 {\nmodule example {\n\n    struct Balance has key { value: u64 }\n\n    public fun add_balance(s: &signer, value: u64) {\n        move_to(s, Balance { value })\n    }\n\n    public fun extract_balance(addr: address): u64 acquires Balance {\n        let Balance { value } = move_from(addr); // acquires needed\n        value\n    }\n\n    public fun extract_and_add(sender: address, receiver: &signer) acquires Balance {\n        let value = extract_balance(sender); // acquires needed here\n        add_balance(receiver, value)\n    }\n}\n}\n\naddress 0x42 {\nmodule other {\n    fun extract_balance(addr: address): u64 {\n        0x42::example::extract_balance(addr) // no acquires needed\n    }\n}\n}\n\n\nA function can acquire as many resources as it needs to\n\naddress 0x42 {\nmodule example {\n    use std::vector;\n\n    struct Balance has key { value: u64 }\n    struct Box<T> has key { items: vector<T> }\n\n    public fun store_two<Item1: store, Item2: store>(\n        addr: address,\n        item1: Item1,\n        item2: Item2,\n    ) acquires Balance, Box {\n        let balance = borrow_global_mut<Balance>(addr); // acquires needed\n        balance.value = balance.value - 2;\n        let box1 = borrow_global_mut<Box<Item1>>(addr); // acquires needed\n        vector::push_back(&mut box1.items, item1);\n        let box2 = borrow_global_mut<Box<Item2>>(addr); // acquires needed\n        vector::push_back(&mut box2.items, item2);\n    }\n}\n}\n\nReturn type\n\nAfter the parameters, a function specifies its return type.\n\nfun zero(): u64 { 0 }\n\n\nHere : u64 indicates that the function's return type is u64.\n\nUsing tuples, a function can return multiple values:\n\nfun one_two_three(): (u64, u64, u64) { (0, 1, 2) }\n\n\nIf no return type is specified, the function has an implicit return type of unit (). These functions are equivalent:\n\nfun just_unit(): () { () }\nfun just_unit() { () }\nfun just_unit() { }\n\n\nscript functions must have a return type of unit ():\n\nscript {\n    fun do_nothing() {\n    }\n}\n\n\nAs mentioned in the tuples section, these tuple \"values\" are virtual and do not exist at runtime. So for a function that returns unit (), it will not be returning any value at all during execution.\n\nFunction body\n\nA function's body is an expression block. The return value of the function is the last value in the sequence\n\nfun example(): u64 {\n    let x = 0;\n    x = x + 1;\n    x // returns 'x'\n}\n\n\nSee the section below for more information on returns\n\nFor more information on expression blocks, see Move variables.\n\nNative Functions\n\nSome functions do not have a body specified, and instead have the body provided by the VM. These functions are marked native.\n\nWithout modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that native functions are used for either standard library code or for functionality needed for the given Move environment.\n\nMost native functions you will likely see are in standard library code such as vector\n\nmodule std::vector {\n    native public fun empty<Element>(): vector<Element>;\n    ...\n}\n\nCalling\n\nWhen calling a function, the name can be specified either through an alias or fully qualified\n\naddress 0x42 {\nmodule example {\n    public fun zero(): u64 { 0 }\n}\n}\n\nscript {\n    use 0x42::example::{Self, zero};\n    fun call_zero() {\n        // With the `use` above all of these calls are equivalent\n        0x42::example::zero();\n        example::zero();\n        zero();\n    }\n}\n\n\nWhen calling a function, an argument must be given for every parameter.\n\naddress 0x42 {\nmodule example {\n    public fun takes_none(): u64 { 0 }\n    public fun takes_one(x: u64): u64 { x }\n    public fun takes_two(x: u64, y: u64): u64 { x + y }\n    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }\n}\n}\n\nscript {\n    use 0x42::example;\n    fun call_all() {\n        example::takes_none();\n        example::takes_one(0);\n        example::takes_two(0, 1);\n        example::takes_three(0, 1, 2);\n    }\n}\n\n\nType arguments can be either specified or inferred. Both calls are equivalent.\n\naddress 0x42 {\nmodule example {\n    public fun id<T>(x: T): T { x }\n}\n}\n\nscript {\n    use 0x42::example;\n    fun call_all() {\n        example::id(0);\n        example::id<u64>(0);\n    }\n}\n\n\nFor more details, see Move generics.\n\nReturning values\n\nThe result of a function, its \"return value\", is the final value of its function body. For example\n\nfun add(x: u64, y: u64): u64 {\n    x + y\n}\n\n\nAs mentioned above, the function's body is an expression block. The expression block can sequence various statements, and the final expression in the block will be be the value of that block\n\nfun double_and_add(x: u64, y: u64): u64 {\n    let double_x = x * 2;\n    let double_y = y * 2;\n    double_x + double_y\n}\n\n\nThe return value here is double_x + double_y\n\nreturn expression\n\nA function implicitly returns the value that its body evaluates to. However, functions can also use the explicit return expression:\n\nfun f1(): u64 { return 0 }\nfun f2(): u64 { 0 }\n\n\nThese two functions are equivalent. In this slightly more involved example, the function subtracts two u64 values, but returns early with 0 if the second value is too large:\n\nfun safe_sub(x: u64, y: u64): u64 {\n    if (y > x) return 0;\n    x - y\n}\n\n\nNote that the body of this function could also have been written as if (y > x) 0 else x - y.\n\nHowever return really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:\n\nuse std::vector;\nuse std::option::{Self, Option};\nfun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        if (vector::borrow(v, i) == target) return option::some(i);\n        i = i + 1\n    };\n\n    option::none()\n}\n\n\nUsing return without an argument is shorthand for return (). That is, the following two functions are equivalent:\n\nfun foo() { return }\nfun foo() { return () }\n\nStructs and Resources\n\nA struct is a user-defined data structure containing typed fields. Structs can store any non-reference type, including other structs.\n\nWe often refer to struct values as resources if they cannot be copied and cannot be dropped. In this case, resource values must have ownership transferred by the end of the function. This property makes resources particularly well served for defining global storage schemas or for representing important values (such as a token).\n\nBy default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped, and cannot be stored in global storage. This means that all values have to have ownership transferred (linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can relax this behavior by giving the struct abilities which allow values to be copied or dropped and also to be stored in global storage or to define global storage schemas.\n\nDefining Structs\n\nStructs must be defined inside a module:\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64, y: bool }\n    struct Bar {}\n    struct Baz { foo: Foo, }\n    //                   ^ note: it is fine to have a trailing comma\n}\n}\n\n\nStructs cannot be recursive, so the following definition is invalid:\n\nstruct Foo { x: Foo }\n//              ^ error! Foo cannot contain Foo\n\n\nAs mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value to be used with certain operations (that copy it, drop it, store it in global storage, or use it as a storage schema), structs can be granted abilities by annotating them with has <ability>:\n\naddress 0x2 {\nmodule m {\n    struct Foo has copy, drop { x: u64, y: bool }\n}\n}\n\n\nFor more details, see the annotating structs section.\n\nNaming\n\nStructs must start with a capital letter A to Z. After the first letter, struct names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nstruct Foo {}\nstruct BAR {}\nstruct B_a_z_4_2 {}\n\n\nThis naming restriction of starting with A to Z is in place to give room for future language features. It may or may not be removed later.\n\nUsing Structs\nCreating Structs\n\nValues of a struct type can be created (or \"packed\") by indicating the struct name, followed by value for each field:\n\naddress 0x2 {\nmodule m {\n    struct Foo has drop { x: u64, y: bool }\n    struct Baz has drop { foo: Foo }\n\n    fun example() {\n        let foo = Foo { x: 0, y: false };\n        let baz = Baz { foo: foo };\n    }\n}\n}\n\n\nIf you initialize a struct field with a local variable whose name is the same as the field, you can use the following shorthand:\n\nlet baz = Baz { foo: foo };\n// is equivalent to\nlet baz = Baz { foo };\n\n\nThis is called sometimes called \"field name punning\".\n\nDestroying Structs via Pattern Matching\n\nStruct values can be destroyed by binding or assigning them patterns.\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64, y: bool }\n    struct Bar { foo: Foo }\n    struct Baz {}\n\n    fun example_destroy_foo() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: foo_y } = foo;\n        //        ^ shorthand for `x: x`\n\n        // two new bindings\n        //   x: u64 = 3\n        //   foo_y: bool = false\n    }\n\n    fun example_destroy_foo_wildcard() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: _ } = foo;\n\n        // only one new binding since y was bound to a wildcard\n        //   x: u64 = 3\n    }\n\n    fun example_destroy_foo_assignment() {\n        let x: u64;\n        let y: bool;\n        Foo { x, y } = Foo { x: 3, y: false };\n\n        // mutating existing variables x & y\n        //   x = 3, y = false\n    }\n\n    fun example_foo_ref() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &foo;\n\n        // two new bindings\n        //   x: &u64\n        //   y: &bool\n    }\n\n    fun example_foo_ref_mut() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &mut foo;\n\n        // two new bindings\n        //   x: &mut u64\n        //   y: &mut bool\n    }\n\n    fun example_destroy_bar() {\n        let bar = Bar { foo: Foo { x: 3, y: false } };\n        let Bar { foo: Foo { x, y } } = bar;\n        //             ^ nested pattern\n\n        // two new bindings\n        //   x: u64 = 3\n        //   y: bool = false\n    }\n\n    fun example_destroy_baz() {\n        let baz = Baz {};\n        let Baz {} = baz;\n    }\n}\n}\n\nBorrowing Structs and Fields\n\nThe & and &mut operator can be used to create references to structs or fields. These examples include some optional type annotations (e.g., : &Foo) to demonstrate the type of operations.\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref: &Foo = &foo;\nlet y: bool = foo_ref.y;          // reading a field via a reference to the struct\nlet x_ref: &u64 = &foo.x;\n\nlet x_ref_mut: &mut u64 = &mut foo.x;\n*x_ref_mut = 42;            // modifying a field via a mutable reference\n\n\nIt is possible to borrow inner fields of nested structs:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo };\n\nlet x_ref = &bar.foo.x;\n\n\nYou can also borrow a field via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &foo;\nlet x_ref = &foo_ref.x;\n// this has the same effect as let x_ref = &foo.x\n\nReading and Writing Fields\n\nIf you need to read and copy a field's value, you can then dereference the borrowed field:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo: copy foo };\nlet x: u64 = *&foo.x;\nlet y: bool = *&foo.y;\nlet foo2: Foo = *&bar.foo;\n\n\nIf the field is implicitly copyable, the dot operator can be used to read fields of a struct without any borrowing. (Only scalar values with the copy ability are implicitly copyable.)\n\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n\n\nDot operators can be chained to access nested fields:\n\nlet baz = Baz { foo: Foo { x: 3, y: true } };\nlet x = baz.foo.x; // x = 3;\n\n\nHowever, this is not permitted for fields that contain non-primitive types, such a vector or another struct:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo };\nlet foo2: Foo = *&bar.foo;\nlet foo3: Foo = bar.foo; // error! must add an explicit copy with *&\n\n\nThe reason behind this design decision is that copying a vector or another struct might be an expensive operation. It is important for a programmer to be aware of this copy and make others aware with the explicit syntax *&.\n\nIn addition reading from fields, the dot syntax can be used to modify fields, regardless of the field being a primitive type or some other struct.\n\nlet foo = Foo { x: 3, y: true };\nfoo.x = 42;     // foo = Foo { x: 42, y: true }\nfoo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }\nbar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }\nbar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }\n\n\nThe dot syntax also works via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &mut foo;\nfoo_ref.x = foo_ref.x + 1;\n\nPrivileged Struct Operations\n\nMost struct operations on a struct type T can only be performed inside the module that declares T:\n\nStruct types can only be created (\"packed\"), destroyed (\"unpacked\") inside the module that defines the struct.\nThe fields of a struct are only accessible inside the module that defines the struct.\n\nFollowing these rules, if you want to modify your struct outside the module, you will need to provide public APIs for them. The end of the chapter contains some examples of this.\n\nHowever, struct types are always visible to another module or script:\n\n// m.move\naddress 0x2 {\nmodule m {\n    struct Foo has drop { x: u64 }\n\n    public fun new_foo(): Foo {\n        Foo { x: 42 }\n    }\n}\n}\n\n// n.move\naddress 0x2 {\nmodule n {\n    use 0x2::m;\n\n    struct Wrapper has drop {\n        foo: m::Foo\n    }\n\n    fun f1(foo: m::Foo) {\n        let x = foo.x;\n        //      ^ error! cannot access fields of `foo` here\n    }\n\n    fun f2() {\n        let foo_wrapper = Wrapper { foo: m::new_foo() };\n    }\n}\n}\n\n\nNote that structs do not have visibility modifiers (e.g., public or private).\n\nOwnership\n\nAs mentioned above in Defining Structs, structs are by default linear and ephemeral. This means they cannot be copied or dropped. This property can be very useful when modeling real world resources like money, as you do not want money to be duplicated or get lost in circulation.\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64 }\n\n    public fun copying_resource() {\n        let foo = Foo { x: 100 };\n        let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability\n        let foo_ref = &foo;\n        let another_copy = *foo_ref // error! dereference requires the 'copy' ability\n    }\n\n    public fun destroying_resource1() {\n        let foo = Foo { x: 100 };\n\n        // error! when the function returns, foo still contains a value.\n        // This destruction requires the 'drop' ability\n    }\n\n    public fun destroying_resource2(f: &mut Foo) {\n        *f = Foo { x: 100 } // error!\n                            // destroying the old value via a write requires the 'drop' ability\n    }\n}\n}\n\n\nTo fix the second example (fun destroying_resource1), you would need to manually \"unpack\" the resource:\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64 }\n\n    public fun destroying_resource1_fixed() {\n        let foo = Foo { x: 100 };\n        let Foo { x: _ } = foo;\n    }\n}\n}\n\n\nRecall that you are only able to deconstruct a resource within the module in which it is defined. This can be leveraged to enforce certain invariants in a system, for example, conservation of money.\n\nIf on the other hand, your struct does not represent something valuable, you can add the abilities copy and drop to get a struct value that might feel more familiar from other programming languages:\n\naddress 0x2 {\nmodule m {\n    struct Foo has copy, drop { x: u64 }\n\n    public fun run() {\n        let foo = Foo { x: 100 };\n        let foo_copy = copy foo;\n        // ^ this code copies foo, whereas `let x = foo` or\n        // `let x = move foo` both move foo\n\n        let x = foo.x;            // x = 100\n        let x_copy = foo_copy.x;  // x = 100\n\n        // both foo and foo_copy are implicitly discarded when the function returns\n    }\n}\n}\n\nStoring Resources in Global Storage\n\nOnly structs with the key ability can be saved directly in persistent global storage. All values stored within those key structs must have the store ability. See the ability and global storage chapters for more detail.\n\nExamples\n\nHere are two short examples of how you might use structs to represent valuable data (in the case of Coin) or more classical data (in the case of Point and Circle).\n\nExample 1: Coin\naddress 0x2 {\nmodule m {\n    // We do not want the Coin to be copied because that would be duplicating this \"money\",\n    // so we do not give the struct the 'copy' ability.\n    // Similarly, we do not want programmers to destroy coins, so we do not give the struct the\n    // 'drop' ability.\n    // However, we *want* users of the modules to be able to store this coin in persistent global\n    // storage, so we grant the struct the 'store' ability. This struct will only be inside of\n    // other resources inside of global storage, so we do not give the struct the 'key' ability.\n    struct Coin has store {\n        value: u64,\n    }\n\n    public fun mint(value: u64): Coin {\n        // You would want to gate this function with some form of access control to prevent\n        // anyone using this module from minting an infinite amount of coins.\n        Coin { value }\n    }\n\n    public fun withdraw(coin: &mut Coin, amount: u64): Coin {\n        assert!(coin.balance >= amount, 1000);\n        coin.value = coin.value - amount;\n        Coin { value: amount }\n    }\n\n    public fun deposit(coin: &mut Coin, other: Coin) {\n        let Coin { value } = other;\n        coin.value = coin.value + value;\n    }\n\n    public fun split(coin: Coin, amount: u64): (Coin, Coin) {\n        let other = withdraw(&mut coin, amount);\n        (coin, other)\n    }\n\n    public fun merge(coin1: Coin, coin2: Coin): Coin {\n        deposit(&mut coin1, coin2);\n        coin1\n    }\n\n    public fun destroy_zero(coin: Coin) {\n        let Coin { value } = coin;\n        assert!(value == 0, 1001);\n    }\n}\n}\n\nExample 2: Geometry\naddress 0x2 {\nmodule point {\n    struct Point has copy, drop, store {\n        x: u64,\n        y: u64,\n    }\n\n    public fun new(x: u64, y: u64): Point {\n        Point {\n            x, y\n        }\n    }\n\n    public fun x(p: &Point): u64 {\n        p.x\n    }\n\n    public fun y(p: &Point): u64 {\n        p.y\n    }\n\n    fun abs_sub(a: u64, b: u64): u64 {\n        if (a < b) {\n            b - a\n        }\n        else {\n            a - b\n        }\n    }\n\n    public fun dist_squared(p1: &Point, p2: &Point): u64 {\n        let dx = abs_sub(p1.x, p2.x);\n        let dy = abs_sub(p1.y, p2.y);\n        dx*dx + dy*dy\n    }\n}\n}\n\naddress 0x2 {\nmodule circle {\n    use 0x2::point::{Self, Point};\n\n    struct Circle has copy, drop, store {\n        center: Point,\n        radius: u64,\n    }\n\n    public fun new(center: Point, radius: u64): Circle {\n        Circle { center, radius }\n    }\n\n    public fun overlaps(c1: &Circle, c2: &Circle): bool {\n        let d = point::dist_squared(&c1.center, &c2.center);\n        let r1 = c1.radius;\n        let r2 = c2.radius;\n        d*d <= r1*r1 + 2*r1*r2 + r2*r2\n    }\n}\n}\n\nConstants\n\nConstants are a way of giving a name to shared, static values inside of a module or script.\n\nThe constant's must be known at compilation. The constant's value is stored in the compiled module or script. And each time the constant is used, a new copy of that value is made.\n\nDeclaration\n\nConstant declarations begin with the const keyword, followed by a name, a type, and a value. They can exist in either a script or module\n\nconst <name>: <type> = <expression>;\n\n\nFor example\n\nscript {\n\n    const MY_ERROR_CODE: u64 = 0;\n\n    fun main(input: u64) {\n        assert!(input > 0, MY_ERROR_CODE);\n    }\n\n}\n\naddress 0x42 {\nmodule example {\n\n    const MY_ADDRESS: address = @0x42;\n\n    public fun permissioned(s: &signer) {\n        assert!(std::signer::address_of(s) == MY_ADDRESS, 0);\n    }\n\n}\n}\n\nNaming\n\nConstants must start with a capital letter A to Z. After the first letter, constant names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nconst FLAG: bool = false;\nconst MY_ERROR_CODE: u64 = 0;\nconst ADDRESS_42: address = @0x42;\n\n\nEven though you can use letters a to z in a constant. The general style guidelines are to use just uppercase letters A to Z, with underscores _ between each word.\n\nThis naming restriction of starting with A to Z is in place to give room for future language features. It may or may not be removed later.\n\nVisibility\n\npublic constants are not currently supported. const values can be used only in the declaring module.\n\nValid Expressions\n\nCurrently, constants are limited to the primitive types bool, u8, u16, u32, u64, u128, u256, address, and vector<u8>. Future support for other vector values (besides the \"string\"-style literals) will come later.\n\nValues\n\nCommonly, consts are assigned a simple value, or literal, of their type. For example\n\nconst MY_BOOL: bool = false;\nconst MY_ADDRESS: address = @0x70DD;\nconst BYTES: vector<u8> = b\"hello world\";\nconst HEX_BYTES: vector<u8> = x\"DEADBEEF\";\n\nComplex Expressions\n\nIn addition to literals, constants can include more complex expressions, as long as the compiler is able to reduce the expression to a value at compile time.\n\nCurrently, equality operations, all boolean operations, all bitwise operations, and all arithmetic operations can be used.\n\nconst RULE: bool = true && false;\nconst CAP: u64 = 10 * 100 + 1;\nconst SHIFTY: u8 = {\n  (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)\n};\nconst HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\nconst REM: u256 = 57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\nconst EQUAL: bool = 1 == 1;\n\n\nIf the operation would result in a runtime exception, the compiler will give an error that it is unable to generate the constant's value\n\nconst DIV_BY_ZERO: u64 = 1 / 0; // error!\nconst SHIFT_BY_A_LOT: u64 = 1 << 100; // error!\nconst NEGATIVE_U64: u64 = 0 - 1; // error!\n\n\nNote that constants cannot currently refer to other constants. This feature, along with support for other expressions, will be added in the future.\n\nGenerics\n\nGenerics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term generics interchangeably with type parameters and type arguments.\n\nGenerics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.\n\nDeclaring Type Parameters\n\nBoth functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets <...>.\n\nGeneric Functions\n\nType parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.\n\nfun id<T>(x: T): T {\n    // this type annotation is unnecessary but valid\n    (x: T)\n}\n\n\nOnce defined, the type parameter T can be used in parameter types, return types, and inside the function body.\n\nGeneric Structs\n\nType parameters for structs are placed after the struct name, and can be used to name the types of the fields.\n\nstruct Foo<T> has copy, drop { x: T }\n\nstruct Bar<T1, T2> has copy, drop {\n    x: T1,\n    y: vector<T2>,\n}\n\n\nNote that type parameters do not have to be used\n\nType Arguments\nCalling Generic Functions\n\nWhen calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.\n\nfun foo() {\n    let x = id<bool>(true);\n}\n\n\nIf you do not specify the type arguments, Move's type inference will supply them for you.\n\nUsing Generic Structs\n\nSimilarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.\n\nfun foo() {\n    let foo = Foo<bool> { x: true };\n    let Foo<bool> { x } = foo;\n}\n\n\nIf you do not specify the type arguments, Move's type inference will supply them for you.\n\nType Argument Mismatch\n\nIf you specify the type arguments and they conflict with the actual values supplied, an error will be given:\n\nfun foo() {\n    let x = id<u64>(true); // error! true is not a u64\n}\n\n\nand similarly:\n\nfun foo() {\n    let foo = Foo<bool> { x: 0 }; // error! 0 is not a bool\n    let Foo<address> { x } = foo; // error! bool is incompatible with address\n}\n\nType Inference\n\nIn most cases, the Move compiler will be able to infer the type arguments so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments:\n\nfun foo() {\n    let x = id(true);\n    //        ^ <bool> is inferred\n\n    let foo = Foo { x: true };\n    //           ^ <bool> is inferred\n\n    let Foo { x } = foo;\n    //     ^ <bool> is inferred\n}\n\n\nNote: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.\n\naddress 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        // let v = vector::new();\n        //                    ^ The compiler cannot figure out the element type.\n\n        let v = vector::new<u64>();\n        //                 ^~~~~ Must annotate manually.\n    }\n}\n}\n\n\nHowever, the compiler will be able to infer the type if that return value is used later in that function:\n\naddress 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        let v = vector::new();\n        //                 ^ <u64> is inferred\n        vector::push_back(&mut v, 42);\n    }\n}\n}\n\nUnused Type Parameters\n\nFor a struct definition, an unused type parameter is one that does not appear in any field defined in the struct, but is checked statically at compile time. Move allows unused type parameters so the following struct definition is valid:\n\nstruct Foo<T> {\n    foo: u64\n}\n\n\nThis can be convenient when modeling certain concepts. Here is an example:\n\naddress 0x2 {\nmodule m {\n    // Currency Specifiers\n    struct Currency1 {}\n    struct Currency2 {}\n\n    // A generic coin type that can be instantiated using a currency\n    // specifier type.\n    //   e.g. Coin<Currency1>, Coin<Currency2> etc.\n    struct Coin<Currency> has store {\n        value: u64\n    }\n\n    // Write code generically about all currencies\n    public fun mint_generic<Currency>(value: u64): Coin<Currency> {\n        Coin { value }\n    }\n\n    // Write code concretely about one currency\n    public fun mint_concrete(value: u64): Coin<Currency1> {\n        Coin { value }\n    }\n}\n}\n\n\nIn this example, struct Coin<Currency> is generic on the Currency type parameter, which specifies the currency of the coin and allows code to be written either generically on any currency or concretely on a specific currency. This genericity applies even when the Currency type parameter does not appear in any of the fields defined in Coin.\n\nPhantom Type Parameters\n\nIn the example above, although struct Coin asks for the store ability, neither Coin<Currency1> nor Coin<Currency2> will have the store ability. This is because of the rules for Conditional Abilities and Generic Types and the fact that Currency1 and Currency2 don't have the store ability, despite the fact that they are not even used in the body of struct Coin. This might cause some unpleasant consequences. For example, we are unable to put Coin<Currency1> into a wallet in the global storage.\n\nOne possible solution would be to add spurious ability annotations to Currency1 and Currency2 (i.e., struct Currency1 has store {}). But, this might lead to bugs or security vulnerabilities because it weakens the types with unnecessary ability declarations. For example, we would never expect a resource in the global storage to have a field in type Currency1, but this would be possible with the spurious store ability. Moreover, the spurious annotations would be infectious, requiring many functions generic on the unused type parameter to also include the necessary constraints.\n\nPhantom type parameters solve this problem. Unused type parameters can be marked as phantom type parameters, which do not participate in the ability derivation for structs. In this way, arguments to phantom type parameters are not considered when deriving the abilities for generic types, thus avoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type system guarantees that a parameter declared as phantom is either not used at all in the struct definition, or it is only used as an argument to type parameters also declared as phantom.\n\nDeclaration\n\nIn a struct definition a type parameter can be declared as phantom by adding the phantom keyword before its declaration. If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a struct, Move's type checker ensures that every phantom type parameter is either not used inside the struct definition or it is only used as an argument to a phantom type parameter.\n\nMore formally, if a type is used as an argument to a phantom type parameter we say the type appears in phantom position. With this definition in place, the rule for the correct use of phantom parameters can be specified as follows: A phantom type parameter can only appear in phantom position.\n\nThe following two examples show valid uses of phantom parameters. In the first one, the parameter T1 is not used at all inside the struct definition. In the second one, the parameter T1 is only used as an argument to a phantom type parameter.\n\nstruct S1<phantom T1, T2> { f: u64 }\n                  ^^\n                  Ok: T1 does not appear inside the struct definition\n\n\nstruct S2<phantom T1, T2> { f: S1<T1, T2> }\n                                  ^^\n                                  Ok: T1 appears in phantom position\n\n\nThe following code shows examples of violations of the rule:\n\nstruct S1<phantom T> { f: T }\n                          ^\n                          Error: Not a phantom position\n\nstruct S2<T> { f: T }\n\nstruct S3<phantom T> { f: S2<T> }\n                             ^\n                             Error: Not a phantom position\n\nInstantiation\n\nWhen instantiating a struct, the arguments to phantom parameters are excluded when deriving the struct abilities. For example, consider the following code:\n\nstruct S<T1, phantom T2> has copy { f: T1 }\nstruct NoCopy {}\nstruct HasCopy has copy {}\n\n\nConsider now the type S<HasCopy, NoCopy>. Since S is defined with copy and all non-phantom arguments have copy then S<HasCopy, NoCopy> also has copy.\n\nPhantom Type Parameters with Ability Constraints\n\nAbility constraints and phantom type parameters are orthogonal features in the sense that phantom parameters can be declared with ability constraints. When instantiating a phantom type parameter with an ability constraint, the type argument has to satisfy that constraint, even though the parameter is phantom. For example, the following definition is perfectly valid:\n\nstruct S<phantom T: copy> {}\n\n\nThe usual restrictions apply and T can only be instantiated with arguments having copy.\n\nConstraints\n\nIn the examples above, we have demonstrated how one can use type parameters to define \"unknown\" types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no abilities.\n\nThis is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.\n\nDeclaring Constraints\n\nConstraints can be imposed on type parameters using the following syntax.\n\n// T is the name of the type parameter\nT: <ability> (+ <ability>)*\n\n\nThe <ability> can be any of the four abilities, and a type parameter can be constrained with multiple abilities at once. So all of the following would be valid type parameter declarations:\n\nT: copy\nT: copy + drop\nT: copy + drop + store + key\n\nVerifying Constraints\n\nConstraints are checked at call sites so the following code won't compile.\n\nstruct Foo<T: key> { x: T }\n\nstruct Bar { x: Foo<u8> }\n//                  ^ error! u8 does not have 'key'\n\nstruct Baz<T> { x: Foo<T> }\n//                     ^ error! T does not have 'key'\n\nstruct R {}\n\nfun unsafe_consume<T>(x: T) {\n    // error! x does not have 'drop'\n}\n\nfun consume<T: drop>(x: T) {\n    // valid!\n    // x will be dropped automatically\n}\n\nfun foo() {\n    let r = R {};\n    consume<R>(r);\n    //      ^ error! R does not have 'drop'\n}\n\nstruct R {}\n\nfun unsafe_double<T>(x: T) {\n    (copy x, x)\n    // error! x does not have 'copy'\n}\n\nfun double<T: copy>(x: T) {\n    (copy x, x) // valid!\n}\n\nfun foo(): (R, R) {\n    let r = R {};\n    double<R>(r)\n    //     ^ error! R does not have 'copy'\n}\n\n\nFor more information, see the abilities section on conditional abilities and generic types.\n\nLimitations on Recursions\nRecursive Structs\n\nGeneric structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All of the following struct definitions are invalid:\n\nstruct Foo<T> {\n    x: Foo<u64> // error! 'Foo' containing 'Foo'\n}\n\nstruct Bar<T> {\n    x: Bar<T> // error! 'Bar' containing 'Bar'\n}\n\n// error! 'A' and 'B' forming a cycle, which is not allowed either.\nstruct A<T> {\n    x: B<T, u64>\n}\n\nstruct B<T1, T2> {\n    x: A<T1>\n    y: A<T2>\n}\n\nAdvanced Topic: Type-level Recursions\n\nMove allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.\n\nAllowed:\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<T> -> foo<T> -> ... is valid\n    fun foo<T>() {\n        foo<T>();\n    }\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid\n    fun foo<T>() {\n        foo<A<u64>>();\n    }\n}\n}\n\n\nNot allowed:\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...\n    fun foo<T>() {\n        foo<Foo<T>>();\n    }\n}\n}\n\naddress 0x2 {\nmodule n {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>\n    //   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>\n    //   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>\n    //   -> ...\n    fun foo<T1, T2>() {\n        bar<T2, T1>();\n    }\n\n    fun bar<T1, T2> {\n        foo<T1, A<T2>>();\n    }\n}\n}\n\n\nNote, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    fun foo<T>(n: u64) {\n        if (n > 0) {\n            foo<A<T>>(n - 1);\n        };\n    }\n}\n}\n\n\nThe function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system.\n\nAbilities\n\nAbilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the \"linear\" typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).\n\nThe Four Abilities\n\nThe four abilities are:\n\ncopy\nAllows values of types with this ability to be copied.\ndrop\nAllows values of types with this ability to be popped/dropped.\nstore\nAllows values of types with this ability to exist inside a struct in global storage.\nkey\nAllows the type to serve as a key for global storage operations.\ncopy\n\nThe copy ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the copy operator and to copy values via references with dereference *e.\n\nIf a value has copy, all values contained inside of that value have copy.\n\ndrop\n\nThe drop ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:\n\nnot using the value in a local variable or parameter\nnot using the value in a sequence via ;\noverwriting values in variables in assignments\noverwriting values via references when writing *e1 = e2.\n\nIf a value has drop, all values contained inside of that value have drop.\n\nstore\n\nThe store ability allows values of types with this ability to exist inside of a struct (resource) in global storage, but not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with key.\n\nIf a value has store, all values contained inside of that value have store\n\nkey\n\nThe key ability allows the type to serve as a key for global storage operations. It gates all global storage operations, so in order for a type to be used with move_to, borrow_global, move_from, etc., the type must have the key ability. Note that the operations still must be used in the module where the key type is defined (in a sense, the operations are private to the defining module).\n\nIf a value has key, all values contained inside of that value have store. This is the only ability with this sort of asymmetry.\n\nBuiltin Types\n\nMost primitive, builtin types have copy, drop, and store with the exception of signer, which just has drop\n\nbool, u8, u16, u32, u64, u128, u256, and address all have copy, drop, and store.\nsigner has drop\nCannot be copied and cannot be put into global storage\nvector<T> may have copy, drop, and store depending on the abilities of T.\nSee Conditional Abilities and Generic Types for more details.\nImmutable references & and mutable references &mut both have copy and drop.\nThis refers to copying and dropping the reference itself, not what they refer to.\nReferences cannot appear in global storage, hence they do not have store.\n\nNone of the primitive types have key, meaning none of them can be used directly with the global storage operations.\n\nAnnotating Structs\n\nTo declare that a struct has an ability, it is declared with has <ability> after the struct name but before the fields. For example:\n\nstruct Ignorable has drop { f: u64 }\nstruct Pair has copy, drop, store { x: u64, y: u64 }\n\n\nIn this case: Ignorable has the drop ability. Pair has copy, drop, and store.\n\nAll of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!\n\nAs such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...\n\ncopy, all fields must have copy.\ndrop, all fields must have drop.\nstore, all fields must have store.\nkey, all fields must have store.\nkey is the only ability currently that doesn’t require itself.\n\nFor example:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct WantsCopy has copy {\n    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'\n}\n\n\nand similarly:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct MyResource has key {\n    f: NoAbilities, // Error 'NoAbilities' does not have 'store'\n}\n\nConditional Abilities and Generic Types\n\nWhen abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:\n\nstruct Cup<T> has copy, drop, store, key { item: T }\n\n\nIt might be very helpful if Cup could hold any type, regardless of its abilities. The type system can see the type parameter, so it should be able to remove abilities from Cup if it sees a type parameter that would violate the guarantees for that ability.\n\nThis behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type vector to have the following type declaration:\n\nvector<T> has copy, drop, store;\n\n\nWe want vectors to work with any type. We don't want separate vector types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above. So, it would be safe to copy a vector value only if the inner elements can be copied. It would be safe to ignore a vector value only if the inner elements can be ignored/dropped. And, it would be safe to put a vector in global storage only if the inner elements can be in global storage.\n\nTo have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration and its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking Cup from above as an example:\n\nCup has the ability copy only if T has copy.\nIt has drop only if T has drop.\nIt has store only if T has store.\nIt has key only if T has store.\n\nHere are examples for this conditional system for each ability:\n\nExample: conditional copy\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun example(c_x: Cup<u64>, c_s: Cup<S>) {\n    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'\n    let c_x2 = copy c_x;\n    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'\n    let c_s2 = copy c_s;\n}\n\nfun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {\n    // Invalid, 'Cup<signer>' does not have 'copy'.\n    // Even though 'Cup' was declared with copy, the instance does not have 'copy'\n    // because 'signer' does not have 'copy'\n    let c_account2 = copy c_account;\n    // Invalid, 'Cup<NoAbilities>' does not have 'copy'\n    // because 'NoAbilities' does not have 'copy'\n    let c_n2 = copy c_n;\n}\n\nExample: conditional drop\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun unused() {\n    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'\n    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'\n}\n\nfun left_in_local(c_account: Cup<signer>): u64 {\n    let c_b = Cup<bool> { item: true };\n    let c_s = Cup<S> { item: S { f: false }};\n    // Valid return: 'c_account', 'c_b', and 'c_s' have values\n    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'\n    0\n}\n\nfun invalid_unused() {\n    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.\n    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'\n    // because 'NoAbilities' does not have 'drop'\n    Cup<NoAbilities> { item: NoAbilities {}};\n}\n\nfun invalid_left_in_local(): u64 {\n    let n = Cup<NoAbilities> { item: NoAbilities {}};\n    // Invalid return: 'n' has a value\n    // and 'Cup<NoAbilities>' does not have 'drop'\n    0\n}\n\nExample: conditional store\nstruct Cup<T> has copy, drop, store { item: T }\n\n// 'MyInnerResource' is declared with 'store' so all fields need 'store'\nstruct MyInnerResource has store {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\n// 'MyResource' is declared with 'key' so all fields need 'store'\nstruct MyResource has key {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    inner: Cup<MyInnerResource>, // Valid, 'Cup<MyInnerResource>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\nExample: conditional key\nstruct NoAbilities {}\nstruct MyResource<T> has key { f: T }\n\nfun valid(account: &signer) acquires MyResource {\n    let addr = signer::address_of(account);\n     // Valid, 'MyResource<u64>' has 'key'\n    let has_resource = exists<MyResource<u64>>(addr);\n    if (!has_resource) {\n         // Valid, 'MyResource<u64>' has 'key'\n        move_to(account, MyResource<u64> { f: 0 })\n    };\n    // Valid, 'MyResource<u64>' has 'key'\n    let r = borrow_global_mut<MyResource<u64>>(addr)\n    r.f = r.f + 1;\n}\n\nfun invalid(account: &signer) {\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let has_it = exists<MyResource<NoAbilities>>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let NoAbilities {} = move_from<NoAbilities>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   move_to(account, NoAbilities {});\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   borrow_global<NoAbilities>(addr);\n}\n\nUses and Aliases\n\nThe use syntax can be used to create aliases to members in other modules. use can be used to create aliases that last either for the entire module, or for a given expression block scope.\n\nSyntax\n\nThere are several different syntax cases for use. Starting with the most simple, we have the following for creating aliases to other modules\n\nuse <address>::<module name>;\nuse <address>::<module name> as <module alias name>;\n\n\nFor example\n\nuse std::vector;\nuse std::vector as V;\n\n\nuse std::vector; introduces an alias vector for std::vector. This means that anywhere you would want to use the module name std::vector (assuming this use is in scope), you could use vector instead. use std::vector; is equivalent to use std::vector as vector;\n\nSimilarly use std::vector as V; would let you use V instead of std::vector\n\nuse std::vector;\nuse std::vector as V;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = vector::empty();\n    let v3 = V::empty();\n    (v1, v2, v3)\n}\n\n\nIf you want to import a specific module member (such as a function, struct, or constant). You can use the following syntax.\n\nuse <address>::<module name>::<module member>;\nuse <address>::<module name>::<module member> as <member alias>;\n\n\nFor example\n\nuse std::vector::empty;\nuse std::vector::empty as empty_vec;\n\n\nThis would let you use the function std::vector::empty without full qualification. Instead you could use empty and empty_vec respectively. Again, use std::vector::empty; is equivalent to use std::vector::empty as empty;\n\nuse std::vector::empty;\nuse std::vector::empty as empty_vec;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = empty();\n    let v3 = empty_vec();\n    (v1, v2, v3)\n}\n\n\nIf you want to add aliases for multiple module members at once, you can do so with the following syntax\n\nuse <address>::<module name>::{<module member>, <module member> as <member alias> ... };\n\n\nFor example\n\nuse std::vector::{push_back, length as len, pop_back};\n\nfun swap_last_two<T>(v: &mut vector<T>) {\n    assert!(len(v) >= 2, 42);\n    let last = pop_back(v);\n    let second_to_last = pop_back(v);\n    push_back(v, last);\n    push_back(v, second_to_last)\n}\n\n\nIf you need to add an alias to the Module itself in addition to module members, you can do that in a single use using Self. Self is a member of sorts that refers to the module.\n\nuse std::vector::{Self, empty};\n\n\nFor clarity, all of the following are equivalent:\n\nuse std::vector;\nuse std::vector as vector;\nuse std::vector::Self;\nuse std::vector::Self as vector;\nuse std::vector::{Self};\nuse std::vector::{Self as vector};\n\n\nIf needed, you can have as many aliases for any item as you like\n\nuse std::vector::{\n    Self,\n    Self as V,\n    length,\n    length as len,\n};\n\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    // all options available given the `use` above\n    assert!(vector::length(v) > 1, 42);\n    assert!(V::length(v) > 1, 42);\n    assert!(length(v) > 1, 42);\n    assert!(len(v) > 1, 42);\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\nInside a module\n\nInside of a module all use declarations are usable regardless of the order of declaration.\n\naddress 0x42 {\nmodule example {\n    use std::vector;\n\n    fun example(): vector<u8> {\n        let v = empty();\n        vector::push_back(&mut v, 0);\n        vector::push_back(&mut v, 10);\n        v\n    }\n\n    use std::vector::empty;\n}\n}\n\n\nThe aliases declared by use in the module usable within that module.\n\nAdditionally, the aliases introduced cannot conflict with other module members. See Uniqueness for more details\n\nInside an expression\n\nYou can add use declarations to the beginning of any expression block\n\naddress 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        use std::vector::{empty, push_back};\n\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    }\n}\n}\n\n\nAs with let, the aliases introduced by use in an expression block are removed at the end of that block.\n\naddress 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        let result = {\n            use std::vector::{empty, push_back};\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 10);\n            v\n        };\n        result\n    }\n\n}\n}\n\n\nAttempting to use the alias after the block ends will result in an error\n\nfun example(): vector<u8> {\n    let result = {\n        use std::vector::{empty, push_back};\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    };\n    let v2 = empty(); // ERROR!\n//           ^^^^^ unbound function 'empty'\n    result\n}\n\n\nAny use must be the first item in the block. If the use comes after any expression or let, it will result in a parsing error\n\n{\n    let x = 0;\n    use std::vector; // ERROR!\n    let v = vector::empty();\n}\n\nNaming rules\n\nAliases must follow the same rules as other module members. This means that aliases to structs or constants must start with A to Z\n\naddress 0x42 {\nmodule data {\n    struct S {}\n    const FLAG: bool = false;\n    fun foo() {}\n}\nmodule example {\n    use 0x42::data::{\n        S as s, // ERROR!\n        FLAG as fLAG, // ERROR!\n        foo as FOO,  // valid\n        foo as bar, // valid\n    };\n}\n}\n\nUniqueness\n\nInside a given scope, all aliases introduced by use declarations must be unique.\n\nFor a module, this means aliases introduced by use cannot overlap\n\naddress 0x42 {\nmodule example {\n\n    use std::vector::{empty as foo, length as foo}; // ERROR!\n    //                                        ^^^ duplicate 'foo'\n\n    use std::vector::empty as bar;\n\n    use std::vector::length as bar; // ERROR!\n    //                         ^^^ duplicate 'bar'\n\n}\n}\n\n\nAnd, they cannot overlap with any of the module's other members\n\naddress 0x42 {\nmodule data {\n    struct S {}\n}\nmodule example {\n    use 0x42::data::S;\n\n    struct S { value: u64 } // ERROR!\n    //     ^ conflicts with alias 'S' above\n}\n}\n\n\nInside of an expression block, they cannot overlap with each other, but they can shadow other aliases or names from an outer scope\n\nShadowing\n\nuse aliases inside of an expression block can shadow names (module members or aliases) from the outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;\n\naddress 0x42 {\nmodule example {\n\n    struct WrappedVector { vec: vector<u64> }\n\n    fun empty(): WrappedVector {\n        WrappedVector { vec: std::vector::empty() }\n    }\n\n    fun example1(): (WrappedVector, WrappedVector) {\n        let vec = {\n            use std::vector::{empty, push_back};\n            // 'empty' now refers to std::vector::empty\n\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 1);\n            push_back(&mut v, 10);\n            v\n        };\n        // 'empty' now refers to Self::empty\n\n        (empty(), WrappedVector { vec })\n    }\n\n    fun example2(): (WrappedVector, WrappedVector) {\n        use std::vector::{empty, push_back};\n        let w: WrappedVector = {\n            use 0x42::example::empty;\n            empty()\n        };\n        push_back(&mut w.vec, 0);\n        push_back(&mut w.vec, 1);\n        push_back(&mut w.vec, 10);\n\n        let vec = empty();\n        push_back(&mut vec, 0);\n        push_back(&mut vec, 1);\n        push_back(&mut vec, 10);\n\n        (w, WrappedVector { vec })\n    }\n}\n}\n\nUnused Use or Alias\n\nAn unused use will result in an error\n\naddress 0x42 {\nmodule example {\n    use std::vector::{empty, push_back}; // ERROR!\n    //                       ^^^^^^^^^ unused alias 'push_back'\n\n    fun example(): vector<u8> {\n        empty()\n    }\n}\n}\n\nFriends\n\nThe friend syntax is used to declare modules that are trusted by the current module. A trusted module is allowed to call any function defined in the current module that have the public(friend) visibility. For details on function visibilities, please refer to the Visibility section in Functions.\n\nFriend declaration\n\nA module can declare other modules as friends via friend declaration statements, in the format of\n\nfriend <address::name> — friend declaration using fully qualified module name like the example below, or\n\naddress 0x42 {\nmodule a {\n    friend 0x42::b;\n}\n}\n\n\nfriend <module-name-alias> — friend declaration using a module name alias, where the module alias is introduced via the use statement.\n\naddress 0x42 {\nmodule a {\n    use 0x42::b;\n    friend b;\n}\n}\n\n\nA module may have multiple friend declarations, and the union of all the friend modules forms the friend list. In the example below, both 0x42::B and 0x42::C are considered as friends of 0x42::A.\n\naddress 0x42 {\nmodule a {\n    friend 0x42::b;\n    friend 0x42::c;\n}\n}\n\n\nUnlike use statements, friend can only be declared in the module scope and not in the expression block scope. friend declarations may be located anywhere a top-level construct (e.g., use, function, struct, etc.) is allowed. However, for readability, it is advised to place friend declarations near the beginning of the module definition.\n\nNote that the concept of friendship does not apply to Move scripts:\n\nA Move script cannot declare friend modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.\nA Move module cannot declare friend scripts as well because scripts are ephemeral code snippets that are never published to global storage.\nFriend declaration rules\n\nFriend declarations are subject to the following rules:\n\nA module cannot declare itself as a friend.\n\naddress 0x42 {\nmodule m { friend Self; // ERROR! }\n//                ^^^^ Cannot declare the module itself as a friend\n}\n\naddress 0x43 {\nmodule m { friend 0x43::M; // ERROR! }\n//                ^^^^^^^ Cannot declare the module itself as a friend\n}\n\n\nFriend modules must be known by the compiler\n\naddress 0x42 {\nmodule m { friend 0x42::nonexistent; // ERROR! }\n//                ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'\n}\n\n\nFriend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which may be relaxed later.)\n\naddress 0x42 {\nmodule m {}\n}\n\naddress 0x43 {\nmodule n { friend 0x42::m; // ERROR! }\n//                ^^^^^^^ Cannot declare modules out of the current address as a friend\n}\n\n\nFriends relationships cannot create cyclic module dependencies.\n\nCycles are not allowed in the friend relationships, e.g., the relation 0x2::a friends 0x2::b friends 0x2::c friends 0x2::a is not allowed. More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module). If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.\n\naddress 0x2 {\nmodule a {\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a() {\n        c::c()\n    }\n}\n\nmodule b {\n    friend 0x2::c; // ERROR!\n//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'\n}\n\nmodule c {\n    public fun c() {}\n}\n}\n\n\nThe friend list for a module cannot contain duplicates.\n\naddress 0x42 {\nmodule a {}\n\nmodule m {\n    use 0x42::a as aliased_a;\n    friend 0x42::A;\n    friend aliased_a; // ERROR!\n//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique\n}\n}\n\nPackages\n\nPackages allow Move programmers to more easily re-use code and share it across projects. The Move package system allows programmers to easily:\n\nDefine a package containing Move code;\nParameterize a package by named addresses;\nImport and use packages in other Move code and instantiate named addresses;\nBuild packages and generate associated compilation artifacts from packages; and\nWork with a common interface around compiled Move artifacts.\nPackage Layout and Manifest Syntax\n\nA Move package source directory contains a Move.toml package manifest file along with a set of subdirectories:\n\na_move_package\n├── Move.toml      (required)\n├── sources        (required)\n├── examples       (optional, test & dev mode)\n├── scripts        (optional)\n├── doc_templates  (optional)\n└── tests          (optional, test mode)\n\n\nThe directories marked required must be present in order for the directory to be considered a Move package and to be compiled. Optional directories can be present, and if so will be included in the compilation process. Depending on the mode that the package is built with (test or dev), the tests and examples directories will be included as well.\n\nThe sources directory can contain both Move modules and Move scripts (both transaction scripts and modules containing script functions). The examples directory can hold additional code to be used only for development and/or tutorial purposes that will not be included when compiled outside test or dev mode.\n\nA scripts directory is supported so transaction scripts can be separated from modules if that is desired by the package author. The scripts directory will always be included for compilation if it is present. Documentation will be built using any documentation templates present in the doc_templates directory.\n\nMove.toml\n\nThe Move package manifest is defined within the Move.toml file and has the following syntax. Optional fields are marked with *, + denotes one or more elements:\n\n[package]\nname = <string>                  # e.g., \"MoveStdlib\"\nversion = \"<uint>.<uint>.<uint>\" # e.g., \"0.1.1\"\nlicense* = <string>              # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\nauthors* = [<string>]            # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"Jane Smith (janesmith@noemail.com)\"]\n\n[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph\n# One or more lines declaring named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency\n# One or more lines declaring dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # local dependencies\n<string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # git dependencies\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }\n\n\nAn example of a minimal package manifest with one local dependency and one git dependency:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\n\n\nAn example of a more standard package manifest that also includes the Move standard library and instantiates the named address Std from it with the address value 0x1:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\nlicense = \"Apache 2.0\"\n\n[addresses]\naddress_to_be_filled_in = \"_\"\nspecified_address = \"0xB0B\"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = \"projects/move-awesomeness\", addr_subst = { \"std\" = \"0x1\" } }\n# Git dependency\nMoveStdlib = { git = \"https://github.com/diem/diem.git\", subdir=\"language/move-stdlib\", rev = \"56ab033cc403b489e891424a629e76f643d4fb6b\" }\n\n[dev-addresses] # For use when developing this module\naddress_to_be_filled_in = \"0x101010101\"\n\n\nMost of the sections in the package manifest are self explanatory, but named addresses can be a bit difficult to understand so it's worth examining them in a bit more detail.\n\nNamed Addresses During Compilation\n\nRecall that Move has named addresses and that named addresses cannot be declared in Move. Because of this, until now named addresses and their values needed to be passed to the compiler on the command line. With the Move package system this is no longer needed, and you can declare named addresses in the package, instantiate other named addresses in scope, and rename named addresses from other packages within the Move package system manifest file. Let's go through each of these individually:\n\nDeclaration\n\nLet's say we have a Move module in example_pkg/sources/A.move as follows:\n\nmodule named_addr::A {\n    public fun x(): address { @named_addr }\n}\n\n\nWe could in example_pkg/Move.toml declare the named address named_addr in two different ways. The first:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n\nDeclares named_addr as a named address in the package ExamplePkg and that this address can be any valid address value. Therefore an importing package can pick the value of the named address named_addr to be any address it wishes. Intuitively you can think of this as parameterizing the package ExamplePkg by the named address named_addr, and the package can then be instantiated later on by an importing package.\n\nnamed_addr can also be declared as:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"0xCAFE\"\n\n\nwhich states that the named address named_addr is exactly 0xCAFE and cannot be changed. This is useful so other importing packages can use this named address without needing to worry about the exact value assigned to it.\n\nWith these two different declaration methods, there are two ways that information about named addresses can flow in the package graph:\n\nThe former (\"unassigned named addresses\") allows named address values to flow from the importation site to the declaration site.\nThe latter (\"assigned named addresses\") allows named address values to flow from the declaration site upwards in the package graph to usage sites.\n\nWith these two methods for flowing named address information throughout the package graph the rules around scoping and renaming become important to understand.\n\nScoping and Renaming of Named Addresses\n\nA named address N in a package P is in scope if:\n\nIt declares a named address N; or\nA package in one of P's transitive dependencies declares the named address N and there is a dependency path in the package graph between between P and the declaring package of N with no renaming of N.\n\nAdditionally, every named address in a package is exported. Because of this and the above scoping rules each package can be viewed as coming with a set of named addresses that will be brought into scope when the package is imported, e.g., if the ExamplePkg package was imported, that importation would bring into scope the named_addr named address. Because of this, if P imports two packages P1 and P2 both of which declare a named address N an issue arises in P: which \"N\" is meant when N is referred to in P? The one from P1 or P2? To prevent this ambiguity around which package a named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a package are disjoint, and provide a way to rename named addresses when the package that brings them into scope is imported.\n\nRenaming a named address when importing can be done as follows in our P, P1, and P2 example above:\n\n[package]\nname = \"P\"\n...\n[dependencies]\nP1 = { local = \"some_path_to_P1\", addr_subst = { \"P1N\" = \"N\" } }\nP2 = { local = \"some_path_to_P2\"  }\n\n\nWith this renaming N refers to the N from P2 and P1N will refer to N coming from P1:\n\nmodule N::A {\n    public fun x(): address { @P1N }\n}\n\n\nIt is important to note that renaming is not local: once a named address N has been renamed to N2 in a package P all packages that import P will not see N but only N2 unless N is reintroduced from outside of P. This is why rule (2) in the scoping rules at the start of this section specifies a \"dependency path in the package graph between between P and the declaring package of N with no renaming of N.\"\n\nInstantiation\n\nNamed addresses can be instantiated multiple times across the package graph as long as it is always with the same value. It is an error if the same named address (regardless of renaming) is instantiated with differing values across the package graph.\n\nA Move package can only be compiled if all named addresses resolve to a value. This presents issues if the package wishes to expose an uninstantiated named address. This is what the [dev-addresses] section solves. This section can set values for named addresses, but cannot introduce any named addresses. Additionally, only the [dev-addresses] in the root package are included in dev mode. For example a root package with the following manifest would not compile outside of dev mode since named_addr would be uninstantiated:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n[dev-addresses]\nnamed_addr = \"0xC0FFEE\"\n\nUsage, Artifacts, and Data Structures\n\nThe Move package system comes with a command line option as part of the Move CLI move <flags> <command> <command_flags>. Unless a particular path is provided, all package commands will run in the current working directory. The full list of commands and flags for the Move CLI can be found by running move --help.\n\nUsage\n\nA package can be compiled either through the Move CLI commands, or as a library command in Rust with the function compile_package. This will create a CompiledPackage that holds the compiled bytecode along with other compilation artifacts (source maps, documentation, ABIs) in memory. This CompiledPackage can be converted to an OnDiskPackage and vice versa -- the latter being the data of the CompiledPackage laid out in the file system in the following format:\n\na_move_package\n├── Move.toml\n...\n└── build\n    ├── <dep_pkg_name>\n    │   ├── BuildInfo.yaml\n    │   ├── bytecode_modules\n    │   │   └── *.mv\n    │   ├── source_maps\n    │   │   └── *.mvsm\n    │   ├── bytecode_scripts\n    │   │   └── *.mv\n    │   ├── abis\n    │   │   ├── *.abi\n    │   │   └── <module_name>/*.abi\n    │   └── sources\n    │       └── *.move\n    ...\n    └── <dep_pkg_name>\n        ├── BuildInfo.yaml\n        ...\n        └── sources\n\n\nSee the move-package crate for more information on these data structures and how to use the Move package system as a Rust library.\n\nUnit Tests\n\nUnit testing for Move adds three new annotations to the Move source language:\n\n#[test]\n#[test_only], and\n#[expected_failure].\n\nThey respectively mark a function as a test, mark a module or module member (use, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as #[test_only] or #[test], it will not be included in the compiled bytecode unless it is compiled for testing.\n\nTesting Annotations: Their Meaning and Usage\n\nBoth the #[test] and #[expected_failure] annotations can be used either with or without arguments.\n\nWithout arguments, the #[test] annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.\n\n#[test] // OK\nfun this_is_a_test() { ... }\n\n#[test] // Will fail to compile since the test takes an argument\nfun this_is_not_correct(arg: signer) { ... }\n\n\nA test can also be annotated as an #[expected_failure]. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with #[expected_failure(abort_code = <code>)], if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the #[test] annotation can also be annotated as an #[expected_failure].\n\n#[test]\n#[expected_failure]\npublic fun this_test_will_abort_and_pass() { abort 1 }\n\n#[test]\n#[expected_failure]\npublic fun test_will_error_and_pass() { 1/0; }\n\n#[test]\n#[expected_failure(abort_code = 0)]\npublic fun test_will_error_and_fail() { 1/0; }\n\n#[test, expected_failure] // Can have multiple in one attribute. This test will pass.\npublic fun this_other_test_will_abort_and_pass() { abort 1 }\n\n\nWith arguments, a test annotation takes the form #[test(<param_name_1> = <address>, ..., <param_name_n> = <address>)]. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters <param_name_1>, ..., <param_name_n>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.\n\nOnly parameters with a type of signer are supported as test parameters. If a non-signer parameter is supplied, the test will result in an error when run.\n\n#[test(arg = @0xC0FFEE)] // OK\nfun this_is_correct_now(arg: signer) { ... }\n\n#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match\nfun this_is_incorrect(arg: signer) { ... }\n\n#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument\nfun this_works(a: signer, b: signer) { ... }\n\n// somewhere a named address is declared\n#[test_only] // test-only named addresses are supported\naddress TEST_NAMED_ADDR = @0x1;\n...\n#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!\nfun this_is_correct_now(arg: signer) { ... }\n\n\nAn expected failure annotation can also take the form #[expected_failure(abort_code = <u64>)]. If a test function is annotated in such a way, the test must abort with an abort code equal to <u64>. Any other failure or abort code will result in a test failure.\n\n#[test, expected_failure(abort_code = 1)] // This test will fail\nfun this_test_should_abort_and_fail() { abort 0 }\n\n#[test]\n#[expected_failure(abort_code = 0)] // This test will pass\nfun this_test_should_abort_and_pass_too() { abort 0 }\n\n\nA module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test uses of a #[test_only] module will raise an error during compilation.\n\n#[test_only] // test only attributes can be attached to modules\nmodule abc { ... }\n\n#[test_only] // test only attributes can be attached to named addresses\naddress ADDR = @0x1;\n\n#[test_only] // .. to uses\nuse 0x1::some_other_module;\n\n#[test_only] // .. to structs\nstruct SomeStruct { ... }\n\n#[test_only] // .. and functions. Can only be called from test code, but not a test\nfun test_only_function(...) { ... }\n\nRunning Unit Tests\n\nUnit tests for a Move package can be run with the move test command.\n\nWhen running tests, every test will either PASS, FAIL, or TIMEOUT. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.\n\nA test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see OPTIONS below).\n\nThere are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag:\n\n$ move -h\n\nExample\n\nA simple module using some of the unit testing features is shown in the following example:\n\nFirst create an empty package and change directory into it:\n\n$ move new TestExample; cd TestExample\n\n\nNext add the following to the Move.toml:\n\n[dependencies]\nMoveStdlib = { git = \"https://github.com/diem/diem.git\", subdir=\"language/move-stdlib\", rev = \"56ab033cc403b489e891424a629e76f643d4fb6b\", addr_subst = { \"std\" = \"0x1\" } }\n\n\nNext add the following module under the sources directory:\n\n// filename: sources/my_module.move\nmodule 0x1::my_module {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n\nRunning Tests\n\nYou can then run these tests with the move test command:\n\n$ move test\nBUILDING MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\nUsing Test Flags\n-f <str> or --filter <str>\n\nThis will only run tests whose fully qualified name contains <str>. For example if we wanted to only run tests with \"zero_coin\" in their name:\n\n$ move test -f zero_coin\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\n-i <bound> or --gas_used <bound>\n\nThis bounds the amount of gas that can be consumed for any one test to <bound>:\n\n$ move test -i 0\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ TIMEOUT ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ TIMEOUT ] 0x1::my_module::make_sure_zero_coin_fails\n[ TIMEOUT ] 0x1::my_module::test_has_coin\n\nTest failures:\n\nFailures in 0x1::my_module:\n\n┌── make_sure_non_zero_coin_passes ──────\n│ Test timed out\n└──────────────────\n\n\n┌── make_sure_zero_coin_fails ──────\n│ Test timed out\n└──────────────────\n\n\n┌── test_has_coin ──────\n│ Test timed out\n└──────────────────\n\nTest result: FAILED. Total tests: 3; passed: 0; failed: 3\n\n-s or --statistics\n\nWith these flags you can gather statistics about the tests run and report the runtime and gas used for each test. For example, if we wanted to see the statistics for the tests in the example above:\n\n$ move test -s\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\n\nTest Statistics:\n\n┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐\n│                   Test Name                    │    Time    │   Gas Used   │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::make_sure_non_zero_coin_passes │   0.009    │             1             │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::make_sure_zero_coin_fails      │   0.008    │             1             │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::test_has_coin                  │   0.008    │             1             │\n└────────────────────────────────────────────────┴────────────┴───────────────────────────┘\n\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\n-g or --state-on-error\n\nThese flags will print the global state for any test failures. e.g., if we added the following (failing) test to the my_module example:\n\nmodule 0x1::my_module {\n    ...\n    #[test(a = @0x1)]\n    fun test_has_coin_bad(a: signer) {\n        publish_coin(&a);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n    }\n}\n\n\nwe would get the following output when running the tests:\n\n$ move test -g\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\n[ FAIL    ] 0x1::my_module::test_has_coin_bad\n\nTest failures:\n\nFailures in 0x1::my_module:\n\n┌── test_has_coin_bad ──────\n│ error[E11001]: test failure\n│    ┌─ /home/tzakian/TestExample/sources/my_module.move:47:10\n│    │\n│ 44 │      fun test_has_coin_bad(a: signer) {\n│    │          ----------------- In this function in 0x1::my_module\n│    ·\n│ 47 │          assert!(has_coin(@0x2), 1);\n│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here\n│\n│\n│ ────── Storage state at point of failure ──────\n│ 0x1:\n│       => key 0x1::my_module::MyCoin {\n│           value: 1\n│       }\n│\n└──────────────────\n\nTest result: FAILED. Total tests: 4; passed: 3; failed: 1\n\nGlobal Storage - Structure\n\nThe purpose of Move programs is to read from and write to tree-shaped persistent global storage. Programs cannot access the filesystem, network, or any other data outside of this tree.\n\nIn pseudocode, the global storage looks something like:\n\nstruct GlobalStorage {\n  resources: Map<(address, ResourceType), ResourceValue>\n  modules: Map<(address, ModuleName), ModuleBytecode>\n}\n\n\nStructurally, global storage is a forest consisting of trees rooted at an account address. Each address can store both resource data values and module code values. As the pseudocode above indicates, each address can store at most one resource value of a given type and at most one module with a given name.\n\nGlobal Storage - Operators\n\nMove programs can create, delete, and update resources in global storage using the following five instructions:\n\nOperation\tDescription\tAborts?\nmove_to<T>(&signer,T)\tPublish T under signer.address\tIf signer.address already holds a T\nmove_from<T>(address): T\tRemove T from address and return it\tIf address does not hold a T\nborrow_global_mut<T>(address): &mut T\tReturn a mutable reference to the T stored under address\tIf address does not hold a T\nborrow_global<T>(address): &T\tReturn an immutable reference to the T stored under address\tIf address does not hold a T\nexists<T>(address): bool\tReturn true if a T is stored under address\tNever\n\nEach of these instructions is parameterized by a type T with the key ability. However, each type T must be declared in the current module. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an address or &signer representing the account address where the resource of type T is stored.\n\nReferences to resources\n\nReferences to global resources returned by borrow_global or borrow_global_mut mostly behave like references to local storage: they can be extended, read, and written using ordinary reference operators and passed as arguments to other function. However, there is one important difference between local and global references: a function cannot return a reference that points into global storage. For example, these two functions will each fail to compile:\n\nstruct R has key { f: u64 }\n// will not compile\nfun ret_direct_resource_ref_bad(a: address): &R {\n    borrow_global<R>(a) // error!\n}\n// also will not compile\nfun ret_resource_field_ref_bad(a: address): &u64 {\n    &borrow_global<R>(a).f // error!\n}\n\n\nMove must enforce this restriction to guarantee absence of dangling references to global storage. This section contains much more detail for the interested reader.\n\nGlobal storage operators with generics\n\nGlobal storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:\n\nstruct Container<T> has key { t: T }\n\n// Publish a Container storing a type T of the caller's choosing\nfun publish_generic_container<T>(account: &signer, t: T) {\n    move_to<Container<T>>(account, Container { t })\n}\n\n/// Publish a container storing a u64\nfun publish_instantiated_generic_container(account: &signer, t: u64) {\n    move_to<Container<u64>>(account, Container { t })\n}\n\n\nThe ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as storage polymorphism. For more on the design patterns enabled by this feature, see Move generics.\n\nExample: Counter\n\nThe simple Counter module below exercises each of the five global storage operators. The API exposed by this module allows:\n\nAnyone to publish a Counter resource under their account\nAnyone to check if a Counter exists under any address\nAnyone to read or increment the value of a Counter resource under any address\nAn account that stores a Counter resource to reset it to zero\nAn account that stores a Counter resource to remove and delete it\naddress 0x42 {\nmodule counter {\n    use std::signer;\n\n    /// Resource that wraps an integer counter\n    struct Counter has key { i: u64 }\n\n    /// Publish a `Counter` resource with value `i` under the given `account`\n    public fun publish(account: &signer, i: u64) {\n      // \"Pack\" (create) a Counter resource. This is a privileged operation that\n      // can only be done inside the module that declares the `Counter` resource\n      move_to(account, Counter { i })\n    }\n\n    /// Read the value in the `Counter` resource stored at `addr`\n    public fun get_count(addr: address): u64 acquires Counter {\n        borrow_global<Counter>(addr).i\n    }\n\n    /// Increment the value of `addr`'s `Counter` resource\n    public fun increment(addr: address) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(addr).i;\n        *c_ref = *c_ref + 1\n    }\n\n    /// Reset the value of `account`'s `Counter` to 0\n    public fun reset(account: &signer) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(signer::address_of(account)).i;\n        *c_ref = 0\n    }\n\n    /// Delete the `Counter` resource under `account` and return its value\n    public fun delete(account: &signer): u64 acquires Counter {\n        // remove the Counter resource\n        let c = move_from<Counter>(signer::address_of(account));\n        // \"Unpack\" the `Counter` resource into its fields. This is a\n        // privileged operation that can only be done inside the module\n        // that declares the `Counter` resource\n        let Counter { i } = c;\n        i\n    }\n\n    /// Return `true` if `addr` contains a `Counter` resource\n    public fun exists(addr: address): bool {\n        exists<Counter>(addr)\n    }\n}\n}\n\nAnnotating functions with acquires\n\nIn the counter example, you might have noticed that the get_count, increment, reset, and delete functions are annotated with acquires Counter. A Move function m::f must be annotated with acquires T if and only if:\n\nThe body of m::f contains a move_from<T>, borrow_global_mut<T>, or borrow_global<T> instruction, or\nThe body of m::f invokes a function m::g declared in the same module that is annotated with acquires\n\nFor example, the following function inside Counter would need an acquires annotation:\n\n// Needs `acquires` because `increment` is annotated with `acquires`\nfun call_increment(addr: address): u64 acquires Counter {\n    counter::increment(addr)\n}\n\n\nHowever, the same function outside Counter would not need an annotation:\n\naddress 0x43 {\nmodule m {\n   use 0x42::counter;\n\n   // Ok. Only need annotation when resource acquired by callee is declared\n   // in the same module\n   fun call_increment(addr: address): u64 {\n       counter::increment(addr)\n   }\n}\n}\n\n\nIf a function touches multiple resources, it needs multiple acquires:\n\naddress 0x42 {\nmodule two_resources {\n    struct R1 has key { f: u64 }\n    struct R2 has key { g: u64 }\n\n    fun double_acquires(a: address): u64 acquires R1, R2 {\n        borrow_global<R1>(a).f + borrow_global<R2>.g\n    }\n}\n}\n\n\nThe acquires annotation does not take generic type parameters into account:\n\naddress 0x42 {\nmodule m {\n    struct R<T> has key { t: T }\n\n    // `acquires R`, not `acquires R<T>`\n    fun acquire_generic_resource<T: store>(a: addr) acquires R {\n        let _ = borrow_global<R<T>>(a);\n    }\n\n    // `acquires R`, not `acquires R<u64>\n    fun acquire_instantiated_generic_resource(a: addr) acquires R {\n        let _ = borrow_global<R<u64>>(a);\n    }\n}\n}\n\n\nFinally: redundant acquires are not allowed. Adding this function inside Counter will result in a compilation error:\n\n// This code will not compile because the body of the function does not use a global\n// storage instruction or invoke a function with `acquires`\nfun redundant_acquires_bad() acquires Counter {}\n\n\nFor more information on acquires, see Move functions.\n\nReference Safety For Global Resources\n\nMove prohibits returning global references and requires the acquires annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no null or nil dereferences) for all reference types.\n\nThis example illustrates how the Move type system uses acquires to prevent a dangling reference:\n\naddress 0x42 {\nmodule dangling {\n    struct T has key { f: u64 }\n\n    fun borrow_then_remove_bad(a: address) acquires T {\n        let t_ref: &mut T = borrow_global_mut<T>(a);\n        let t = remove_t(a); // type system complains here\n        // t_ref now dangling!\n        let uh_oh = *&t_ref.f\n    }\n\n    fun remove_t(a: address): T acquires T {\n        move_from<T>(a)\n    }\n\n}\n}\n\n\nIn this code, line 6 acquires a reference to the T stored at address a in global storage. The callee remove_t then removes the value, which makes t_ref a dangling reference.\n\nFortunately, this cannot happen because the type system will reject this program. The acquires annotation on remove_t lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of remove_t separately!\n\nThe restriction on returning global references prevents a similar, but even more insidious problem:\n\naddress 0x42 {\nmodule m1 {\n    struct T has key {}\n\n    public fun ret_t_ref(a: address): &T acquires T {\n        borrow_global<T>(a) // error! type system complains here\n    }\n\n    public fun remove_t(a: address) acquires T {\n        let T {} = move_from<T>(a);\n    }\n}\n\nmodule m2 {\n    fun borrow_then_remove_bad(a: address) {\n        let t_ref = m1::ret_t_ref(a);\n        let t = m1::remove_t(a); // t_ref now dangling!\n    }\n}\n}\n\n\nLine 16 acquires a reference to a global resource m1::T, then line 17 removes that same resource, which makes t_ref dangle. In this case, acquires annotations do not help us because the borrow_then_remove_bad function is outside of the m1 module that declares T (recall that acquires annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.\n\nFancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between expressivity, annotation burden, and type system complexity.\n\nStandard Library\n\nThe Move standard library exposes interfaces that implement the following functionality:\n\nBasic operations on vectors.\nOption types and operations onOption types.\nA common error encoding code interface for abort codes.\n32-bit precision fixed-point numbers.\nvector\n\nThe vector module defines a number of operations over the primitive vector type. The module is published under the named address Std and consists of a number of native functions, as well as functions defined in Move. The API for this module is as follows.\n\nFunctions\n\nCreate an empty vector. The Element type can be both a resource or copyable type.\n\n    native public fun empty<Element>(): vector<Element>;\n\n\nCreate a vector of length 1 containing the passed in element.\n\n    public fun singleton<Element>(e: Element): vector<Element>;\n\n\nDestroy (deallocate) the vector v. Will abort if v is non-empty. Note: The emptiness restriction is due to the fact that Element can be a resource type, and destruction of a non-empty vector would violate resource conservation.\n\n    native public fun destroy_empty<Element>(v: vector<Element>);\n\n\nAcquire an immutable reference to the ith element of the vector v. Will abort if the index i is out of bounds for the vector v.\n\n    native public fun borrow<Element>(v: &vector<Element>, i: u64): &Element;\n\n\nAcquire a mutable reference to the ith element of the vector v. Will abort if the index i is out of bounds for the vector v.\n\n    native public fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;\n\n\nEmpty and destroy the other vector, and push each of the elements in the other vector onto the lhs vector in the same order as they occurred in other.\n\n    public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>);\n\n\nPush an element e of type Element onto the end of the vector v. May trigger a resizing of the underlying vector's memory.\n\n    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);\n\n\nPop an element from the end of the vector v in-place and return the owned value. Will abort if v is empty.\n\n    native public fun pop_back<Element>(v: &mut vector<Element>): Element;\n\n\nRemove the element at index i in the vector v and return the owned value that was previously stored at i in v. All elements occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds for v.\n\n    public fun remove<Element>(v: &mut vector<Element>, i: u64): Element;\n\n\nSwap the ith element of the vector v with the last element and then pop this element off of the back of the vector and return the owned value that was previously stored at index i. This operation is O(1), but does not preserve ordering of elements in the vector. Aborts if the index i is out of bounds for the vector v.\n\n    public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element;\n\n\nSwap the elements at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds for v.\n\n    native public fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64);\n\n\nReverse the order of the elements in the vector v in-place.\n\n    public fun reverse<Element>(v: &mut vector<Element>);\n\n\nReturn the index of the first occurrence of an element in v that is equal to e. Returns (true, index) if such an element was found, and (false, 0) otherwise.\n\n    public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64);\n\n\nReturn if an element equal to e exists in the vector v.\n\n    public fun contains<Element>(v: &vector<Element>, e: &Element): bool;\n\n\nReturn the length of a vector.\n\n    native public fun length<Element>(v: &vector<Element>): u64;\n\n\nReturn whether the vector v is empty.\n\n    public fun is_empty<Element>(v: &vector<Element>): bool;\n\noption\n\nThe option module defines a generic option type Option<T> that represents a value of type T that may, or may not, be present. It is published under the named address Std.\n\nThe Move option type is internally represented as a singleton vector, and may contain a value of resource or copyable kind. If you are familiar with option types in other languages, the Move Option behaves similarly to those with a couple notable exceptions since the option can contain a value of kind resource. Particularly, certain operations such as get_with_default and destroy_with_default require that the element type T be of copyable kind.\n\nThe API for the option module is as as follows\n\nTypes\n\nGeneric type abstraction of a value that may, or may not, be present. Can contain a value of either resource or copyable kind.\n\n    struct Option<T>;\n\nFunctions\n\nCreate an empty Option of that can contain a value of Element type.\n\n    public fun none<Element>(): Option<Element>;\n\n\nCreate a non-empty Option type containing a value e of type Element.\n\n    public fun some<Element>(e: T): Option<Element>;\n\n\nReturn an immutable reference to the value inside the option opt_elem Will abort if opt_elem does not contain a value.\n\n    public fun borrow<Element>(opt_elem: &Option<Element>): &Element;\n\n\nReturn a reference to the value inside opt_elem if it contains one. If opt_elem does not contain a value the passed in default_ref reference will be returned. Does not abort.\n\n    public fun borrow_with_default<Element>(opt_elem: &Option<Element>, default_ref: &Element): &Element;\n\n\nReturn a mutable reference to the value inside opt_elem. Will abort if opt_elem does not contain a value.\n\n    public fun borrow_mut<Element>(opt_elem: &mut Option<Element>): &mut Element;\n\n\nConvert an option value that contains a value to one that is empty in-place by removing and returning the value stored inside opt_elem. Will abort if opt_elem does not contain a value.\n\n    public fun extract<Element>(opt_elem: &mut Option<Element>): Element;\n\n\nReturn the value contained inside the option opt_elem if it contains one. Will return the passed in default value if opt_elem does not contain a value. The Element type that the Option type is instantiated with must be of copyable kind in order for this function to be callable.\n\n    public fun get_with_default<Element: copyable>(opt_elem: &Option<Element>, default: Element): Element;\n\n\nConvert an empty option opt_elem to an option value that contains the value e. Will abort if opt_elem already contains a value.\n\n    public fun fill<Element>(opt_elem: &mut Option<Element>, e: Element);\n\n\nSwap the value currently contained in opt_elem with new_elem and return the previously contained value. Will abort if opt_elem does not contain a value.\n\n    public fun swap<Element>(opt_elem: &mut Option<Element>, e: Element): Element;\n\n\nReturn true if opt_elem contains a value equal to the value of e_ref. Otherwise, false will be returned.\n\n    public fun contains<Element>(opt_elem: &Option<Element>, e_ref: &Element): bool;\n\n\nReturn true if opt_elem does not contain a value.\n\n    public fun is_none<Element>(opt_elem: &Option<Element>): bool;\n\n\nReturn true if opt_elem contains a value.\n\n    public fun is_some<Element>(opt_elem: &Option<Element>): bool;\n\n\nUnpack opt_elem and return the value that it contained. Will abort if opt_elem does not contain a value.\n\n    public fun destroy_some<Element>(opt_elem: Option<Element>): Element;\n\n\nDestroys the opt_elem value passed in. If opt_elem contained a value it will be returned otherwise, the passed in default value will be returned.\n\n    public fun destroy_with_default<Element: copyable>(opt_elem: Option<Element>, default: Element): Element;\n\n\nDestroys the opt_elem value passed in, opt_elem must be empty and not contain a value. Will abort if opt_elem contains a value.\n\n    public fun destroy_none<Element>(opt_elem: Option<Element>);\n\nerrors\n\nRecall that each abort code in Move is represented as an unsigned 64-bit integer. The errors module defines a common interface that can be used to \"tag\" each of these abort codes so that they can represent both the error category along with an error reason.\n\nError categories are declared as constants in the errors module and are globally unique with respect to this module. Error reasons on the other hand are module-specific error codes, and can provide greater detail (perhaps, even a particular reason) about the specific error condition. This representation of a category and reason for each error code is done by dividing the abort code into two sections.\n\nThe lower 8 bits of the abort code hold the error category. The remaining 56 bits of the abort code hold the error reason. The reason should be a unique number relative to the module which raised the error and can be used to obtain more information about the error at hand. It should mostly be used for diagnostic purposes as error reasons may change over time if the module is updated.\n\nCategory\tReason\n8 bits\t56 bits\n\nSince error categories are globally stable, these present the most stable API and should in general be what is used by clients to determine the messages they may present to users (whereas the reason is useful for diagnostic purposes). There are public functions in the errors module for creating an abort code of each error category with a specific reason number (represented as a u64).\n\nConstants\n\nThe system is in a state where the performed operation is not allowed.\n\n    const INVALID_STATE: u8 = 1;\n\n\nA specific account address was required to perform an operation, but a different address from what was expected was encounterd.\n\n    const REQUIRES_ADDRESS: u8 = 2;\n\n\nAn account did not have the expected role for this operation. Useful for Role Based Access Control (RBAC) error conditions.\n\n    const REQUIRES_ROLE: u8 = 3;\n\n\nAn account did not not have a required capability. Useful for RBAC error conditions.\n\n    const REQUIRES_CAPABILITY: u8 = 4;\n\n\nA resource was expected, but did not exist under an address.\n\n    const NOT_PUBLISHED: u8 = 5;\n\n\nAttempted to publish a resource under an address where one was already published.\n\n    const ALREADY_PUBLISHED: u8 = 6;\n\n\nAn argument provided for an operation was invalid.\n\n    const INVALID_ARGUMENT: u8 = 7;\n\n\nA limit on a value was exceeded.\n\n    const LIMIT_EXCEEDED: u8 = 8;\n\n\nAn internal error (bug) has occurred.\n\n    const INTERNAL: u8 = 10;\n\n\nA custom error category for extension points.\n\n    const CUSTOM: u8 = 255;\n\nFunctions\n\nShould be used in the case where invalid (global) state is encountered. Constructs an abort code with specified reason and category INVALID_STATE. Will abort if reason does not fit in 56 bits.\n\n    public fun invalid_state(reason: u64): u64;\n\n\nShould be used if an account's address does not match a specific address. Constructs an abort code with specified reason and category REQUIRES_ADDRESS. Will abort if reason does not fit in 56 bits.\n\n    public fun requires_address(reason: u64): u64;\n\n\nShould be used if a role did not match a required role when using RBAC. Constructs an abort code with specified reason and category REQUIRES_ROLE. Will abort if reason does not fit in 56 bits.\n\n    public fun requires_role(reason: u64): u64;\n\n\nShould be used if an account did not have a required capability when using RBAC. Constructs an abort code with specified reason and category REQUIRES_CAPABILITY. Should be Will abort if reason does not fit in 56 bits.\n\n    public fun requires_capability(reason: u64): u64;\n\n\nShould be used if a resource did not exist where one was expected. Constructs an abort code with specified reason and category NOT_PUBLISHED. Will abort if reason does not fit in 56 bits.\n\n    public fun not_published(reason: u64): u64;\n\n\nShould be used if a resource already existed where one was about to be published. Constructs an abort code with specified reason and category ALREADY_PUBLISHED. Will abort if reason does not fit in 56 bits.\n\n    public fun already_published(reason: u64): u64;\n\n\nShould be used if an invalid argument was passed to a function/operation. Constructs an abort code with specified reason and category INVALID_ARGUMENT. Will abort if reason does not fit in 56 bits.\n\n    public fun invalid_argument(reason: u64): u64;\n\n\nShould be used if a limit on a specific value is reached, e.g., subtracting 1 from a value of 0. Constructs an abort code with specified reason and category LIMIT_EXCEEDED. Will abort if reason does not fit in 56 bits.\n\n    public fun limit_exceeded(reason: u64): u64;\n\n\nShould be used if an internal error or bug was encountered. Constructs an abort code with specified reason and category INTERNAL. Will abort if reason does not fit in 56 bits.\n\n    public fun internal(reason: u64): u64;\n\n\nUsed for extension points, should be not used under most circumstances. Constructs an abort code with specified reason and category CUSTOM. Will abort if reason does not fit in 56 bits.\n\n    public fun custom(reason: u64): u64;\n\nfixed_point32\n\nThe fixed_point32 module defines a fixed-point numeric type with 32 integer bits and 32 fractional bits. Internally, this is represented as a u64 integer wrapped in a struct to make a unique fixed_point32 type. Since the numeric representation is a binary one, some decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so you should be careful about using floating-point to convert these values to decimal.\n\nTypes\n\nRepresents a fixed-point numeric number with 32 fractional bits.\n\n    struct FixedPoint32;\n\nFunctions\n\nMultiply a u64 integer by a fixed-point number, truncating any fractional part of the product. This will abort if the product overflows.\n\n    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64;\n\n\nDivide a u64 integer by a fixed-point number, truncating any fractional part of the quotient. This will abort if the divisor is zero or if the quotient overflows.\n\n    public fun divide_u64(val: u64, divisor: FixedPoint32): u64;\n\n\nCreate a fixed-point value from a rational number specified by its numerator and denominator. Calling this function should be preferred for using fixed_point32::create_from_raw_value which is also available. This will abort if the denominator is zero. It will also abort if the numerator is nonzero and the ratio is not in the range $2^{-32}\\ldots2^{32}-1$. When specifying decimal fractions, be careful about rounding errors: if you round to display $N$ digits after the decimal point, you can use a denominator of $10^N$ to avoid numbers where the very small imprecision in the binary representation could change the rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.\n\n    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32;\n\n\nCreate a fixedpoint value from a raw u64 value.\n\n    public fun create_from_raw_value(value: u64): FixedPoint32;\n\n\nReturns true if the decimal value of num is equal to zero.\n\n    public fun is_zero(num: FixedPoint32): bool;\n\n\nAccessor for the raw u64 value. Other less common operations, such as adding or subtracting FixedPoint32 values, can be done using the raw values directly.\n\n    public fun get_raw_value(num: FixedPoint32): u64;\n\nMove Coding Conventions\n\nThis section lays out some basic coding conventions for Move that the Move team has found helpful. These are only recommendations, and you should feel free to use other formatting guidelines and conventions if you have a preference for them.\n\nNaming\nModule names: should be lower snake case, e.g., fixed_point32, vector.\nType names: should be camel case if they are not a native type, e.g., Coin, RoleId.\nFunction names: should be lower snake case, e.g., destroy_empty.\nConstant names: should be upper camel case and begin with an E if they represent error codes (e.g., EIndexOutOfBounds) and upper snake case if they represent a non-error value (e.g., MIN_STAKE).\nGeneric type names: should be descriptive, or anti-descriptive where appropriate, e.g., T or Element for the Vector generic type parameter. Most of the time the \"main\" type in a module should be the same name as the module e.g., option::Option, fixed_point32::FixedPoint32.\nModule file names: should be the same as the module name e.g., Option.move.\nScript file names: should be lower snake case and should match the name of the “main” function in the script.\nMixed file names: If the file contains multiple modules and/or scripts, the file name should be lower snake case, where the name does not match any particular module/script inside.\nImports\nAll module use statements should be at the top of the module.\nFunctions should be imported and used fully qualified from the module in which they are declared, and not imported at the top level.\nTypes should be imported at the top-level. Where there are name clashes, as should be used to rename the type locally as appropriate.\n\nFor example, if there is a module:\n\nmodule 0x1::foo {\n    struct Foo { }\n    const CONST_FOO: u64 = 0;\n    public fun do_foo(): Foo { Foo{} }\n    ...\n}\n\n\nthis would be imported and used as:\n\nmodule 0x1::bar {\n    use 0x1::foo::{Self, Foo};\n\n    public fun do_bar(x: u64): Foo {\n        if (x == 10) {\n            foo::do_foo()\n        } else {\n            abort 0\n        }\n    }\n    ...\n}\n\n\nAnd, if there is a local name-clash when importing two modules:\n\nmodule other_foo {\n    struct Foo {}\n    ...\n}\n\nmodule 0x1::importer {\n    use 0x1::other_foo::Foo as OtherFoo;\n    use 0x1::foo::Foo;\n    ...\n}\n\nComments\nEach module, struct, and public function declaration should be commented.\nMove has doc comments ///, regular single-line comments //, block comments /* */, and block doc comments /** */.\nFormatting\n\nThe Move team plans to write an autoformatter to enforce formatting conventions. However, in the meantime:\n\nFour space indentation should be used except for script and address blocks whose contents should not be indented.\nLines should be broken if they are longer than 100 characters.\nStructs and constants should be declared before all functions in a module."
    },
    {
      "title": "Type Abilities - The Move Book",
      "url": "https://move-language.github.io/move/abilities",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nAbilities\n\nAbilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the \"linear\" typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).\n\nThe Four Abilities\n\nThe four abilities are:\n\ncopy\nAllows values of types with this ability to be copied.\ndrop\nAllows values of types with this ability to be popped/dropped.\nstore\nAllows values of types with this ability to exist inside a struct in global storage.\nkey\nAllows the type to serve as a key for global storage operations.\ncopy\n\nThe copy ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the copy operator and to copy values via references with dereference *e.\n\nIf a value has copy, all values contained inside of that value have copy.\n\ndrop\n\nThe drop ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:\n\nnot using the value in a local variable or parameter\nnot using the value in a sequence via ;\noverwriting values in variables in assignments\noverwriting values via references when writing *e1 = e2.\n\nIf a value has drop, all values contained inside of that value have drop.\n\nstore\n\nThe store ability allows values of types with this ability to exist inside of a struct (resource) in global storage, but not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with key.\n\nIf a value has store, all values contained inside of that value have store\n\nkey\n\nThe key ability allows the type to serve as a key for global storage operations. It gates all global storage operations, so in order for a type to be used with move_to, borrow_global, move_from, etc., the type must have the key ability. Note that the operations still must be used in the module where the key type is defined (in a sense, the operations are private to the defining module).\n\nIf a value has key, all values contained inside of that value have store. This is the only ability with this sort of asymmetry.\n\nBuiltin Types\n\nMost primitive, builtin types have copy, drop, and store with the exception of signer, which just has drop\n\nbool, u8, u16, u32, u64, u128, u256, and address all have copy, drop, and store.\nsigner has drop\nCannot be copied and cannot be put into global storage\nvector<T> may have copy, drop, and store depending on the abilities of T.\nSee Conditional Abilities and Generic Types for more details.\nImmutable references & and mutable references &mut both have copy and drop.\nThis refers to copying and dropping the reference itself, not what they refer to.\nReferences cannot appear in global storage, hence they do not have store.\n\nNone of the primitive types have key, meaning none of them can be used directly with the global storage operations.\n\nAnnotating Structs\n\nTo declare that a struct has an ability, it is declared with has <ability> after the struct name but before the fields. For example:\n\nstruct Ignorable has drop { f: u64 }\nstruct Pair has copy, drop, store { x: u64, y: u64 }\n\n\nIn this case: Ignorable has the drop ability. Pair has copy, drop, and store.\n\nAll of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!\n\nAs such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...\n\ncopy, all fields must have copy.\ndrop, all fields must have drop.\nstore, all fields must have store.\nkey, all fields must have store.\nkey is the only ability currently that doesn’t require itself.\n\nFor example:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct WantsCopy has copy {\n    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'\n}\n\n\nand similarly:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct MyResource has key {\n    f: NoAbilities, // Error 'NoAbilities' does not have 'store'\n}\n\nConditional Abilities and Generic Types\n\nWhen abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:\n\nstruct Cup<T> has copy, drop, store, key { item: T }\n\n\nIt might be very helpful if Cup could hold any type, regardless of its abilities. The type system can see the type parameter, so it should be able to remove abilities from Cup if it sees a type parameter that would violate the guarantees for that ability.\n\nThis behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type vector to have the following type declaration:\n\nvector<T> has copy, drop, store;\n\n\nWe want vectors to work with any type. We don't want separate vector types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above. So, it would be safe to copy a vector value only if the inner elements can be copied. It would be safe to ignore a vector value only if the inner elements can be ignored/dropped. And, it would be safe to put a vector in global storage only if the inner elements can be in global storage.\n\nTo have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration and its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking Cup from above as an example:\n\nCup has the ability copy only if T has copy.\nIt has drop only if T has drop.\nIt has store only if T has store.\nIt has key only if T has store.\n\nHere are examples for this conditional system for each ability:\n\nExample: conditional copy\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun example(c_x: Cup<u64>, c_s: Cup<S>) {\n    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'\n    let c_x2 = copy c_x;\n    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'\n    let c_s2 = copy c_s;\n}\n\nfun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {\n    // Invalid, 'Cup<signer>' does not have 'copy'.\n    // Even though 'Cup' was declared with copy, the instance does not have 'copy'\n    // because 'signer' does not have 'copy'\n    let c_account2 = copy c_account;\n    // Invalid, 'Cup<NoAbilities>' does not have 'copy'\n    // because 'NoAbilities' does not have 'copy'\n    let c_n2 = copy c_n;\n}\n\nExample: conditional drop\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun unused() {\n    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'\n    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'\n}\n\nfun left_in_local(c_account: Cup<signer>): u64 {\n    let c_b = Cup<bool> { item: true };\n    let c_s = Cup<S> { item: S { f: false }};\n    // Valid return: 'c_account', 'c_b', and 'c_s' have values\n    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'\n    0\n}\n\nfun invalid_unused() {\n    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.\n    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'\n    // because 'NoAbilities' does not have 'drop'\n    Cup<NoAbilities> { item: NoAbilities {}};\n}\n\nfun invalid_left_in_local(): u64 {\n    let n = Cup<NoAbilities> { item: NoAbilities {}};\n    // Invalid return: 'n' has a value\n    // and 'Cup<NoAbilities>' does not have 'drop'\n    0\n}\n\nExample: conditional store\nstruct Cup<T> has copy, drop, store { item: T }\n\n// 'MyInnerResource' is declared with 'store' so all fields need 'store'\nstruct MyInnerResource has store {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\n// 'MyResource' is declared with 'key' so all fields need 'store'\nstruct MyResource has key {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    inner: Cup<MyInnerResource>, // Valid, 'Cup<MyInnerResource>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\nExample: conditional key\nstruct NoAbilities {}\nstruct MyResource<T> has key { f: T }\n\nfun valid(account: &signer) acquires MyResource {\n    let addr = signer::address_of(account);\n     // Valid, 'MyResource<u64>' has 'key'\n    let has_resource = exists<MyResource<u64>>(addr);\n    if (!has_resource) {\n         // Valid, 'MyResource<u64>' has 'key'\n        move_to(account, MyResource<u64> { f: 0 })\n    };\n    // Valid, 'MyResource<u64>' has 'key'\n    let r = borrow_global_mut<MyResource<u64>>(addr)\n    r.f = r.f + 1;\n}\n\nfun invalid(account: &signer) {\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let has_it = exists<MyResource<NoAbilities>>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let NoAbilities {} = move_from<NoAbilities>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   move_to(account, NoAbilities {});\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   borrow_global<NoAbilities>(addr);\n}\n"
    },
    {
      "title": "Coding Conventions - The Move Book",
      "url": "https://move-language.github.io/move/coding-conventions.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nMove Coding Conventions\n\nThis section lays out some basic coding conventions for Move that the Move team has found helpful. These are only recommendations, and you should feel free to use other formatting guidelines and conventions if you have a preference for them.\n\nNaming\nModule names: should be lower snake case, e.g., fixed_point32, vector.\nType names: should be camel case if they are not a native type, e.g., Coin, RoleId.\nFunction names: should be lower snake case, e.g., destroy_empty.\nConstant names: should be upper camel case and begin with an E if they represent error codes (e.g., EIndexOutOfBounds) and upper snake case if they represent a non-error value (e.g., MIN_STAKE).\nGeneric type names: should be descriptive, or anti-descriptive where appropriate, e.g., T or Element for the Vector generic type parameter. Most of the time the \"main\" type in a module should be the same name as the module e.g., option::Option, fixed_point32::FixedPoint32.\nModule file names: should be the same as the module name e.g., Option.move.\nScript file names: should be lower snake case and should match the name of the “main” function in the script.\nMixed file names: If the file contains multiple modules and/or scripts, the file name should be lower snake case, where the name does not match any particular module/script inside.\nImports\nAll module use statements should be at the top of the module.\nFunctions should be imported and used fully qualified from the module in which they are declared, and not imported at the top level.\nTypes should be imported at the top-level. Where there are name clashes, as should be used to rename the type locally as appropriate.\n\nFor example, if there is a module:\n\nmodule 0x1::foo {\n    struct Foo { }\n    const CONST_FOO: u64 = 0;\n    public fun do_foo(): Foo { Foo{} }\n    ...\n}\n\n\nthis would be imported and used as:\n\nmodule 0x1::bar {\n    use 0x1::foo::{Self, Foo};\n\n    public fun do_bar(x: u64): Foo {\n        if (x == 10) {\n            foo::do_foo()\n        } else {\n            abort 0\n        }\n    }\n    ...\n}\n\n\nAnd, if there is a local name-clash when importing two modules:\n\nmodule other_foo {\n    struct Foo {}\n    ...\n}\n\nmodule 0x1::importer {\n    use 0x1::other_foo::Foo as OtherFoo;\n    use 0x1::foo::Foo;\n    ...\n}\n\nComments\nEach module, struct, and public function declaration should be commented.\nMove has doc comments ///, regular single-line comments //, block comments /* */, and block doc comments /** */.\nFormatting\n\nThe Move team plans to write an autoformatter to enforce formatting conventions. However, in the meantime:\n\nFour space indentation should be used except for script and address blocks whose contents should not be indented.\nLines should be broken if they are longer than 100 characters.\nStructs and constants should be declared before all functions in a module."
    },
    {
      "title": "Standard Library - The Move Book",
      "url": "https://move-language.github.io/move/standard-library.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nStandard Library\n\nThe Move standard library exposes interfaces that implement the following functionality:\n\nBasic operations on vectors.\nOption types and operations onOption types.\nA common error encoding code interface for abort codes.\n32-bit precision fixed-point numbers.\nvector\n\nThe vector module defines a number of operations over the primitive vector type. The module is published under the named address Std and consists of a number of native functions, as well as functions defined in Move. The API for this module is as follows.\n\nFunctions\n\nCreate an empty vector. The Element type can be both a resource or copyable type.\n\n    native public fun empty<Element>(): vector<Element>;\n\n\nCreate a vector of length 1 containing the passed in element.\n\n    public fun singleton<Element>(e: Element): vector<Element>;\n\n\nDestroy (deallocate) the vector v. Will abort if v is non-empty. Note: The emptiness restriction is due to the fact that Element can be a resource type, and destruction of a non-empty vector would violate resource conservation.\n\n    native public fun destroy_empty<Element>(v: vector<Element>);\n\n\nAcquire an immutable reference to the ith element of the vector v. Will abort if the index i is out of bounds for the vector v.\n\n    native public fun borrow<Element>(v: &vector<Element>, i: u64): &Element;\n\n\nAcquire a mutable reference to the ith element of the vector v. Will abort if the index i is out of bounds for the vector v.\n\n    native public fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;\n\n\nEmpty and destroy the other vector, and push each of the elements in the other vector onto the lhs vector in the same order as they occurred in other.\n\n    public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>);\n\n\nPush an element e of type Element onto the end of the vector v. May trigger a resizing of the underlying vector's memory.\n\n    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);\n\n\nPop an element from the end of the vector v in-place and return the owned value. Will abort if v is empty.\n\n    native public fun pop_back<Element>(v: &mut vector<Element>): Element;\n\n\nRemove the element at index i in the vector v and return the owned value that was previously stored at i in v. All elements occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds for v.\n\n    public fun remove<Element>(v: &mut vector<Element>, i: u64): Element;\n\n\nSwap the ith element of the vector v with the last element and then pop this element off of the back of the vector and return the owned value that was previously stored at index i. This operation is O(1), but does not preserve ordering of elements in the vector. Aborts if the index i is out of bounds for the vector v.\n\n    public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element;\n\n\nSwap the elements at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds for v.\n\n    native public fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64);\n\n\nReverse the order of the elements in the vector v in-place.\n\n    public fun reverse<Element>(v: &mut vector<Element>);\n\n\nReturn the index of the first occurrence of an element in v that is equal to e. Returns (true, index) if such an element was found, and (false, 0) otherwise.\n\n    public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64);\n\n\nReturn if an element equal to e exists in the vector v.\n\n    public fun contains<Element>(v: &vector<Element>, e: &Element): bool;\n\n\nReturn the length of a vector.\n\n    native public fun length<Element>(v: &vector<Element>): u64;\n\n\nReturn whether the vector v is empty.\n\n    public fun is_empty<Element>(v: &vector<Element>): bool;\n\noption\n\nThe option module defines a generic option type Option<T> that represents a value of type T that may, or may not, be present. It is published under the named address Std.\n\nThe Move option type is internally represented as a singleton vector, and may contain a value of resource or copyable kind. If you are familiar with option types in other languages, the Move Option behaves similarly to those with a couple notable exceptions since the option can contain a value of kind resource. Particularly, certain operations such as get_with_default and destroy_with_default require that the element type T be of copyable kind.\n\nThe API for the option module is as as follows\n\nTypes\n\nGeneric type abstraction of a value that may, or may not, be present. Can contain a value of either resource or copyable kind.\n\n    struct Option<T>;\n\nFunctions\n\nCreate an empty Option of that can contain a value of Element type.\n\n    public fun none<Element>(): Option<Element>;\n\n\nCreate a non-empty Option type containing a value e of type Element.\n\n    public fun some<Element>(e: T): Option<Element>;\n\n\nReturn an immutable reference to the value inside the option opt_elem Will abort if opt_elem does not contain a value.\n\n    public fun borrow<Element>(opt_elem: &Option<Element>): &Element;\n\n\nReturn a reference to the value inside opt_elem if it contains one. If opt_elem does not contain a value the passed in default_ref reference will be returned. Does not abort.\n\n    public fun borrow_with_default<Element>(opt_elem: &Option<Element>, default_ref: &Element): &Element;\n\n\nReturn a mutable reference to the value inside opt_elem. Will abort if opt_elem does not contain a value.\n\n    public fun borrow_mut<Element>(opt_elem: &mut Option<Element>): &mut Element;\n\n\nConvert an option value that contains a value to one that is empty in-place by removing and returning the value stored inside opt_elem. Will abort if opt_elem does not contain a value.\n\n    public fun extract<Element>(opt_elem: &mut Option<Element>): Element;\n\n\nReturn the value contained inside the option opt_elem if it contains one. Will return the passed in default value if opt_elem does not contain a value. The Element type that the Option type is instantiated with must be of copyable kind in order for this function to be callable.\n\n    public fun get_with_default<Element: copyable>(opt_elem: &Option<Element>, default: Element): Element;\n\n\nConvert an empty option opt_elem to an option value that contains the value e. Will abort if opt_elem already contains a value.\n\n    public fun fill<Element>(opt_elem: &mut Option<Element>, e: Element);\n\n\nSwap the value currently contained in opt_elem with new_elem and return the previously contained value. Will abort if opt_elem does not contain a value.\n\n    public fun swap<Element>(opt_elem: &mut Option<Element>, e: Element): Element;\n\n\nReturn true if opt_elem contains a value equal to the value of e_ref. Otherwise, false will be returned.\n\n    public fun contains<Element>(opt_elem: &Option<Element>, e_ref: &Element): bool;\n\n\nReturn true if opt_elem does not contain a value.\n\n    public fun is_none<Element>(opt_elem: &Option<Element>): bool;\n\n\nReturn true if opt_elem contains a value.\n\n    public fun is_some<Element>(opt_elem: &Option<Element>): bool;\n\n\nUnpack opt_elem and return the value that it contained. Will abort if opt_elem does not contain a value.\n\n    public fun destroy_some<Element>(opt_elem: Option<Element>): Element;\n\n\nDestroys the opt_elem value passed in. If opt_elem contained a value it will be returned otherwise, the passed in default value will be returned.\n\n    public fun destroy_with_default<Element: copyable>(opt_elem: Option<Element>, default: Element): Element;\n\n\nDestroys the opt_elem value passed in, opt_elem must be empty and not contain a value. Will abort if opt_elem contains a value.\n\n    public fun destroy_none<Element>(opt_elem: Option<Element>);\n\nerrors\n\nRecall that each abort code in Move is represented as an unsigned 64-bit integer. The errors module defines a common interface that can be used to \"tag\" each of these abort codes so that they can represent both the error category along with an error reason.\n\nError categories are declared as constants in the errors module and are globally unique with respect to this module. Error reasons on the other hand are module-specific error codes, and can provide greater detail (perhaps, even a particular reason) about the specific error condition. This representation of a category and reason for each error code is done by dividing the abort code into two sections.\n\nThe lower 8 bits of the abort code hold the error category. The remaining 56 bits of the abort code hold the error reason. The reason should be a unique number relative to the module which raised the error and can be used to obtain more information about the error at hand. It should mostly be used for diagnostic purposes as error reasons may change over time if the module is updated.\n\nCategory\tReason\n8 bits\t56 bits\n\nSince error categories are globally stable, these present the most stable API and should in general be what is used by clients to determine the messages they may present to users (whereas the reason is useful for diagnostic purposes). There are public functions in the errors module for creating an abort code of each error category with a specific reason number (represented as a u64).\n\nConstants\n\nThe system is in a state where the performed operation is not allowed.\n\n    const INVALID_STATE: u8 = 1;\n\n\nA specific account address was required to perform an operation, but a different address from what was expected was encounterd.\n\n    const REQUIRES_ADDRESS: u8 = 2;\n\n\nAn account did not have the expected role for this operation. Useful for Role Based Access Control (RBAC) error conditions.\n\n    const REQUIRES_ROLE: u8 = 3;\n\n\nAn account did not not have a required capability. Useful for RBAC error conditions.\n\n    const REQUIRES_CAPABILITY: u8 = 4;\n\n\nA resource was expected, but did not exist under an address.\n\n    const NOT_PUBLISHED: u8 = 5;\n\n\nAttempted to publish a resource under an address where one was already published.\n\n    const ALREADY_PUBLISHED: u8 = 6;\n\n\nAn argument provided for an operation was invalid.\n\n    const INVALID_ARGUMENT: u8 = 7;\n\n\nA limit on a value was exceeded.\n\n    const LIMIT_EXCEEDED: u8 = 8;\n\n\nAn internal error (bug) has occurred.\n\n    const INTERNAL: u8 = 10;\n\n\nA custom error category for extension points.\n\n    const CUSTOM: u8 = 255;\n\nFunctions\n\nShould be used in the case where invalid (global) state is encountered. Constructs an abort code with specified reason and category INVALID_STATE. Will abort if reason does not fit in 56 bits.\n\n    public fun invalid_state(reason: u64): u64;\n\n\nShould be used if an account's address does not match a specific address. Constructs an abort code with specified reason and category REQUIRES_ADDRESS. Will abort if reason does not fit in 56 bits.\n\n    public fun requires_address(reason: u64): u64;\n\n\nShould be used if a role did not match a required role when using RBAC. Constructs an abort code with specified reason and category REQUIRES_ROLE. Will abort if reason does not fit in 56 bits.\n\n    public fun requires_role(reason: u64): u64;\n\n\nShould be used if an account did not have a required capability when using RBAC. Constructs an abort code with specified reason and category REQUIRES_CAPABILITY. Should be Will abort if reason does not fit in 56 bits.\n\n    public fun requires_capability(reason: u64): u64;\n\n\nShould be used if a resource did not exist where one was expected. Constructs an abort code with specified reason and category NOT_PUBLISHED. Will abort if reason does not fit in 56 bits.\n\n    public fun not_published(reason: u64): u64;\n\n\nShould be used if a resource already existed where one was about to be published. Constructs an abort code with specified reason and category ALREADY_PUBLISHED. Will abort if reason does not fit in 56 bits.\n\n    public fun already_published(reason: u64): u64;\n\n\nShould be used if an invalid argument was passed to a function/operation. Constructs an abort code with specified reason and category INVALID_ARGUMENT. Will abort if reason does not fit in 56 bits.\n\n    public fun invalid_argument(reason: u64): u64;\n\n\nShould be used if a limit on a specific value is reached, e.g., subtracting 1 from a value of 0. Constructs an abort code with specified reason and category LIMIT_EXCEEDED. Will abort if reason does not fit in 56 bits.\n\n    public fun limit_exceeded(reason: u64): u64;\n\n\nShould be used if an internal error or bug was encountered. Constructs an abort code with specified reason and category INTERNAL. Will abort if reason does not fit in 56 bits.\n\n    public fun internal(reason: u64): u64;\n\n\nUsed for extension points, should be not used under most circumstances. Constructs an abort code with specified reason and category CUSTOM. Will abort if reason does not fit in 56 bits.\n\n    public fun custom(reason: u64): u64;\n\nfixed_point32\n\nThe fixed_point32 module defines a fixed-point numeric type with 32 integer bits and 32 fractional bits. Internally, this is represented as a u64 integer wrapped in a struct to make a unique fixed_point32 type. Since the numeric representation is a binary one, some decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so you should be careful about using floating-point to convert these values to decimal.\n\nTypes\n\nRepresents a fixed-point numeric number with 32 fractional bits.\n\n    struct FixedPoint32;\n\nFunctions\n\nMultiply a u64 integer by a fixed-point number, truncating any fractional part of the product. This will abort if the product overflows.\n\n    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64;\n\n\nDivide a u64 integer by a fixed-point number, truncating any fractional part of the quotient. This will abort if the divisor is zero or if the quotient overflows.\n\n    public fun divide_u64(val: u64, divisor: FixedPoint32): u64;\n\n\nCreate a fixed-point value from a rational number specified by its numerator and denominator. Calling this function should be preferred for using fixed_point32::create_from_raw_value which is also available. This will abort if the denominator is zero. It will also abort if the numerator is nonzero and the ratio is not in the range $2^{-32}\\ldots2^{32}-1$. When specifying decimal fractions, be careful about rounding errors: if you round to display $N$ digits after the decimal point, you can use a denominator of $10^N$ to avoid numbers where the very small imprecision in the binary representation could change the rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.\n\n    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32;\n\n\nCreate a fixedpoint value from a raw u64 value.\n\n    public fun create_from_raw_value(value: u64): FixedPoint32;\n\n\nReturns true if the decimal value of num is equal to zero.\n\n    public fun is_zero(num: FixedPoint32): bool;\n\n\nAccessor for the raw u64 value. Other less common operations, such as adding or subtracting FixedPoint32 values, can be done using the raw values directly.\n\n    public fun get_raw_value(num: FixedPoint32): u64;\n"
    },
    {
      "title": "Global Storage Operators - The Move Book",
      "url": "https://move-language.github.io/move/global-storage-operators.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nGlobal Storage - Operators\n\nMove programs can create, delete, and update resources in global storage using the following five instructions:\n\nOperation\tDescription\tAborts?\nmove_to<T>(&signer,T)\tPublish T under signer.address\tIf signer.address already holds a T\nmove_from<T>(address): T\tRemove T from address and return it\tIf address does not hold a T\nborrow_global_mut<T>(address): &mut T\tReturn a mutable reference to the T stored under address\tIf address does not hold a T\nborrow_global<T>(address): &T\tReturn an immutable reference to the T stored under address\tIf address does not hold a T\nexists<T>(address): bool\tReturn true if a T is stored under address\tNever\n\nEach of these instructions is parameterized by a type T with the key ability. However, each type T must be declared in the current module. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an address or &signer representing the account address where the resource of type T is stored.\n\nReferences to resources\n\nReferences to global resources returned by borrow_global or borrow_global_mut mostly behave like references to local storage: they can be extended, read, and written using ordinary reference operators and passed as arguments to other function. However, there is one important difference between local and global references: a function cannot return a reference that points into global storage. For example, these two functions will each fail to compile:\n\nstruct R has key { f: u64 }\n// will not compile\nfun ret_direct_resource_ref_bad(a: address): &R {\n    borrow_global<R>(a) // error!\n}\n// also will not compile\nfun ret_resource_field_ref_bad(a: address): &u64 {\n    &borrow_global<R>(a).f // error!\n}\n\n\nMove must enforce this restriction to guarantee absence of dangling references to global storage. This section contains much more detail for the interested reader.\n\nGlobal storage operators with generics\n\nGlobal storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:\n\nstruct Container<T> has key { t: T }\n\n// Publish a Container storing a type T of the caller's choosing\nfun publish_generic_container<T>(account: &signer, t: T) {\n    move_to<Container<T>>(account, Container { t })\n}\n\n/// Publish a container storing a u64\nfun publish_instantiated_generic_container(account: &signer, t: u64) {\n    move_to<Container<u64>>(account, Container { t })\n}\n\n\nThe ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as storage polymorphism. For more on the design patterns enabled by this feature, see Move generics.\n\nExample: Counter\n\nThe simple Counter module below exercises each of the five global storage operators. The API exposed by this module allows:\n\nAnyone to publish a Counter resource under their account\nAnyone to check if a Counter exists under any address\nAnyone to read or increment the value of a Counter resource under any address\nAn account that stores a Counter resource to reset it to zero\nAn account that stores a Counter resource to remove and delete it\naddress 0x42 {\nmodule counter {\n    use std::signer;\n\n    /// Resource that wraps an integer counter\n    struct Counter has key { i: u64 }\n\n    /// Publish a `Counter` resource with value `i` under the given `account`\n    public fun publish(account: &signer, i: u64) {\n      // \"Pack\" (create) a Counter resource. This is a privileged operation that\n      // can only be done inside the module that declares the `Counter` resource\n      move_to(account, Counter { i })\n    }\n\n    /// Read the value in the `Counter` resource stored at `addr`\n    public fun get_count(addr: address): u64 acquires Counter {\n        borrow_global<Counter>(addr).i\n    }\n\n    /// Increment the value of `addr`'s `Counter` resource\n    public fun increment(addr: address) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(addr).i;\n        *c_ref = *c_ref + 1\n    }\n\n    /// Reset the value of `account`'s `Counter` to 0\n    public fun reset(account: &signer) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(signer::address_of(account)).i;\n        *c_ref = 0\n    }\n\n    /// Delete the `Counter` resource under `account` and return its value\n    public fun delete(account: &signer): u64 acquires Counter {\n        // remove the Counter resource\n        let c = move_from<Counter>(signer::address_of(account));\n        // \"Unpack\" the `Counter` resource into its fields. This is a\n        // privileged operation that can only be done inside the module\n        // that declares the `Counter` resource\n        let Counter { i } = c;\n        i\n    }\n\n    /// Return `true` if `addr` contains a `Counter` resource\n    public fun exists(addr: address): bool {\n        exists<Counter>(addr)\n    }\n}\n}\n\nAnnotating functions with acquires\n\nIn the counter example, you might have noticed that the get_count, increment, reset, and delete functions are annotated with acquires Counter. A Move function m::f must be annotated with acquires T if and only if:\n\nThe body of m::f contains a move_from<T>, borrow_global_mut<T>, or borrow_global<T> instruction, or\nThe body of m::f invokes a function m::g declared in the same module that is annotated with acquires\n\nFor example, the following function inside Counter would need an acquires annotation:\n\n// Needs `acquires` because `increment` is annotated with `acquires`\nfun call_increment(addr: address): u64 acquires Counter {\n    counter::increment(addr)\n}\n\n\nHowever, the same function outside Counter would not need an annotation:\n\naddress 0x43 {\nmodule m {\n   use 0x42::counter;\n\n   // Ok. Only need annotation when resource acquired by callee is declared\n   // in the same module\n   fun call_increment(addr: address): u64 {\n       counter::increment(addr)\n   }\n}\n}\n\n\nIf a function touches multiple resources, it needs multiple acquires:\n\naddress 0x42 {\nmodule two_resources {\n    struct R1 has key { f: u64 }\n    struct R2 has key { g: u64 }\n\n    fun double_acquires(a: address): u64 acquires R1, R2 {\n        borrow_global<R1>(a).f + borrow_global<R2>.g\n    }\n}\n}\n\n\nThe acquires annotation does not take generic type parameters into account:\n\naddress 0x42 {\nmodule m {\n    struct R<T> has key { t: T }\n\n    // `acquires R`, not `acquires R<T>`\n    fun acquire_generic_resource<T: store>(a: addr) acquires R {\n        let _ = borrow_global<R<T>>(a);\n    }\n\n    // `acquires R`, not `acquires R<u64>\n    fun acquire_instantiated_generic_resource(a: addr) acquires R {\n        let _ = borrow_global<R<u64>>(a);\n    }\n}\n}\n\n\nFinally: redundant acquires are not allowed. Adding this function inside Counter will result in a compilation error:\n\n// This code will not compile because the body of the function does not use a global\n// storage instruction or invoke a function with `acquires`\nfun redundant_acquires_bad() acquires Counter {}\n\n\nFor more information on acquires, see Move functions.\n\nReference Safety For Global Resources\n\nMove prohibits returning global references and requires the acquires annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no null or nil dereferences) for all reference types.\n\nThis example illustrates how the Move type system uses acquires to prevent a dangling reference:\n\naddress 0x42 {\nmodule dangling {\n    struct T has key { f: u64 }\n\n    fun borrow_then_remove_bad(a: address) acquires T {\n        let t_ref: &mut T = borrow_global_mut<T>(a);\n        let t = remove_t(a); // type system complains here\n        // t_ref now dangling!\n        let uh_oh = *&t_ref.f\n    }\n\n    fun remove_t(a: address): T acquires T {\n        move_from<T>(a)\n    }\n\n}\n}\n\n\nIn this code, line 6 acquires a reference to the T stored at address a in global storage. The callee remove_t then removes the value, which makes t_ref a dangling reference.\n\nFortunately, this cannot happen because the type system will reject this program. The acquires annotation on remove_t lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of remove_t separately!\n\nThe restriction on returning global references prevents a similar, but even more insidious problem:\n\naddress 0x42 {\nmodule m1 {\n    struct T has key {}\n\n    public fun ret_t_ref(a: address): &T acquires T {\n        borrow_global<T>(a) // error! type system complains here\n    }\n\n    public fun remove_t(a: address) acquires T {\n        let T {} = move_from<T>(a);\n    }\n}\n\nmodule m2 {\n    fun borrow_then_remove_bad(a: address) {\n        let t_ref = m1::ret_t_ref(a);\n        let t = m1::remove_t(a); // t_ref now dangling!\n    }\n}\n}\n\n\nLine 16 acquires a reference to a global resource m1::T, then line 17 removes that same resource, which makes t_ref dangle. In this case, acquires annotations do not help us because the borrow_then_remove_bad function is outside of the m1 module that declares T (recall that acquires annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.\n\nFancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between expressivity, annotation burden, and type system complexity."
    },
    {
      "title": "Global Storage Structure - The Move Book",
      "url": "https://move-language.github.io/move/global-storage-structure.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nGlobal Storage - Structure\n\nThe purpose of Move programs is to read from and write to tree-shaped persistent global storage. Programs cannot access the filesystem, network, or any other data outside of this tree.\n\nIn pseudocode, the global storage looks something like:\n\nstruct GlobalStorage {\n  resources: Map<(address, ResourceType), ResourceValue>\n  modules: Map<(address, ModuleName), ModuleBytecode>\n}\n\n\nStructurally, global storage is a forest consisting of trees rooted at an account address. Each address can store both resource data values and module code values. As the pseudocode above indicates, each address can store at most one resource value of a given type and at most one module with a given name."
    },
    {
      "title": "Unit Tests - The Move Book",
      "url": "https://move-language.github.io/move/unit-testing.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nUnit Tests\n\nUnit testing for Move adds three new annotations to the Move source language:\n\n#[test]\n#[test_only], and\n#[expected_failure].\n\nThey respectively mark a function as a test, mark a module or module member (use, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as #[test_only] or #[test], it will not be included in the compiled bytecode unless it is compiled for testing.\n\nTesting Annotations: Their Meaning and Usage\n\nBoth the #[test] and #[expected_failure] annotations can be used either with or without arguments.\n\nWithout arguments, the #[test] annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.\n\n#[test] // OK\nfun this_is_a_test() { ... }\n\n#[test] // Will fail to compile since the test takes an argument\nfun this_is_not_correct(arg: signer) { ... }\n\n\nA test can also be annotated as an #[expected_failure]. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with #[expected_failure(abort_code = <code>)], if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the #[test] annotation can also be annotated as an #[expected_failure].\n\n#[test]\n#[expected_failure]\npublic fun this_test_will_abort_and_pass() { abort 1 }\n\n#[test]\n#[expected_failure]\npublic fun test_will_error_and_pass() { 1/0; }\n\n#[test]\n#[expected_failure(abort_code = 0)]\npublic fun test_will_error_and_fail() { 1/0; }\n\n#[test, expected_failure] // Can have multiple in one attribute. This test will pass.\npublic fun this_other_test_will_abort_and_pass() { abort 1 }\n\n\nWith arguments, a test annotation takes the form #[test(<param_name_1> = <address>, ..., <param_name_n> = <address>)]. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters <param_name_1>, ..., <param_name_n>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.\n\nOnly parameters with a type of signer are supported as test parameters. If a non-signer parameter is supplied, the test will result in an error when run.\n\n#[test(arg = @0xC0FFEE)] // OK\nfun this_is_correct_now(arg: signer) { ... }\n\n#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match\nfun this_is_incorrect(arg: signer) { ... }\n\n#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument\nfun this_works(a: signer, b: signer) { ... }\n\n// somewhere a named address is declared\n#[test_only] // test-only named addresses are supported\naddress TEST_NAMED_ADDR = @0x1;\n...\n#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!\nfun this_is_correct_now(arg: signer) { ... }\n\n\nAn expected failure annotation can also take the form #[expected_failure(abort_code = <u64>)]. If a test function is annotated in such a way, the test must abort with an abort code equal to <u64>. Any other failure or abort code will result in a test failure.\n\n#[test, expected_failure(abort_code = 1)] // This test will fail\nfun this_test_should_abort_and_fail() { abort 0 }\n\n#[test]\n#[expected_failure(abort_code = 0)] // This test will pass\nfun this_test_should_abort_and_pass_too() { abort 0 }\n\n\nA module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test uses of a #[test_only] module will raise an error during compilation.\n\n#[test_only] // test only attributes can be attached to modules\nmodule abc { ... }\n\n#[test_only] // test only attributes can be attached to named addresses\naddress ADDR = @0x1;\n\n#[test_only] // .. to uses\nuse 0x1::some_other_module;\n\n#[test_only] // .. to structs\nstruct SomeStruct { ... }\n\n#[test_only] // .. and functions. Can only be called from test code, but not a test\nfun test_only_function(...) { ... }\n\nRunning Unit Tests\n\nUnit tests for a Move package can be run with the move test command.\n\nWhen running tests, every test will either PASS, FAIL, or TIMEOUT. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.\n\nA test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see OPTIONS below).\n\nThere are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag:\n\n$ move -h\n\nExample\n\nA simple module using some of the unit testing features is shown in the following example:\n\nFirst create an empty package and change directory into it:\n\n$ move new TestExample; cd TestExample\n\n\nNext add the following to the Move.toml:\n\n[dependencies]\nMoveStdlib = { git = \"https://github.com/diem/diem.git\", subdir=\"language/move-stdlib\", rev = \"56ab033cc403b489e891424a629e76f643d4fb6b\", addr_subst = { \"std\" = \"0x1\" } }\n\n\nNext add the following module under the sources directory:\n\n// filename: sources/my_module.move\nmodule 0x1::my_module {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n\nRunning Tests\n\nYou can then run these tests with the move test command:\n\n$ move test\nBUILDING MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\nUsing Test Flags\n-f <str> or --filter <str>\n\nThis will only run tests whose fully qualified name contains <str>. For example if we wanted to only run tests with \"zero_coin\" in their name:\n\n$ move test -f zero_coin\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\n-i <bound> or --gas_used <bound>\n\nThis bounds the amount of gas that can be consumed for any one test to <bound>:\n\n$ move test -i 0\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ TIMEOUT ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ TIMEOUT ] 0x1::my_module::make_sure_zero_coin_fails\n[ TIMEOUT ] 0x1::my_module::test_has_coin\n\nTest failures:\n\nFailures in 0x1::my_module:\n\n┌── make_sure_non_zero_coin_passes ──────\n│ Test timed out\n└──────────────────\n\n\n┌── make_sure_zero_coin_fails ──────\n│ Test timed out\n└──────────────────\n\n\n┌── test_has_coin ──────\n│ Test timed out\n└──────────────────\n\nTest result: FAILED. Total tests: 3; passed: 0; failed: 3\n\n-s or --statistics\n\nWith these flags you can gather statistics about the tests run and report the runtime and gas used for each test. For example, if we wanted to see the statistics for the tests in the example above:\n\n$ move test -s\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\n\nTest Statistics:\n\n┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐\n│                   Test Name                    │    Time    │   Gas Used   │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::make_sure_non_zero_coin_passes │   0.009    │             1             │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::make_sure_zero_coin_fails      │   0.008    │             1             │\n├────────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::my_module::test_has_coin                  │   0.008    │             1             │\n└────────────────────────────────────────────────┴────────────┴───────────────────────────┘\n\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\n-g or --state-on-error\n\nThese flags will print the global state for any test failures. e.g., if we added the following (failing) test to the my_module example:\n\nmodule 0x1::my_module {\n    ...\n    #[test(a = @0x1)]\n    fun test_has_coin_bad(a: signer) {\n        publish_coin(&a);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n    }\n}\n\n\nwe would get the following output when running the tests:\n\n$ move test -g\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x1::my_module::test_has_coin\n[ FAIL    ] 0x1::my_module::test_has_coin_bad\n\nTest failures:\n\nFailures in 0x1::my_module:\n\n┌── test_has_coin_bad ──────\n│ error[E11001]: test failure\n│    ┌─ /home/tzakian/TestExample/sources/my_module.move:47:10\n│    │\n│ 44 │      fun test_has_coin_bad(a: signer) {\n│    │          ----------------- In this function in 0x1::my_module\n│    ·\n│ 47 │          assert!(has_coin(@0x2), 1);\n│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here\n│\n│\n│ ────── Storage state at point of failure ──────\n│ 0x1:\n│       => key 0x1::my_module::MyCoin {\n│           value: 1\n│       }\n│\n└──────────────────\n\nTest result: FAILED. Total tests: 4; passed: 3; failed: 1\n"
    },
    {
      "title": "Packages - The Move Book",
      "url": "https://move-language.github.io/move/packages.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nPackages\n\nPackages allow Move programmers to more easily re-use code and share it across projects. The Move package system allows programmers to easily:\n\nDefine a package containing Move code;\nParameterize a package by named addresses;\nImport and use packages in other Move code and instantiate named addresses;\nBuild packages and generate associated compilation artifacts from packages; and\nWork with a common interface around compiled Move artifacts.\nPackage Layout and Manifest Syntax\n\nA Move package source directory contains a Move.toml package manifest file along with a set of subdirectories:\n\na_move_package\n├── Move.toml      (required)\n├── sources        (required)\n├── examples       (optional, test & dev mode)\n├── scripts        (optional)\n├── doc_templates  (optional)\n└── tests          (optional, test mode)\n\n\nThe directories marked required must be present in order for the directory to be considered a Move package and to be compiled. Optional directories can be present, and if so will be included in the compilation process. Depending on the mode that the package is built with (test or dev), the tests and examples directories will be included as well.\n\nThe sources directory can contain both Move modules and Move scripts (both transaction scripts and modules containing script functions). The examples directory can hold additional code to be used only for development and/or tutorial purposes that will not be included when compiled outside test or dev mode.\n\nA scripts directory is supported so transaction scripts can be separated from modules if that is desired by the package author. The scripts directory will always be included for compilation if it is present. Documentation will be built using any documentation templates present in the doc_templates directory.\n\nMove.toml\n\nThe Move package manifest is defined within the Move.toml file and has the following syntax. Optional fields are marked with *, + denotes one or more elements:\n\n[package]\nname = <string>                  # e.g., \"MoveStdlib\"\nversion = \"<uint>.<uint>.<uint>\" # e.g., \"0.1.1\"\nlicense* = <string>              # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\nauthors* = [<string>]            # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"Jane Smith (janesmith@noemail.com)\"]\n\n[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph\n# One or more lines declaring named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency\n# One or more lines declaring dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # local dependencies\n<string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # git dependencies\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }\n\n\nAn example of a minimal package manifest with one local dependency and one git dependency:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\n\n\nAn example of a more standard package manifest that also includes the Move standard library and instantiates the named address Std from it with the address value 0x1:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\nlicense = \"Apache 2.0\"\n\n[addresses]\naddress_to_be_filled_in = \"_\"\nspecified_address = \"0xB0B\"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = \"projects/move-awesomeness\", addr_subst = { \"std\" = \"0x1\" } }\n# Git dependency\nMoveStdlib = { git = \"https://github.com/diem/diem.git\", subdir=\"language/move-stdlib\", rev = \"56ab033cc403b489e891424a629e76f643d4fb6b\" }\n\n[dev-addresses] # For use when developing this module\naddress_to_be_filled_in = \"0x101010101\"\n\n\nMost of the sections in the package manifest are self explanatory, but named addresses can be a bit difficult to understand so it's worth examining them in a bit more detail.\n\nNamed Addresses During Compilation\n\nRecall that Move has named addresses and that named addresses cannot be declared in Move. Because of this, until now named addresses and their values needed to be passed to the compiler on the command line. With the Move package system this is no longer needed, and you can declare named addresses in the package, instantiate other named addresses in scope, and rename named addresses from other packages within the Move package system manifest file. Let's go through each of these individually:\n\nDeclaration\n\nLet's say we have a Move module in example_pkg/sources/A.move as follows:\n\nmodule named_addr::A {\n    public fun x(): address { @named_addr }\n}\n\n\nWe could in example_pkg/Move.toml declare the named address named_addr in two different ways. The first:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n\nDeclares named_addr as a named address in the package ExamplePkg and that this address can be any valid address value. Therefore an importing package can pick the value of the named address named_addr to be any address it wishes. Intuitively you can think of this as parameterizing the package ExamplePkg by the named address named_addr, and the package can then be instantiated later on by an importing package.\n\nnamed_addr can also be declared as:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"0xCAFE\"\n\n\nwhich states that the named address named_addr is exactly 0xCAFE and cannot be changed. This is useful so other importing packages can use this named address without needing to worry about the exact value assigned to it.\n\nWith these two different declaration methods, there are two ways that information about named addresses can flow in the package graph:\n\nThe former (\"unassigned named addresses\") allows named address values to flow from the importation site to the declaration site.\nThe latter (\"assigned named addresses\") allows named address values to flow from the declaration site upwards in the package graph to usage sites.\n\nWith these two methods for flowing named address information throughout the package graph the rules around scoping and renaming become important to understand.\n\nScoping and Renaming of Named Addresses\n\nA named address N in a package P is in scope if:\n\nIt declares a named address N; or\nA package in one of P's transitive dependencies declares the named address N and there is a dependency path in the package graph between between P and the declaring package of N with no renaming of N.\n\nAdditionally, every named address in a package is exported. Because of this and the above scoping rules each package can be viewed as coming with a set of named addresses that will be brought into scope when the package is imported, e.g., if the ExamplePkg package was imported, that importation would bring into scope the named_addr named address. Because of this, if P imports two packages P1 and P2 both of which declare a named address N an issue arises in P: which \"N\" is meant when N is referred to in P? The one from P1 or P2? To prevent this ambiguity around which package a named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a package are disjoint, and provide a way to rename named addresses when the package that brings them into scope is imported.\n\nRenaming a named address when importing can be done as follows in our P, P1, and P2 example above:\n\n[package]\nname = \"P\"\n...\n[dependencies]\nP1 = { local = \"some_path_to_P1\", addr_subst = { \"P1N\" = \"N\" } }\nP2 = { local = \"some_path_to_P2\"  }\n\n\nWith this renaming N refers to the N from P2 and P1N will refer to N coming from P1:\n\nmodule N::A {\n    public fun x(): address { @P1N }\n}\n\n\nIt is important to note that renaming is not local: once a named address N has been renamed to N2 in a package P all packages that import P will not see N but only N2 unless N is reintroduced from outside of P. This is why rule (2) in the scoping rules at the start of this section specifies a \"dependency path in the package graph between between P and the declaring package of N with no renaming of N.\"\n\nInstantiation\n\nNamed addresses can be instantiated multiple times across the package graph as long as it is always with the same value. It is an error if the same named address (regardless of renaming) is instantiated with differing values across the package graph.\n\nA Move package can only be compiled if all named addresses resolve to a value. This presents issues if the package wishes to expose an uninstantiated named address. This is what the [dev-addresses] section solves. This section can set values for named addresses, but cannot introduce any named addresses. Additionally, only the [dev-addresses] in the root package are included in dev mode. For example a root package with the following manifest would not compile outside of dev mode since named_addr would be uninstantiated:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n[dev-addresses]\nnamed_addr = \"0xC0FFEE\"\n\nUsage, Artifacts, and Data Structures\n\nThe Move package system comes with a command line option as part of the Move CLI move <flags> <command> <command_flags>. Unless a particular path is provided, all package commands will run in the current working directory. The full list of commands and flags for the Move CLI can be found by running move --help.\n\nUsage\n\nA package can be compiled either through the Move CLI commands, or as a library command in Rust with the function compile_package. This will create a CompiledPackage that holds the compiled bytecode along with other compilation artifacts (source maps, documentation, ABIs) in memory. This CompiledPackage can be converted to an OnDiskPackage and vice versa -- the latter being the data of the CompiledPackage laid out in the file system in the following format:\n\na_move_package\n├── Move.toml\n...\n└── build\n    ├── <dep_pkg_name>\n    │   ├── BuildInfo.yaml\n    │   ├── bytecode_modules\n    │   │   └── *.mv\n    │   ├── source_maps\n    │   │   └── *.mvsm\n    │   ├── bytecode_scripts\n    │   │   └── *.mv\n    │   ├── abis\n    │   │   ├── *.abi\n    │   │   └── <module_name>/*.abi\n    │   └── sources\n    │       └── *.move\n    ...\n    └── <dep_pkg_name>\n        ├── BuildInfo.yaml\n        ...\n        └── sources\n\n\nSee the move-package crate for more information on these data structures and how to use the Move package system as a Rust library."
    },
    {
      "title": "Friends - The Move Book",
      "url": "https://move-language.github.io/move/friends.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nFriends\n\nThe friend syntax is used to declare modules that are trusted by the current module. A trusted module is allowed to call any function defined in the current module that have the public(friend) visibility. For details on function visibilities, please refer to the Visibility section in Functions.\n\nFriend declaration\n\nA module can declare other modules as friends via friend declaration statements, in the format of\n\nfriend <address::name> — friend declaration using fully qualified module name like the example below, or\n\naddress 0x42 {\nmodule a {\n    friend 0x42::b;\n}\n}\n\n\nfriend <module-name-alias> — friend declaration using a module name alias, where the module alias is introduced via the use statement.\n\naddress 0x42 {\nmodule a {\n    use 0x42::b;\n    friend b;\n}\n}\n\n\nA module may have multiple friend declarations, and the union of all the friend modules forms the friend list. In the example below, both 0x42::B and 0x42::C are considered as friends of 0x42::A.\n\naddress 0x42 {\nmodule a {\n    friend 0x42::b;\n    friend 0x42::c;\n}\n}\n\n\nUnlike use statements, friend can only be declared in the module scope and not in the expression block scope. friend declarations may be located anywhere a top-level construct (e.g., use, function, struct, etc.) is allowed. However, for readability, it is advised to place friend declarations near the beginning of the module definition.\n\nNote that the concept of friendship does not apply to Move scripts:\n\nA Move script cannot declare friend modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.\nA Move module cannot declare friend scripts as well because scripts are ephemeral code snippets that are never published to global storage.\nFriend declaration rules\n\nFriend declarations are subject to the following rules:\n\nA module cannot declare itself as a friend.\n\naddress 0x42 {\nmodule m { friend Self; // ERROR! }\n//                ^^^^ Cannot declare the module itself as a friend\n}\n\naddress 0x43 {\nmodule m { friend 0x43::M; // ERROR! }\n//                ^^^^^^^ Cannot declare the module itself as a friend\n}\n\n\nFriend modules must be known by the compiler\n\naddress 0x42 {\nmodule m { friend 0x42::nonexistent; // ERROR! }\n//                ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'\n}\n\n\nFriend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which may be relaxed later.)\n\naddress 0x42 {\nmodule m {}\n}\n\naddress 0x43 {\nmodule n { friend 0x42::m; // ERROR! }\n//                ^^^^^^^ Cannot declare modules out of the current address as a friend\n}\n\n\nFriends relationships cannot create cyclic module dependencies.\n\nCycles are not allowed in the friend relationships, e.g., the relation 0x2::a friends 0x2::b friends 0x2::c friends 0x2::a is not allowed. More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module). If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.\n\naddress 0x2 {\nmodule a {\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a() {\n        c::c()\n    }\n}\n\nmodule b {\n    friend 0x2::c; // ERROR!\n//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'\n}\n\nmodule c {\n    public fun c() {}\n}\n}\n\n\nThe friend list for a module cannot contain duplicates.\n\naddress 0x42 {\nmodule a {}\n\nmodule m {\n    use 0x42::a as aliased_a;\n    friend 0x42::A;\n    friend aliased_a; // ERROR!\n//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique\n}\n}\n"
    },
    {
      "title": "Uses and Aliases - The Move Book",
      "url": "https://move-language.github.io/move/uses.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nUses and Aliases\n\nThe use syntax can be used to create aliases to members in other modules. use can be used to create aliases that last either for the entire module, or for a given expression block scope.\n\nSyntax\n\nThere are several different syntax cases for use. Starting with the most simple, we have the following for creating aliases to other modules\n\nuse <address>::<module name>;\nuse <address>::<module name> as <module alias name>;\n\n\nFor example\n\nuse std::vector;\nuse std::vector as V;\n\n\nuse std::vector; introduces an alias vector for std::vector. This means that anywhere you would want to use the module name std::vector (assuming this use is in scope), you could use vector instead. use std::vector; is equivalent to use std::vector as vector;\n\nSimilarly use std::vector as V; would let you use V instead of std::vector\n\nuse std::vector;\nuse std::vector as V;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = vector::empty();\n    let v3 = V::empty();\n    (v1, v2, v3)\n}\n\n\nIf you want to import a specific module member (such as a function, struct, or constant). You can use the following syntax.\n\nuse <address>::<module name>::<module member>;\nuse <address>::<module name>::<module member> as <member alias>;\n\n\nFor example\n\nuse std::vector::empty;\nuse std::vector::empty as empty_vec;\n\n\nThis would let you use the function std::vector::empty without full qualification. Instead you could use empty and empty_vec respectively. Again, use std::vector::empty; is equivalent to use std::vector::empty as empty;\n\nuse std::vector::empty;\nuse std::vector::empty as empty_vec;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = empty();\n    let v3 = empty_vec();\n    (v1, v2, v3)\n}\n\n\nIf you want to add aliases for multiple module members at once, you can do so with the following syntax\n\nuse <address>::<module name>::{<module member>, <module member> as <member alias> ... };\n\n\nFor example\n\nuse std::vector::{push_back, length as len, pop_back};\n\nfun swap_last_two<T>(v: &mut vector<T>) {\n    assert!(len(v) >= 2, 42);\n    let last = pop_back(v);\n    let second_to_last = pop_back(v);\n    push_back(v, last);\n    push_back(v, second_to_last)\n}\n\n\nIf you need to add an alias to the Module itself in addition to module members, you can do that in a single use using Self. Self is a member of sorts that refers to the module.\n\nuse std::vector::{Self, empty};\n\n\nFor clarity, all of the following are equivalent:\n\nuse std::vector;\nuse std::vector as vector;\nuse std::vector::Self;\nuse std::vector::Self as vector;\nuse std::vector::{Self};\nuse std::vector::{Self as vector};\n\n\nIf needed, you can have as many aliases for any item as you like\n\nuse std::vector::{\n    Self,\n    Self as V,\n    length,\n    length as len,\n};\n\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    // all options available given the `use` above\n    assert!(vector::length(v) > 1, 42);\n    assert!(V::length(v) > 1, 42);\n    assert!(length(v) > 1, 42);\n    assert!(len(v) > 1, 42);\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\nInside a module\n\nInside of a module all use declarations are usable regardless of the order of declaration.\n\naddress 0x42 {\nmodule example {\n    use std::vector;\n\n    fun example(): vector<u8> {\n        let v = empty();\n        vector::push_back(&mut v, 0);\n        vector::push_back(&mut v, 10);\n        v\n    }\n\n    use std::vector::empty;\n}\n}\n\n\nThe aliases declared by use in the module usable within that module.\n\nAdditionally, the aliases introduced cannot conflict with other module members. See Uniqueness for more details\n\nInside an expression\n\nYou can add use declarations to the beginning of any expression block\n\naddress 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        use std::vector::{empty, push_back};\n\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    }\n}\n}\n\n\nAs with let, the aliases introduced by use in an expression block are removed at the end of that block.\n\naddress 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        let result = {\n            use std::vector::{empty, push_back};\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 10);\n            v\n        };\n        result\n    }\n\n}\n}\n\n\nAttempting to use the alias after the block ends will result in an error\n\nfun example(): vector<u8> {\n    let result = {\n        use std::vector::{empty, push_back};\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    };\n    let v2 = empty(); // ERROR!\n//           ^^^^^ unbound function 'empty'\n    result\n}\n\n\nAny use must be the first item in the block. If the use comes after any expression or let, it will result in a parsing error\n\n{\n    let x = 0;\n    use std::vector; // ERROR!\n    let v = vector::empty();\n}\n\nNaming rules\n\nAliases must follow the same rules as other module members. This means that aliases to structs or constants must start with A to Z\n\naddress 0x42 {\nmodule data {\n    struct S {}\n    const FLAG: bool = false;\n    fun foo() {}\n}\nmodule example {\n    use 0x42::data::{\n        S as s, // ERROR!\n        FLAG as fLAG, // ERROR!\n        foo as FOO,  // valid\n        foo as bar, // valid\n    };\n}\n}\n\nUniqueness\n\nInside a given scope, all aliases introduced by use declarations must be unique.\n\nFor a module, this means aliases introduced by use cannot overlap\n\naddress 0x42 {\nmodule example {\n\n    use std::vector::{empty as foo, length as foo}; // ERROR!\n    //                                        ^^^ duplicate 'foo'\n\n    use std::vector::empty as bar;\n\n    use std::vector::length as bar; // ERROR!\n    //                         ^^^ duplicate 'bar'\n\n}\n}\n\n\nAnd, they cannot overlap with any of the module's other members\n\naddress 0x42 {\nmodule data {\n    struct S {}\n}\nmodule example {\n    use 0x42::data::S;\n\n    struct S { value: u64 } // ERROR!\n    //     ^ conflicts with alias 'S' above\n}\n}\n\n\nInside of an expression block, they cannot overlap with each other, but they can shadow other aliases or names from an outer scope\n\nShadowing\n\nuse aliases inside of an expression block can shadow names (module members or aliases) from the outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;\n\naddress 0x42 {\nmodule example {\n\n    struct WrappedVector { vec: vector<u64> }\n\n    fun empty(): WrappedVector {\n        WrappedVector { vec: std::vector::empty() }\n    }\n\n    fun example1(): (WrappedVector, WrappedVector) {\n        let vec = {\n            use std::vector::{empty, push_back};\n            // 'empty' now refers to std::vector::empty\n\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 1);\n            push_back(&mut v, 10);\n            v\n        };\n        // 'empty' now refers to Self::empty\n\n        (empty(), WrappedVector { vec })\n    }\n\n    fun example2(): (WrappedVector, WrappedVector) {\n        use std::vector::{empty, push_back};\n        let w: WrappedVector = {\n            use 0x42::example::empty;\n            empty()\n        };\n        push_back(&mut w.vec, 0);\n        push_back(&mut w.vec, 1);\n        push_back(&mut w.vec, 10);\n\n        let vec = empty();\n        push_back(&mut vec, 0);\n        push_back(&mut vec, 1);\n        push_back(&mut vec, 10);\n\n        (w, WrappedVector { vec })\n    }\n}\n}\n\nUnused Use or Alias\n\nAn unused use will result in an error\n\naddress 0x42 {\nmodule example {\n    use std::vector::{empty, push_back}; // ERROR!\n    //                       ^^^^^^^^^ unused alias 'push_back'\n\n    fun example(): vector<u8> {\n        empty()\n    }\n}\n}\n"
    },
    {
      "title": "Type Abilities - The Move Book",
      "url": "https://move-language.github.io/move/abilities.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nAbilities\n\nAbilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the \"linear\" typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).\n\nThe Four Abilities\n\nThe four abilities are:\n\ncopy\nAllows values of types with this ability to be copied.\ndrop\nAllows values of types with this ability to be popped/dropped.\nstore\nAllows values of types with this ability to exist inside a struct in global storage.\nkey\nAllows the type to serve as a key for global storage operations.\ncopy\n\nThe copy ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the copy operator and to copy values via references with dereference *e.\n\nIf a value has copy, all values contained inside of that value have copy.\n\ndrop\n\nThe drop ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:\n\nnot using the value in a local variable or parameter\nnot using the value in a sequence via ;\noverwriting values in variables in assignments\noverwriting values via references when writing *e1 = e2.\n\nIf a value has drop, all values contained inside of that value have drop.\n\nstore\n\nThe store ability allows values of types with this ability to exist inside of a struct (resource) in global storage, but not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with key.\n\nIf a value has store, all values contained inside of that value have store\n\nkey\n\nThe key ability allows the type to serve as a key for global storage operations. It gates all global storage operations, so in order for a type to be used with move_to, borrow_global, move_from, etc., the type must have the key ability. Note that the operations still must be used in the module where the key type is defined (in a sense, the operations are private to the defining module).\n\nIf a value has key, all values contained inside of that value have store. This is the only ability with this sort of asymmetry.\n\nBuiltin Types\n\nMost primitive, builtin types have copy, drop, and store with the exception of signer, which just has drop\n\nbool, u8, u16, u32, u64, u128, u256, and address all have copy, drop, and store.\nsigner has drop\nCannot be copied and cannot be put into global storage\nvector<T> may have copy, drop, and store depending on the abilities of T.\nSee Conditional Abilities and Generic Types for more details.\nImmutable references & and mutable references &mut both have copy and drop.\nThis refers to copying and dropping the reference itself, not what they refer to.\nReferences cannot appear in global storage, hence they do not have store.\n\nNone of the primitive types have key, meaning none of them can be used directly with the global storage operations.\n\nAnnotating Structs\n\nTo declare that a struct has an ability, it is declared with has <ability> after the struct name but before the fields. For example:\n\nstruct Ignorable has drop { f: u64 }\nstruct Pair has copy, drop, store { x: u64, y: u64 }\n\n\nIn this case: Ignorable has the drop ability. Pair has copy, drop, and store.\n\nAll of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!\n\nAs such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...\n\ncopy, all fields must have copy.\ndrop, all fields must have drop.\nstore, all fields must have store.\nkey, all fields must have store.\nkey is the only ability currently that doesn’t require itself.\n\nFor example:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct WantsCopy has copy {\n    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'\n}\n\n\nand similarly:\n\n// A struct without any abilities\nstruct NoAbilities {}\n\nstruct MyResource has key {\n    f: NoAbilities, // Error 'NoAbilities' does not have 'store'\n}\n\nConditional Abilities and Generic Types\n\nWhen abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:\n\nstruct Cup<T> has copy, drop, store, key { item: T }\n\n\nIt might be very helpful if Cup could hold any type, regardless of its abilities. The type system can see the type parameter, so it should be able to remove abilities from Cup if it sees a type parameter that would violate the guarantees for that ability.\n\nThis behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type vector to have the following type declaration:\n\nvector<T> has copy, drop, store;\n\n\nWe want vectors to work with any type. We don't want separate vector types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above. So, it would be safe to copy a vector value only if the inner elements can be copied. It would be safe to ignore a vector value only if the inner elements can be ignored/dropped. And, it would be safe to put a vector in global storage only if the inner elements can be in global storage.\n\nTo have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration and its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking Cup from above as an example:\n\nCup has the ability copy only if T has copy.\nIt has drop only if T has drop.\nIt has store only if T has store.\nIt has key only if T has store.\n\nHere are examples for this conditional system for each ability:\n\nExample: conditional copy\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun example(c_x: Cup<u64>, c_s: Cup<S>) {\n    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'\n    let c_x2 = copy c_x;\n    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'\n    let c_s2 = copy c_s;\n}\n\nfun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {\n    // Invalid, 'Cup<signer>' does not have 'copy'.\n    // Even though 'Cup' was declared with copy, the instance does not have 'copy'\n    // because 'signer' does not have 'copy'\n    let c_account2 = copy c_account;\n    // Invalid, 'Cup<NoAbilities>' does not have 'copy'\n    // because 'NoAbilities' does not have 'copy'\n    let c_n2 = copy c_n;\n}\n\nExample: conditional drop\nstruct NoAbilities {}\nstruct S has copy, drop { f: bool }\nstruct Cup<T> has copy, drop, store { item: T }\n\nfun unused() {\n    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'\n    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'\n}\n\nfun left_in_local(c_account: Cup<signer>): u64 {\n    let c_b = Cup<bool> { item: true };\n    let c_s = Cup<S> { item: S { f: false }};\n    // Valid return: 'c_account', 'c_b', and 'c_s' have values\n    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'\n    0\n}\n\nfun invalid_unused() {\n    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.\n    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'\n    // because 'NoAbilities' does not have 'drop'\n    Cup<NoAbilities> { item: NoAbilities {}};\n}\n\nfun invalid_left_in_local(): u64 {\n    let n = Cup<NoAbilities> { item: NoAbilities {}};\n    // Invalid return: 'n' has a value\n    // and 'Cup<NoAbilities>' does not have 'drop'\n    0\n}\n\nExample: conditional store\nstruct Cup<T> has copy, drop, store { item: T }\n\n// 'MyInnerResource' is declared with 'store' so all fields need 'store'\nstruct MyInnerResource has store {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\n// 'MyResource' is declared with 'key' so all fields need 'store'\nstruct MyResource has key {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    inner: Cup<MyInnerResource>, // Valid, 'Cup<MyInnerResource>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\nExample: conditional key\nstruct NoAbilities {}\nstruct MyResource<T> has key { f: T }\n\nfun valid(account: &signer) acquires MyResource {\n    let addr = signer::address_of(account);\n     // Valid, 'MyResource<u64>' has 'key'\n    let has_resource = exists<MyResource<u64>>(addr);\n    if (!has_resource) {\n         // Valid, 'MyResource<u64>' has 'key'\n        move_to(account, MyResource<u64> { f: 0 })\n    };\n    // Valid, 'MyResource<u64>' has 'key'\n    let r = borrow_global_mut<MyResource<u64>>(addr)\n    r.f = r.f + 1;\n}\n\nfun invalid(account: &signer) {\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let has_it = exists<MyResource<NoAbilities>>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   let NoAbilities {} = move_from<NoAbilities>(addr);\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   move_to(account, NoAbilities {});\n   // Invalid, 'MyResource<NoAbilities>' does not have 'key'\n   borrow_global<NoAbilities>(addr);\n}\n"
    },
    {
      "title": "Generics - The Move Book",
      "url": "https://move-language.github.io/move/generics.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nGenerics\n\nGenerics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term generics interchangeably with type parameters and type arguments.\n\nGenerics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.\n\nDeclaring Type Parameters\n\nBoth functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets <...>.\n\nGeneric Functions\n\nType parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.\n\nfun id<T>(x: T): T {\n    // this type annotation is unnecessary but valid\n    (x: T)\n}\n\n\nOnce defined, the type parameter T can be used in parameter types, return types, and inside the function body.\n\nGeneric Structs\n\nType parameters for structs are placed after the struct name, and can be used to name the types of the fields.\n\nstruct Foo<T> has copy, drop { x: T }\n\nstruct Bar<T1, T2> has copy, drop {\n    x: T1,\n    y: vector<T2>,\n}\n\n\nNote that type parameters do not have to be used\n\nType Arguments\nCalling Generic Functions\n\nWhen calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.\n\nfun foo() {\n    let x = id<bool>(true);\n}\n\n\nIf you do not specify the type arguments, Move's type inference will supply them for you.\n\nUsing Generic Structs\n\nSimilarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.\n\nfun foo() {\n    let foo = Foo<bool> { x: true };\n    let Foo<bool> { x } = foo;\n}\n\n\nIf you do not specify the type arguments, Move's type inference will supply them for you.\n\nType Argument Mismatch\n\nIf you specify the type arguments and they conflict with the actual values supplied, an error will be given:\n\nfun foo() {\n    let x = id<u64>(true); // error! true is not a u64\n}\n\n\nand similarly:\n\nfun foo() {\n    let foo = Foo<bool> { x: 0 }; // error! 0 is not a bool\n    let Foo<address> { x } = foo; // error! bool is incompatible with address\n}\n\nType Inference\n\nIn most cases, the Move compiler will be able to infer the type arguments so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments:\n\nfun foo() {\n    let x = id(true);\n    //        ^ <bool> is inferred\n\n    let foo = Foo { x: true };\n    //           ^ <bool> is inferred\n\n    let Foo { x } = foo;\n    //     ^ <bool> is inferred\n}\n\n\nNote: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.\n\naddress 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        // let v = vector::new();\n        //                    ^ The compiler cannot figure out the element type.\n\n        let v = vector::new<u64>();\n        //                 ^~~~~ Must annotate manually.\n    }\n}\n}\n\n\nHowever, the compiler will be able to infer the type if that return value is used later in that function:\n\naddress 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        let v = vector::new();\n        //                 ^ <u64> is inferred\n        vector::push_back(&mut v, 42);\n    }\n}\n}\n\nUnused Type Parameters\n\nFor a struct definition, an unused type parameter is one that does not appear in any field defined in the struct, but is checked statically at compile time. Move allows unused type parameters so the following struct definition is valid:\n\nstruct Foo<T> {\n    foo: u64\n}\n\n\nThis can be convenient when modeling certain concepts. Here is an example:\n\naddress 0x2 {\nmodule m {\n    // Currency Specifiers\n    struct Currency1 {}\n    struct Currency2 {}\n\n    // A generic coin type that can be instantiated using a currency\n    // specifier type.\n    //   e.g. Coin<Currency1>, Coin<Currency2> etc.\n    struct Coin<Currency> has store {\n        value: u64\n    }\n\n    // Write code generically about all currencies\n    public fun mint_generic<Currency>(value: u64): Coin<Currency> {\n        Coin { value }\n    }\n\n    // Write code concretely about one currency\n    public fun mint_concrete(value: u64): Coin<Currency1> {\n        Coin { value }\n    }\n}\n}\n\n\nIn this example, struct Coin<Currency> is generic on the Currency type parameter, which specifies the currency of the coin and allows code to be written either generically on any currency or concretely on a specific currency. This genericity applies even when the Currency type parameter does not appear in any of the fields defined in Coin.\n\nPhantom Type Parameters\n\nIn the example above, although struct Coin asks for the store ability, neither Coin<Currency1> nor Coin<Currency2> will have the store ability. This is because of the rules for Conditional Abilities and Generic Types and the fact that Currency1 and Currency2 don't have the store ability, despite the fact that they are not even used in the body of struct Coin. This might cause some unpleasant consequences. For example, we are unable to put Coin<Currency1> into a wallet in the global storage.\n\nOne possible solution would be to add spurious ability annotations to Currency1 and Currency2 (i.e., struct Currency1 has store {}). But, this might lead to bugs or security vulnerabilities because it weakens the types with unnecessary ability declarations. For example, we would never expect a resource in the global storage to have a field in type Currency1, but this would be possible with the spurious store ability. Moreover, the spurious annotations would be infectious, requiring many functions generic on the unused type parameter to also include the necessary constraints.\n\nPhantom type parameters solve this problem. Unused type parameters can be marked as phantom type parameters, which do not participate in the ability derivation for structs. In this way, arguments to phantom type parameters are not considered when deriving the abilities for generic types, thus avoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type system guarantees that a parameter declared as phantom is either not used at all in the struct definition, or it is only used as an argument to type parameters also declared as phantom.\n\nDeclaration\n\nIn a struct definition a type parameter can be declared as phantom by adding the phantom keyword before its declaration. If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a struct, Move's type checker ensures that every phantom type parameter is either not used inside the struct definition or it is only used as an argument to a phantom type parameter.\n\nMore formally, if a type is used as an argument to a phantom type parameter we say the type appears in phantom position. With this definition in place, the rule for the correct use of phantom parameters can be specified as follows: A phantom type parameter can only appear in phantom position.\n\nThe following two examples show valid uses of phantom parameters. In the first one, the parameter T1 is not used at all inside the struct definition. In the second one, the parameter T1 is only used as an argument to a phantom type parameter.\n\nstruct S1<phantom T1, T2> { f: u64 }\n                  ^^\n                  Ok: T1 does not appear inside the struct definition\n\n\nstruct S2<phantom T1, T2> { f: S1<T1, T2> }\n                                  ^^\n                                  Ok: T1 appears in phantom position\n\n\nThe following code shows examples of violations of the rule:\n\nstruct S1<phantom T> { f: T }\n                          ^\n                          Error: Not a phantom position\n\nstruct S2<T> { f: T }\n\nstruct S3<phantom T> { f: S2<T> }\n                             ^\n                             Error: Not a phantom position\n\nInstantiation\n\nWhen instantiating a struct, the arguments to phantom parameters are excluded when deriving the struct abilities. For example, consider the following code:\n\nstruct S<T1, phantom T2> has copy { f: T1 }\nstruct NoCopy {}\nstruct HasCopy has copy {}\n\n\nConsider now the type S<HasCopy, NoCopy>. Since S is defined with copy and all non-phantom arguments have copy then S<HasCopy, NoCopy> also has copy.\n\nPhantom Type Parameters with Ability Constraints\n\nAbility constraints and phantom type parameters are orthogonal features in the sense that phantom parameters can be declared with ability constraints. When instantiating a phantom type parameter with an ability constraint, the type argument has to satisfy that constraint, even though the parameter is phantom. For example, the following definition is perfectly valid:\n\nstruct S<phantom T: copy> {}\n\n\nThe usual restrictions apply and T can only be instantiated with arguments having copy.\n\nConstraints\n\nIn the examples above, we have demonstrated how one can use type parameters to define \"unknown\" types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no abilities.\n\nThis is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.\n\nDeclaring Constraints\n\nConstraints can be imposed on type parameters using the following syntax.\n\n// T is the name of the type parameter\nT: <ability> (+ <ability>)*\n\n\nThe <ability> can be any of the four abilities, and a type parameter can be constrained with multiple abilities at once. So all of the following would be valid type parameter declarations:\n\nT: copy\nT: copy + drop\nT: copy + drop + store + key\n\nVerifying Constraints\n\nConstraints are checked at call sites so the following code won't compile.\n\nstruct Foo<T: key> { x: T }\n\nstruct Bar { x: Foo<u8> }\n//                  ^ error! u8 does not have 'key'\n\nstruct Baz<T> { x: Foo<T> }\n//                     ^ error! T does not have 'key'\n\nstruct R {}\n\nfun unsafe_consume<T>(x: T) {\n    // error! x does not have 'drop'\n}\n\nfun consume<T: drop>(x: T) {\n    // valid!\n    // x will be dropped automatically\n}\n\nfun foo() {\n    let r = R {};\n    consume<R>(r);\n    //      ^ error! R does not have 'drop'\n}\n\nstruct R {}\n\nfun unsafe_double<T>(x: T) {\n    (copy x, x)\n    // error! x does not have 'copy'\n}\n\nfun double<T: copy>(x: T) {\n    (copy x, x) // valid!\n}\n\nfun foo(): (R, R) {\n    let r = R {};\n    double<R>(r)\n    //     ^ error! R does not have 'copy'\n}\n\n\nFor more information, see the abilities section on conditional abilities and generic types.\n\nLimitations on Recursions\nRecursive Structs\n\nGeneric structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All of the following struct definitions are invalid:\n\nstruct Foo<T> {\n    x: Foo<u64> // error! 'Foo' containing 'Foo'\n}\n\nstruct Bar<T> {\n    x: Bar<T> // error! 'Bar' containing 'Bar'\n}\n\n// error! 'A' and 'B' forming a cycle, which is not allowed either.\nstruct A<T> {\n    x: B<T, u64>\n}\n\nstruct B<T1, T2> {\n    x: A<T1>\n    y: A<T2>\n}\n\nAdvanced Topic: Type-level Recursions\n\nMove allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.\n\nAllowed:\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<T> -> foo<T> -> ... is valid\n    fun foo<T>() {\n        foo<T>();\n    }\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid\n    fun foo<T>() {\n        foo<A<u64>>();\n    }\n}\n}\n\n\nNot allowed:\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...\n    fun foo<T>() {\n        foo<Foo<T>>();\n    }\n}\n}\n\naddress 0x2 {\nmodule n {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>\n    //   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>\n    //   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>\n    //   -> ...\n    fun foo<T1, T2>() {\n        bar<T2, T1>();\n    }\n\n    fun bar<T1, T2> {\n        foo<T1, A<T2>>();\n    }\n}\n}\n\n\nNote, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.\n\naddress 0x2 {\nmodule m {\n    struct A<T> {}\n\n    fun foo<T>(n: u64) {\n        if (n > 0) {\n            foo<A<T>>(n - 1);\n        };\n    }\n}\n}\n\n\nThe function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system."
    },
    {
      "title": "Constants - The Move Book",
      "url": "https://move-language.github.io/move/constants.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nConstants\n\nConstants are a way of giving a name to shared, static values inside of a module or script.\n\nThe constant's must be known at compilation. The constant's value is stored in the compiled module or script. And each time the constant is used, a new copy of that value is made.\n\nDeclaration\n\nConstant declarations begin with the const keyword, followed by a name, a type, and a value. They can exist in either a script or module\n\nconst <name>: <type> = <expression>;\n\n\nFor example\n\nscript {\n\n    const MY_ERROR_CODE: u64 = 0;\n\n    fun main(input: u64) {\n        assert!(input > 0, MY_ERROR_CODE);\n    }\n\n}\n\naddress 0x42 {\nmodule example {\n\n    const MY_ADDRESS: address = @0x42;\n\n    public fun permissioned(s: &signer) {\n        assert!(std::signer::address_of(s) == MY_ADDRESS, 0);\n    }\n\n}\n}\n\nNaming\n\nConstants must start with a capital letter A to Z. After the first letter, constant names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nconst FLAG: bool = false;\nconst MY_ERROR_CODE: u64 = 0;\nconst ADDRESS_42: address = @0x42;\n\n\nEven though you can use letters a to z in a constant. The general style guidelines are to use just uppercase letters A to Z, with underscores _ between each word.\n\nThis naming restriction of starting with A to Z is in place to give room for future language features. It may or may not be removed later.\n\nVisibility\n\npublic constants are not currently supported. const values can be used only in the declaring module.\n\nValid Expressions\n\nCurrently, constants are limited to the primitive types bool, u8, u16, u32, u64, u128, u256, address, and vector<u8>. Future support for other vector values (besides the \"string\"-style literals) will come later.\n\nValues\n\nCommonly, consts are assigned a simple value, or literal, of their type. For example\n\nconst MY_BOOL: bool = false;\nconst MY_ADDRESS: address = @0x70DD;\nconst BYTES: vector<u8> = b\"hello world\";\nconst HEX_BYTES: vector<u8> = x\"DEADBEEF\";\n\nComplex Expressions\n\nIn addition to literals, constants can include more complex expressions, as long as the compiler is able to reduce the expression to a value at compile time.\n\nCurrently, equality operations, all boolean operations, all bitwise operations, and all arithmetic operations can be used.\n\nconst RULE: bool = true && false;\nconst CAP: u64 = 10 * 100 + 1;\nconst SHIFTY: u8 = {\n  (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)\n};\nconst HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\nconst REM: u256 = 57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\nconst EQUAL: bool = 1 == 1;\n\n\nIf the operation would result in a runtime exception, the compiler will give an error that it is unable to generate the constant's value\n\nconst DIV_BY_ZERO: u64 = 1 / 0; // error!\nconst SHIFT_BY_A_LOT: u64 = 1 << 100; // error!\nconst NEGATIVE_U64: u64 = 0 - 1; // error!\n\n\nNote that constants cannot currently refer to other constants. This feature, along with support for other expressions, will be added in the future."
    },
    {
      "title": "Structs and Resources - The Move Book",
      "url": "https://move-language.github.io/move/structs-and-resources.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nStructs and Resources\n\nA struct is a user-defined data structure containing typed fields. Structs can store any non-reference type, including other structs.\n\nWe often refer to struct values as resources if they cannot be copied and cannot be dropped. In this case, resource values must have ownership transferred by the end of the function. This property makes resources particularly well served for defining global storage schemas or for representing important values (such as a token).\n\nBy default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped, and cannot be stored in global storage. This means that all values have to have ownership transferred (linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can relax this behavior by giving the struct abilities which allow values to be copied or dropped and also to be stored in global storage or to define global storage schemas.\n\nDefining Structs\n\nStructs must be defined inside a module:\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64, y: bool }\n    struct Bar {}\n    struct Baz { foo: Foo, }\n    //                   ^ note: it is fine to have a trailing comma\n}\n}\n\n\nStructs cannot be recursive, so the following definition is invalid:\n\nstruct Foo { x: Foo }\n//              ^ error! Foo cannot contain Foo\n\n\nAs mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value to be used with certain operations (that copy it, drop it, store it in global storage, or use it as a storage schema), structs can be granted abilities by annotating them with has <ability>:\n\naddress 0x2 {\nmodule m {\n    struct Foo has copy, drop { x: u64, y: bool }\n}\n}\n\n\nFor more details, see the annotating structs section.\n\nNaming\n\nStructs must start with a capital letter A to Z. After the first letter, struct names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nstruct Foo {}\nstruct BAR {}\nstruct B_a_z_4_2 {}\n\n\nThis naming restriction of starting with A to Z is in place to give room for future language features. It may or may not be removed later.\n\nUsing Structs\nCreating Structs\n\nValues of a struct type can be created (or \"packed\") by indicating the struct name, followed by value for each field:\n\naddress 0x2 {\nmodule m {\n    struct Foo has drop { x: u64, y: bool }\n    struct Baz has drop { foo: Foo }\n\n    fun example() {\n        let foo = Foo { x: 0, y: false };\n        let baz = Baz { foo: foo };\n    }\n}\n}\n\n\nIf you initialize a struct field with a local variable whose name is the same as the field, you can use the following shorthand:\n\nlet baz = Baz { foo: foo };\n// is equivalent to\nlet baz = Baz { foo };\n\n\nThis is called sometimes called \"field name punning\".\n\nDestroying Structs via Pattern Matching\n\nStruct values can be destroyed by binding or assigning them patterns.\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64, y: bool }\n    struct Bar { foo: Foo }\n    struct Baz {}\n\n    fun example_destroy_foo() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: foo_y } = foo;\n        //        ^ shorthand for `x: x`\n\n        // two new bindings\n        //   x: u64 = 3\n        //   foo_y: bool = false\n    }\n\n    fun example_destroy_foo_wildcard() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y: _ } = foo;\n\n        // only one new binding since y was bound to a wildcard\n        //   x: u64 = 3\n    }\n\n    fun example_destroy_foo_assignment() {\n        let x: u64;\n        let y: bool;\n        Foo { x, y } = Foo { x: 3, y: false };\n\n        // mutating existing variables x & y\n        //   x = 3, y = false\n    }\n\n    fun example_foo_ref() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &foo;\n\n        // two new bindings\n        //   x: &u64\n        //   y: &bool\n    }\n\n    fun example_foo_ref_mut() {\n        let foo = Foo { x: 3, y: false };\n        let Foo { x, y } = &mut foo;\n\n        // two new bindings\n        //   x: &mut u64\n        //   y: &mut bool\n    }\n\n    fun example_destroy_bar() {\n        let bar = Bar { foo: Foo { x: 3, y: false } };\n        let Bar { foo: Foo { x, y } } = bar;\n        //             ^ nested pattern\n\n        // two new bindings\n        //   x: u64 = 3\n        //   y: bool = false\n    }\n\n    fun example_destroy_baz() {\n        let baz = Baz {};\n        let Baz {} = baz;\n    }\n}\n}\n\nBorrowing Structs and Fields\n\nThe & and &mut operator can be used to create references to structs or fields. These examples include some optional type annotations (e.g., : &Foo) to demonstrate the type of operations.\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref: &Foo = &foo;\nlet y: bool = foo_ref.y;          // reading a field via a reference to the struct\nlet x_ref: &u64 = &foo.x;\n\nlet x_ref_mut: &mut u64 = &mut foo.x;\n*x_ref_mut = 42;            // modifying a field via a mutable reference\n\n\nIt is possible to borrow inner fields of nested structs:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo };\n\nlet x_ref = &bar.foo.x;\n\n\nYou can also borrow a field via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &foo;\nlet x_ref = &foo_ref.x;\n// this has the same effect as let x_ref = &foo.x\n\nReading and Writing Fields\n\nIf you need to read and copy a field's value, you can then dereference the borrowed field:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo: copy foo };\nlet x: u64 = *&foo.x;\nlet y: bool = *&foo.y;\nlet foo2: Foo = *&bar.foo;\n\n\nIf the field is implicitly copyable, the dot operator can be used to read fields of a struct without any borrowing. (Only scalar values with the copy ability are implicitly copyable.)\n\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n\n\nDot operators can be chained to access nested fields:\n\nlet baz = Baz { foo: Foo { x: 3, y: true } };\nlet x = baz.foo.x; // x = 3;\n\n\nHowever, this is not permitted for fields that contain non-primitive types, such a vector or another struct:\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar { foo };\nlet foo2: Foo = *&bar.foo;\nlet foo3: Foo = bar.foo; // error! must add an explicit copy with *&\n\n\nThe reason behind this design decision is that copying a vector or another struct might be an expensive operation. It is important for a programmer to be aware of this copy and make others aware with the explicit syntax *&.\n\nIn addition reading from fields, the dot syntax can be used to modify fields, regardless of the field being a primitive type or some other struct.\n\nlet foo = Foo { x: 3, y: true };\nfoo.x = 42;     // foo = Foo { x: 42, y: true }\nfoo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }\nbar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }\nbar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }\n\n\nThe dot syntax also works via a reference to a struct:\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &mut foo;\nfoo_ref.x = foo_ref.x + 1;\n\nPrivileged Struct Operations\n\nMost struct operations on a struct type T can only be performed inside the module that declares T:\n\nStruct types can only be created (\"packed\"), destroyed (\"unpacked\") inside the module that defines the struct.\nThe fields of a struct are only accessible inside the module that defines the struct.\n\nFollowing these rules, if you want to modify your struct outside the module, you will need to provide public APIs for them. The end of the chapter contains some examples of this.\n\nHowever, struct types are always visible to another module or script:\n\n// m.move\naddress 0x2 {\nmodule m {\n    struct Foo has drop { x: u64 }\n\n    public fun new_foo(): Foo {\n        Foo { x: 42 }\n    }\n}\n}\n\n// n.move\naddress 0x2 {\nmodule n {\n    use 0x2::m;\n\n    struct Wrapper has drop {\n        foo: m::Foo\n    }\n\n    fun f1(foo: m::Foo) {\n        let x = foo.x;\n        //      ^ error! cannot access fields of `foo` here\n    }\n\n    fun f2() {\n        let foo_wrapper = Wrapper { foo: m::new_foo() };\n    }\n}\n}\n\n\nNote that structs do not have visibility modifiers (e.g., public or private).\n\nOwnership\n\nAs mentioned above in Defining Structs, structs are by default linear and ephemeral. This means they cannot be copied or dropped. This property can be very useful when modeling real world resources like money, as you do not want money to be duplicated or get lost in circulation.\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64 }\n\n    public fun copying_resource() {\n        let foo = Foo { x: 100 };\n        let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability\n        let foo_ref = &foo;\n        let another_copy = *foo_ref // error! dereference requires the 'copy' ability\n    }\n\n    public fun destroying_resource1() {\n        let foo = Foo { x: 100 };\n\n        // error! when the function returns, foo still contains a value.\n        // This destruction requires the 'drop' ability\n    }\n\n    public fun destroying_resource2(f: &mut Foo) {\n        *f = Foo { x: 100 } // error!\n                            // destroying the old value via a write requires the 'drop' ability\n    }\n}\n}\n\n\nTo fix the second example (fun destroying_resource1), you would need to manually \"unpack\" the resource:\n\naddress 0x2 {\nmodule m {\n    struct Foo { x: u64 }\n\n    public fun destroying_resource1_fixed() {\n        let foo = Foo { x: 100 };\n        let Foo { x: _ } = foo;\n    }\n}\n}\n\n\nRecall that you are only able to deconstruct a resource within the module in which it is defined. This can be leveraged to enforce certain invariants in a system, for example, conservation of money.\n\nIf on the other hand, your struct does not represent something valuable, you can add the abilities copy and drop to get a struct value that might feel more familiar from other programming languages:\n\naddress 0x2 {\nmodule m {\n    struct Foo has copy, drop { x: u64 }\n\n    public fun run() {\n        let foo = Foo { x: 100 };\n        let foo_copy = copy foo;\n        // ^ this code copies foo, whereas `let x = foo` or\n        // `let x = move foo` both move foo\n\n        let x = foo.x;            // x = 100\n        let x_copy = foo_copy.x;  // x = 100\n\n        // both foo and foo_copy are implicitly discarded when the function returns\n    }\n}\n}\n\nStoring Resources in Global Storage\n\nOnly structs with the key ability can be saved directly in persistent global storage. All values stored within those key structs must have the store ability. See the ability and global storage chapters for more detail.\n\nExamples\n\nHere are two short examples of how you might use structs to represent valuable data (in the case of Coin) or more classical data (in the case of Point and Circle).\n\nExample 1: Coin\naddress 0x2 {\nmodule m {\n    // We do not want the Coin to be copied because that would be duplicating this \"money\",\n    // so we do not give the struct the 'copy' ability.\n    // Similarly, we do not want programmers to destroy coins, so we do not give the struct the\n    // 'drop' ability.\n    // However, we *want* users of the modules to be able to store this coin in persistent global\n    // storage, so we grant the struct the 'store' ability. This struct will only be inside of\n    // other resources inside of global storage, so we do not give the struct the 'key' ability.\n    struct Coin has store {\n        value: u64,\n    }\n\n    public fun mint(value: u64): Coin {\n        // You would want to gate this function with some form of access control to prevent\n        // anyone using this module from minting an infinite amount of coins.\n        Coin { value }\n    }\n\n    public fun withdraw(coin: &mut Coin, amount: u64): Coin {\n        assert!(coin.balance >= amount, 1000);\n        coin.value = coin.value - amount;\n        Coin { value: amount }\n    }\n\n    public fun deposit(coin: &mut Coin, other: Coin) {\n        let Coin { value } = other;\n        coin.value = coin.value + value;\n    }\n\n    public fun split(coin: Coin, amount: u64): (Coin, Coin) {\n        let other = withdraw(&mut coin, amount);\n        (coin, other)\n    }\n\n    public fun merge(coin1: Coin, coin2: Coin): Coin {\n        deposit(&mut coin1, coin2);\n        coin1\n    }\n\n    public fun destroy_zero(coin: Coin) {\n        let Coin { value } = coin;\n        assert!(value == 0, 1001);\n    }\n}\n}\n\nExample 2: Geometry\naddress 0x2 {\nmodule point {\n    struct Point has copy, drop, store {\n        x: u64,\n        y: u64,\n    }\n\n    public fun new(x: u64, y: u64): Point {\n        Point {\n            x, y\n        }\n    }\n\n    public fun x(p: &Point): u64 {\n        p.x\n    }\n\n    public fun y(p: &Point): u64 {\n        p.y\n    }\n\n    fun abs_sub(a: u64, b: u64): u64 {\n        if (a < b) {\n            b - a\n        }\n        else {\n            a - b\n        }\n    }\n\n    public fun dist_squared(p1: &Point, p2: &Point): u64 {\n        let dx = abs_sub(p1.x, p2.x);\n        let dy = abs_sub(p1.y, p2.y);\n        dx*dx + dy*dy\n    }\n}\n}\n\naddress 0x2 {\nmodule circle {\n    use 0x2::point::{Self, Point};\n\n    struct Circle has copy, drop, store {\n        center: Point,\n        radius: u64,\n    }\n\n    public fun new(center: Point, radius: u64): Circle {\n        Circle { center, radius }\n    }\n\n    public fun overlaps(c1: &Circle, c2: &Circle): bool {\n        let d = point::dist_squared(&c1.center, &c2.center);\n        let r1 = c1.radius;\n        let r2 = c2.radius;\n        d*d <= r1*r1 + 2*r1*r2 + r2*r2\n    }\n}\n}\n"
    },
    {
      "title": "Functions - The Move Book",
      "url": "https://move-language.github.io/move/functions.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nFunctions\n\nFunction syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.\n\nDeclaration\n\nFunctions are declared with the fun keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.\n\nfun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <acquires [identifier],*> <function_body>\n\n\nFor example\n\nfun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n\nVisibility\n\nModule functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.\n\naddress 0x42 {\nmodule m {\n    fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\n\nTo allow access from other modules or from scripts, the function must be declared public or public(friend).\n\npublic visibility\n\nA public function can be called by any function defined in any module or script. As shown in the following example, a public function can be called by:\n\nother functions defined in the same module,\nfunctions defined in another module, or\nthe function defined in a script.\naddress 0x42 {\nmodule m {\n    public fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n\npublic(friend) visibility\n\nThe public(friend) visibility modifier is a more restricted form of the public modifier to give more control about where a function can be used. A public(friend) function can be called by:\n\nother functions defined in the same module, or\nfunctions defined in modules which are explicitly specified in the friend list (see Friends on how to specify the friend list).\n\nNote that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a public(friend) function.\n\naddress 0x42 {\nmodule m {\n    friend 0x42::n;  // friend declaration\n    public(friend) fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid\n    }\n}\n\nmodule other {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'\n    }\n}\n\nentry modifier\n\nThe entry modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-entry function will be called from a Move program already in execution.\n\nEssentially, entry functions are the \"main\" functions of a module, and they specify where Move programs start executing.\n\nNote though, an entry function can still be called by other Move functions. So while they can serve as the start of a Move program, they aren't restricted to that case.\n\nFor example:\n\naddress 0x42 {\nmodule m {\n    public entry fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid!\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n\nmodule other {\n    public entry fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // valid!\n    }\n}\n\n\nEven internal functions can be marked as entry! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)\n\naddress 0x42 {\nmodule m {\n    entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public\n}\n\nmodule n {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\nmodule other {\n    public entry fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n}\n\nscript {\n    fun calls_m_foo(): u64 {\n        0x42::m::foo() // ERROR!\n//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'\n    }\n}\n\nName\n\nFunction names can start with letters a to z or letters A to Z. After the first character, function names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nfun FOO() {}\nfun bar_42() {}\nfun _bAZ19() {}\n    ^^^^^^ Invalid function name '_bAZ19'. Function names cannot start with '_'\n\nType Parameters\n\nAfter the name, functions can have type parameters\n\nfun id<T>(x: T): T { x }\nfun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }\n\n\nFor more details, see Move generics.\n\nParameters\n\nFunctions parameters are declared with a local variable name followed by a type annotation\n\nfun add(x: u64, y: u64): u64 { x + y }\n\n\nWe read this as x has type u64\n\nA function does not have to have any parameters at all.\n\nfun useless() { }\n\n\nThis is very common for functions that create new or empty data structures\n\naddress 0x42 {\nmodule example {\n  struct Counter { count: u64 }\n\n  fun new_counter(): Counter {\n      Counter { count: 0 }\n  }\n\n}\n}\n\nAcquires\n\nWhen a function accesses a resource using move_from, borrow_global, or borrow_global_mut, the function must indicate that it acquires that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.\n\naddress 0x42 {\nmodule example {\n\n    struct Balance has key { value: u64 }\n\n    public fun add_balance(s: &signer, value: u64) {\n        move_to(s, Balance { value })\n    }\n\n    public fun extract_balance(addr: address): u64 acquires Balance {\n        let Balance { value } = move_from(addr); // acquires needed\n        value\n    }\n}\n}\n\n\nacquires annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.\n\naddress 0x42 {\nmodule example {\n\n    struct Balance has key { value: u64 }\n\n    public fun add_balance(s: &signer, value: u64) {\n        move_to(s, Balance { value })\n    }\n\n    public fun extract_balance(addr: address): u64 acquires Balance {\n        let Balance { value } = move_from(addr); // acquires needed\n        value\n    }\n\n    public fun extract_and_add(sender: address, receiver: &signer) acquires Balance {\n        let value = extract_balance(sender); // acquires needed here\n        add_balance(receiver, value)\n    }\n}\n}\n\naddress 0x42 {\nmodule other {\n    fun extract_balance(addr: address): u64 {\n        0x42::example::extract_balance(addr) // no acquires needed\n    }\n}\n}\n\n\nA function can acquire as many resources as it needs to\n\naddress 0x42 {\nmodule example {\n    use std::vector;\n\n    struct Balance has key { value: u64 }\n    struct Box<T> has key { items: vector<T> }\n\n    public fun store_two<Item1: store, Item2: store>(\n        addr: address,\n        item1: Item1,\n        item2: Item2,\n    ) acquires Balance, Box {\n        let balance = borrow_global_mut<Balance>(addr); // acquires needed\n        balance.value = balance.value - 2;\n        let box1 = borrow_global_mut<Box<Item1>>(addr); // acquires needed\n        vector::push_back(&mut box1.items, item1);\n        let box2 = borrow_global_mut<Box<Item2>>(addr); // acquires needed\n        vector::push_back(&mut box2.items, item2);\n    }\n}\n}\n\nReturn type\n\nAfter the parameters, a function specifies its return type.\n\nfun zero(): u64 { 0 }\n\n\nHere : u64 indicates that the function's return type is u64.\n\nUsing tuples, a function can return multiple values:\n\nfun one_two_three(): (u64, u64, u64) { (0, 1, 2) }\n\n\nIf no return type is specified, the function has an implicit return type of unit (). These functions are equivalent:\n\nfun just_unit(): () { () }\nfun just_unit() { () }\nfun just_unit() { }\n\n\nscript functions must have a return type of unit ():\n\nscript {\n    fun do_nothing() {\n    }\n}\n\n\nAs mentioned in the tuples section, these tuple \"values\" are virtual and do not exist at runtime. So for a function that returns unit (), it will not be returning any value at all during execution.\n\nFunction body\n\nA function's body is an expression block. The return value of the function is the last value in the sequence\n\nfun example(): u64 {\n    let x = 0;\n    x = x + 1;\n    x // returns 'x'\n}\n\n\nSee the section below for more information on returns\n\nFor more information on expression blocks, see Move variables.\n\nNative Functions\n\nSome functions do not have a body specified, and instead have the body provided by the VM. These functions are marked native.\n\nWithout modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that native functions are used for either standard library code or for functionality needed for the given Move environment.\n\nMost native functions you will likely see are in standard library code such as vector\n\nmodule std::vector {\n    native public fun empty<Element>(): vector<Element>;\n    ...\n}\n\nCalling\n\nWhen calling a function, the name can be specified either through an alias or fully qualified\n\naddress 0x42 {\nmodule example {\n    public fun zero(): u64 { 0 }\n}\n}\n\nscript {\n    use 0x42::example::{Self, zero};\n    fun call_zero() {\n        // With the `use` above all of these calls are equivalent\n        0x42::example::zero();\n        example::zero();\n        zero();\n    }\n}\n\n\nWhen calling a function, an argument must be given for every parameter.\n\naddress 0x42 {\nmodule example {\n    public fun takes_none(): u64 { 0 }\n    public fun takes_one(x: u64): u64 { x }\n    public fun takes_two(x: u64, y: u64): u64 { x + y }\n    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }\n}\n}\n\nscript {\n    use 0x42::example;\n    fun call_all() {\n        example::takes_none();\n        example::takes_one(0);\n        example::takes_two(0, 1);\n        example::takes_three(0, 1, 2);\n    }\n}\n\n\nType arguments can be either specified or inferred. Both calls are equivalent.\n\naddress 0x42 {\nmodule example {\n    public fun id<T>(x: T): T { x }\n}\n}\n\nscript {\n    use 0x42::example;\n    fun call_all() {\n        example::id(0);\n        example::id<u64>(0);\n    }\n}\n\n\nFor more details, see Move generics.\n\nReturning values\n\nThe result of a function, its \"return value\", is the final value of its function body. For example\n\nfun add(x: u64, y: u64): u64 {\n    x + y\n}\n\n\nAs mentioned above, the function's body is an expression block. The expression block can sequence various statements, and the final expression in the block will be be the value of that block\n\nfun double_and_add(x: u64, y: u64): u64 {\n    let double_x = x * 2;\n    let double_y = y * 2;\n    double_x + double_y\n}\n\n\nThe return value here is double_x + double_y\n\nreturn expression\n\nA function implicitly returns the value that its body evaluates to. However, functions can also use the explicit return expression:\n\nfun f1(): u64 { return 0 }\nfun f2(): u64 { 0 }\n\n\nThese two functions are equivalent. In this slightly more involved example, the function subtracts two u64 values, but returns early with 0 if the second value is too large:\n\nfun safe_sub(x: u64, y: u64): u64 {\n    if (y > x) return 0;\n    x - y\n}\n\n\nNote that the body of this function could also have been written as if (y > x) 0 else x - y.\n\nHowever return really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:\n\nuse std::vector;\nuse std::option::{Self, Option};\nfun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        if (vector::borrow(v, i) == target) return option::some(i);\n        i = i + 1\n    };\n\n    option::none()\n}\n\n\nUsing return without an argument is shorthand for return (). That is, the following two functions are equivalent:\n\nfun foo() { return }\nfun foo() { return () }\n"
    },
    {
      "title": "While and Loop - The Move Book",
      "url": "https://move-language.github.io/move/loops.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nWhile and Loop\n\nMove offers two constructs for looping: while and loop.\n\nwhile loops\n\nThe while construct repeats the body (an expression of type unit) until the condition (an expression of type bool) evaluates to false.\n\nHere is an example of simple while loop that computes the sum of the numbers from 1 to n:\n\nfun sum(n: u64): u64 {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum = sum + i;\n        i = i + 1\n    };\n\n    sum\n}\n\n\nInfinite loops are allowed:\n\nfun foo() {\n    while (true) { }\n}\n\nbreak\n\nThe break expression can be used to exit a loop before the condition evaluates to false. For example, this loop uses break to find the smallest factor of n that's greater than 1:\n\nfun smallest_factor(n: u64): u64 {\n    // assuming the input is not 0 or 1\n    let i = 2;\n    while (i <= n) {\n        if (n % i == 0) break;\n        i = i + 1\n    };\n\n    i\n}\n\n\nThe break expression cannot be used outside of a loop.\n\ncontinue\n\nThe continue expression skips the rest of the loop and continues to the next iteration. This loop uses continue to compute the sum of 1, 2, ..., n, except when the number is divisible by 10:\n\nfun sum_intermediate(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        i = i + 1;\n        if (i % 10 == 0) continue;\n        sum = sum + i;\n    };\n\n    sum\n}\n\n\nThe continue expression cannot be used outside of a loop.\n\nThe type of break and continue\n\nbreak and continue, much like return and abort, can have any type. The following examples illustrate where this flexible typing can be helpful:\n\nfun pop_smallest_while_not_equal(\n    v1: vector<u64>,\n    v2: vector<u64>,\n): vector<u64> {\n    let result = vector::empty();\n    while (!vector::is_empty(&v1) && !vector::is_empty(&v2)) {\n        let u1 = *vector::borrow(&v1, vector::length(&v1) - 1);\n        let u2 = *vector::borrow(&v2, vector::length(&v2) - 1);\n        let popped =\n            if (u1 < u2) vector::pop_back(&mut v1)\n            else if (u2 < u1) vector::pop_back(&mut v2)\n            else break; // Here, `break` has type `u64`\n        vector::push_back(&mut result, popped);\n    };\n\n    result\n}\n\nfun pick(\n    indexes: vector<u64>,\n    v1: &vector<address>,\n    v2: &vector<address>\n): vector<address> {\n    let len1 = vector::length(v1);\n    let len2 = vector::length(v2);\n    let result = vector::empty();\n    while (!vector::is_empty(&indexes)) {\n        let index = vector::pop_back(&mut indexes);\n        let chosen_vector =\n            if (index < len1) v1\n            else if (index < len2) v2\n            else continue; // Here, `continue` has type `&vector<address>`\n        vector::push_back(&mut result, *vector::borrow(chosen_vector, index))\n    };\n\n    result\n}\n\nThe loop expression\n\nThe loop expression repeats the loop body (an expression with type ()) until it hits a break\n\nWithout a break, the loop will continue forever\n\nfun foo() {\n    let i = 0;\n    loop { i = i + 1 }\n}\n\n\nHere is an example that uses loop to write the sum function:\n\nfun sum(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    loop {\n        i = i + 1;\n        if (i > n) break;\n        sum = sum + i\n    };\n\n    sum\n}\n\n\nAs you might expect, continue can also be used inside a loop. Here is sum_intermediate from above rewritten using loop instead of while\n\nfun sum_intermediate(n: u64): u64 {\n    let sum = 0;\n    let i = 0;\n    loop {\n        i = i + 1;\n        if (i % 10 == 0) continue;\n        if (i > n) break;\n        sum = sum + i\n    };\n\n    sum\n}\n\nThe type of while and loop\n\nMove loops are typed expressions. A while expression always has type ().\n\nlet () = while (i < 10) { i = i + 1 };\n\n\nIf a loop contains a break, the expression has type unit ()\n\n(loop { if (i < 10) i = i + 1 else break }: ());\nlet () = loop { if (i < 10) i = i + 1 else break };\n\n\nIf loop does not have a break, loop can have any type much like return, abort, break, and continue.\n\n(loop (): u64);\n(loop (): address);\n(loop (): &vector<vector<u8>>);\n"
    },
    {
      "title": "Conditionals - The Move Book",
      "url": "https://move-language.github.io/move/conditionals.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nConditionals\n\nAn if expression specifies that some code should only be evaluated if a certain condition is true. For example:\n\nif (x > 5) x = x - 5\n\n\nThe condition must be an expression of type bool.\n\nAn if expression can optionally include an else clause to specify another expression to evaluate when the condition is false.\n\nif (y <= 10) y = y + 1 else y = 10\n\n\nEither the \"true\" branch or the \"false\" branch will be evaluated, but not both. Either branch can be a single expression or an expression block.\n\nThe conditional expressions may produce values so that the if expression has a result.\n\nlet z = if (x < 100) x else 100;\n\n\nThe expressions in the true and false branches must have compatible types. For example:\n\n// x and y must be u64 integers\nlet maximum: u64 = if (x > y) x else y;\n\n// ERROR! branches different types\nlet z = if (maximum < 10) 10u8 else 100u64;\n\n// ERROR! branches different types, as default false-branch is () not u64\nif (maximum >= 10) maximum;\n\n\nIf the else clause is not specified, the false branch defaults to the unit value. The following are equivalent:\n\nif (condition) true_branch // implied default: else ()\nif (condition) true_branch else ()\n\n\nCommonly, if expressions are used in conjunction with expression blocks.\n\nlet maximum = if (x > y) x else y;\nif (maximum < 10) {\n    x = x + 10;\n    y = y + 10;\n} else if (x >= 10 && y >= 10) {\n    x = x - 10;\n    y = y - 10;\n}\n\nGrammar for Conditionals\n\nif-expression → if ( expression ) expression else-clauseopt else-clause → else expression"
    },
    {
      "title": "Abort and Assert - The Move Book",
      "url": "https://move-language.github.io/move/abort-and-assert.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nAbort and Assert\n\nreturn and abort are two control flow constructs that end execution, one for the current function and one for the entire transaction.\n\nMore information on return can be found in the linked section\n\nabort\n\nabort is an expression that takes one argument: an abort code of type u64. For example:\n\nabort 42\n\n\nThe abort expression halts execution the current function and reverts all changes made to global state by the current transaction. There is no mechanism for \"catching\" or otherwise handling an abort.\n\nLuckily, in Move transactions are all or nothing, meaning any changes to global storage are made all at once only if the transaction succeeds. Because of this transactional commitment of changes, after an abort there is no need to worry about backing out changes. While this approach is lacking in flexibility, it is incredibly simple and predictable.\n\nSimilar to return, abort is useful for exiting control flow when some condition cannot be met.\n\nIn this example, the function will pop two items off of the vector, but will abort early if the vector does not have two items\n\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    if (vector::length(v) < 2) abort 42;\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nThis is even more useful deep inside a control-flow construct. For example, this function checks that all numbers in the vector are less than the specified bound. And aborts otherwise\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        if (cur > bound) abort 42;\n        i = i + 1;\n    }\n}\n\nassert\n\nassert is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a condition of type bool and a code of type u64\n\nassert!(condition: bool, code: u64)\n\n\nSince the operation is a macro, it must be invoked with the !. This is to convey that the arguments to assert are call-by-expression. In other words, assert is not a normal function and does not exist at the bytecode level. It is replaced inside the compiler with\n\nif (condition) () else abort code\n\n\nassert is more commonly used than just abort by itself. The abort examples above can be rewritten using assert\n\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    assert!(vector::length(v) >= 2, 42); // Now uses 'assert'\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n\n\nand\n\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        let cur = *vector::borrow(v, i);\n        assert!(cur <= bound, 42); // Now uses 'assert'\n        i = i + 1;\n    }\n}\n\n\nNote that because the operation is replaced with this if-else, the argument for the code is not always evaluated. For example:\n\nassert!(true, 1 / 0)\n\n\nWill not result in an arithmetic error, it is equivalent to\n\nif (true) () else (1 / 0)\n\n\nSo the arithmetic expression is never evaluated!\n\nAbort codes in the Move VM\n\nWhen using abort, it is important to understand how the u64 code will be used by the VM.\n\nNormally, after successful execution, the Move VM produces a change-set for the changes made to global storage (added/removed resources, updates to existing resources, etc).\n\nIf an abort is reached, the VM will instead indicate an error. Included in that error will be two pieces of information:\n\nThe module that produced the abort (address and name)\nThe abort code.\n\nFor example\n\naddress 0x2 {\nmodule example {\n    public fun aborts() {\n        abort 42\n    }\n}\n}\n\nscript {\n    fun always_aborts() {\n        0x2::example::aborts()\n    }\n}\n\n\nIf a transaction, such as the script always_aborts above, calls 0x2::example::aborts, the VM would produce an error that indicated the module 0x2::example and the code 42.\n\nThis can be useful for having multiple aborts being grouped together inside a module.\n\nIn this example, the module has two separate error codes used in multiple functions\n\naddress 0x42 {\nmodule example {\n\n    use std::vector;\n\n    const EMPTY_VECTOR: u64 = 0;\n    const INDEX_OUT_OF_BOUNDS: u64 = 1;\n\n    // move i to j, move j to k, move k to i\n    public fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {\n        let n = vector::length(v);\n        assert!(n > 0, EMPTY_VECTOR);\n        assert!(i < n, INDEX_OUT_OF_BOUNDS);\n        assert!(j < n, INDEX_OUT_OF_BOUNDS);\n        assert!(k < n, INDEX_OUT_OF_BOUNDS);\n\n        vector::swap(v, i, k);\n        vector::swap(v, j, k);\n    }\n\n    public fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {\n        let n = vector::length(v);\n        assert!(n > 0, EMPTY_VECTOR);\n        assert!(i < n, INDEX_OUT_OF_BOUNDS);\n        assert!(j < n, INDEX_OUT_OF_BOUNDS);\n        assert!(i > j, INDEX_OUT_OF_BOUNDS);\n\n        (vector::remove<T>(v, i), vector::remove<T>(v, j))\n    }\n}\n}\n\nThe type of abort\n\nThe abort i expression can have any type! This is because both constructs break from the normal control flow, so they never need to evaluate to the value of that type.\n\nThe following are not useful, but they will type check\n\nlet y: address = abort 0;\n\n\nThis behavior can be helpful in situations where you have a branching instruction that produces a value on some branches, but not all. For example:\n\nlet b =\n    if (x == 0) false\n    else if (x == 1) true\n    else abort 42;\n//       ^^^^^^^^ `abort 42` has type `bool`\n"
    },
    {
      "title": "Equality - The Move Book",
      "url": "https://move-language.github.io/move/equality.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nEquality\n\nMove supports two equality operations == and !=\n\nOperations\nSyntax\tOperation\tDescription\n==\tequal\tReturns true if the two operands have the same value, false otherwise\n!=\tnot equal\tReturns true if the two operands have different values, false otherwise\nTyping\n\nBoth the equal (==) and not-equal (!=) operations only work if both operands are the same type\n\n0 == 0; // `true`\n1u128 == 2u128; // `false`\nb\"hello\" != x\"00\"; // `true`\n\n\nEquality and non-equality also work over user defined types!\n\naddress 0x42 {\nmodule example {\n    struct S has copy, drop { f: u64, s: vector<u8> }\n\n    fun always_true(): bool {\n        let s = S { f: 0, s: b\"\" };\n        // parens are not needed but added for clarity in this example\n        (copy s) == s\n    }\n\n    fun always_false(): bool {\n        let s = S { f: 0, s: b\"\" };\n        // parens are not needed but added for clarity in this example\n        (copy s) != s\n    }\n}\n}\n\n\nIf the operands have different types, there is a type checking error\n\n1u8 == 1u128; // ERROR!\n//     ^^^^^ expected an argument of type 'u8'\nb\"\" != 0; // ERROR!\n//     ^ expected an argument of type 'vector<u8>'\n\nTyping with references\n\nWhen comparing references, the type of the reference (immutable or mutable) does not matter. This means that you can compare an immutable & reference with a mutable one &mut of the same underlying type.\n\nlet i = &0;\nlet m = &mut 1;\n\ni == m; // `false`\nm == i; // `false`\nm == m; // `true`\ni == i; // `true`\n\n\nThe above is equivalent to applying an explicit freeze to each mutable reference where needed\n\nlet i = &0;\nlet m = &mut 1;\n\ni == freeze(m); // `false`\nfreeze(m) == i; // `false`\nm == m; // `true`\ni == i; // `true`\n\n\nBut again, the underlying type must be the same type\n\nlet i = &0;\nlet s = &b\"\";\n\ni == s; // ERROR!\n//   ^ expected an argument of type '&u64'\n\nRestrictions\n\nBoth == and != consume the value when comparing them. As a result, the type system enforces that the type must have drop. Recall that without the drop ability, ownership must be transferred by the end of the function, and such values can only be explicitly destroyed within their declaring module. If these were used directly with either equality == or non-equality !=, the value would be destroyed which would break drop ability safety guarantees!\n\naddress 0x42 {\nmodule example {\n    struct Coin has store { value: u64 }\n    fun invalid(c1: Coin, c2: Coin) {\n        c1 == c2 // ERROR!\n//      ^^    ^^ These resources would be destroyed!\n    }\n}\n}\n\n\nBut, a programmer can always borrow the value first instead of directly comparing the value, and reference types have the drop ability. For example\n\naddress 0x42 {\nmodule example {\n    struct Coin as store { value: u64 }\n    fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {\n        let are_equal = &c1 == &c2; // valid\n        if (are_equal) (c2, c1) else (c1, c2)\n    }\n}\n}\n\nAvoid Extra Copies\n\nWhile a programmer can compare any value whose type has drop, a programmer should often compare by reference to avoid expensive copies.\n\nlet v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(copy v1 == copy v2, 42);\n//     ^^^^       ^^^^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(copy s1 == copy s2, 42);\n//     ^^^^       ^^^^\nuse_two_foos(s1, s2);\n\n\nThis code is perfectly acceptable (assuming Foo has drop), just not efficient. The highlighted copies can be removed and replaced with borrows\n\nlet v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(&v1 == &v2, 42);\n//     ^      ^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(&s1 == &s2, 42);\n//     ^      ^\nuse_two_foos(s1, s2);\n\n\nThe efficiency of the == itself remains the same, but the copys are removed and thus the program is more efficient."
    },
    {
      "title": "Local Variables and Scopes - The Move Book",
      "url": "https://move-language.github.io/move/variables.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nLocal Variables and Scope\n\nLocal variables in Move are lexically (statically) scoped. New variables are introduced with the keyword let, which will shadow any previous local with the same name. Locals are mutable and can be updated both directly and via a mutable reference.\n\nDeclaring Local Variables\nlet bindings\n\nMove programs use let to bind variable names to values:\n\nlet x = 1;\nlet y = x + x:\n\n\nlet can also be used without binding a value to the local.\n\nlet x;\n\n\nThe local can then be assigned a value later.\n\nlet x;\nif (cond) {\n  x = 1\n} else {\n  x = 0\n}\n\n\nThis can be very helpful when trying to extract a value from a loop when a default value cannot be provided.\n\nlet x;\nlet cond = true;\nlet i = 0;\nloop {\n    (x, cond) = foo(i);\n    if (!cond) break;\n    i = i + 1;\n}\n\nVariables must be assigned before use\n\nMove's type system prevents a local variable from being used before it has been assigned.\n\nlet x;\nx + x // ERROR!\n\nlet x;\nif (cond) x = 0;\nx + x // ERROR!\n\nlet x;\nwhile (cond) x = 0;\nx + x // ERROR!\n\nValid variable names\n\nVariable names can contain underscores _, letters a to z, letters A to Z, and digits 0 to 9. Variable names must start with either an underscore _ or a letter a through z. They cannot start with uppercase letters.\n\n// all valid\nlet x = e;\nlet _x = e;\nlet _A = e;\nlet x0 = e;\nlet xA = e;\nlet foobar_123 = e;\n\n// all invalid\nlet X = e; // ERROR!\nlet Foo = e; // ERROR!\n\nType annotations\n\nThe type of a local variable can almost always be inferred by Move's type system. However, Move allows explicit type annotations that can be useful for readability, clarity, or debuggability. The syntax for adding a type annotation is:\n\nlet x: T = e; // \"Variable x of type T is initialized to expression e\"\n\n\nSome examples of explicit type annotations:\n\naddress 0x42 {\nmodule example {\n\n    struct S { f: u64, g: u64 }\n\n    fun annotated() {\n        let u: u8 = 0;\n        let b: vector<u8> = b\"hello\";\n        let a: address = @0x0;\n        let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n        let S { f, g: f2 }: S = S { f: 0, g: 1 };\n    }\n}\n}\n\n\nNote that the type annotations must always be to the right of the pattern:\n\nlet (x: &u64, y: &mut u64) = (&0, &mut 1); // ERROR! should be let (x, y): ... =\n\nWhen annotations are necessary\n\nIn some cases, a local type annotation is required if the type system cannot infer the type. This commonly occurs when the type argument for a generic type cannot be inferred. For example:\n\nlet _v1 = vector::empty(); // ERROR!\n//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\nlet v2: vector<u64> = vector::empty(); // no error\n\n\nIn a rarer case, the type system might not be able to infer a type for divergent code (where all the following code is unreachable). Both return and abort are expressions and can have any type. A loop has type () if it has a break, but if there is no break out of the loop, it could have any type. If these types cannot be inferred, a type annotation is required. For example, this code:\n\nlet a: u8 = return ();\nlet b: bool = abort 0;\nlet c: signer = loop ();\n\nlet x = return (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet y = abort 0; // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet z = loop (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\n\n\nAdding type annotations to this code will expose other errors about dead code or unused local variables, but the example is still helpful for understanding this problem.\n\nMultiple declarations with tuples\n\nlet can introduce more than one local at a time using tuples. The locals declared inside the parenthesis are initialized to the corresponding values from the tuple.\n\nlet () = ();\nlet (x0, x1) = (0, 1);\nlet (y0, y1, y2) = (0, 1, 2);\nlet (z0, z1, z2, z3) = (0, 1, 2, 3);\n\n\nThe type of the expression must match the arity of the tuple pattern exactly.\n\nlet (x, y) = (0, 1, 2); // ERROR!\nlet (x, y, z, q) = (0, 1, 2); // ERROR!\n\n\nYou cannot declare more than one local with the same name in a single let.\n\nlet (x, x) = 0; // ERROR!\n\nMultiple declarations with structs\n\nlet can also introduce more than one local at a time when destructuring (or matching against) a struct. In this form, the let creates a set of local variables that are initialized to the values of the fields from a struct. The syntax looks like this:\n\nstruct T { f1: u64, f2: u64 }\n\nlet T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n\n\nHere is a more complicated example:\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };\n        assert!(f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };\n        assert!(f1 + f2 == 2, 42);\n    }\n}\n}\n\n\nFields of structs can serve double duty, identifying the field to bind and the name of the variable. This is sometimes referred to as punning.\n\nlet X { f } = e;\n\n\nis equivalent to:\n\nlet X { f: f } = e;\n\n\nAs shown with tuples, you cannot declare more than one local with the same name in a single let.\n\nlet Y { x1: x, x2: x } = e; // ERROR!\n\nDestructuring against references\n\nIn the examples above for structs, the bound value in the let was moved, destroying the struct value and binding its fields.\n\nstruct T { f1: u64, f2: u64 }\n\nlet T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n\n\nIn this scenario the struct value T { f1: 1, f2: 2 } no longer exists after the let.\n\nIf you wish instead to not move and destroy the struct value, you can borrow each of its fields. For example:\n\nlet t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &t;\n// local1: &u64\n// local2: &u64\n\n\nAnd similarly with mutable references:\n\nlet t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &mut t;\n// local1: &mut u64\n// local2: &mut u64\n\n\nThis behavior can also work with nested structs.\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let y = Y { x1: new_x(), x2: new_x() };\n\n        let Y { x1: X { f }, x2 } = &y;\n        assert!(*f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;\n        *f1 = *f1 + 1;\n        *f2 = *f2 + 1;\n        assert!(*f1 + *f2 == 4, 42);\n    }\n}\n}\n\nIgnoring Values\n\nIn let bindings, it is often helpful to ignore some values. Local variables that start with _ will be ignored and not introduce a new variable\n\nfun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}\n\nlet (x1, _, z1) = three();\nlet (x2, _y, z2) = three();\nassert!(x1 + z1 == x2 + z2, 42);\n\n\nThis can be necessary at times as the compiler will error on unused local variables\n\nlet (x1, y, z1) = three(); // ERROR!\n//       ^ unused local 'y'\n\nGeneral let grammar\n\nAll of the different structures in let can be combined! With that we arrive at this general grammar for let statements:\n\nlet-binding → let pattern-or-list type-annotationopt initializeropt > pattern-or-list → pattern | ( pattern-list ) > pattern-list → pattern ,opt | pattern , pattern-list > type-annotation → : type initializer → = expression\n\nThe general term for the item that introduces the bindings is a pattern. The pattern serves to both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as follows:\n\npattern → local-variable | struct-type { field-binding-list } > field-binding-list → field-binding ,opt | field-binding , field-binding-list > field-binding → field | field : pattern\n\nA few concrete examples with this grammar applied:\n\n    let (x, y): (u64, u64) = (0, 1);\n//       ^                           local-variable\n//       ^                           pattern\n//          ^                        local-variable\n//          ^                        pattern\n//          ^                        pattern-list\n//       ^^^^                        pattern-list\n//      ^^^^^^                       pattern-or-list\n//            ^^^^^^^^^^^^           type-annotation\n//                         ^^^^^^^^  initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\n    let Foo { f, g: x } = Foo { f: 0, g: 1 };\n//      ^^^                                    struct-type\n//            ^                                field\n//            ^                                field-binding\n//               ^                             field\n//                  ^                          local-variable\n//                  ^                          pattern\n//               ^^^^                          field-binding\n//            ^^^^^^^                          field-binding-list\n//      ^^^^^^^^^^^^^^^                        pattern\n//      ^^^^^^^^^^^^^^^                        pattern-or-list\n//                      ^^^^^^^^^^^^^^^^^^^^   initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\nMutations\nAssignments\n\nAfter the local is introduced (either by let or as a function parameter), the local can be modified via an assignment:\n\nx = e\n\n\nUnlike let bindings, assignments are expressions. In some languages, assignments return the value that was assigned, but in Move, the type of any assignment is always ().\n\n(x = e: ())\n\n\nPractically, assignments being expressions means that they can be used without adding a new expression block with braces ({...}).\n\nlet x = 0;\nif (cond) x = 1 else x = 2;\n\n\nThe assignment uses the same pattern syntax scheme as let bindings:\n\naddress 0x42 {\nmodule example {\n    struct X { f: u64 }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    // This example will complain about unused variables and assignments.\n    fun example() {\n       let (x, _, z) = (0, 1, 3);\n       let (x, y, f, g);\n\n       (X { f }, X { f: x }) = (new_x(), new_x());\n       assert!(f + x == 2, 42);\n\n       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);\n    }\n}\n}\n\n\nNote that a local variable can only have one type, so the type of the local cannot change between assignments.\n\nlet x;\nx = 0;\nx = false; // ERROR!\n\nMutating through a reference\n\nIn addition to directly modifying a local with assignment, a local can be modified via a mutable reference &mut.\n\nlet x = 0;\nlet r = &mut x;\n*r = 1;\nassert!(x == 1, 42);\n\n\nThis is particularly useful if either:\n\n(1) You want to modify different variables depending on some condition.\n\nlet x = 0;\nlet y = 1;\nlet r = if (cond) &mut x else &mut y;\n*r = *r + 1;\n\n\n(2) You want another function to modify your local value.\n\nlet x = 0;\nmodify_ref(&mut x);\n\n\nThis sort of modification is how you modify structs and vectors!\n\nlet v = vector::empty();\nvector::push_back(&mut v, 100);\nassert!(*vector::borrow(&v, 0) == 100, 42);\n\n\nFor more details, see Move references.\n\nScopes\n\nAny local declared with let is available for any subsequent expression, within that scope. Scopes are declared with expression blocks, {...}.\n\nLocals cannot be used outside of the declared scope.\n\nlet x = 0;\n{\n    let y = 1;\n};\nx + y // ERROR!\n//  ^ unbound local 'y'\n\n\nBut, locals from an outer scope can be used in a nested scope.\n\n{\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}\n\n\nLocals can be mutated in any scope where they are accessible. That mutation survives with the local, regardless of the scope that performed the mutation.\n\nlet x = 0;\nx = x + 1;\nassert!(x == 1, 42);\n{\n    x = x + 1;\n    assert!(x == 2, 42);\n};\nassert!(x == 2, 42);\n\nExpression Blocks\n\nAn expression block is a series of statements separated by semicolons (;). The resulting value of an expression block is the value of the last expression in the block.\n\n{ let x = 1; let y = 1; x + y }\n\n\nIn this example, the result of the block is x + y.\n\nA statement can be either a let declaration or an expression. Remember that assignments (x = e) are expressions of type ().\n\n{ let x; let y = 1; x = 1; x + y }\n\n\nFunction calls are another common expression of type (). Function calls that modify data are commonly used as statements.\n\n{ let v = vector::empty(); vector::push_back(&mut v, 1); v }\n\n\nThis is not just limited to () types---any expression can be used as a statement in a sequence!\n\n{\n    let x = 0;\n    x + 1; // value is discarded\n    x + 2; // value is discarded\n    b\"hello\"; // value is discarded\n}\n\n\nBut! If the expression contains a resource (a value without the drop ability), you will get an error. This is because Move's type system guarantees that any value that is dropped has the drop ability. (Ownership must be transferred or the value must be explicitly destroyed within its declaring module.)\n\n{\n    let x = 0;\n    Coin { value: x }; // ERROR!\n//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability\n    x\n}\n\n\nIf a final expression is not present in a block---that is, if there is a trailing semicolon ;, there is an implicit unit () value. Similarly, if the expression block is empty, there is an implicit unit () value.\n\n// Both are equivalent\n{ x = x + 1; 1 / x; }\n{ x = x + 1; 1 / x; () }\n\n// Both are equivalent\n{ }\n{ () }\n\n\nAn expression block is itself an expression and can be used anyplace an expression is used. (Note: The body of a function is also an expression block, but the function body cannot be replaced by another expression.)\n\nlet my_vector: vector<vector<u8>> = {\n    let v = vector::empty();\n    vector::push_back(&mut v, b\"hello\");\n    vector::push_back(&mut v, b\"goodbye\");\n    v\n};\n\n\n(The type annotation is not needed in this example and only added for clarity.)\n\nShadowing\n\nIf a let introduces a local variable with a name already in scope, that previous variable can no longer be accessed for the rest of this scope. This is called shadowing.\n\nlet x = 0;\nassert!(x == 0, 42);\n\nlet x = 1; // x is shadowed\nassert!(x == 1, 42);\n\n\nWhen a local is shadowed, it does not need to retain the same type as before.\n\nlet x = 0;\nassert!(x == 0, 42);\n\nlet x = b\"hello\"; // x is shadowed\nassert!(x == b\"hello\", 42);\n\n\nAfter a local is shadowed, the value stored in the local still exists, but will no longer be accessible. This is important to keep in mind with values of types without the drop ability, as ownership of the value must be transferred by the end of the function.\n\naddress 0x42 {\n    module example {\n        struct Coin has store { value: u64 }\n\n        fun unused_resource(): Coin {\n            let x = Coin { value: 0 }; // ERROR!\n//              ^ This local still contains a value without the `drop` ability\n            x.value = 1;\n            let x = Coin { value: 10 };\n            x\n//          ^ Invalid return\n        }\n    }\n}\n\n\nWhen a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is gone once that scope ends.\n\nlet x = 0;\n{\n    let x = 1;\n    assert!(x == 1, 42);\n};\nassert!(x == 0, 42);\n\n\nRemember, locals can change type when they are shadowed.\n\nlet x = 0;\n{\n    let x = b\"hello\";\n    assert!(x = b\"hello\", 42);\n};\nassert!(x == 0, 42);\n\nMove and Copy\n\nAll local variables in Move can be used in two ways, either by move or copy. If one or the other is not specified, the Move compiler is able to infer whether a copy or a move should be used. This means that in all of the examples above, a move or a copy would be inserted by the compiler. A local variable cannot be used without the use of move or copy.\n\ncopy will likely feel the most familiar coming from other programming languages, as it creates a new copy of the value inside of the variable to use in that expression. With copy, the local variable can be used more than once.\n\nlet x = 0;\nlet y = copy x + 1;\nlet z = copy x + 2;\n\n\nAny value with the copy ability can be copied in this way.\n\nmove takes the value out of the local variable without copying the data. After a move occurs, the local variable is unavailable.\n\nlet x = 1;\nlet y = move x + 1;\n//      ------ Local was moved here\nlet z = move x + 2; // Error!\n//      ^^^^^^ Invalid usage of local 'x'\ny + z\n\nSafety\n\nMove's type system will prevent a value from being used after it is moved. This is the same safety check described in let declaration that prevents local variables from being used before it is assigned a value.\n\nInference\n\nAs mentioned above, the Move compiler will infer a copy or move if one is not indicated. The algorithm for doing so is quite simple:\n\nAny scalar value with the copy ability is given a copy.\nAny reference (both mutable &mut and immutable &) is given a copy.\nExcept under special circumstances where it is made a move for predictable borrow checker errors.\nAny other value is given a move.\nThis means that even though other values might be have the copy ability, it must be done explicitly by the programmer.\nThis is to prevent accidental copies of large data structures.\n\nFor example:\n\nlet s = b\"hello\";\nlet foo = Foo { f: 0 };\nlet coin = Coin { value: 0 };\n\nlet s2 = s; // move\nlet foo2 = foo; // move\nlet coin2 = coin; // move\n\nlet x = 0;\nlet b = false;\nlet addr = @0x42;\nlet x_ref = &x;\nlet coin_ref = &mut coin2;\n\nlet x2 = x; // copy\nlet b2 = b; // copy\nlet addr2 = @0x42; // copy\nlet x_ref2 = x_ref; // copy\nlet coin_ref2 = coin_ref; // copy\n"
    },
    {
      "title": "Tuples and Unit - The Move Book",
      "url": "https://move-language.github.io/move/tuples.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nTuples and Unit\n\nMove does not fully support tuples as one might expect coming from another language with them as a first-class value. However, in order to support multiple return values, Move has tuple-like expressions. These expressions do not result in a concrete value at runtime (there are no tuples in the bytecode), and as a result they are very limited: they can only appear in expressions (usually in the return position for a function); they cannot be bound to local variables; they cannot be stored in structs; and tuple types cannot be used to instantiate generics.\n\nSimilarly, unit () is a type created by the Move source language in order to be expression based. The unit value () does not result in any runtime value. We can consider unit() to be an empty tuple, and any restrictions that apply to tuples also apply to unit.\n\nIt might feel weird to have tuples in the language at all given these restrictions. But one of the most common use cases for tuples in other languages is for functions to allow functions to return multiple values. Some languages work around this by forcing the users to write structs that contain the multiple return values. However in Move, you cannot put references inside of structs. This required Move to support multiple return values. These multiple return values are all pushed on the stack at the bytecode level. At the source level, these multiple return values are represented using tuples.\n\nLiterals\n\nTuples are created by a comma separated list of expressions inside of parentheses.\n\nSyntax\tType\tDescription\n()\t(): ()\tUnit, the empty tuple, or the tuple of arity 0\n(e1, ..., en)\t(e1, ..., en): (T1, ..., Tn) where e_i: Ti s.t. 0 < i <= n and n > 0\tA n-tuple, a tuple of arity n, a tuple with n elements\n\nNote that (e) does not have type (e): (t), in other words there is no tuple with one element. If there is only a single element inside of the parentheses, the parentheses are only used for disambiguation and do not carry any other special meaning.\n\nSometimes, tuples with two elements are called \"pairs\" and tuples with three elements are called \"triples.\"\n\nExamples\naddress 0x42 {\nmodule example {\n    // all 3 of these functions are equivalent\n\n    // when no return type is provided, it is assumed to be `()`\n    fun returns_unit_1() { }\n\n    // there is an implicit () value in empty expression blocks\n    fun returns_unit_2(): () { }\n\n    // explicit version of `returns_unit_1` and `returns_unit_2`\n    fun returns_unit_3(): () { () }\n\n\n    fun returns_3_values(): (u64, bool, address) {\n        (0, false, @0x42)\n    }\n    fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n        (x, 0, 1, b\"foobar\")\n    }\n}\n}\n\nOperations\n\nThe only operation that can be done on tuples currently is destructuring.\n\nDestructuring\n\nFor tuples of any size, they can be destructured in either a let binding or in an assignment.\n\nFor example:\n\naddress 0x42 {\nmodule example {\n    // all 3 of these functions are equivalent\n    fun returns_unit() {}\n    fun returns_2_values(): (bool, bool) { (true, false) }\n    fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b\"foobar\") }\n\n    fun examples(cond: bool) {\n        let () = ();\n        let (x, y): (u8, u64) = (0, 1);\n        let (a, b, c, d) = (@0x0, 0, false, b\"\");\n\n        () = ();\n        (x, y) = if (cond) (1, 2) else (3, 4);\n        (a, b, c, d) = (@0x1, 1, true, b\"1\");\n    }\n\n    fun examples_with_function_calls() {\n        let () = returns_unit();\n        let (x, y): (bool, bool) = returns_2_values();\n        let (a, b, c, d) = returns_4_values(&0);\n\n        () = returns_unit();\n        (x, y) = returns_2_values();\n        (a, b, c, d) = returns_4_values(&1);\n    }\n}\n}\n\n\nFor more details, see Move Variables.\n\nSubtyping\n\nAlong with references, tuples are the only types that have subtyping in Move. Tuples do have subtyping only in the sense that subtype with references (in a covariant way).\n\nFor example:\n\nlet x: &u64 = &0;\nlet y: &mut u64 = &mut 1;\n\n// (&u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (a, b): (&u64, &u64) = (x, y);\n\n// (&mut u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (c, d): (&u64, &u64) = (y, y);\n\n// error! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)\n// since &u64 is NOT a subtype of &mut u64\nlet (e, f): (&mut u64, &mut u64) = (x, y);\n\nOwnership\n\nAs mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored into local variables because of this (but it is likely that this feature will come soon). As such, tuples can only be moved currently, as copying them would require putting them into a local variable first."
    },
    {
      "title": "References - The Move Book",
      "url": "https://move-language.github.io/move/references.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nReferences\n\nMove has two types of references: immutable & and mutable &mut. Immutable references are read only, and cannot modify the underlying value (or any of its fields). Mutable references allow for modifications via a write through that reference. Move's type system enforces an ownership discipline that prevents reference errors.\n\nFor more details on the rules of references, see Structs and Resources\n\nReference Operators\n\nMove provides operators for creating and extending references as well as converting a mutable reference to an immutable one. Here and elsewhere, we use the notation e: T for \"expression e has type T\".\n\nSyntax\tType\tDescription\n&e\t&T where e: T and T is a non-reference type\tCreate an immutable reference to e\n&mut e\t&mut T where e: T and T is a non-reference type\tCreate a mutable reference to e.\n&e.f\t&T where e.f: T\tCreate an immutable reference to field f of struct e.\n&mut e.f\t&mut T where e.f: T\tCreate a mutable reference to field f of structe.\nfreeze(e)\t&T where e: &mut T\tConvert the mutable reference e into an immutable reference.\n\nThe &e.f and &mut e.f operators can be used both to create a new reference into a struct or to extend an existing reference:\n\nlet s = S { f: 10 };\nlet f_ref1: &u64 = &s.f; // works\nlet s_ref: &S = &s;\nlet f_ref2: &u64 = &s_ref.f // also works\n\n\nA reference expression with multiple fields works as long as both structs are in the same module:\n\nstruct A { b: B }\nstruct B { c : u64 }\nfun f(a: &A): &u64 {\n  &a.b.c\n}\n\n\nFinally, note that references to references are not allowed:\n\nlet x = 7;\nlet y: &u64 = &x;\nlet z: &&u64 = &y; // will not compile\n\nReading and Writing Through References\n\nBoth mutable and immutable references can be read to produce a copy of the referenced value.\n\nOnly mutable references can be written. A write *x = v discards the value previously stored in x and updates it with v.\n\nBoth operations use the C-like * syntax. However, note that a read is an expression, whereas a write is a mutation that must occur on the left hand side of an equals.\n\nSyntax\tType\tDescription\n*e\tT where e is &T or &mut T\tRead the value pointed to by e\n*e1 = e2\t() where e1: &mut T and e2: T\tUpdate the value in e1 with e2.\n\nIn order for a reference to be read, the underlying type must have the copy ability as reading the reference creates a new copy of the value. This rule prevents the copying of resource values:\n\nfun copy_resource_via_ref_bad(c: Coin) {\n    let c_ref = &c;\n    let counterfeit: Coin = *c_ref; // not allowed!\n    pay(c);\n    pay(counterfeit);\n}\n\n\nDually: in order for a reference to be written to, the underlying type must have the drop ability as writing to the reference will discard (or \"drop\") the old value. This rule prevents the destruction of resource values:\n\nfun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {\n    let ref = &mut ten_coins;\n    *ref = c; // not allowed--would destroy 10 coins!\n}\n\nfreeze inference\n\nA mutable reference can be used in a context where an immutable reference is expected:\n\nlet x = 7;\nlet y: &u64 = &mut x;\n\n\nThis works because the under the hood, the compiler inserts freeze instructions where they are needed. Here are a few more examples of freeze inference in action:\n\nfun takes_immut_returns_immut(x: &u64): &u64 { x }\n\n// freeze inference on return value\nfun takes_mut_returns_immut(x: &mut u64): &u64 { x }\n\nfun expression_examples() {\n    let x = 0;\n    let y = 0;\n    takes_immut_returns_immut(&x); // no inference\n    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)\n    takes_mut_returns_immut(&mut x); // no inference\n\n    assert!(&x == &mut y, 42); // inferred freeze(&mut y)\n}\n\nfun assignment_examples() {\n    let x = 0;\n    let y = 0;\n    let imm_ref: &u64 = &x;\n\n    imm_ref = &x; // no inference\n    imm_ref = &mut y; // inferred freeze(&mut y)\n}\n\nSubtyping\n\nWith this freeze inference, the Move type checker can view &mut T as a subtype of &T. As shown above, this means that anywhere for any expression where a &T value is used, a &mut T value can also be used. This terminology is used in error messages to concisely indicate that a &mut T was needed where a &T was supplied. For example\n\naddress 0x42 {\nmodule example {\n    fun read_and_assign(store: &mut u64, new_value: &u64) {\n        *store = *new_value\n    }\n\n    fun subtype_examples() {\n        let x: &u64 = &0;\n        let y: &mut u64 = &mut 1;\n\n        x = &mut 1; // valid\n        y = &2; // invalid!\n\n        read_and_assign(y, x); // valid\n        read_and_assign(x, y); // invalid!\n    }\n}\n}\n\n\nwill yield the following error messages\n\nerror:\n\n    ┌── example.move:12:9 ───\n    │\n 12 │         y = &2; // invalid!\n    │         ^ Invalid assignment to local 'y'\n    ·\n 12 │         y = &2; // invalid!\n    │             -- The type: '&{integer}'\n    ·\n  9 │         let y: &mut u64 = &mut 1;\n    │                -------- Is not a subtype of: '&mut u64'\n    │\n\nerror:\n\n    ┌── example.move:15:9 ───\n    │\n 15 │         read_and_assign(x, y); // invalid!\n    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'\n    ·\n  8 │         let x: &u64 = &0;\n    │                ---- The type: '&u64'\n    ·\n  3 │     fun read_and_assign(store: &mut u64, new_value: &u64) {\n    │                                -------- Is not a subtype of: '&mut u64'\n    │\n\n\nThe only other types currently that has subtyping are tuples\n\nOwnership\n\nBoth mutable and immutable references can always be copied and extended even if there are existing copies or extensions of the same reference:\n\nfun reference_copies(s: &mut S) {\n  let s_copy1 = s; // ok\n  let s_extension = &mut s.f; // also ok\n  let s_copy2 = s; // still ok\n  ...\n}\n\n\nThis might be surprising for programmers familiar with Rust's ownership system, which would reject the code above. Move's type system is more permissive in its treatment of copies, but equally strict in ensuring unique ownership of mutable references before writes.\n\nReferences Cannot Be Stored\n\nReferences and tuples are the only types that cannot be stored as a field value of structs, which also means that they cannot exist in global storage. All references created during program execution will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is also true for values of types without the store ability, but note that references and tuples go a step further by never being allowed in structs in the first place.\n\nThis is another difference between Move and Rust, which allows references to be stored inside of structs.\n\nCurrently, Move cannot support this because references cannot be serialized, but every Move value must be serializable. This requirement comes from Move's persistent global storage, which needs to serialize values to persist them across program executions. Structs can be written to global storage, and thus they must be serializable.\n\nOne could imagine a fancier, more expressive, type system that would allow references to be stored in structs and ban those structs from existing in global storage. We could perhaps allow references inside of structs that do not have the store ability, but that would not completely solve the problem: Move has a fairly complex system for tracking static reference safety, and this aspect of the type system would also have to be extended to support storing references inside of structs. In short, Move's type system (particularly the aspects around reference safety) would have to expand to support stored references. But it is something we are keeping an eye on as the language evolves."
    },
    {
      "title": "Signer - The Move Book",
      "url": "https://move-language.github.io/move/signer.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nSigner\n\nsigner is a built-in Move resource type. A signer is a capability that allows the holder to act on behalf of a particular address. You can think of the native implementation as being:\n\nstruct signer has drop { a: address }\n\n\nA signer is somewhat similar to a Unix UID in that it represents a user authenticated by code outside of Move (e.g., by checking a cryptographic signature or password).\n\nComparison to address\n\nA Move program can create any address value without special permission using address literals:\n\nlet a1 = @0x1;\nlet a2 = @0x2;\n// ... and so on for every other possible address\n\n\nHowever, signer values are special because they cannot be created via literals or instructions--only by the Move VM. Before the VM runs a script with parameters of type signer, it will automatically create signer values and pass them into the script:\n\nscript {\n    use std::signer;\n    fun main(s: signer) {\n        assert!(signer::address_of(&s) == @0x42, 0);\n    }\n}\n\n\nThis script will abort with code 0 if the script is sent from any address other than 0x42.\n\nA transaction script can have an arbitrary number of signers as long as the signers are a prefix to any other arguments. In other words, all of the signer arguments must come first:\n\nscript {\n    use std::signer;\n    fun main(s1: signer, s2: signer, x: u64, y: u8) {\n        // ...\n    }\n}\n\n\nThis is useful for implementing multi-signer scripts that atomically act with the authority of multiple parties. For example, an extension of the script above could perform an atomic currency swap between s1 and s2.\n\nsigner Operators\n\nThe std::signer standard library module provides two utility functions over signer values:\n\nFunction\tDescription\nsigner::address_of(&signer): address\tReturn the address wrapped by this &signer.\nsigner::borrow_address(&signer): &address\tReturn a reference to the address wrapped by this &signer.\n\nIn addition, the move_to<T>(&signer, T) global storage operator requires a &signer argument to publish a resource T under signer.address's account. This ensures that only an authenticated user can elect to publish a resource under their address.\n\nOwnership\n\nUnlike simple scalar values, signer values are not copyable, meaning they cannot be copied (from any operation whether it be through an explicit copy instruction or through a dereference *."
    },
    {
      "title": "Vector - The Move Book",
      "url": "https://move-language.github.io/move/vector.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nVector\n\nvector<T> is the only primitive collection type provided by Move. A vector<T> is a homogenous collection of T's that can grow or shrink by pushing/popping values off the \"end\".\n\nA vector<T> can be instantiated with any type T. For example, vector<u64>, vector<address>, vector<0x42::MyModule::MyResource>, and vector<vector<u8>> are all valid vector types.\n\nLiterals\nGeneral vector Literals\n\nVectors of any type can be created with vector literals.\n\nSyntax\tType\tDescription\nvector[]\tvector[]: vector<T> where T is any single, non-reference type\tAn empty vector\nvector[e1, ..., en]\tvector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0\tA vector with n elements (of length n)\n\nIn these cases, the type of the vector is inferred, either from the element type or from the vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be specified explicitly:\n\nvector<T>[]: vector<T>\nvector<T>[e1, ..., en]: vector<T>\n\nExample Vector Literals\n(vector[]: vector<bool>);\n(vector[0u8, 1u8, 2u8]: vector<u8>);\n(vector<u128>[]: vector<u128>);\n(vector<address>[@0x42, @0x100]: vector<address>);\n\nvector<u8> literals\n\nA common use-case for vectors in Move is to represent \"byte arrays\", which are represented with vector<u8>. These values are often used for cryptographic purposes, such as a public key or a hash result. These values are so common that specific syntax is provided to make the values more readable, as opposed to having to use vector[] where each individual u8 value is specified in numeric form.\n\nThere are currently two supported types of vector<u8> literals, byte strings and hex strings.\n\nByte Strings\n\nByte strings are quoted string literals prefixed by a b, e.g. b\"Hello!\\n\".\n\nThese are ASCII encoded strings that allow for escape sequences. Currently, the supported escape sequences are:\n\nEscape Sequence\tDescription\n\\n\tNew line (or Line feed)\n\\r\tCarriage return\n\\t\tTab\n\\\\\tBackslash\n\\0\tNull\n\\\"\tQuote\n\\xHH\tHex escape, inserts the hex byte sequence HH\nHex Strings\n\nHex strings are quoted string literals prefixed by a x, e.g. x\"48656C6C6F210A\".\n\nEach byte pair, ranging from 00 to FF, is interpreted as hex encoded u8 value. So each byte pair corresponds to a single entry in the resulting vector<u8>.\n\nExample String Literals\nscript {\nfun byte_and_hex_strings() {\n    assert!(b\"\" == x\"\", 0);\n    assert!(b\"Hello!\\n\" == x\"48656C6C6F210A\", 1);\n    assert!(b\"\\x48\\x65\\x6C\\x6C\\x6F\\x21\\x0A\" == x\"48656C6C6F210A\", 2);\n    assert!(\n        b\"\\\"Hello\\tworld!\\\"\\n \\r \\\\Null=\\0\" ==\n            x\"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00\",\n        3\n    );\n}\n}\n\nOperations\n\nvector supports the following operations via the std::vector module in the Move standard library:\n\nFunction\tDescription\tAborts?\nvector::empty<T>(): vector<T>\tCreate an empty vector that can store values of type T\tNever\nvector::singleton<T>(t: T): vector<T>\tCreate a vector of size 1 containing t\tNever\nvector::push_back<T>(v: &mut vector<T>, t: T)\tAdd t to the end of v\tNever\nvector::pop_back<T>(v: &mut vector<T>): T\tRemove and return the last element in v\tIf v is empty\nvector::borrow<T>(v: &vector<T>, i: u64): &T\tReturn an immutable reference to the T at index i\tIf i is not in bounds\nvector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T\tReturn a mutable reference to the T at index i\tIf i is not in bounds\nvector::destroy_empty<T>(v: vector<T>)\tDelete v\tIf v is not empty\nvector::append<T>(v1: &mut vector<T>, v2: vector<T>)\tAdd the elements in v2 to the end of v1\tNever\nvector::contains<T>(v: &vector<T>, e: &T): bool\tReturn true if e is in the vector v. Otherwise, returns false\tNever\nvector::swap<T>(v: &mut vector<T>, i: u64, j: u64)\tSwaps the elements at the ith and jth indices in the vector v\tIf i or j is out of bounds\nvector::reverse<T>(v: &mut vector<T>)\tReverses the order of the elements in the vector v in place\tNever\nvector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)\tReturn (true, i) if e is in the vector v at index i. Otherwise, returns (false, 0)\tNever\nvector::remove<T>(v: &mut vector<T>, i: u64): T\tRemove the ith element of the vector v, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector\tIf i is out of bounds\nvector::swap_remove<T>(v: &mut vector<T>, i: u64): T\tSwap the ith element of the vector v with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector\tIf i is out of bounds\n\nMore operations may be added over time.\n\nExample\nuse std::vector;\n\nlet v = vector::empty<u64>();\nvector::push_back(&mut v, 5);\nvector::push_back(&mut v, 6);\n\nassert!(*vector::borrow(&v, 0) == 5, 42);\nassert!(*vector::borrow(&v, 1) == 6, 42);\nassert!(vector::pop_back(&mut v) == 6, 42);\nassert!(vector::pop_back(&mut v) == 5, 42);\n\nDestroying and copying vectors\n\nSome behaviors of vector<T> depend on the abilities of the element type, T. For example, vectors containing elements that do not have drop cannot be implicitly discarded like v in the example above--they must be explicitly destroyed with vector::destroy_empty.\n\nNote that vector::destroy_empty will abort at runtime unless vec contains zero elements:\n\nfun destroy_any_vector<T>(vec: vector<T>) {\n    vector::destroy_empty(vec) // deleting this line will cause a compiler error\n}\n\n\nBut no error would occur for dropping a vector that contains elements with drop:\n\nfun destroy_droppable_vector<T: drop>(vec: vector<T>) {\n    // valid!\n    // nothing needs to be done explicitly to destroy the vector\n}\n\n\nSimilarly, vectors cannot be copied unless the element type has copy. In other words, a vector<T> has copy if and only if T has copy. However, even copyable vectors are never implicitly copied:\n\nlet x = vector::singleton<u64>(10);\nlet y = copy x; // compiler error without the copy!\n\n\nCopies of large vectors can be expensive, so the compiler requires explicit copy's to make it easier to see where they are happening.\n\nFor more details see the sections on type abilities and generics.\n\nOwnership\n\nAs mentioned above, vector values can be copied only if the elements can be copied. In that case, the copy must be explicit via a copy or a dereference *."
    },
    {
      "title": "Address - The Move Book",
      "url": "https://move-language.github.io/move/address.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nAddress\n\naddress is a built-in type in Move that is used to represent locations (sometimes called accounts) in global storage. An address value is a 128-bit (16 byte) identifier. At a given address, two things can be stored: Modules and Resources.\n\nAlthough an address is a 128 bit integer under the hood, Move addresses are intentionally opaque---they cannot be created from integers, they do not support arithmetic operations, and they cannot be modified. Even though there might be interesting programs that would use such a feature (e.g., pointer arithmetic in C fills a similar niche), Move does not allow this dynamic behavior because it has been designed from the ground up to support static verification.\n\nYou can use runtime address values (values of type address) to access resources at that address. You cannot access modules at runtime via address values.\n\nAddresses and Their Syntax\n\nAddresses come in two flavors, named or numerical. The syntax for a named address follows the same rules for any named identifier in Move. The syntax of a numerical address is not restricted to hex-encoded values, and any valid u128 numerical value can be used as an address value, e.g., 42, 0xCAFE, and 2021 are all valid numerical address literals.\n\nTo distinguish when an address is being used in an expression context or not, the syntax when using an address differs depending on the context where it's used:\n\nWhen an address is used as an expression the address must be prefixed by the @ character, i.e., @<numerical_value> or @<named_address_identifier>.\nOutside of expression contexts, the address may be written without the leading @ character, i.e., <numerical_value> or <named_address_identifier>.\n\nIn general, you can think of @ as an operator that takes an address from being a namespace item to being an expression item.\n\nNamed Addresses\n\nNamed addresses are a feature that allow identifiers to be used in place of numerical values in any spot where addresses are used, and not just at the value level. Named addresses are declared and bound as top level elements (outside of modules and scripts) in Move Packages, or passed as arguments to the Move compiler.\n\nNamed addresses only exist at the source language level and will be fully substituted for their value at the bytecode level. Because of this, modules and module members must be accessed through the module's named address and not through the numerical value assigned to the named address during compilation, e.g., use my_addr::foo is not equivalent to use 0x2::foo even if the Move program is compiled with my_addr set to 0x2. This distinction is discussed in more detail in the section on Modules and Scripts.\n\nExamples\nlet a1: address = @0x1; // shorthand for 0x00000000000000000000000000000001\nlet a2: address = @0x42; // shorthand for 0x00000000000000000000000000000042\nlet a3: address = @0xDEADBEEF; // shorthand for 0x000000000000000000000000DEADBEEF\nlet a4: address = @0x0000000000000000000000000000000A;\nlet a5: address = @std; // Assigns `a5` the value of the named address `std`\nlet a6: address = @66;\nlet a7: address = @0x42;\n\nmodule 66::some_module {   // Not in expression context, so no @ needed\n    use 0x1::other_module; // Not in expression context so no @ needed\n    use std::vector;       // Can use a named address as a namespace item when using other modules\n    ...\n}\n\nmodule std::other_module {  // Can use a named address as a namespace item to declare a module\n    ...\n}\n\nGlobal Storage Operations\n\nThe primary purpose of address values are to interact with the global storage operations.\n\naddress values are used with the exists, borrow_global, borrow_global_mut, and move_from operations.\n\nThe only global storage operation that does not use address is move_to, which uses signer.\n\nOwnership\n\nAs with the other scalar values built-in to the language, address values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy."
    },
    {
      "title": "Bool - The Move Book",
      "url": "https://move-language.github.io/move/bool.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nBool\n\nbool is Move's primitive type for boolean true and false values.\n\nLiterals\n\nLiterals for bool are either true or false.\n\nOperations\nLogical\n\nbool supports three logical operations:\n\nSyntax\tDescription\tEquivalent Expression\n&&\tshort-circuiting logical and\tp && q is equivalent to if (p) q else false\n||\tshort-circuiting logical or\tp || q is equivalent to if (p) true else q\n!\tlogical negation\t!p is equivalent to if (p) false else true\nControl Flow\n\nbool values are used in several of Move's control-flow constructs:\n\nif (bool) { ... }\nwhile (bool) { .. }\nassert!(bool, u64)\nOwnership\n\nAs with the other scalar values built-in to the language, boolean values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy."
    },
    {
      "title": "Integers - The Move Book",
      "url": "https://move-language.github.io/move/integers.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nIntegers\n\nMove supports six unsigned integer types: u8, u16, u32, u64, u128, and u256. Values of these types range from 0 to a maximum that depends on the size of the type.\n\nType\tValue Range\nUnsigned 8-bit integer, u8\t0 to 28 - 1\nUnsigned 16-bit integer, u16\t0 to 216 - 1\nUnsigned 32-bit integer, u32\t0 to 232 - 1\nUnsigned 64-bit integer, u64\t0 to 264 - 1\nUnsigned 128-bit integer, u128\t0 to 2128 - 1\nUnsigned 256-bit integer, u256\t0 to 2256 - 1\nLiterals\n\nLiteral values for these types are specified either as a sequence of digits (e.g.,112) or as hex literals, e.g., 0xFF. The type of the literal can optionally be added as a suffix, e.g., 112u8. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be u64.\n\nNumber literals can be separated by underscores for grouping and readability. (e.g.,1_234_5678, 1_000u128, 0xAB_CD_12_35).\n\nIf a literal is too large for its specified (or inferred) size range, an error is reported.\n\nExamples\n// literals with explicit annotations;\nlet explicit_u8 = 1u8;\nlet explicit_u16 = 1u16;\nlet explicit_u32 = 1u32;\nlet explicit_u64 = 2u64;\nlet explicit_u128 = 3u128;\nlet explicit_u256 = 1u256;\nlet explicit_u64_underscored = 154_322_973u64;\n\n// literals with simple inference\nlet simple_u8: u8 = 1;\nlet simple_u16: u16 = 1;\nlet simple_u32: u32 = 1;\nlet simple_u64: u64 = 2;\nlet simple_u128: u128 = 3;\nlet simple_u256: u256 = 1;\n\n// literals with more complex inference\nlet complex_u8 = 1; // inferred: u8\n// right hand argument to shift must be u8\nlet _unused = 10 << complex_u8;\n\nlet x: u8 = 38;\nlet complex_u8 = 2; // inferred: u8\n// arguments to `+` must have the same type\nlet _unused = x + complex_u8;\n\nlet complex_u128 = 133_876; // inferred: u128\n// inferred from function argument type\nfunction_that_takes_u128(complex_u128);\n\n// literals can be written in hex\nlet hex_u8: u8 = 0x1;\nlet hex_u16: u16 = 0x1BAE;\nlet hex_u32: u32 = 0xDEAD80;\nlet hex_u64: u64 = 0xCAFE;\nlet hex_u128: u128 = 0xDEADBEEF;\nlet hex_u256: u256 = 0x1123_456A_BCDE_F;\n\nOperations\nArithmetic\n\nEach of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) must be of the same type. If you need to operate over values of different types, you will need to first perform a cast. Similarly, if you expect the result of the operation to be too large for the integer type, perform a cast to a larger size before performing the operation.\n\nAll arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).\n\nSyntax\tOperation\tAborts If\n+\taddition\tResult is too large for the integer type\n-\tsubtraction\tResult is less than zero\n*\tmultiplication\tResult is too large for the integer type\n%\tmodular division\tThe divisor is 0\n/\ttruncating division\tThe divisor is 0\nBitwise\n\nThe integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.\n\nBitwise operations do not abort.\n\nSyntax\tOperation\tDescription\n&\tbitwise and\tPerforms a boolean and for each bit pairwise\n|\tbitwise or\tPerforms a boolean or for each bit pairwise\n^\tbitwise xor\tPerforms a boolean exclusive or for each bit pairwise\nBit Shifts\n\nSimilar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must always be a u8 and need not match the left side operand (the number you are shifting).\n\nBit shifts can abort if the number of bits to shift by is greater than or equal to 8, 16, 32, 64, 128 or 256 for u8, u16, u32, u64, u128 and u256 respectively.\n\nSyntax\tOperation\tAborts if\n<<\tshift left\tNumber of bits to shift by is greater than the size of the integer type\n>>\tshift right\tNumber of bits to shift by is greater than the size of the integer type\nComparisons\n\nInteger types are the only types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to cast one of them first.\n\nComparison operations do not abort.\n\nSyntax\tOperation\n<\tless than\n>\tgreater than\n<=\tless than or equal to\n>=\tgreater than or equal to\nEquality\n\nLike all types with drop in Move, all integer types support the \"equal\" and \"not equal\" operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to cast one of them first.\n\nEquality operations do not abort.\n\nSyntax\tOperation\n==\tequal\n!=\tnot equal\n\nFor more details see the section on equality\n\nCasting\n\nInteger types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.\n\nCasts do not truncate. Casting will abort if the result is too large for the specified type\n\nSyntax\tOperation\tAborts if\n(e as T)\tCast integer expression e into an integer type T\te is too large to represent as a T\n\nHere, the type of e must be 8, 16, 32, 64, 128 or 256 and T must be u8, u16, u32, u64, u128 oe u256.\n\nFor example:\n\n(x as u8)\n(y as u16)\n(873u16 as u32)\n(2u8 as u64)\n(1 + 3 as u128)\n(4/2 + 12345 as u256)\nOwnership\n\nAs with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as copy."
    },
    {
      "title": "Move Tutorial - The Move Book",
      "url": "https://move-language.github.io/move/creating-coins.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nMove Tutorial\n\nPlease refer to the Move Tutorial."
    },
    {
      "title": "Modules and Scripts - The Move Book",
      "url": "https://move-language.github.io/move/modules-and-scripts.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nModules and Scripts\n\nMove has two different types of programs: Modules and Scripts. Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's global storage, and module functions define the rules for updating storage. Modules themselves are also stored in global storage. Scripts are executable entrypoints similar to a main function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage.\n\nA Move source file (or compilation unit) may contain multiple modules and scripts. However, publishing a module or executing a script are separate VM operations.\n\nSyntax\nScripts\n\nA script has the following structure:\n\nscript {\n    <use>*\n    <constants>*\n    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>\n}\n\n\nA script block must start with all of its use declarations, followed by any constants and (finally) the main function declaration. The main function can have any name (i.e., it need not be called main), is the only function in a script block, can have any number of arguments, and must not return a value. Here is an example with each of these components:\n\nscript {\n    // Import the debug module published at the named account address std.\n    use std::debug;\n\n    const ONE: u64 = 1;\n\n    fun main(x: u64) {\n        let sum = x + ONE;\n        debug::print(&sum)\n    }\n}\n\n\nScripts have very limited power—they cannot declare friends, struct types or access global storage. Their primary purpose is to invoke module functions.\n\nModules\n\nA module has the following syntax:\n\nmodule <address>::<identifier> {\n    (<use> | <friend> | <type> | <function> | <constant>)*\n}\n\n\nwhere <address> is a valid named or literal address.\n\nFor example:\n\nmodule 0x42::test {\n    struct Example has copy, drop { i: u64 }\n\n    use std::debug;\n    friend 0x42::another_test;\n\n    const ONE: u64 = 1;\n\n    public fun print(x: u64) {\n        let sum = x + ONE;\n        let example = Example { i: sum };\n        debug::print(&sum)\n    }\n}\n\n\nThe module 0x42::test part specifies that the module test will be published under the account address 0x42 in global storage.\n\nModules can also be declared using named addresses. For example:\n\nmodule test_addr::test {\n    struct Example has copy, drop { a: address }\n\n    use std::debug;\n    friend test_addr::another_test;\n\n    public fun print() {\n        let example = Example { a: @test_addr };\n        debug::print(&example)\n    }\n}\n\n\nBecause named addresses only exist at the source language level and during compilation, named addresses will be fully substituted for their value at the bytecode level. For example if we had the following code:\n\nscript {\n    fun example() {\n        my_addr::m::foo(@my_addr);\n    }\n}\n\n\nand we compiled it with my_addr set to 0xC0FFEE, then it would be equivalent to the following operationally:\n\nscript {\n    fun example() {\n        0xC0FFEE::m::foo(@0xC0FFEE);\n    }\n}\n\n\nHowever at the source level, these are not equivalent—the function m::foo must be accessed through the my_addr named address, and not through the numerical value assigned to that address.\n\nModule names can start with letters a to z or letters A to Z. After the first character, module names can contain underscores _, letters a to z, letters A to Z, or digits 0 to 9.\n\nmodule my_module {}\nmodule foo_bar_42 {}\n\n\nTypically, module names start with an lowercase letter. A module named my_module should be stored in a source file named my_module.move.\n\nAll elements inside a module block can appear in any order. Fundamentally, a module is a collection of types and functions. The use keyword is used to import types from other modules. The friend keyword specifies a list of trusted modules. The const keyword defines private constants that can be used in the functions of a module."
    },
    {
      "title": "Introduction - The Move Book",
      "url": "https://move-language.github.io/move/introduction.html",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nIntroduction\n\nWelcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.\n\nMove takes its cue from Rust by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.\n\nWho is Move for?\n\nMove was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.\n\nThe early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.\n\nHobbyists\n\nUnderstanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.\n\nCore Contributor\n\nBeyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to contribute directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.\n\nWho Move is currently not targeting\n\nCurrently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.\n\nWhere Do I Start?\n\nBegin with understanding modules and scripts and then work through the Move Tutorial."
    },
    {
      "title": "Introduction - The Move Book",
      "url": "https://move-language.github.io/move/",
      "html": "Introduction\n1. Modules and Scripts\n2. Move Tutorial\n3. Integers\n4. Bool\n5. Address\n6. Vector\n7. Signer\n8. References\n9. Tuples and Unit\n10. Local Variables and Scopes\n11. Equality\n12. Abort and Assert\n13. Conditionals\n14. While and Loop\n15. Functions\n16. Structs and Resources\n17. Constants\n18. Generics\n19. Type Abilities\n20. Uses and Aliases\n21. Friends\n22. Packages\n23. Unit Tests\n24. Global Storage Structure\n25. Global Storage Operators\n26. Standard Library\n27. Coding Conventions\nThe Move Book\n  \nIntroduction\n\nWelcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.\n\nMove takes its cue from Rust by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.\n\nWho is Move for?\n\nMove was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.\n\nThe early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.\n\nHobbyists\n\nUnderstanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.\n\nCore Contributor\n\nBeyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to contribute directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.\n\nWho Move is currently not targeting\n\nCurrently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.\n\nWhere Do I Start?\n\nBegin with understanding modules and scripts and then work through the Move Tutorial."
    }
  ]