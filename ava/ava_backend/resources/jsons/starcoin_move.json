[
    {
      "title": "How to handle the mapping requirement | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/advance-move/how-to-handle-mapping-requirement/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nHow to design permission system with Capability\nHow to handle the mapping requirement\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentAdvance Move DevelopmentHow to handle the mapping requirement\nHow to handle the mapping requirement\nEdit this page\nPrevious\nHow to design permission system with Capability\nNext\nMove prover\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Create a new NFT | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-examples/create-a-new-nft/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nCreate a new Token\nCreate a new NFT\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMore Move ExamplesCreate a new NFT\nCreate a new NFT\n\nIn this chapter, we will focus on how to create a custom non-fungible token on the Starcoin blockchain. Let's get started.\n\nRequired​\n\nFirst, start a dev network described in How to set up a local dev network and get some coins, say 1000000000.\n\nIn this document, I will use 0xb19b07b76f00a8df445368a91c0547cc, the default account address of my dev network, to represent the person who issues and send the new token.\n\nThe source file can be found at simple-nft.\n\nCompile the module​\n\nClone the code from github and enter the simple-nft folder:\n\ngit clone https://github.com/starcoinorg/starcoin-cookbook.git\ncd starcoin-cookbook/examples/simple-nft\n\n\nReplace the SNFT address with your default address in the Move.toml file.\n\n[addresses]\nStarcoinFramework = \"0x1\"\nSNFT = \"0xb19b07b76f00a8df445368a91c0547cc\"\n\n\nRun mpm release in another shell console for release package:\n\n$ mpm release\n\nPackaging Modules:\n         0xb19b07b76f00a8df445368a91c0547cc::SimpleNFT\n         0xb19b07b76f00a8df445368a91c0547cc::SimpleNFTScripts\nRelease done: release/simple-nft.v0.0.1.blob, package hash: 0x39bf53490461a9ccf07804312561280e7dafa4ba8ea102913c022de5c9a80555\n\n\nIt will compile the module, and then you will get the binary package simple-nft.v0.0.1.blob in release folder. We will use it then.\n\nWe will need to import 0xb19b07b76f00a8df445368a91c0547cc account to deploy the module.\n\nstarcoin% account import -i 0x05c9d09cd06a49e99efd0308c64bfdfb57409e10bc9e2a57cb4330cd946b4e83 -p <MY-PASSWORD>\n\n{\n  \"ok\": {\n    \"address\": \"0xb19b07b76f00a8df445368a91c0547cc\",\n    \"is_default\": false,\n    \"is_readonly\": false,\n    \"public_key\": \"0x7932502fa3f8c9bc9c9bb994f718b9bd90e58a6cdb145e24769560d3c96254d2\",\n    \"receipt_identifier\": \"stc1pkxds0dm0qz5d73zndz53cp28esyfj4ue\"\n  }\n}\n\nGet devnet test coins​\n\nGet some STC coin from dev net, and it will send 1000000000 STC to the account by default.\n\nstarcoin% dev get-coin 0xb19b07b76f00a8df445368a91c0547cc\n\nDeploy module​\n\nThen, unlock the account and deploy SimpleNFT module and SimpleNFTScripts module.\n\nstarcoin% account unlock 0xb19b07b76f00a8df445368a91c0547cc -p <MY-PASSWORD>\n\nstarcoin% dev deploy /path/to/simple-nft/release/simple-nft.v0.0.1.blob -s 0xb19b07b76f00a8df445368a91c0547cc -b\n\ntxn 0x60e31b4e4fe974f66b80c3e69c659a573b4022754430bf030576292e1358d7b0 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"37536\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 322067\n                }\n              },\n              \"raw\": \"0x13ea0400000000000000000000000000\"\n            }\n          }\n        },\n  .....\n  ....\n}\n\n\nYou can see that the transation is submitted and the result status is Executed. That means the module has been deployed.\n\nExecute script function​\n\nFirst，execute the initialize transaction in starcoin console:\n\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::SimpleNFTScripts::initialize -b\n\n\nThen, mint a test nft:\n\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::SimpleNFTScripts::test_mint_with_image_data -b\n\n\nLast, run account nft list to check the NFT in the account:\n\nstarcoin% account nft list\n{\n  \"ok\": {\n    \"list\": [\n      {\n        \"base_meta\": {\n          \"description\": \"test description\",\n          \"image\": \"\",\n          \"image_data\": \"<省略 image_data>\",\n          \"name\": \"test nft\"\n        },\n        \"body\": {\n          \"dummy_field\": false\n        },\n        \"creator\": \"0xb19b07b76f00a8df445368a91c0547cc\",\n        \"id\": 1,\n        \"nft_type\": \"0xb19b07b76f00a8df445368a91c0547cc::SimpleNFT::SimpleNFT/0xb19b07b76f00a8df445368a91c0547cc::SimpleNFT::SimpleNFTBody\",\n        \"type_meta\": {\n          \"dummy_field\": false\n        },\n        \"uuid\": \"0xb19b07b76f00a8df445368a91c0547cc::SimpleNFT::SimpleNFT/0xb19b07b76f00a8df445368a91c0547cc::SimpleNFT::SimpleNFTBody/1\"\n      }\n    ]\n  }\n}\n\n\nWe can now see a NFT witd id 1 in your account.\n\nEdit this page\nPrevious\nCreate a new Token\nNext\nAdvanced Move\nRequired\nCompile the module\nGet devnet test coins\nDeploy module\nExecute script function\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "How to design permission system with Capability | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/advance-move/how-to-design-permission-system/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nHow to design permission system with Capability\nHow to handle the mapping requirement\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentAdvance Move DevelopmentHow to design permission system with Capability\nHow to design permission system with Capability\nEdit this page\nPrevious\nAdvanced Move\nNext\nHow to handle the mapping requirement\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Create a new Token | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-examples/create-a-new-token/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nCreate a new Token\nCreate a new NFT\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMore Move ExamplesCreate a new Token\nCreate a new Token\n\nIn this chapter, we will focus on how to create a custom token on the Starcoin blockchain. Let's get started.\n\nRequired​\n\nFirst, start a dev network described in How to set up a local dev network and get some coins, say 1000000000.\n\nIn this document, I will use 0xb19b07b76f00a8df445368a91c0547cc, the default account address of my dev network, to represent the person who issues and send the new token. And I also created another account 0x831d51f0087596e6aa4e7b3b9c85f945 and transfer some STC to it. The account will be used to receive the token.\n\nThe source file can be found at my-token.\n\nCompile the module​\n\nChange the address of the module:\n\nedit Move.toml\nchange MyToken = \"0xABCDE\" to MyToken = \"0xb19b07b76f00a8df445368a91c0547cc\"\n\nThen open a console and run the following command:\n\n$ mpm release\n\nPackaging Modules:\n         0xb19b07b76f00a8df445368a91c0547cc::MyToken\nRelease done: release/my_token.v0.0.1.blob, package hash: 0xc3b9cf32499f4bdf0a38d57f7c7c66a6f4df69881a8980bcda2106782dce88ba\n\n\nIt will compile the module, and then you will get the binary package my_token.v0.0.1.blob in release folder. We will use it then.\n\nImport account​\n\nWe will need to import 0xb19b07b76f00a8df445368a91c0547cc account to deploy the module.\n\nstarcoin% account import -i 0x05c9d09cd06a49e99efd0308c64bfdfb57409e10bc9e2a57cb4330cd946b4e83 -p <MY-PASSWORD>\n\n{\n  \"ok\": {\n    \"address\": \"0xb19b07b76f00a8df445368a91c0547cc\",\n    \"is_default\": false,\n    \"is_readonly\": false,\n    \"public_key\": \"0x7932502fa3f8c9bc9c9bb994f718b9bd90e58a6cdb145e24769560d3c96254d2\",\n    \"receipt_identifier\": \"stc1pkxds0dm0qz5d73zndz53cp28esyfj4ue\"\n  }\n}\n\nGet devnet test coins​\n\nGet some STC coin from dev net, and it will send 1000000000 STC to the account by default. Notice that, this command can only be used in dev net.\n\nstarcoin% dev get-coin 0xb19b07b76f00a8df445368a91c0547cc\n\nDeploy module​\n\nThen, unlock the account and deploy MyToken module.\n\nstarcoin% account unlock 0xb19b07b76f00a8df445368a91c0547cc -p <MY-PASSWORD>\n\nstarcoin% dev deploy /path/to/my-token/release/my_token.v0.0.1.blob -s 0xb19b07b76f00a8df445368a91c0547cc -b\n\ntxn 0x686964d6a4212f1e32e8626132e14dabffb034d6f3aec921e80a2e54726391b1 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"7800\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 25031\n                }\n              },\n              \"raw\": \"0xc7610000000000000000000000000000\"\n            }\n          }\n        },\n  .....\n  ....\n}\n\n\nYou can see that the transation is submitted and the result status is Executed. That means the module has been deployed.\n\nExecute script function​\n\nFirst，use the account 0xb19b07b76f00a8df445368a91c0547cc to initial module via init function.\n\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::MyToken::init -s 0xb19b07b76f00a8df445368a91c0547cc --blocking\n\n\nSecond, use the account 0xb19b07b76f00a8df445368a91c0547cc to mint some MyToken.\n\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::MyToken::mint --blocking --arg 1000000u128 -s 0xb19b07b76f00a8df445368a91c0547cc\n\n\nThird, use the account 0xb19b07b76f00a8df445368a91c0547cc to transfer 1000 MyToken to another user 0x831d51f0087596e6aa4e7b3b9c85f945.\n\nstarcoin%  account execute-function --function 0x1::TransferScripts::peer_to_peer_v2 -t 0xb19b07b76f00a8df445368a91c0547cc::MyToken::MyToken --arg 0x831d51f0087596e6aa4e7b3b9c85f945 --arg 10000u128 -s 0xb19b07b76f00a8df445368a91c0547cc\n\n\nLast, show balances of the second user.\n\nstarcoin% account show 0x831d51f0087596e6aa4e7b3b9c85f945\n{\n  \"ok\": {\n    \"account\": {\n      \"address\": \"0x831d51f0087596e6aa4e7b3b9c85f945\",\n      \"is_default\": true,\n      \"is_readonly\": false,\n      \"public_key\": \"0x29894dafe73616f807ed48aef1978974122d790a62be767d115f396b422cbb75\",\n      \"receipt_identifier\": \"stc1psvw4ruqgwktwd2jw0vaeep0eg5eac86k\"\n    },\n    \"auth_key\": \"0xedf8fad3eb73ab981793ca5b29b9f660831d51f0087596e6aa4e7b3b9c85f945\",\n    \"balances\": {\n      \"0x00000000000000000000000000000001::STC::STC\": 100000533341,\n      \"0xb19b07b76f00a8df445368a91c0547cc::MyToken::MyToken\": 10000    <- Note that MyToken has been successfully received\n    },\n    \"sequence_number\": 3\n  }\n}\n\nEdit this page\nPrevious\nMove examples\nNext\nCreate a new NFT\nRequired\nCompile the module\nImport account\nGet devnet test coins\nDeploy module\nExecute script function\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move VM, Bytecode, and Disassembler | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-test/disassembler/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nUnit Tests\nWrite Move integration test\nHow to debug Move module and troubleshooting\nMove VM, Bytecode, and Disassembler\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to test Move ModuleMove VM, Bytecode, and Disassembler\nMove VM, Bytecode, and Disassembler\n\nThere are times we wish to understand what's actually going on under the hood when we write a piece of code, compile it, and execute it in the move VM.\n\nIn this post, we will take a look at them.\n\nMove VM execution model​\n\nA Move Interpreter handles program execution at the bytecode level.\n\nJust like other stack-based interpreters, when seeing an instruction, move interpreters may consume operands from the stack and may push results to it. But unlike x86 machines, where operands/variables share the same region with the call stack, Move VM logically separate them apart: a Move interpreter has two parts -- An operand stack, and a call stack (its internal structure is shown below).\n\nInterpreter\n├── operand Stack\n│   ├── value[0]  <---- stack bottom\n│   ├── value[1]\n│   ├── ...\n│   └── value[n]  <---- stack top\n└── call stack\n    ├── frame[0]                            <-- Call stack bottom\n    │   ├── pc (program counter)\n    │   ├── locals (an array of ValueImpl, contains local variables and paramters)\n    │   ├── function (a runtime function)\n    │   └── ty_args (type arguments)\n    ├── frame[1]\n    ├── ...\n    └── frame[m]                            <-- Call stack top\n\n\nUpon any procedural call, the caller prepares arguments (a.k.a, actual parameters) and pushes them to the operand stack, then the Call instruction will result in the creation of a new frame for the callee on top of the call stack, where formal parameters are copied from the stack.\n\nWe can understand most instructions' meaning from their name. Whenever you wonder the effect of any instruction, refer to the execute_code_impl() in interpreter.rs for details.\n\nMove Disassembler​\n\nMost of the time, Move developers write code, test, and debug at the source level. However, since bytecode is actually what the Move VM executes, in some rare conditions, we might need to inspect the corresponding bytecode of a particular module or function.\n\nFor instance, in Starcoin Framework, there's a function owns() in the IdentiferNFT module of NFT.move. Its original implementation is:\n\npublic fun owns<NFTMeta: copy + store + drop, NFTBody: store>(owner: address): bool acquires IdentifierNFT {\n    if (!exists<IdentifierNFT<NFTMeta, NFTBody>>(owner)) {\n        return false\n    };\n    let id_nft = borrow_global<IdentifierNFT<NFTMeta, NFTBody>>(owner);\n    Option::is_some(&id_nft.nft)\n}\n\n\nSome readers may have noticed that the logic of the form if not X then false else Y is actually equivalent to X and Y. Therefore, it is tempting to simplify the function to this form (let's call it the one-liner version):\n\npublic fun owns<NFTMeta: copy + store + drop, NFTBody: store>(owner: address): bool acquires IdentifierNFT {\n    exists<IdentifierNFT<NFTMeta, NFTBody>>(owner)) && \n        Option::is_some(borrow_global<IdentifierNFT<NFTMeta, NFTBody>>(owner)&.nft)\n}\n\n\nBut if we try to run the tests, we might notice that the gas fee for the one-liner consumption differs from that of the original version. Why?\n\nNow it's time to examine the bytecode.\n\nFirst, let's check the bytecode of the original implementation. To disassemble the module IdentifierNFT, run mpm package disassemble --name IdentifierNFT. Here's is the result of the owns function:\n\npublic owns<NFTMeta: copy + drop + store, NFTBody: store>(id_nft: address): bool {\nB0:\n    0: CopyLoc[0](owner: address)\n    1: ExistsGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    2: Not\n    3: BrTrue(5)\nB1:\n    4: Branch(7)\nB2:\n    5: LdFalse\n    6: Ret\nB3:\n    7: CopyLoc[0](owner: address)\n    8: ImmBorrowGlobalGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    9: StLoc[1](id_nft: &IdentifierNFT<NFTMeta, NFTBody>)\n    10: MoveLoc[1](id_nft: &IdentifierNFT<NFTMeta, NFTBody>)\n    11: ImmBorrowFieldGeneric[0](IdentifierNFT.nft: Option<NFT<NFTMeta, NFTBody>>)\n    12: Call[5](is_some<NFT<NFTMeta, NFTBody>>(&Option<NFT<NFTMeta, NFTBody>>): bool)\n    13: Ret\n}\n\n\nLet's try to understand it using what we've learned earlier: There are 4 basic blocks in the function. In B0, it copied the owner address to the stack, and then use it to do the existence check, followed by a negation, finally branches to B2 conditionally.\n\nB2 simply pushes false and returns.\n\nB1 is a dummy block that takes the control flow to B3. It does the global borrow from instruction 7-8 and store it in id_nft at instruction 9. Instruction 10 loads that to the stack again (yes, you might have noticed that a simple peephole optimization can eliminate instructions 9-10. Currently Move compiler doesn't really do much optimization). The last three instructions 11-13 return the result of the predicate is_some() on field 0.\n\nNow let's check the one-liner's bytecode out:\n\npublic owns<NFTMeta: copy + drop + store, NFTBody: store>(%#1: address): bool {\nB0:\n    0: CopyLoc[0](owner: address)\n    1: ExistsGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    2: BrTrue(4)\nB1:\n    3: Branch(10)\nB2:\n    4: CopyLoc[0](owner: address)\n    5: ImmBorrowGlobalGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    6: ImmBorrowFieldGeneric[0](IdentifierNFT.nft: Option<NFT<NFTMeta, NFTBody>>)\n    7: Call[5](is_some<NFT<NFTMeta, NFTBody>>(&Option<NFT<NFTMeta, NFTBody>>): bool)\n    8: StLoc[1](%#1: bool)\n    9: Branch(12)\nB3:\n    10: LdFalse\n    11: StLoc[1](%#1: bool)\nB4:\n    12: MoveLoc[1](%#1: bool)\n    13: Ret\n}\n\n\nWe won't elaborate on the details here again, since most of the instructions are the same. We can notice a few differences:\n\nThere are more basic blocks in the one-liner version.\nResults are no longer returned directly from the stack. Notice that the compiler generated an unnamed local variable %#1, any value to be returned gets stored into it, and finally B4 returns it.\nRedundant instructions 9-10 in the original bytecode no longer exists here, since the one-liner don't have a temporary variable id_nft.\n\nNow we fully understand the behavioral difference caused by the refactoring.\n\nEdit this page\nPrevious\nHow to debug Move module and troubleshooting\nNext\nMove examples\nMove VM execution model\nMove Disassembler\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "How to debug Move module and troubleshooting | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-test/how-to-debug/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nUnit Tests\nWrite Move integration test\nHow to debug Move module and troubleshooting\nMove VM, Bytecode, and Disassembler\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to test Move ModuleHow to debug Move module and troubleshooting\nHow to debug Move module and troubleshooting\n\nThere are two test methods for move, unit test and integration test.\nUsing the two test methods separately can cover almost 90% of the usage scenarios.\nWe can usually test some functional modules in unit tests as simple verification.\nHowever, many test scenarios require that we must initiate transactions on the block to debug the correctness of the module, and unit testing cannot meet these requirements.\nSo we must use more powerful canonical tests to simulate transactions in real blocks to cover most use cases and make your code more robust.\n\nSimple Example​\n\nLet's take an example, this is a very simple Token module\nI will leave some small errors in it to demonstrate the whole debug process\nYou can use this test address\n\naddress:0xf2aa2eae4ceaae88b308fc904975e4ae  \npublic_key:0x98826ab91a9a5d85dec536418090aa6342991bc8f947613721c8165e7102b132  \nprivate_key:0xa5ead1fb25114b335ad21a07ed5cee8cecba8763309ec78656e7c4ccaf5735e7\n\nUse the mpm command​\n\nCreate a project\n\nmpm package new MyCake\n\nGo to the folder and edit mycake.move​\ncd MyCake\n\nvi sources/mycake.move\n\n\nfill in\n\naddress Chef{\n    module Cake{\n        use StarcoinFramework::Signer;\n        use StarcoinFramework::Token;\n        use StarcoinFramework::Account;\n\n        struct Cake has copy, drop, store { }\n\n        public fun admin():address{\n            @Chef\n        }\n\n        public fun init(account :&signer){\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::register_token<Cake>( account, 9 );\n        }\n\n        public fun make_cake( account: &signer , amount : u128): Token::Token<Cake> {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::mint<Cake>( account , amount  )\n        }\n\n        public fun destroy_cake( account: &signer , cake: Token::Token<Cake>) {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::burn<Cake>( account , cake  );\n        }\n\n        public fun send_cake( _to :address , cake: Token::Token<Cake> ){\n            Account::deposit<Cake>(@Chef, cake);\n        }\n\n        public fun add (x:u128, y:u128 ):u128{\n            x - y\n        }\n\n    }\n}\n\n\nEdit Move.toml​\nvi Move.toml\n\n[package]\nname = \"MyCake\"\nversion = \"0.0.0\"\n\n[addresses]\nChef = \"0xf2aa2eae4ceaae88b308fc904975e4ae\"\n\n[dependencies]\nStarcoinFramework = { git = \"https://github.com/starcoinorg/starcoin-framework.git\", rev = \"01c84198819310620f2417413c3c800df8292ae5\" }\n\nUnit Test Debug​\n\nAfter you have written some move code, you need to unit test first to ensure that your code is correct in the details\nUnit testing is generally used to test the correctness of certain functions or functional modules\n\nLet's test the return value of the add function\n\nadd unit test​\naddress Chef{\n    module Cake{\n        use StarcoinFramework::Signer;\n        use StarcoinFramework::Token;\n        use StarcoinFramework::Account;\n\n        struct Cake has copy, drop, store { }\n\n        public fun admin():address{\n            @Chef\n        }\n\n        public fun init(account :&signer){\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::register_token<Cake>( account, 9 );\n        }\n\n        public fun make_cake( account: &signer , amount : u128): Token::Token<Cake> {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::mint<Cake>( account , amount  )\n        }\n\n        public fun destroy_cake( account: &signer , cake: Token::Token<Cake>) {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::burn<Cake>( account , cake  );\n        }\n\n        public fun send_cake( _to :address , cake: Token::Token<Cake> ){\n            Account::deposit<Cake>(@Chef, cake);\n        }\n\n        public fun add (x:u128, y:u128 ):u128{\n            x - y\n        }\n\n        #[test]\n        public fun add_test(){\n            assert!( add(10 , 1) == 11, 101);\n        }\n    }\n}\n\n\nexecute test command​\nmpm package test\n\nget test results​\nBUILDING UnitTest\nBUILDING StarcoinFramework\nBUILDING MyCake\nRunning Move unit tests\n[ FAIL    ] 0xf2aa2eae4ceaae88b308fc904975e4ae::Cake::add_test\n\nTest failures:\n\nFailures in 0xf2aa2eae4ceaae88b308fc904975e4ae::Cake:\n\n┌── add_test ──────\n│ error[E11001]: test failure\n│    ┌─ ./sources/mycake.move:38:13\n│    │\n│ 37 │         public fun add_test(){\n│    │                    -------- In this function in 0xf2aa2eae4ceaae88b308fc904975e4ae::Cake\n│ 38 │             assert!( add(10 , 1) == 11, 101);\n│    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 101 here\n│ \n│ \n└──────────────────\n\nTest result: FAILED. Total tests: 1; passed: 0; failed: 1\n\n\nWe can see that the result of the add function is not what we expected\nLet's check the add function, we can see that the internal implementation of the add function is incorrect\nFix it\n\n    public fun add (x:u128, y:u128 ):u128{\n        x + y\n    }\n\nRerun unit test​\nmpm package test\n\nget test results​\nCACHED UnitTest\nCACHED StarcoinFramework\nBUILDING MyCake\nRunning Move unit tests\n[ PASS    ] 0xf2aa2eae4ceaae88b308fc904975e4ae::Cake::add_test\nTest result: OK. Total tests: 1; passed: 1; failed: 0\n\n\nCongratulations! The test has passed, you can find the error of the algorithm this way!\n\nYou can print certain values in unit tests, and you can also call functions in modules, but keep in mind that unit tests are very limited, and if you need a signature, you can use spectest\n\nIntegration-test Debug​\n\nUnit testing can only meet the needs of a small range of tests.\nMore often, we want to simulate the execution of the code on the block during the testing phase,\nbecause many problems occur after the block is executed.\n\nAt this time, integration-test is the best.\n\nCreate a new integration-tests directory and add mycake_test.move​\nmkdir integration-tests\n\nvi integration-test/mycake.move\n\n//# init -n test --public-keys Chef=0x98826ab91a9a5d85dec536418090aa6342991bc8f947613721c8165e7102b132 \n\n//# faucet --addr Chef --amount 10000000000000000\n\n//# faucet --addr guest --amount 10000000000000000\n\n//# run --signers Chef\nscript {\n    use Chef::Cake;\n    fun init(signer: signer) {\n        Cake::init(&signer);\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use StarcoinFramework::Signer;\n    use StarcoinFramework::Account;\n    use Chef::Cake;\n    fun make_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Account::deposit<Cake::Cake>( Signer::address_of(&signer) , cake );\n        assert!( Account::balance<Cake::Cake>(@Chef) == 1 * 1000 * 1000 * 1000 , 1001);\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use Chef::Cake;\n    fun destroy_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Cake::destroy_cake(&signer, cake);\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use StarcoinFramework::Account;\n    use Chef::Cake;\n    fun send_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Cake::send_cake(@guest, cake);\n        assert!( Account::balance<Cake::Cake>(@guest) == 1 * 1000 * 1000 * 1000 , 1001);\n    }\n}\n// check: EXECUTED\n\nRun integration-test​\nmpm integration-test\n\n\nThe following will be output on the command line\nWe can see that most of the tests are as we expected\nBut the result of the last test is wrong\nWe need to examine the code used by the test and the logic behind it\n\nBUILDING StarcoinFramework\nBUILDING MyCake\n\nrunning 1 tests\n\ntest transactional-test::mycake_test.move ... FAILED\nError: Expected errors differ from actual errors:\nprocessed 7 tasks\n\ntask 3 'run'. lines 7-14:\n{\n  \"gas_used\": 97115,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 4 'run'. lines 16-26:\n{\n  \"gas_used\": 128354,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 5 'run'. lines 28-36:\n{\n  \"gas_used\": 90747,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 6 'run'. lines 38-48:\n{\n  \"gas_used\": 90471,\n  \"status\": {\n    \"Keep\": {\n      \"MoveAbort\": [\n        \"Script\",\n        1001\n      ]\n    }\n  }\n}\n\n\n\nfailures:\n    transactional-test::mycake_test.move\n\ntest result: FAILED. 0 passed; 1 failed; 0 filtered out\n\nAnalyse Problem​\n\nFirst look at the test code\nWe made some cakes and wanted to give them to the guest, but after send_cake, the cake did not appear in the guest's account\n\n//# run --signers Chef\nscript {\n    use StarcoinFramework::Account;\n    use Chef::Cake;\n    fun send_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Cake::send_cake(@guest, cake);\n        assert!( Account::balance<Cake::Cake>(@guest) == 1 * 1000 * 1000 * 1000 , 1001);\n    }\n}\n// check: EXECUTED\n\n\nWe already know in the above test that the make_cake function is normal\nThen the problem must be in send_cake\nLet's check it out\n\n    public fun send_cake( _to :address , cake: Token::Token<Cake> ){\n        Account::deposit<Cake>(@Chef, cake);\n    }\n\n\nWhen we look at the send_cake function, we will find that the parameter of Account::deposit\\<Cake>(@Chef, cake) is fixed to the administrator address, which is wrong\nIt should be sent to whoever needs to send it\nFix it\n\n    public fun send_cake( to :address , cake: Token::Token<Cake> ){\n        Account::deposit<Cake>(to, cake);\n    }\n\n\nOk, let's rerun integration-test\n\nmpm integration-test\n\n\nWe didn't find any errors in the test items, but the test still failed. What's going on?\n\nBUILDING StarcoinFramework\nBUILDING MyCake\n\nrunning 1 tests\n\ntest transactional-test::mycake_test.move ... FAILED\nError: Expected errors differ from actual errors:\nprocessed 7 tasks\n\ntask 3 'run'. lines 7-14:\n{\n  \"gas_used\": 97115,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 4 'run'. lines 16-26:\n{\n  \"gas_used\": 128354,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 5 'run'. lines 28-36:\n{\n  \"gas_used\": 90747,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\ntask 6 'run'. lines 38-48:\n{\n  \"gas_used\": 141989,\n  \"status\": {\n    \"Keep\": \"Executed\"\n  }\n}\n\n\n\nfailures:\n    transactional-test::mycake_test.move\n\ntest result: FAILED. 0 passed; 1 failed; 0 filtered out\n\nExecution update test baseline​\n\nThis is because we need to update test baseline\n\nmpm integration-test --ub\n\n\nAn exp file with the same name as the test file will appear in the integration-tests directory\nThe result of the simultaneous test results is a pass\n\nBUILDING StarcoinFramework\nBUILDING MyCake\n\nrunning 1 tests\n\ntest transactional-test::mycake_test.move ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 filtered out\n\n\nWhen you need to modify test items, remember to execute mpm integration-test --ub after all test items are within the expected range\n\nCorrect Code​\nMove.toml​\n[package]\nname = \"MyCake\"\nversion = \"0.0.0\"\n\n[addresses]\nChef = \"0xf2aa2eae4ceaae88b308fc904975e4ae\"\n\n[dependencies]\nStarcoinFramework = { git = \"https://github.com/starcoinorg/starcoin-framework.git\", rev = \"01c84198819310620f2417413c3c800df8292ae5\" }\n\n\nmycake.move​\naddress Chef{\n    module Cake{\n        use StarcoinFramework::Signer;\n        use StarcoinFramework::Token;\n        use StarcoinFramework::Account;\n\n        struct Cake has copy, drop, store { }\n\n        public fun admin():address{\n            @Chef\n        }\n\n        public fun init(account :&signer){\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::register_token<Cake>( account, 9 );\n        }\n\n        public fun make_cake( account: &signer , amount : u128): Token::Token<Cake> {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::mint<Cake>( account , amount  )\n        }\n\n        public fun destroy_cake( account: &signer , cake: Token::Token<Cake>) {\n            assert!( admin() == Signer::address_of( account ) , 10000);\n            Token::burn<Cake>( account , cake  );\n        }\n\n        public fun send_cake( to :address , cake: Token::Token<Cake> ){\n            Account::deposit<Cake>(to, cake);\n        }\n\n        public fun add (x:u128, y:u128 ):u128{\n            x + y\n        }\n\n        #[test]\n        public fun add_test(){\n            assert!( add(10 , 1) == 11, 101);\n        }\n    }\n}\n\n\nmycake_test.move​\n//# init -n test --public-keys Chef=0x98826ab91a9a5d85dec536418090aa6342991bc8f947613721c8165e7102b132 \n\n//# faucet --addr Chef --amount 10000000000000000\n\n//# faucet --addr guest --amount 10000000000000000\n\n//# run --signers Chef\nscript {\n    use Chef::Cake;\n    fun init(signer: signer) {\n        Cake::init(&signer);\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use StarcoinFramework::Signer;\n    use StarcoinFramework::Account;\n    use Chef::Cake;\n    fun make_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Account::deposit<Cake::Cake>( Signer::address_of(&signer) , cake );\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use Chef::Cake;\n    fun destroy_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Cake::destroy_cake(&signer, cake);\n    }\n}\n// check: EXECUTED\n\n//# run --signers Chef\nscript {\n    use StarcoinFramework::Account;\n    use Chef::Cake;\n    fun send_cake(signer: signer) {\n        let cake = Cake::make_cake(&signer , 1 * 1000 * 1000 * 1000);\n        Cake::send_cake(@guest, cake);\n        assert!( Account::balance<Cake::Cake>(@guest) == 1 * 1000 * 1000 * 1000 , 1001);\n    }\n}\n// check: EXECUTED\n\nEdit this page\nPrevious\nWrite Move integration test\nNext\nMove VM, Bytecode, and Disassembler\nSimple Example\nUnit Test Debug\nIntegration-test Debug\nCorrect Code\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Write Move integration test | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-test/move-integration-test/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nUnit Tests\nWrite Move integration test\nHow to debug Move module and troubleshooting\nMove VM, Bytecode, and Disassembler\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to test Move ModuleWrite Move integration test\nWrite Move integration test\n\nNow you know how to write unit test in Move. But unit test only suits for simple test scenarios, like mathematical computation. For end-to-end test cases with user interactions, integration test comes to play.\n\nIntegration test is a feature of mpm.\n\nIt can simulates:\n\naccount initialization.\nblock generation.\nmodule publishing.\nexecute scripts or script function.\n\nAll actions are wrapped into transactions.\n\nAll integration test files should be in integration-tests dir under the package root path.\n\nIntegration testing for Move adds new annotations to the Move source files. These annotations start with //#, and are separated by an empty line.\n\nDirectives works like a command line, you provide command name and command arguments, and move pacakge manager executes the directives like OS executes cli commands.\n\n$ mpm integration-test --help\nmpm-integration-test\nRun integration tests in tests dir\n\nUSAGE:\n    mpm integration-test [OPTIONS] [FILTER]\n\nARGS:\n    <FILTER>    The FILTER string is tested against the name of all tests, and only those tests\n                whose names contain the filter are run\n\nOPTIONS:\n        --abi\n            Generate ABIs for packages\n\n    -d, --dev\n            Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if\n            this flag is set. This flag is useful for development of packages that expose named\n            addresses that are not set to a specific value\n\n        --doc\n            Generate documentation for packages\n\n        --exact\n            Exactly match filters rather than by substring\n\n        --force\n            Force recompilation of all packages\n\n        --format <FORMAT>\n            Configure formatting of output: pretty = Print verbose output; terse = Display one\n            character per test; (json is unsupported, exists for compatibility with the default test\n            harness) [default: pretty] [possible values: pretty, terse]\n\n    -h, --help\n            Print help information\n\n        --install-dir <INSTALL_DIR>\n            Installation directory for compiled artifacts. Defaults to current directory\n\n        --list\n            List all tests\n\n    -p, --path <PACKAGE_PATH>\n            Path to a package which the command should be run with respect to [default: .]\n\n    -q, --quiet\n            Output minimal information\n\n        --test\n            Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used\n            along with any code in the 'test' directory\n\n        --test-threads <TEST_THREADS>\n            Number of threads used for running tests in parallel [env: RUST_TEST_THREADS=] [default:\n            32]\n\n        --ub\n            update test baseline\n\n    -v\n            Print additional diagnostics if available\n\n\nIntegration Test Directives​\nDirective - init​\ntask-init 0.1.0\n\nUSAGE:\n    task init [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --block-number <block-number>       block number to read state from. default to latest block number\n        --addresses <named-addresses>...\n    -n, --network <network>                 genesis with the network\n        --public-keys <public-keys>...      the `public-keys` option is deprecated, please remove it.\n        --rpc <rpc>                         use remote starcoin rpc as initial state\n        --debug <debug>                     enable debug mode, output more info to stderr.\n\n\nDirective init can declare the initial state of you integration test. You can either start from a fresh blockchain state by providing arg -n test, or fork from a remote state snapshot like --rpc http://main.seed.starcoin.org:9850 --block-number 100000. --address <named-addresses> can be used to declare additional named addressed which will be used in the integration test later. --debug mode will print more information of transaction results.\n\nExamples:\n\n//# init -n dev\n\n//# init -n test --addresses alice=0xAA\n\n//# init -n barnard\n\n//# init --rpc http://main.seed.starcoin.org:9850 --block-number 100000\n\n\nDirective - block​\ntask-block 0.1.0\n\nUSAGE:\n    task block [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --author <author>\n        --number <number>\n        --timestamp <timestamp>\n        --uncles <uncles>\n\n\nDirective block start a new block.\n\nEvery directives between this block directive and next block directive are running in this block. You can pass custom --author, --timestamp, --uncles to fit your need.\n\nIf no block directive specified, transactions will run on default block whose block number is the next block number of initial state. If you fork from a remote state of block number h, then the next block's number is h+1.\n\nExamples:\n\n//# block\n\n//# block --author alice\n\n//# block --timestamp 100000000\n\n//# block --uncles 10\n\nDirective - faucet​\ntask-faucet 0.1.0\n\nUSAGE:\n    task faucet [OPTIONS] --addr <address>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --addr <address>\n        --amount <initial-balance>     [default: 100000000000]\n\n\nDirective faucet can create and faucet an address (can be named address like alice, tom or raw address like 0x1, 0x2) with some STC of given amount. If the address is a named address, it will auto generate an raw address(and public key) and assign it to the named address.\n\nExamples:\n\n//# faucet --addr bob\n\n//# faucet --addr alice --amount 0\n\n//# faucet --addr tom --amount 10000000000000\n\n\nDirective - call​\ntask-call 0.1.0\n\nCall a smart contract function \n\nUSAGE:\n    task call <function>  [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nARGS:\n    <function>       Smart contract function name\n\nOPTIONS:\n    -i, --args <args>               function arguments\n    -t, --type-args <type-args>     function type arguments\n\n\nDirective call can use to call smart contract functions.\n\nExamples:\n\n//# call 0x1::Account::balance --type-args 0x1::STC::STC --args 0x662ba5a1a1da0f1c70a9762c7eeb7aaf\n\nDirective - call-api​\ntask-call-api 0.1.0\n\nCall a RPC api from remote starcoin node.\n\nUSAGE:\n    task call-api <method> <params>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nARGS:\n    <method>         api method to call, example: node.info\n    <params>         api params, should be a json array string\n\n\nDirective call-api can use to call starcoin RPC apis. The outputs are stored in mpm runtime context, user can use the result through templete variable as the following directive's args. You can check jsonrpc to get available APIs and their output schema.\n\nExamples:\n\n//# call-api chain.info\n\n//# call-api chain.get_block_by_hash [{{$.call-api[0].head.parent_hash}}]\n\n\nDirective - package​\ntask-package 0.1.0\n\nPackage a module\n\nUSAGE:\n    task package [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --signers\n        --init-function\n        --type-args\n        --args\n\n\nDirective package package a module and return the packed binary blob, blob hash, and the temporary file path. It's usefull in two-phase module upgrade test.\n\nThe output example:\n\n{\n    \"file\":\"/tmp/.tmpnok0M6/0x3c6b00fadc6b4f37fa6e2c6c0949e97c89b00c07c0d1f1761671e6fe18792676.blob\",\n    \"hex\":\"0x662ba5a1a1da0f1c70a9762c7eeb7aaf0146a11ceb0b040000000601000203020505070107080b0813100c2307000000010000000004746573740568656c6c6f662ba5a1a1da0f1c70a9762c7eeb7aaf000100000001020000\",\n    \"package_hash\":\"0x3c6b00fadc6b4f37fa6e2c6c0949e97c89b00c07c0d1f1761671e6fe18792676\"\n}\n\n\nExamples:\n\n//# package\nmodule creator::test {\n    public fun hello() {}\n}\n\nDirective - deploy​\ntask-deploy 0.1.0\n\nDeploy a packed module.\n\nUSAGE:\n    task deploy [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nARGS:\n    <mv-or-package-file>    move bytecode file path or package binary path\n\nOPTIONS:\n        --signers\n        --gas-budget\n\n\nDirective deploy can deploy a packed module to the blockchain.\n\n--signers used in the second phase of a two-phase upgrade plan, any one call the deploy directive. --gas-budget specifies the max gas of the transaction.\n\nExamples:\n\n//# deploy {{$.package[0].file}}\n\nDirective - publish​\ntask-publish 0.1.0\nStarcoin-specific arguments for the publish command\n\nUSAGE:\n    task publish [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --gas-budget <gas-budget>\n    -k, --public-key <public-key>\n        --syntax <syntax>\n\n\nDirective publish can publish a module to the blockchain. The module code must follows the directive.\n\n--gas-budget specifies the max gas of the transaction. --syntax can be ingored for now.\n\nExamples:\n\n//# publish\nmodule alice::Holder {\n    use StarcoinFramework::Signer;\n\n    struct Hold<T> has key, store {\n        x: T\n    }\n\n    public fun hold<T: store>(account: &signer, x: T) {\n        move_to(account, Hold<T>{x})\n    }\n\n    public fun get<T: store>(account: &signer): T\n    acquires Hold {\n        let Hold {x} = move_from<Hold<T>>(Signer::address_of(account));\n        x\n    }\n}\n\n//# publish\nmodule Dummy::DummyModule {}\n\n\n\nDirective - run​\ntask-run 0.1.0\nStarcoin-specifc arguments for the run command,\n\nUSAGE:\n    task run [FLAGS] [OPTIONS] [--] [NAME]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n    -v, --verbose    print detailed outputs\n\nOPTIONS:\n        --args <args>...\n        --gas-budget <gas-budget>\n    -k, --public-key <public-key>\n        --signers <signers>...\n        --syntax <syntax>\n        --type-args <type-args>...\n\nARGS:\n    <NAME>\n\n\nDirective run can execute a script of script function. If it's a script, the script code must follow the directive. If it's a script function, then <NAME> should be provided.\n\n--signers declare the transaction sender. --type-args and --args declare type arguments and arguments of the script of script function.\n\nExamples:\n\n//# run --signers alice\nscript {\nuse StarcoinFramework::STC::{STC};\nuse StarcoinFramework::Token;\nuse StarcoinFramework::Account;\nfun main(account: signer) {\n    let coin = Account::withdraw<STC>(&account, 0);\n    Token::destroy_zero(coin);\n}\n}\n\n//# run --signers alice --type-args 0x1::DummyToken::DummyToken 0x1::Account::accept_token\n\n\nDirective - view​\ntask-view 0.1.0\n\nUSAGE:\n    task view --address <address> --resource <resource>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --address <address>\n        --resource <resource>\n\n\nDirective view can query any resource of any address.\n\nExamples:\n\n//# view --address alice --resource 01::Account::Account\n\n//# view --address StarcoinFramework --resource 0x1::Config::Config<0x1::VMConfig::VMConfig>\n\nDirective - print-bytecode​\ntask-print-bytecode 0.1.0\nTranslates the given Move IR module or script into bytecode, then prints a textual representation of that bytecode\n\nUSAGE:\n    task print-bytecode [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --input <input>    The kind of input: either a script, or a module [default: script]\n\n\nDirective print-bytecode can print the bytecode of given module or script.\n\nIntegration Test Expectation​\n\nEach integration test should have an corresponding expectation file, which contains the expected output of each directives in integration test. Move package manager will compare the test result of a integration test with the expectation file. If there are different outputs, then the integration test fails. You can generate the expected file by providing --ub argument when running mpm integration-test for the first time. But you have to check whether the generated output really is the expected output of your integration test.\n\nExample:\n\ncd coin-swap\nmpm pacakge build\nmpm integration-test test_coin_swap\n\n\nThis's all about integration test of move.\n\nEdit this page\nPrevious\nUnit Tests\nNext\nHow to debug Move module and troubleshooting\nIntegration Test Directives\nIntegration Test Expectation\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Modify and Drop Resource in MoveVM | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-vm/modify-and-drop-resource/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nMove VM\nCreate Resource in MoveVM\nModify and Drop Resource in MoveVM\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentREADMEModify and Drop Resource in MoveVM\nModify and Drop Resource in MoveVM\n\nTODO: need to translate from Chinese.\n\nEdit this page\nPrevious\nCreate Resource in MoveVM\nNext\nMove test\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Create Resource in MoveVM | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-vm/create-resource/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nMove VM\nCreate Resource in MoveVM\nModify and Drop Resource in MoveVM\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentREADMECreate Resource in MoveVM\nCreate Resource in MoveVM\n\nTODO: need to translate from Chinese.\n\nEdit this page\nPrevious\nMove VM\nNext\nModify and Drop Resource in MoveVM\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move VM | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-vm/summary/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nMove VM\nCreate Resource in MoveVM\nModify and Drop Resource in MoveVM\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentREADMEMove VM\nMove VM\n\nTODO: need to translation from Chinese.\n\nEdit this page\nPrevious\nREADME\nNext\nCreate Resource in MoveVM\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Oracle protocol | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/oracle/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkOracle protocol\nOracle protocol\nNOTE\n\nMigrate and Rewrite\n\nhttps://starcoin.org/zh/developer/blog/starcoin_oracle_protocol/\nhttps://starcoin.org/en/developer/blog/starcoin_oracle_protocol/\nEdit this page\nPrevious\nDAO\nNext\nHow to deploy Move smart contracts\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "DAO | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/dao/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkDAO\nDAO\nNOTE\n\nMigrate and Rewrite:\n\nhttps://starcoin.org/zh/developer/blog/starcoin_dao_1/\nhttps://starcoin.org/en/developer/blog/starcoin_dao_1/\nhttps://starcoin.org/zh/developer/key_concepts/dao_governance/\nEdit this page\nPrevious\nNFT standard\nNext\nOracle protocol\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "NFT standard | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/nft/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkNFT standard\nNFT standard\nNOTE\n\nMigrate and Rewrite:\n\nhttps://starcoin.org/zh/developer/blog/starcoin_merkle_nft/\n\nhttps://starcoin.org/en/developer/blog/starcoin_merkle_nft/\n\nhttps://starcoin.org/zh/developer/blog/starcoin_nft_application/\n\nhttps://starcoin.org/en/developer/blog/starcoin_nft_application/\n\nEdit this page\nPrevious\nToken standard\nNext\nDAO\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Token standard | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/token/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkToken standard\nToken standard\nNOTE\n\nMigrate and Rewrite:\n\nhttps://starcoin.org/zh/developer/blog/starcoin_token_proto/\nhttps://starcoin.org/en/developer/blog/starcoin_token_proto/\nEdit this page\nPrevious\nConfig\nNext\nNFT standard\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Config | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/config/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkConfig\nConfig\nNOTE\n\nMigrate and Rewrite:\n\nhttps://starcoin.org/zh/developer/blog/starcoin_stdlib_config/\n\nhttps://starcoin.org/en/developer/blog/starcoin_stdlib_config/\n\nhttps://starcoin.org/zh/developer/key_concepts/on_chain_config/\n\nEdit this page\nPrevious\nContract Account and SignerDelegated\nNext\nToken standard\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Contract Account and SignerDelegated | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/signer-delegated/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkContract Account and SignerDelegated\nContract Account and SignerDelegated\nNOTE\n\nMigrate and Rewrite:\n\nhttps://starcoin.org/zh/developer/blog/starcoin_contract_account/\nhttps://starcoin.org/en/developer/blog/starcoin_contract_account/\nEdit this page\nPrevious\nAccount\nNext\nConfig\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Account | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/account/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move FrameworkAccount\nAccount\nNOTE\n\nintroduce Account module\n\nAccount Resource\nBalance Resource\nAccount scripts\nEdit this page\nPrevious\nStarcoin Move Framework\nNext\nContract Account and SignerDelegated\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move Specification Language | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-prover/move-spec-language/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nMove Specification Language\nVerify Smart Contract: Move Prover Tutorials\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMove Specification Language and Move ProverMove Specification Language\nMove Specification Language\n\nhttps://github.com/diem/move/blob/cb82dbac8fd72b0b0d0c104e1dd748dc3c92fffd/language/move-prover/doc/user/spec-lang.md\n\nhttps://research.facebook.com/publications/the-move-prover/\n\nEdit this page\nPrevious\nMove prover\nNext\nVerify Smart Contract: Move Prover Tutorials\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Unit Tests | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-test/move-unit-test/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nUnit Tests\nWrite Move integration test\nHow to debug Move module and troubleshooting\nMove VM, Bytecode, and Disassembler\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to test Move ModuleUnit Tests\nUnit Tests\n\nUnit testing for Move adds three new annotations to the Move source language:\n\n#[test]\n#[test_only]\n#[expected_failure]\n\nThey respectively mark a function as a test, mark a module or module member (use, fun, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as #[test_only] or #[test], it will not be included in the compiled bytecode unless it is compiled for testing.\n\nTesting Annotations: Their Meaning and Usage​\n\nBoth the #[test] and #[expected_failure] annotations can be used either with or without arguments.\n\nWithout arguments, the #[test] annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.\n\n#[test] // OK\nfun this_is_a_test() { ... }\n\n#[test] // Will fail to compile since the test takes an argument\nfun this_is_not_correct(arg: signer) { ... }\n\n\nA test can also be annotated as an #[expected_failure]. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with #[expected_failure(abort_code = <code>)], if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the #[test] annotation can also be annotated as an #[expected_failure].\n\n#[test]\n#[expected_failure]\npublic fun this_test_will_abort_and_pass() { abort 1 }\n\n#[test]\n#[expected_failure]\npublic fun test_will_error_and_pass() { 1/0; }\n\n#[test]\n#[expected_failure(abort_code = 0)]\npublic fun test_will_error_and_fail() { 1/0; }\n\n#[test, expected_failure] // Can have multiple in one attribute. This test will pass.\npublic(script) fun this_other_test_will_abort_and_pass() { abort 1 }\n\n\nWith arguments, a test annotation takes the form #[test(<param_name_1> = <address>, ..., <param_name_n> = <address>)]. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters <param_name_1>, ..., <param_name_n>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.\n\nOnly parameters with a type of signer are supported as test parameters. If a non-signer parameter is supplied, the test will result in an error when run.\n\n#[test(arg = @0xC0FFEE)] // OK\nfun this_is_correct_now(arg: signer) { ... }\n\n#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match\nfun this_is_incorrect(arg: signer) { ... }\n\n#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument\nfun this_works(a: signer, b: signer) { ... }\n\n// somewhere a named address is declared\n#[test_only] // test-only named addresses are supported\naddress TEST_NAMED_ADDR = @0x1;\n...\n#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!\nfun this_is_correct_now(arg: signer) { ... }\n\n\nAn expected failure annotation can also take the form #[expected_failure(abort_code = <u64>)]. If a test function is annotated in such a way, the test must abort with an abort code equal to <u64>. Any other failure or abort code will result in a test failure.\n\n#[test, expected_failure(abort_code = 1)] // This test will fail\nfun this_test_should_abort_and_fail() { abort 0 }\n\n#[test]\n#[expected_failure(abort_code = 0)] // This test will pass\nfun this_test_should_abort_and_pass_too() { abort 0 }\n\n\nA module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test use s of a #[test_only] module will raise an error during compilation.\n\n#[test_only] // test only attributes can be attached to modules\nmodule ABC { ... }\n\n#[test_only] // test only attributes can be attached to named addresses\naddress ADDR = @0x1;\n\n#[test_only] // .. to uses\nuse 0x1::SomeOtherModule;\n\n#[test_only] // .. to structs\nstruct SomeStruct { ... }\n\n#[test_only] // .. and functions. Can only be called from test code, but not a test\nfun test_only_function(...) { ... }\n\nRunning Unit Tests​\n\nUnit tests for a Move package can be run with the move package test command.\n\nWhen running tests, every test will either PASS, FAIL, or TIMEOUT. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.\n\nA test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see OPTIONS below).\n\nThere are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag: mpm pacakge -h\n\nExample​\n\nA simple module using some of the unit testing features is shown in the following example:\n\nFirst create an empty package and change directory into it:\n\n$ move package new TestExample; cd TestExample\n\nNext add the following to the Move.toml:\n\n// filename: sources/MyModule.move\nmodule 0x1::MyModule {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n\n\nNext add the following module under the sources directory:\n\n// filename: sources/MyModule.move\nmodule 0x1::MyModule {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n\nRunning Tests​\n\nYou can then run these tests with the mpm package test command:\n\n$ mpm package test\nBUILDING MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\n\nUsing Test Flags​\n\nType <str> following mpm package test, which will only run tests whose fully qualified name contains <str>. For example, if we want to only run tests with \"zero_coin\" in their name:\n\n$ mpm package test zero_coin\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n\n\n-i <bound> or --instructions <bound>\n\nThis bounds the number of instructions that can be executed for any one test to <bound>:\n\n$ mpm package test -i 0\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ TIMEOUT ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ TIMEOUT ] 0x1::MyModule::make_sure_zero_coin_fails\n[ TIMEOUT ] 0x1::MyModule::test_has_coin\n\nTest failures:\n\nFailures in 0x1::MyModule:\n\n┌── make_sure_non_zero_coin_passes ──────\n│ Test timed out\n└──────────────────\n\n\n┌── make_sure_zero_coin_fails ──────\n│ Test timed out\n└──────────────────\n\n\n┌── test_has_coin ──────\n│ Test timed out\n└──────────────────\n\nTest result: FAILED. Total tests: 3; passed: 0; failed: 3\n\n\n\n-s or --statistics With these flags you can gather statistics about the tests run and report the runtime and instructions executed for each test. For example, if we wanted to see the statistics for the tests in the example above:\n\n$ mpm package test -s\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\n\nTest Statistics:\n\n┌───────────────────────────────────────────────┬────────────┬───────────────────────────┐\n│                   Test Name                   │    Time    │   Instructions Executed   │\n├───────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::MyModule::make_sure_non_zero_coin_passes │   0.009    │             1             │\n├───────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::MyModule::make_sure_zero_coin_fails      │   0.008    │             1             │\n├───────────────────────────────────────────────┼────────────┼───────────────────────────┤\n│ 0x1::MyModule::test_has_coin                  │   0.008    │             1             │\n└───────────────────────────────────────────────┴────────────┴───────────────────────────┘\n\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\n\n-g or --state-on-error These flags will print the global state for any test failures. e.g., if we added the following (failing) test to the MyModule example:\n\nmodule 0x1::MyModule {\n    ...\n    #[test(a = @0x1)]\n    fun test_has_coin_bad(a: signer) {\n        publish_coin(&a);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n    }\n}\n\n\nwe would get get the following output when running the tests:\n\n$ mpm package test -g\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\n[ FAIL    ] 0x1::MyModule::test_has_coin_bad\n\nTest failures:\n\nFailures in 0x1::MyModule:\n\n┌── test_has_coin_bad ──────\n│ error[E11001]: test failure\n│    ┌─ /home/tzakian/TestExample/sources/MyModule.move:47:10\n│    │\n│ 44 │      fun test_has_coin_bad(a: signer) {\n│    │          ----------------- In this function in 0x1::MyModule\n│    ·\n│ 47 │          assert!(has_coin(@0x2), 1);\n│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here\n│\n│\n│ ────── Storage state at point of failure ──────\n│ 0x1:\n│       => key 0x1::MyModule::MyCoin {\n│           value: 1\n│       }\n│\n└──────────────────\n\nTest result: FAILED. Total tests: 4; passed: 3; failed: 1\n\nEdit this page\nPrevious\nMove test\nNext\nWrite Move integration test\nTesting Annotations: Their Meaning and Usage\nRunning Unit Tests\nExample\nRunning Tests\nUsing Test Flags\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Packages | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-language/packages/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nPackages\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMove LanguagePackages\nPackages\n\nPackages allow Move programmers to more easily re-use code and share it across projects. The Move package system allows programmers to easily:\n\nDefine a package containing Move code;\nParameterize a package by named addresses;\nImport and use packages in other Move code and instantiate named addresses;\nBuild packages and generate associated compilation artifacts from packages; and\nWork with a common interface around compiled Move artifacts.\nPackage Layout and Manifest Syntax​\n\nA Move package source directory contains a Move.toml package manifest file along with a set of subdirectories:\n\na_move_package\n├── Move.toml      (required)\n├── sources        (required)\n├── examples       (optional, test & dev mode)\n├── scripts        (optional)\n├── doc_templates  (optional)\n└── tests          (optional, test mode)\n\n\nThe directories marked required must be present in order for the directory to be considered a Move package and to be compiled. Optional directories can be present, and if so will be included in the compilation process. Depending on the mode that the package is built with (test or dev), the tests and examples directories will be included as well.\n\nThe sources directory can contain both Move modules and Move scripts (both transaction scripts and modules containing script functions). The examples directory can hold additional code to be used only for development and/or tutorial purposes that will not be included when compiled outside test or dev mode.\n\nA scripts directory is supported so transaction scripts can be separated from modules if that is desired by the package author. The scripts directory will always be included for compilation if it is present. Documentation will be built using any documentation templates present in the doc_templates directory.\n\nMove.toml​\n\nThe Move package manifest is defined within the Move.toml file and has the following syntax. Optional fields are marked with *, + denotes one or more elements:\n\n[package]\nname = <string>                  # e.g., \"MoveStdlib\"\nversion = \"<uint>.<uint>.<uint>\" # e.g., \"0.1.1\"\nlicense* = <string>              # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\nauthors* = [<string>]            # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"Jane Smith (janesmith@noemail.com)\"]\n\n[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph\n# One or more lines declaring named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., Std = \"_\" or Addr = \"0xC0FFEECAFE\"\n\n[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency\n# One or more lines declaring dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # local dependencies\n<string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash>, addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ } } # git dependencies\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev named addresses in the following format\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., Std = \"_\" or Addr = \"0xC0FFEECAFE\"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in \"dev\" and \"test\" modes\n# One or more lines declaring dev dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }\n\n\nAn example of a minimal package manifest with one local dependency and one git dependency:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\n\n\nAn example of a more standard package manifest that also includes the Move standard library and instantiates the named address Std from it with the address value 0x1:\n\n[package]\nname = \"AName\"\nversion = \"0.0.0\"\nlicense = \"Apache 2.0\"\n\n[addresses]\nAddressToBeFilledIn = \"_\"\nSpecifiedAddress = \"0xB0B\"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = \"projects/move-awesomeness\", addr_subst = { \"Std\" = \"0x1\" } }\n# Git dependency\nMoveStdlib = { git = \"https://github.com/diem/diem.git\", subdir=\"language/move-stdlib\", rev = \"56ab033cc403b489e891424a629e76f643d4fb6b\" }\n\n[dev-addresses] # For use when developing this module\nAddressToBeFilledIn = \"0x101010101\"\n\n\nMost of the sections in the package manifest are self explanatory, but named addresses can be a bit difficult to understand so it's worth examining them in a bit more detail.\n\nNamed Addresses During Compilation​\n\nRecall that Move has named addresses and that named addresses cannot be declared in Move. Because of this, until now named addresses and their values needed to be passed to the compiler on the command line. With the Move package system this is no longer needed, and you can declare named addresses in the package, instantiate other named addresses in scope, and rename named addresses from other packages within the Move package system manifest file. Let's go through each of these individually:\n\nDeclaration​\n\nLet's say we have a Move module in example_pkg/sources/A.move as follows:\n\nmodule NamedAddr::A {\n    public fun x(): address { @NamedAddr }\n}\n\n\nWe could in example_pkg/Move.toml declare the named address NamedAddr in two different ways. The first:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nNamedAddr = \"_\"\n\n\nDeclares NamedAddr as a named address in the package ExamplePkg and that this address can be any valid address value. Therefore an importing package can pick the value of the named address NamedAddr to be any address it wishes. Intuitively you can think of this as parameterizing the package ExamplePkg by the named address NamedAddr, and the package can then be instantiated later on by an importing package.\n\nNamedAddr can also be declared as:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nNamedAddr = \"0xCAFE\"\n\n\nwhich states that the named address NamedAddr is exactly 0xCAFE and cannot be changed. This is useful so other importing packages can use this named address without needing to worry about the exact value assigned to it.\n\nWith these two different declaration methods, there are two ways that information about named addresses can flow in the package graph:\n\nThe former (\"unassigned named addresses\") allows named address values to flow from the importation site to the declaration site.\nThe latter (\"assigned named addresses\") allows named address values to flow from the declaration site upwards in the package graph to usage sites.\n\nWith these two methods for flowing named address information throughout the package graph the rules around scoping and renaming become important to understand.\n\nScoping and Renaming of Named Addresses​\n\nA named address N in a package P is in scope if:\n\nIt declares a named address N; or\nA package in one of P's transitive dependencies declares the named address N and there is a dependency path in the package graph between between P and the declaring package of N with no renaming of N.\n\nAdditionally, every named address in a package is exported. Because of this and the above scoping rules each package can be viewed as coming with a set of named addresses that will be brought into scope when the package is imported, e.g., if the ExamplePkg package was imported, that importation would bring into scope the NamedAddr named address. Because of this, if P imports two packages P1 and P2 both of which declare a named address N an issue arises in P: which \"N\" is meant when N is referred to in P? The one from P1 or P2? To prevent this ambiguity around which package a named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a package are disjoint, and provide a way to rename named addresses when the package that brings them into scope is imported.\n\nRenaming a named address when importing can be done as follows in our P, P1, and P2 example above:\n\n[package]\nname = \"P\"\n...\n[dependencies]\nP1 = { local = \"some_path_to_P1\", addr_subst = { \"P1N\" = \"N\" } }\nP2 = { local = \"some_path_to_P2\"  }\n\n\nWith this renaming N refers to the N from P2 and P1N will refer to N coming from P1:\n\nmodule N::A {\n    public fun x(): address { @P1N }\n}\n\n\nIt is important to note that renaming is not local: once a named address N has been renamed to N2 in a package P all packages that import P will not see N but only N2 unless N is reintroduced from outside of P. This is why rule (2) in the scoping rules at the start of this section specifies a \"dependency path in the package graph between between P and the declaring package of N with no renaming of N.\"\n\nInstantiation​\n\nNamed addresses can be instantiated multiple times across the package graph as long as it is always with the same value. It is an error if the same named address (regardless of renaming) is instantiated with differing values across the package graph.\n\nA Move package can only be compiled if all named addresses resolve to a value. This presents issues if the package wishes to expose an uninstantiated named address. This is what the [dev-addresses] section solves. This section can set values for named addresses, but cannot introduce any named addresses. Additionally, only the [dev-addresses] in the root package are included in dev mode. For example a root package with the following manifest would not compile outside of dev mode since NamedAddr would be uninstantiated:\n\n[package]\nname = \"ExamplePkg\"\n...\n[addresses]\nNamedAddr = \"_\"\n\n[dev-addresses]\nNamedAddr = \"0xC0FFEE\"\n\nUsage, Artifacts, and Data Structures​\n\nThe Move package system comes with a command line option as part of the Move CLI move package <package_flags> <command> <command_flags>. Unless a particular path is provided, all package commands will run in the current working directory. The full list of commands and flags for the Move Package CLI can be found by running move package --help.\n\nUsage​\n\nA package can be compiled either through the Move CLI commands, or as a library command in Rust with the function compile_package. This will create a CompiledPackage that holds the compiled bytecode along with other compilation artifacts (source maps, documentation, ABIs) in memory. This CompiledPackage can be converted to an OnDiskPackage and vice versa -- the latter being the data of the CompiledPackage laid out in the file system in the following format:\n\na_move_package\n├── Move.toml\n...\n└── build\n    ├── <dep_pkg_name>\n    │   ├── BuildInfo.yaml\n    │   ├── bytecode_modules\n    │   │   └── *.mv\n    │   ├── source_maps\n    │   │   └── *.mvsm\n    │   ├── bytecode_scripts\n    │   │   └── *.mv\n    │   ├── abis\n    │   │   ├── *.abi\n    │   │   └── <module_name>/*.abi\n    │   └── sources\n    │       └── *.move\n    ...\n    └── <dep_pkg_name>\n        ├── BuildInfo.yaml\n        ...\n        └── sources\n\n\nSee the move-package crate for more information on these data structures and how to use the Move package system as a Rust library.\n\nEdit this page\nPrevious\nMove Language\nNext\nUnderstanding abilities\nPackage Layout and Manifest Syntax\nMove.toml\nNamed Addresses During Compilation\nDeclaration\nScoping and Renaming of Named Addresses\nInstantiation\nUsage, Artifacts, and Data Structures\nUsage\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Verify Smart Contract: Move Prover Tutorials | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-prover/mvp-tutorial/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nMove Specification Language\nVerify Smart Contract: Move Prover Tutorials\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMove Specification Language and Move ProverVerify Smart Contract: Move Prover Tutorials\nVerify Smart Contract: Move Prover Tutorials\nWhat is Move Prover​\n\nFormal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems. Now it has certain applications in the fields of operating systems, compilers and other fields that require high correctness.\n\nSmart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical. Move Prover (MVP) is designed to prevent bugs in smart contracts written in the Move language. Users can specify functional properties of smart contracts using the Move Specification Language (MSL), and then use Move Prover to automatically and statically inspect them.\n\nSimply put, there can be two components in a Move file:\n\nPart of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, functions.\n\nThe other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.\n\nWhen we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and give other users confidence in the properties of the program that has been verified.\n\nInstall Prover dependencies​\n\nBefore using Move Prover, let's install some of its external dependencies. It is assumed that you already have a copy of the Starcoin source code and have built the project. We switch to the root directory of Starcoin and run the following command:\n\ncd $PATH_TO_STARCOIN\n./scripts/dev_setup.sh -ypt\nsource ~/.profile\n\n\nWhen the above command is executed, enter boogie /version, if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently Move Prover can only run under UNIX-based operating systems (such as Linux, macOS). Windows users can run it by installing WSL.\n\nPrepare an example for verification​\nProject creation​\n\nFirst, let's create a new empty Move package:\n\nmpm package new BasicCoin\n\n\nYou can see that its directory structure is as follows:\n\nBasicCoin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n\nModule code​\n\nNow create BasicCoin/sources/BasicCoin.move.\n\nBasicCoin.move content\n\nHere we assume that you have a certain grasp of the Move language, and can understand the source code of BasicCoin.move above and know the function of each part.\n\nTOML configuration​\n\nBasicCoin uses some facilities of the Starcoin standard library, and also needs to add StarcoinFramework to the dependencies. At the same time, the named address is used in BasicCoin, and we also need to specify what numerical address it should be replaced with. Therefore, we modify Move.toml as follows:\n\n[package]\nname = \"BasicCoin\"\nversion = \"0.0.0\"\n\n[addresses]\nNamedAddr = \"0xcafe\"\n\n[dependencies]\nStarcoinFramework = { git = \"https://github.com/starcoinorg/starcoin-framework\", rev=\"01c84198819310620f2417413c3c800df8292ae5\" }\n\nThe first verification code​\n\nTo give us a first impression of the use of Move Prover, add the following code snippet to BasicCoin.move:\n\nspec balance_of {\n    pragma aborts_if_is_strict;\n}\n\n\nSyntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the balance_of function in order to clearly see the correspondence between the definition and the specification when reading the code.\n\nSimply put, the spec balance_of {...} block will contain our property specification for the balance_of function. There are many types of property specifications, some common examples are:\n\nWill this function abort? Under what circumstances does it abort?\nWhat conditions must be met for the parameters to call this function?\nWhat is the return value of this function?\nAfter the function is executed, how will the state of the virtual machine be changed?\nWhat invariants does this function maintain?\n\nFor example, Move Prover allows all possible aborts by default when we don't give any abort conditions. And in the simple snippet above, we tell Prover with the directive aborts_if_is_strict:\n\nI would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.\n\nNow, we run the prove command in the BasicCoin directory:\n\nmpm package prove\n\n\nmpm will call Move Prover to check the code in the package. Then we can see the Prover reporting the following error message:\n\nerror: abort not covered by any of the `aborts_if` clauses\n   ┌─ ./sources/BasicCoin.move:38:5\n   │\n35 │           borrow_global<Balance<CoinType>>(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of {\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     }\n   │ ╰─────^\n   │\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nError: exiting with verification errors\n\n\nProver's output tells us that it found a situation where the balance_of function aborts, but we don't explicitly point out the possibility of such aborts. Looking at the code that triggers the abort, we can see that the exception is caused by calling the built-in borrow_global function when the owner does not own a resource of type Balance<CoinType>. Following the guidance of the error message, we can add the following aborts_if condition:\n\nspec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n\n\nAfter adding this condition, try calling Prover again and see that there are no more validation errors. Now we can confidently confirm that the balance_of function has one and only one possibility of abnormal termination, that is, the parameter owner does not own a resource of type Balance<CoinType>.\n\nVerify withdraw function​\n\nThe signature of the function withdraw is as follows:\n\nfun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n\n\nIts role is to withdraw the amount of coins from the address addr and return it.\n\nSpecify the abort condition for widthdraw​\n\nThere are two possibilities for withdraw to abort:\n\nNo resource of type Balance<CoinType> in addr.\nThe balance in addr is less than amount.\n\nFrom these, we can define the abort condition like this:\n\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n\nA spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly. global<T>(addr): T is a built-in function that returns a resource of type T at address addr. Here, we set balance to the number of tokens owned by addr via the let binding;\nexists<T>(address): bool is a built-in function that returns true if resource T exists at address addr; otherwise returns false.\n\nThe two lines of aborts_if statements correspond to the two conditions mentioned above. In general, if a function has multiple aborts_if conditions, the conditions are ORed together.\n\nAs mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts. But once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction pragma aborts_if_is_strict. If only some of the conditions for abnormal exit are listed, the Prover will report a validation error. However, if the pragma aborts_if_is_partial is defined in the spec block, this is equivalent to telling the Prover:\n\nI just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.\n\nIf you are interested, you can do such a set of experiments to verify:\n\nWhen deleting any of the above two aborts_if conditions, Prover will report an error;\nWhen all aborts_if conditions are deleted at the same time, Prover will not report an error;\nWhen adding pragma aborts_if_is_partial, no matter how many aborts_if conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).\n\nSome readers may be curious about the order of the three statements in the spec block: Why the definition of balance can be written after aborts_if !exists<Balance<CoinType>>(addr). Because, if the latter holds true, balance does not actually exist. Wouldn't this order cause the Prover to fail? Simply put: no, the statements in the spec block are declarative and the order doesn't matter.\n\nFor a more detailed understanding, you can refer to the MSL documentation for more information.\n\nSpecify the functional nature of withdraw​\n\nNext we define functional properties. The two ensures statements in the following spec block give us what we expect from the widthdraw functionality:\n\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n\n\nIn this code, first by using let post binding, define balance_post as the balance of addr after the function is executed, it should be equal to balance - amount. Then, result is a special name that represents the return value, which should be the amount of tokens.\n\nVerify the deposit function​\n\nThe signature of the function deposit is as follows:\n\nfun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n\n\nIt deposits the token funds indicated by check into the address addr. Its canonical definition is as follows:\n\nspec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n\n\nHere, balance is defined as the balance in addr before the function is executed, and check_value is defined as the amount of tokens to be deposited. It will abort in two cases:\n\nThere is no resource of type Balance<CoinType> in addr;\nOr the sum of balance and check_value is greater than the maximum value of type u64.\n\nThe ensures statement is used to let the Prover make sure that in any case, the balance in addr can be updated correctly after the function is executed.\n\nThe syntax mentioned earlier will not be repeated here. Astute readers may have noticed that it is worth noting that the expression balance + check_value > MAX_U64 is problematic in the Move program. Because the addition on the left may cause an overflow exception. If we want to write a similar check in the Move program, we should use an expression like balance > MAX_U64 - check_value to avoid the overflow problem.\n\nHowever, this expression is perfectly fine in the Move Specification Language (MSL). Since the spec block uses the MSL language, its type system is different from that of Move. In MSL, all integers are of type num, which is an integer in the mathematical sense. That is, it is signed and has no size limit. All built-in integer types (u8, u64, etc.) are automatically converted to type num when referencing data in a Move program in MSL. A more detailed description of the type system can be found in the MSL documentation.\n\nVerify the transfer function​\n\nThe signature of the function transfer is as follows:\n\npublic fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n\n\nIt is responsible for the transfer from the account from to the address to, and the transfer amount is amount.\n\nLet's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:\n\nspec transfer {\n    let addr_from = Signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n\n\nHere from is of type signer, not a direct address. Although in the program we have created a local variable called addr_from, we cannot directly reference it in the spec block. At the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to addr_from again. Then use let and let post to define several variables, corresponding to the balances in the two addresses addr_from and to before and after the function is executed. Finally, use the ensures statement to tell Prover that the balance in from should be subtracted by amount; the balance in to should be increased by amount.\n\nAt first glance, there seems to be no problem at all. But is it really so? Let's see if Prover thinks this is \"the correct description of the behavior of this function\". After typing mpm package prove you can see:\n\nerror: post-condition does not hold\n   ┌─ ./sources/BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post == balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n\n\nIt is somewhat out of our expectation. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the transfer function. Why is this so? Let's look down again: the parameters that make the postconditions are not satisfied are from = signer{0x0} and to = 0x0. We should know the reason: when the account transfers money to itself, both to and from point to the same address, so the balance does not change.\n\nThere are two solutions now:\n\nPlan A does not modify the function definition, but changes the specification. In the spec block, consider whether the two accounts for the transfer and receiving are the same address.\n\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n\n\nOr use another slightly more intuitive if syntax:\n\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n\n\nNote that if (P) E1 else E2 is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to ensures both P ==> E1 and !P ==> E2. And p ==> q is actually !p || q.\n\nThat is to say, the end of the second way of writing actually represents this logic:\n\nensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n\n\nthat is:\n\nensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n\n\nInterested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former (addr_from == to && eq_post) || (addr_from != to && ne_post) and the latter (addr_from != to || eq_post) && (addr_from == to || ne_post) are actually exactly equivalent expressions.\n\nPlan B does not modify the spec, but directly adds assert!(from_addr != to, EEQUAL_ADDR) in the function body, and adds the definition of the error code EEQUAL_ADDR in front, so that the self-transfer transaction cannot be completed.\n\nObviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction. So plan B is a better practice. It directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.\n\npractice​\n\nCurrently we have only completed functional verification of the transfer function. But it doesn't say under what circumstances it will abort. As an exercise, give it an appropriate aborts_if condition. The answer can be found in later chapters. TODO\n\nVerify mint function​\n\nThe signature of the function mint is as follows:\n\npublic fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n\n\nIt is responsible for minting the amount of tokens and depositing them in the address mint_addr. More interesting is _witness, which is of type CoinType. Because only the module that defines the CoinType can construct a value of this type, this guarantees the identity of the caller.\n\nThere is actually only one call to deposit in the mint function. It is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:\n\nspec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n\nVerify the publish_balance function​\n\nThe signature of the function publish_balance is as follows:\n\npublic fun publish_balance<CoinType>(account: &signer)\n\n\nIt publishes an empty Balance<CoinType> resource under account. So if the resource already exists it should exit abnormally, and end normally the balance should be zero:\n\nspec publish_balance {\n    let addr = Signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n\nSimplify redundant specification with Schema​\n\nCongratulations! So far, we have completed the verification of all the functions of BasicCoin step by step. However, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.\n\nSchema is a means of building a specification by grouping properties. Semantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.\n\nEliminate simple repetitions​\n\nAs a most obvious example, the spec blocks of mint and deposit are a little different except for the variable names (in terms, they are alpha convertible), and the overall structure can be said to be exactly the same. To simplify them, let's create a Schema:\n\nspec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n\n\nThis Schema declares two typed variables, and some conditions about what those variables should satisfy. When other places want to use this Schema, use include DepositSchema {addr: XX, amount: YY} to import it. where XX and YY are expressions used to replace addr and amount. If the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.\n\nWith the above Schema definition, we can now simplify the previous spec:\n\nspec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n\nSchema composition​\n\nSchema can not only eliminate the above almost the same repetition, but also can be combined to form a more complex specification.\n\nIf you experimented and completed the exercises through each step of the tutorial, the spec for your tranfer function should now look something like this:\n\n// initial version\nspec transfer {\n    let addr_from = Signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr_from);\n    aborts_if !exists<Balance<CoinType>>(to);\n    aborts_if balance_from < amount;\n    aborts_if balance_to + amount > MAX_U64;\n    aborts_if addr_from == to;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n\n\nAlthough it is relatively complicated, it is not difficult to see after a little analysis that it actually combines the two logics of withdraw and deposit. This can also be analyzed from the calling relationship of transfer.\n\nIn the previous step, we already have DepositSchema. Now, let's refactor the validation specification for withdraw: extract it into a Schema, and a spec block that uses the Schema:\n\nspec withdraw {\n    include WithdrawSchema<CoinType>;\n    ensures result == Coin<CoinType> { value: amount };\n}\n\nspec schema WithdrawSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n}\n\n\nWith these two schemas, we can easily rewrite the validation specification of transfer:\n\n// After refactoring with Schema\nspec transfer {\n    let addr_from = Signer::address_of(from);\n\n    include WithdrawSchema<CoinType> { addr: addr_from };\n    include DepositSchema<CoinType> { addr: to };\n\n    aborts_if addr_from == to;\n}\n\n\nhow about it? Compared with the original version, it is much simpler and clearer now.\n\npractice​\n\nIn addition to the above example, find another spec block (such as publish_balance), and split it into a Schema declaration and a spec block that uses the corresponding Schema. As an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's much benefit to it. But if in the later development, there are other functions that call publish_balance, it will be more convenient.\n\nEdit this page\nPrevious\nMove Specification Language\nNext\nHow to Dapp\nWhat is Move Prover\nInstall Prover dependencies\nPrepare an example for verification\nProject creation\nModule code\nTOML configuration\nThe first verification code\nVerify withdraw function\nSpecify the abort condition for widthdraw\nSpecify the functional nature of withdraw\nVerify the deposit function\nVerify the transfer function\npractice\nVerify mint function\nVerify the publish_balance function\nSimplify redundant specification with Schema\nEliminate simple repetitions\nSchema composition\npractice\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move prover | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-prover/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nMove Specification Language\nVerify Smart Contract: Move Prover Tutorials\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMove Specification Language and Move Prover\nMove prover\nEdit this page\nPrevious\nHow to handle the mapping requirement\nNext\nMove Specification Language\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Advanced Move | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/advance-move/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nHow to design permission system with Capability\nHow to handle the mapping requirement\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentAdvance Move Development\nAdvanced Move\nEdit this page\nPrevious\nCreate a new NFT\nNext\nHow to design permission system with Capability\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move examples | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-examples/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nCreate a new Token\nCreate a new NFT\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMore Move Examples\nMove examples\nEdit this page\nPrevious\nMove VM, Bytecode, and Disassembler\nNext\nCreate a new Token\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move test | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-test/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nUnit Tests\nWrite Move integration test\nHow to debug Move module and troubleshooting\nMove VM, Bytecode, and Disassembler\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to test Move Module\nMove test\nEdit this page\nPrevious\nModify and Drop Resource in MoveVM\nNext\nUnit Tests\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "README | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-vm/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nMove VM\nCreate Resource in MoveVM\nModify and Drop Resource in MoveVM\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentREADME\nREADME\n\nMove VM 原理分析\n\nEdit this page\nPrevious\nHow to call a function\nNext\nMove VM\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "How to call a function | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/call-function/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to call a function\nHow to call a function\n\nIn the Quick Start tutorial, we experimented with how to call script functions. So how to call ordinary functions?\n\nNext, a small example will show how to call ordinary functions.\n\nProgram source code​\nmodule MyAddr::EthSigVerifier {\n   use StarcoinFramework::Signature;\n   use StarcoinFramework::EVMAddress::{Self, EVMAddress};\n   use StarcoinFramework::Option::{Self, Option};\n\n\n   public fun verify_eth_sig(signature: vector<u8>, addr: vector<u8>, message: vector<u8>) : bool{\n      let receover_address_opt:Option<EVMAddress>  = Signature::ecrecover(message, signature);\n      let expect_address =  EVMAddress::new(addr);\n      &Option::destroy_some<EVMAddress>(receover_address_opt) == &expect_address\n   }\n\n   #[test]\n   public fun verify_eth_sig_test(){\n      let signature = x\"90a938f7457df6e8f741264c32697fc52f9a8f867c52dd70713d9d2d472f2e415d9c94148991bbe1f4a1818d1dff09165782749c877f5cf1eff4ef126e55714d1c\";\n      let msg_hash = x\"b453bd4e271eed985cbab8231da609c4ce0a9cf1f763b6c1594e76315510e0f1\";\n      let address_bytes = x\"29c76e6ad8f28bb1004902578fb108c507be341b\";\n      assert!(verify_eth_sig(signature, address_bytes, msg_hash), 101);\n   }\n}\n\ntest/Move.toml\n[package]\nname = \"did\"\nversion = \"0.0.1\"\n\n[addresses]\nStarcoinFramework = \"0x1\"\n\nMyAddr = \"0x68a0e9bab71d6493456432a676a4a915\"\n\n\n[dependencies]\nStarcoinFramework = {git = \"https://github.com/starcoinorg/starcoin-framework.git\", rev=\"cf1deda180af40a8b3e26c0c7b548c4c290cd7e7\"}\n\n\nNote that replace the MyAddr field with the address where you actually deployed the contract.\n\nCompile and deploy the contract​\nPackaging modules\n$ mpm release\n\nPackaging Modules:\n         0x68a0e9bab71d6493456432a676a4a915::EthSigVerifier\nRelease done: release/test.v0.0.0.blob, package hash: 0x7cf72e1b608844086ad90bd703173fafe0bdc917d8374c078fbd4408a4074312\n\nUnlock account\nstarcoin% account unlock 0x68a0e9bab71d6493456432a676a4a915 -p <MY-PASSWORD>\n\nDeploy the module in the Starcoin console\nstarcoin% dev deploy /home/ubuntu/i/m-pra/test/release/test.v0.0.0.blob -s 0x68a0e9bab71d6493456432a676a4a915 -b\n\ntxn 0xfd4775eaecd962dcfa3197bd5ba954226243fdf97a112116630c58935ea970e1 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"7800\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n......\n\nCall function​\nstarcoin% dev call --function 0x68a0e9bab71d6493456432a676a4a915::EthSigVerifier::verify_eth_sig --arg x\"90a938f7457df6e8f741264c32697fc52f9a8f867c52dd70713d9d2d472f2e415d9c94148991bbe1f4a1818d1dff09165782749c877f5cf1eff4ef126e55714d1c\" --arg x\"29c76e6ad8f28bb1004902578fb108c507be341b\" --arg x\"b453bd4e271eed985cbab8231da609c4ce0a9cf1f763b6c1594e76315510e0f1\"\n\n{\n  \"ok\": [\n    true\n  ]\n}\n\nCall functions via RPC​\n\nAfter publishing to the chain, we can call it through the API interface or SDK.\n\nUse the curl command to call the function remotely:\n\n$ curl 'http://localhost:9850/' -H 'content-type: application/json' --data-raw '{\"jsonrpc\":\"2.0\",\"method\":\"contract.call_v2\",\"params\":[{\"function_id\":\"0x68a0e9bab71d6493456432a676a4a915::EthSigVerifier::verify_eth_sig\",\"args\":[\"x\\\"90a938f7457df6e8f741264c32697fc52f9a8f867c52dd70713d9d2d472f2e415d9c94148991bbe1f4a1818d1dff09165782749c877f5cf1eff4ef126e55714d1c\\\"\",\"x\\\"29c76e6ad8f28bb1004902578fb108c507be341b\\\"\",\"x\\\"b453bd4e271eed985cbab8231da609c4ce0a9cf1f763b6c1594e76315510e0f1\\\"\"],\"type_args\":[]}],\"id\":0}'\n\n{\"jsonrpc\":\"2.0\",\"result\":[true],\"id\":0}\n\nSummary​\n\nThe Starcoin console command used to call a normal function is dev call --function, and the Starcoin console command to call a script function is account execute-function --function.\n\nEdit this page\nPrevious\nFor solidity developer\nNext\nREADME\nProgram source code\nCompile and deploy the contract\nCall function\nCall functions via RPC\nSummary\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "For solidity developer | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/for-solidity-developer/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentFor solidity developer\nFor solidity developer\n\nTODO\n\nCompare Move and Solidity\nhttps://starcoin.org/en/developer/blog/move_vs_solidity_1/\nhttps://starcoin.org/zh/developer/blog/move_vs_solidity_1/\nCross Contract call\nUpgrade\n\nPart of\n\nhttps://starcoin.org/en/developer/blog/starcoin_code_is_law/\nhttps://starcoin.org/zh/developer/blog/starcoin_code_is_law/\nEdit this page\nPrevious\nHow to upgrade Move Module\nNext\nHow to call a function\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "How to upgrade Move Module | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/how-to-upgrade/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to upgrade Move Module\nHow to upgrade Move Module\nNOTE\n\nTODO\n\nIntroduce the Compatibility requirement\nIntroduce upgrade strategy\nSuggestion to keep Compatibility and How to force upgrade\nHot to delegate UpgradeCapability to DAO\nGive an example for upgrade module\n\nMigrate and Rewrite\n\nhttps://starcoin.org/en/developer/blog/starcoin_stdlib_upgrade/\nhttps://starcoin.org/zh/developer/blog/starcoin_stdlib_upgrade/\n\nPart of\n\nhttps://starcoin.org/zh/developer/blog/starcoin_code_is_law/\nhttps://starcoin.org/zh/developer/blog/starcoin_code_is_law/\nFAQ​\n\nCan third-party contract incompatible upgrade be implemented without Dao?\n\nIncompatible upgrades can be achieved through a two-stage commit upgrade, but the current command line does not yet support direct two-stage upgrades.\n\nWhat if BACKWARD_INCOMPATIBLE_MODULE_UPDATE error occurs when redeploying tokenswap?\n\nError due to incompatibility between front and back，add the --ignore-breaking-changes parameter and rerun.\n\nIs there a way to force deploy module?\n\nWithout considering compatibility, the deploy module can be submitted in two phases.\n\nEdit this page\nPrevious\nUnderstanding module dependency\nNext\nFor solidity developer\nFAQ\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Understanding module dependency | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/module-dependency/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentUnderstanding module dependency\nUnderstanding module dependency\n\nTODO\n\nmodule dependency\ncross contract module dependency\nEdit this page\nPrevious\nInteracting with the contract by CLI\nNext\nHow to upgrade Move Module\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Interacting with the contract by CLI | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/interacting-with-the-contract/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentInteracting with the contract by CLI\nInteracting with the contract by CLI\n\nThis article guides you on how to interact with the contract.\n\nIn this article, you will learn:\n\nread to contract\nwrite to contract\nview resource\n\nFirst deploy the MyCounter module as described in Deploy your first Move contract .\n\nCall init_counter script function to init resource.\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::init_counter -s 0xb19b07b76f00a8df445368a91c0547cc -b\ntxn 0x0f67bab5ee5ceeb9c2fe4ffeed9ab6b79f2869e922862ec40dba8aa7787709b1 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"11667\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 23334\n                }\n              },\n              \"raw\": \"0x265b0000000000000000000000000000\"\n            }\n          }\n        },\n  .....\n  .....\n}\n\nShow resource.\nstarcoin% state get resource 0xb19b07b76f00a8df445368a91c0547cc 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::Counter\n{\n  \"ok\": {\n    \"json\": {\n      \"value\": 0\n    },\n    \"raw\": \"0x0000000000000000\"\n  }\n}\n\nCall incr_counter to increment counter.\nstarcoin% account execute-function --function 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::incr_counter -s 0xb19b07b76f00a8df445368a91c0547cc -b\ntxn 0x7e8d6189c144c7640cbd79617247c0e242f52df6d60c74c29250492077b1b690 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"17231\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 34462\n                }\n              },\n              \"raw\": \"0x9e860000000000000000000000000000\"\n            }\n          }\n        },\n    ......\n    ......\n}\n\nShow resource again.\nstarcoin% state get resource 0xb19b07b76f00a8df445368a91c0547cc 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::Counter\n{\n  \"ok\": {\n    \"json\": {\n      \"value\": 1\n    },\n    \"raw\": \"0x0100000000000000\"\n  }\n}\n\n\nYou can see the counter’s value is 1 now.\n\nUse another account to init and incr counter again.\n\nSay the new account address is 0x0da41daaa9dbd912647c765025a12e5a .\n\nstarcoin% account execute-function -s 0x0da41daaa9dbd912647c765025a12e5a  --function 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::init_counter -b\nstarcoin% contract get resource 0x0da41daaa9dbd912647c765025a12e5a 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::Counter\nstarcoin% account execute-function -s 0x0da41daaa9dbd912647c765025a12e5a  --function 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::incr_counter -b\nstarcoin% contract get resource 0x0da41daaa9dbd912647c765025a12e5a 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::Counter\n\nNOTE\n\nTODO\n\nwatch events\nEdit this page\nPrevious\nHow to deploy Move smart contracts\nNext\nUnderstanding module dependency\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "How to deploy Move smart contracts | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/deploy-first-move-contract/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentHow to deploy Move smart contracts\nHow to deploy Move smart contracts\n\nIn the quick start, I believe you have understood the whole process of writing, compiling and deploying smart contracts.\n\nIn this article, the deployment of smart contracts will be explained in more detail.\n\nBackground​\n\nMove language is a domain-specific language (DSL) developed by Meta (formerly Facebook) for the Libra project (later renamed Diem). As a smart contract programming language for resource-oriented programming, the Move language undoubtedly injects new vitality into blockchain technology. Starcoin blockchain is the first public chain to use the Move language. As a contributor and beneficiary of the Move language, Starcoin has been working hard to build the Move ecology.\n\nAlthough Diem ended up due to some irresistible factors, a batch of advanced technologies born in the process have undoubtedly injected new vitality into the Web3 world. Many technicians who are enthusiastic about blockchain technology and look forward to the beautiful world of Web3 have rushed to a new voyage. Using the open source technology left by Diem blockchain, they have built two new public chains Aptos and Sui based on Move language to write smart contracts (It is currently in the test network stage.).\n\nStarcoin, Aptos and Sui, the three major public chains in the Move ecology, are emitting and heating the Move ecology with the momentum that the spark can start a prairie fire.\n\nThe importance of deploying smart contracts​\n\nThe development of blockchain technology has gone through two stages. Bitcoin (BTC) has opened the blockchain 1.0 era, and Ethereum (ETH) has opened the blockchain 2.0 era. The emergence of Ethereum has brought the key technology of smart contracts to blockchain, so that blockchain not only stays at the purpose of bookkeeping, but also brings more application expansion. Unfortunately, smart contracts are like a double-edged sword, which not only brings many rich functional expansions, but also makes it easy for smart contract developers to inadvertently introduce unsafe code and threaten the assets of the chain.\n\nI think writing simple, safe and deployable smart contracts should be the focus of the blockchain 3.0 era. The Move language for resource-oriented programming undoubtedly provides a good solution to this problem.\n\nDeploying smart contracts is almost the most basic function of every smart chain. Next, we will introduce in detail how to deploy contracts in the Starcoin blockchain.\n\nPreparations​\n\nThrough this article, you will learn:\n\nHow to set up working directories and configuration files for Move project development;\nHow to package (compile) a Move module;\nHow to deploy compiled binaries to the Starcoin blockchain.\n\nFirst of all, start a dev network node according to the description of How to set up a local dev network. And get some test tokens of the dev network for the account and unlock the account. The address 0xb19b07b76f00a8df445368a91c0547cc is used as the account address for deploying smart contracts.\n\nstarcoin% dev get-coin 0xb19b07b76f00a8df445368a91c0547cc\n\nContract Codes​\n\nThis is a counter contract with functions such as creating counters and incremental counters. For details, please refer to the introduction in Quick Start.\n\nProject structure:\n\n.\n├── Move.toml\n└── sources\n    └── MyCounter.move\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n     use StarcoinFramework::Signer;\n\n     struct Counter has key, store {\n        value:u64,\n     }\n     public fun init(account: &signer){\n        move_to(account, Counter{value:0});\n     }\n     public fun incr(account: &signer) acquires Counter {\n        let counter = borrow_global_mut<Counter>(Signer::address_of(account));\n        counter.value = counter.value + 1;\n     }\n\n     public(script) fun init_counter(account: signer){\n        Self::init(&account)\n     }\n\n     public(script) fun incr_counter(account: signer)  acquires Counter {\n        Self::incr(&account)\n     }\n}\n\nmy-counter/Move.toml\n[package]\nname = \"my_counter\"\nversion = \"0.0.1\"\n\n[addresses]\nStarcoinFramework = \"0x1\"\n\nMyCounterAddr = \"0xb19b07b76f00a8df445368a91c0547cc\"\n\n\n[dependencies]\nStarcoinFramework = {git = \"https://github.com/starcoinorg/starcoin-framework.git\", rev=\"cf1deda180af40a8b3e26c0c7b548c4c290cd7e7\"}\n\n\nThe Move.toml file and sources directory is the basic structure of the Move project directory.\n\nDeployment process​\n\nAll right, let's get started now!\n\nModify the contract address\n\nSmart contracts are deployed under an account, so the value of MyCounterAddr in the Move.toml file needs to be modified to your actual account address. Take 0xb19b07b76f00a8df445368a91c0547cc as an example.\n\nCompilation module\n$ mpm release\n\nPackaging Modules:\n         0xb19b07b76f00a8df445368a91c0547cc::MyCounter\nRelease done: release/my-counter.v0.0.0.blob, package hash: 0x3be68089a746a7a3d1aaf2e0282a7c73f3724e07d19dbdd5d5514f01ace9a662\n\n\nThe command will compile the module and generate a binary package release/my-counter.v0.0.1.blob.\n\nTip: Use the pwd command to determine the absolute path of the contract, which is convenient for deployment in the Starcoin console.\n\nUnlock the account\nstarcoin% account unlock 0xb19b07b76f00a8df445368a91c0547cc -p <MY-PASSWORD>\n\nDeploy to blockchain\n\nAt present, there are two command-line tools that can deploy Move binaries to the blockchain:\n\nIt is mpm deploy and starcoin% dev deploy respectively.\n\nmpm deploy\n\nThe deployment module requires an account signature, and the mpm deploy command supports three account modes: 1) local wallet; 2) private key files; and 3) environment variables.\n\nThe corresponding commands of the three account modes are as follows:\n\n$ mpm deploy --rpc ws://127.0.0.1:9871 --local-account-dir /your/local/account/dir --password xxxxx /your/dev/path/my-counter/release/my-counter.v0.0.1.blob\n\n$ mpm deploy --rpc ws://127.0.0.1:9871 --secret-file /your/secret/file /your/dev/path/my-counter/release/my-counter.v0.0.1.blob\n\n$ mpm deploy --rpc ws://127.0.0.1:9871 --from-env /your/dev/path/my-counter/release/my-counter.v0.0.1.blob\n\n\nIf you want to deploy the module to the Barnard test network or the Main network, just specify the --rpc option as the corresponding RPC address.\n\nsecret-file is a local file that stores the private key, which contains only one line of private keys, no other prefixes and suffixes.\n\nThe key value of the environment variable is STARCOIN_PRIVATE_KEY\n\nstarcoin% dev deploy\n\nIn Starcoin console mode, run the command:\n\nstarcoin% dev deploy /your/dev/path/my-counter/release/my-counter.v0.0.1.blob -s 0xb19b07b76f00a8df445368a91c0547cc -b\n\ntxn 0xeb055894f0c4440608246825c238a36683a8a0ad57144e905a12398a02ce806b submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"7800\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 292331\n                }\n              },\n              \"raw\": \"0xeb750400000000000000000000000000\"\n            }\n          }\n        },\n  .....\n  ....\n}\n\n\nWhether to deploy directly on the command line with the mpm deploy command or with the Starcoin console, it is mainly selected according to personal preferences or convenience.\n\nEdit this page\nPrevious\nOracle protocol\nNext\nInteracting with the contract by CLI\nBackground\nThe importance of deploying smart contracts\nPreparations\nContract Codes\nDeployment process\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Starcoin Move Framework | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/starcoin-framework/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nAccount\nContract Account and SignerDelegated\nConfig\nToken standard\nNFT standard\nDAO\nOracle protocol\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentStarcoin Move Framework\nStarcoin Move Framework\nNOTE\n\nTODO\n\nintroduce starcoin Move framework overview\nEdit this page\nPrevious\nUser Guide of Move Package Manager\nNext\nAccount\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "User Guide of Move Package Manager | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-package-manager/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentUser Guide of Move Package Manager\nUser Guide of Move Package Manager\n\nMove Package Manager(mpm) is a command line tool to develop move projects, like Cargo for Rust, or NPM for NodeJS.\n\nIt integrates the latest move pacakge system introduced in move-language/move, and reuse most functionality of move-cli by diem. Before dive into this tutorial, please read the pacakge section of move book first. Understanding how move package work is a prerequest.\n\nInstallation​\n\nDownload from the release page of starcoiorg/starcoin.\n\nOr use:\n\ncargo install --git https://github.com/starcoinorg/starcoin move-package-manager --bin mpm\n\nOverview​\njoe@MX:~$ mpm\nmove-package-manager 1.11.7-rc\nStarcoin Core Dev <dev@starcoin.org>\nCLI frontend for the Move compiler and VM\n\nUSAGE:\n    mpm [OPTIONS] <SUBCOMMAND>\n\nOPTIONS:\n        --abi                          Generate ABIs for packages\n    -d, --dev                          Compile in 'dev' mode. The 'dev-addresses' and 'dev-\n                                       dependencies' fields will be used if this flag is set. This\n                                       flag is useful for development of packages that expose named\n                                       addresses that are not set to a specific value\n        --doc                          Generate documentation for packages\n        --force                        Force recompilation of all packages\n    -h, --help                         Print help information\n        --install-dir <INSTALL_DIR>    Installation directory for compiled artifacts. Defaults to\n                                       current directory\n    -p, --path <PACKAGE_PATH>          Path to a package which the command should be run with\n                                       respect to [default: .]\n        --test                         Compile in 'test' mode. The 'dev-addresses' and 'dev-\n                                       dependencies' fields will be used along with any code in the\n                                       'test' directory\n    -v                                 Print additional diagnostics if available\n    -V, --version                      Print version information\n\nSUBCOMMANDS:\n    check-compatibility    Check compatibility of modules comparing with remote chain chate\n    experimental           (Experimental) Run static analyses on Move source or bytecode\n    help                   Print this message or the help of the given subcommand(s)\n    integration-test       Run integration tests in tests dir\n    package                Execute a package command. Executed in the current directory or the\n                               closest containing Move package\n    release                Release the package\n    sandbox                Execute a sandbox command\n\n\nmpm is a convenient wrapper and superset of move-cli.\n\nWhat applies to move-cli is also applied to mpm.\n\nSo, We recommend you to go through the (https://github.com/move-language/move/tree/main/language/documentation/tutorial) written by move-language.\n\nIn that tutorial, you can add an alias alias move=\"mpm\" so that you can invoke move as it is.\n\nYou can check that it is working by running the following command:\n\nmove package -h\n\nmpm-package 0.1.0\nExecute a package command. Executed in the current directory or the closest containing Move package\n\nUSAGE:\n    mpm package [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n    -d, --dev        Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if this flag\n                     is set. This flag is useful for development of packages that expose named addresses that are not\n                     set to a specific value\n        --force      Force recompilation of all packages\n        --abi        Generate ABIs for packages\n        --doc        Generate documentation for packages\n    -h, --help       Prints help information\n        --test       Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used along with\n                     any code in the 'test' directory\n    -V, --version    Prints version information\n    -v               Print additional diagnostics if available\n\nOPTIONS:\n        --install-dir <install-dir>    Installation directory for compiled artifacts. Defaults to current directory\n    -p, --path <package-path>          Path to a package which the command should be run with respect to [default: .]\n\nSUBCOMMANDS:\n    build          Build the package at `path`. If no path is provided defaults to current directory\n    coverage       Inspect test coverage for this package. A previous test run with the `--coverage` flag must have\n                   previously been run\n    disassemble    Disassemble the Move bytecode pointed to\n    errmap         Generate error map for the package and its dependencies at `path` for use by the Move explanation\n                   tool\n    help           Prints this message or the help of the given subcommand(s)\n    info           Print address information\n    new            Create a new Move package with name `name` at `path`. If `path` is not provided the package will\n                   be created in the directory `name`\n    prove          Run the Move Prover on the package at `path`. If no path is provided defaults to current\n                   directory. Use `.. prove .. -- <options>` to pass on options to the prover\n    test           Run Move unit tests in this package\n\nSpec Test​\n\nBased on move-cli, mpm add the support of integration test to test your move project in the whole.\n\nIt can simulates:\n\naccount initialization.\nblock generation.\nmodule publishing.\nexecute scripts or script function.\n\nAll actions are wrapped into transactions.\n\nAll integration test files should be in integration-tests dir under the package root path.\n\nspec test file contains test directives seperated by empty newlines.\n\ndirectives works like a command line, you provide command name and command arguments, and move pacakge manager executes the directives like OS executes cli commands.\n\n$ mpm integration-test --help\nmpm-integration-test\nRun integration tests in tests dir\n\nUSAGE:\n    mpm integration-test [OPTIONS] [FILTER]\n\nARGS:\n    <FILTER>    The FILTER string is tested against the name of all tests, and only those tests\n                whose names contain the filter are run\n\nOPTIONS:\n        --abi\n            Generate ABIs for packages\n\n    -d, --dev\n            Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if\n            this flag is set. This flag is useful for development of packages that expose named\n            addresses that are not set to a specific value\n\n        --doc\n            Generate documentation for packages\n\n        --exact\n            Exactly match filters rather than by substring\n\n        --force\n            Force recompilation of all packages\n\n        --format <FORMAT>\n            Configure formatting of output: pretty = Print verbose output; terse = Display one\n            character per test; (json is unsupported, exists for compatibility with the default test\n            harness) [default: pretty] [possible values: pretty, terse]\n\n    -h, --help\n            Print help information\n\n        --install-dir <INSTALL_DIR>\n            Installation directory for compiled artifacts. Defaults to current directory\n\n        --list\n            List all tests\n\n    -p, --path <PACKAGE_PATH>\n            Path to a package which the command should be run with respect to [default: .]\n\n    -q, --quiet\n            Output minimal information\n\n        --test\n            Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used\n            along with any code in the 'test' directory\n\n        --test-threads <TEST_THREADS>\n            Number of threads used for running tests in parallel [env: RUST_TEST_THREADS=] [default:\n            32]\n\n        --ub\n            update test baseline\n\n    -v\n            Print additional diagnostics if available@\n\nIntegration test Directives​\nDirective - init​\ntask-init 0.1.0\n\nUSAGE:\n    task init [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --block-number <block-number>       block number to read state from. default to latest block number\n        --addresses <named-addresses>...\n    -n, --network <network>                 genesis with the network\n        --public-keys <public-keys>...\n        --rpc <rpc>                         use remote starcoin rpc as initial state\n\n\nDirective init can declare the initial state of you spec test. You can either start from a fresh blockchain state by providing arg -n test, or fork from a remote state snapshot like --rpc http://main.seed.starcoin.org:9850 --block-number 100000. --address <named-addresses> can be used to declare additional named addressed which will be used in the spec test later.\n\nExamples:\n\n//# init -n dev\n\n//# init -n test --addresses alice=0xAA\n\n//# init -n barnard\n\n//# init --rpc http://main.seed.starcoin.org:9850 --block-number 100000\n\n\nDirective - block​\ntask-block 0.1.0\n\nUSAGE:\n    task block [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --author <author>\n        --number <number>\n        --timestamp <timestamp>\n        --uncles <uncles>\n\n\nDirective block start a new block.\n\nEvery directives between this block directive and next block directive are running in this block. You can pass custom --author, --timestamp, --uncles to fit your need.\n\nIf no block directive specified, transactions will run on default block whose block number is the next block number of initial state. If you fork from a remote state of block number h, then the next block's number is h+1.\n\nExamples:\n\n//# block\n\n//# block --author alice\n\n//# block --timestamp 100000000\n\n//# block --uncles 10\n\nDirective - faucet​\ntask-faucet 0.1.0\n\nUSAGE:\n    task faucet [OPTIONS] --addr <address>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --addr <address>\n        --amount <initial-balance>     [default: 100000000000]\n        --public-key <public-key>\n\n\nDirective faucet can create and faucet an address (can be named address like alice, tom or raw address like 0x1, 0x2) with some STC of given amount. If the address is a named address, it will auto generate an raw address(and public key) and assign it to the named address. If you has some specific requirements on public-key, use --public-key to specify it.\n\nExamples:\n\n//# faucet --addr bob\n\n//# faucet --addr alice --amount 0\n\n//# faucet --addr tom --amount 10000000000000\n\n\nDirective - publish​\ntask-publish 0.1.0\nStarcoin-specific arguments for the publish command\n\nUSAGE:\n    task publish [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --gas-budget <gas-budget>\n    -k, --public-key <public-key>\n        --syntax <syntax>\n\n\nDirective publish can publish a module to the blockchain. The module code must follows the directive.\n\n--gas-budget specifies the max gas of the transaction. --syntax can be ingored for now.\n\nExmaples:\n\n//# publish\nmodule alice::Holder {\n    use StarcoinFramework::Signer;\n\n    struct Hold<T> has key, store {\n        x: T\n    }\n\n    public fun hold<T: store>(account: &signer, x: T) {\n        move_to(account, Hold<T>{x})\n    }\n\n    public fun get<T: store>(account: &signer): T\n    acquires Hold {\n        let Hold {x} = move_from<Hold<T>>(Signer::address_of(account));\n        x\n    }\n}\n\n//# publish\nmodule Dummy::DummyModule {}\n\n\n\nDirective - run​\ntask-run 0.1.0\nStarcoin-specifc arguments for the run command,\n\nUSAGE:\n    task run [FLAGS] [OPTIONS] [--] [NAME]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n    -v, --verbose    print detailed outputs\n\nOPTIONS:\n        --args <args>...\n        --gas-budget <gas-budget>\n    -k, --public-key <public-key>\n        --signers <signers>...\n        --syntax <syntax>\n        --type-args <type-args>...\n\nARGS:\n    <NAME>\n\n\nDirective run can execute a script of script function. If it's a script, the script code must follow the directive. If it's a script function, then <NAME> should be provided.\n\n--signers declare the transaction sender. --type-args and --args declare type arguments and arguments of the script of script function.\n\nExamples:\n\n//# run --signers alice\nscript {\nuse StarcoinFramework::STC::{STC};\nuse StarcoinFramework::Token;\nuse StarcoinFramework::Account;\nfun main(account: signer) {\n    let coin = Account::withdraw<STC>(&account, 0);\n    Token::destroy_zero(coin);\n}\n}\n\n//# run --signers alice --type-args 0x1::DummyToken::DummyToken 0x1::Account::accept_token\n\n\nDirective - view​\ntask-view 0.1.0\n\nUSAGE:\n    task view --address <address> --resource <resource>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --address <address>\n        --resource <resource>\n\n\nDirective view can query any resource of any address.\n\nExamples:\n\n//# view --address alice --resource 01::Account::Account\n\n//# view --address StarcoinFramework --resource 0x1::Config::Config<0x1::VMConfig::VMConfig>\n\nDirective - print-bytecode​\ntask-print-bytecode 0.1.0\nTranslates the given Move IR module or script into bytecode, then prints a textual representation of that bytecode\n\nUSAGE:\n    task print-bytecode [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n        --input <input>    The kind of input: either a script, or a module [default: script]\n\n\nDirective print-bytecode can print the bytecode of given module or script.\n\nInstallation Test Expectation​\n\nEach integration test should have an corresponding expectation file, which contains the expected output of each directives in integration test. Move package manager will compare the test result of a integration test with the expectation file. If there are different outputs, then the integration test fails. You can generate the expected file by providing --ub argument when running mpm integration-test for the first time. But you have to check whether the generated output really is the expected output of your integration test.\n\nExample:\n\ncd coin-swap\nmpm pacakge build\nmpm integration-test test_coin_swap\n\n\nThis's all about integration test of move.\n\nMore example​\nbasic-coin\ncoin-swap\nmy-token\nmy-counter\nsimple-nft A NFT example\nQuestions​\n\nIf you have any question, please go to Starcoin/move-lang channel in Discord.\n\nEdit this page\nPrevious\nUnderstanding abilities\nNext\nStarcoin Move Framework\nInstallation\nOverview\nSpec Test\nIntegration test Directives\nInstallation Test Expectation\nMore example\nQuestions\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Understanding abilities | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/understanding-ability/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentUnderstanding abilities\nUnderstanding abilities\n\nMove has unique type system which is very flexible and customizable. Each type can have up to 4 abilities which define how values of this type can be used, dropped or stored.\n\nThere are 4 type abilities: Copy, Drop, Store and Key.\n\nMore information about them can be found in chapter Types with Abilities of 《The Move Language》.\n\nEdit this page\nPrevious\nPackages\nNext\nUser Guide of Move Package Manager\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move Language | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/move-language/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nPackages\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentMove Language\nMove Language\nIntroduction​\n\nMove is a programming language for writing safe smart contracts originally developed at Facebook to power the Diem blockchain. Move is designed to be a platform-agnostic language to enable common libraries, tooling, and developer communities across diverse blockchains with vastly different data and execution models. Move's ambition is to become the \"JavaScript of Web3\" in terms of ubiquity -- when developers want to quickly write safe code involving assets, it should be written in Move.\n\nResources​\nMove's repository\nmove-awesome - Move book\nMove code examples and papers\nEdit this page\nPrevious\nQuick Start\nNext\nPackages\nIntroduction\nResources\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Quick Start | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/quick-start/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentQuick Start\nQuick Start\n\nIn this tutorial, we will implement a simple counter to show how Move manages resources through code. This document covers background knowledge, writing code, how to compile, how to publish to the chain, and how to call. The complete code repository is here.\n\nPrepare in advance:\n\nYou need to build a dev network according to how to set up a local development network and connect to the dev network through the Starcoin console.\n\nCreate an account according to account management or use an existing account, and transfer a little STC to the account.\n\nThere is a basic understanding of the transaction through the first on-chain transaction.\n\nNext, we will introduce some necessary tools and project structure.\n\nmpm command-line tool and project structure​\n\nBefore we start writing code, let's install the mpm (Move Package Manager) command line tool and briefly introduce the structure of the Move project.\n\nINTRODUCTION TO MPM\n\nmpm is encapsulated and integrated with some additional functions on the basis of move-cli by Starcoin developers to facilitate the development, testing and deployment of Starcoin smart contracts.\n\nThe installation method is to set up the Move development environment.\n\nNow you can create a new project through mpm:\n\n$ mpm package new my-counter\n\n\nYou can see the generated directory structure:\n\nmy-counter\n├── Move.toml\n└── sources\n\nsources - Directory of storing the Move module.\nMove.toml - Manifest file: Define the metadata, dependencies and named addresses of the package.\nMOVE MODULE\n\nA module is a library that define structure types and functions of manipulate structures. The concept of class in other programming languages can be used to help understand.\n\nThe module will be published to the publisher's address, and the entry functions in the module can be called and executed by everyone. (You can use function computing platforms such as AWS Lambda to publish functions and call functions to help understand)\n\nA project consisting of Move.toml files and sources directory will be considered a Move Package.\n\nCreate a MyCounter module​\n\nCreate a MyCounter.move file in the sources directory to store the code of the module.\n\nThe module we are going to create is named MyCounter. In this article, we will demonstrate it using an account address 0xcada49d6a37864931afb639203501695 of my local dev network. We will publish the MyCounter module to this address.\n\nDefine the syntax of the module:\n\nmodule <address>::<identifier> {\n    // module body\n}\n\nThe first version of the code​\n\nIn the MyCounter module, we define a structure Counter, which contains a field value representing the number of times the counter is triggered. The type of value is u64, that is, unsigned 64-bit integer.\n\nThe following is the first version of the MyCounter module:\n\nmy-counter/sources/MyCounter.move\nmodule 0xcada49d6a37864931afb639203501695::MyCounter {\n    struct Counter {\n        value: u64,\n    }\n}\n\n\nWe can use the mpm package build command to build our counter program.\n\n$ mpm package build\n\nBUILDING my-counter\n\n\nAs you can see, the program passed the compilation smoothly and then went down.\n\nBecause this address is too long, you can set a named address in the Move.toml file, which can be globally replaced in the Move project.\n\nmy-counter/Move.toml\n[package]\nname = \"my-counter\"\nversion = \"0.0.1\"\n\n\n[addresses]\n\nMyCounterAddr = \"0xcada49d6a37864931afb639203501695\"\n\n...\n\nTIPS\n\nHighlighted blocks of code are changes or parts that need attention.\n\nIn this way, the first version of code can be written as:\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n\n    struct Counter {\n        value: u64,\n    }\n}\n\n\nMyCounterAddr is a named address and MyCounter is a module identifier.\n\nThen we compile the code:\n\n$ mpm package build\n\nBUILDING my-counter\n\n\nThere is no error, indicating that there is no problem.\n\nInitialization method init​\n\nThen we customize an initialization method to create a Counter instance and \"move\" to the storage space of the caller's account.\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n    struct Counter {\n        value: u64,\n    }\n\n\n    public fun init(account: &signer) {\n\n        move_to(account, Counter { value: 0 });\n\n    }\n\n}\n\n\nmove_to<T>(&signer, T) here is a built-in method to add resources of type T to the storage space under the address of the account signer (the brackets here represent generics).\n\nMORE INFORMATION\n\nThe storage space here is GlobalState, which can be simply understood as the place where the account is stored in resources and module code. More details can be found in Concept-Status.\n\nThe signer in the init function on line 6 account: &signer is the built-in type of Move. If you want to put resources under the caller's account address, you need to pass the &signer parameter to the function. The &signer data type represents the initiator of the current transaction (the caller of the function can be any account).\n\nHELP YOU UNDERSTAND —— SIGNER\n\nsigner is like uid under Linux. After logging in to the Linux system, all the commands you enter are considered to be \"this logged-in certified user\" operation. The key is that this authentication process is not done in running commands and programs, but is completed by the operating system after booting.\n\nCorresponding to Move, this authentication process is a well-known \"private key signature, public key verification\" process similar to other blockchain systems. When the function with the &signer parameter is executed, the identity of the initiator has been authenticated by the Starcoin blockchain.\n\nLet's try to compile it:\n\n$ mpm package build\n\nBUILDING my-counter\nerror[E05001]: ability constraint not satisfied\n  ┌─ ./sources/MyCounter.move:7:6\n  │\n2 │     struct Counter {\n  │            ------- To satisfy the constraint, the 'key' ability would need to be added here\n  ·\n7 │         move_to(account, Counter { value: 0 });\n  │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  │         │                │\n  │         │                The type 'MyCounterAddr::MyCounter::Counter' does not have the ability 'key'\n  │         Invalid call of 'move_to'\n\n\nSomething went wrong! Prompt us \"ability constraint not satisfied\", and the following is a sentence \"The type 'MyCounterAddr::MyCounter::Counter' does not have the ability 'key'\". The compiler told us that the resource type MyCounterAddr::MyCounter::Counter lacks key capacity, so it cannot be added to the account address with move_to.\n\nThe ability feature of Move are involved here.\n\nCONCEPT —— ABILITY\n\nMove language is a resource-oriented language, and the core is resource management. For what \"ability\" resources have, the Move programming language abstracts the four attributes of resources -- copyable(copy), indexable (key), discarded(drop), and storable(store). Through the different combinations of these four attributes, users can easily define the resources of any ability. For example, users can define an ordinary information type through the combination of key + copy + drop + store, and an asset type through the combination of key + store -- such as NFT -- without copy attributes ensure that NFT cannot be copied at will, which improves security.\n\nMove provides four competencies:\n\ncopy: Indicates whether the value can be copied.\ndrop: Indicates whether the value can be discarded at the end of the scope.\nkey: Indicates whether the value can be accessed as a global key.\nstore: Indicates whether the value can be saved to the global state.\n\nBy endowing resources with different ability, the Move virtual machine can fundamentally ensure that \"resources\" can only move. As for copying, modifying and discarding, it depends on the specific ability of resources. If it is forcibly copied, modified or discarded, the code compilation will go wrong and there is no chance to run at all.\n\nFor more information, please refer to the Understanding Ability chapter.\n\nGenerally speaking, we believe that the structure with key ability is resources.\n\nWe modify the code and follow the prompts to add key ability.\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n\n    struct Counter has key {\n\n        value: u64,\n    }\n\n    public fun init(account: &signer) {\n        move_to(account, Counter { value: 0 });\n    }\n}\n\n\nAt this time, it can be compiled again.\n\nCounter plus one method incr​\n\nNow add an incr method to the Counter resource.\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n\n\n    use StarcoinFramework::Signer;\n\n\n    struct Counter has key {\n        value: u64,\n    }\n\n    public fun init(account: &signer) {\n        move_to(account, Counter { value: 0 });\n    }\n\n\n    public fun incr(account: &signer) {\n\n        let counter = borrow_global_mut<Counter>(Signer::address_of(account));\n\n        counter.value = counter.value + 1\n\n    }\n\n}\n\n\nNote that in line 3, we refer to a dependency - StarcoinFramwork can be regarded as the Stdlib standard library of Starcoin. We need to use the Signer::address_of(&signer) method in the library to extract the address of the signer.\n\nModify the Move.toml file to add dependencies to the project\n\nmy-counter/Move.toml\n[package]\nname = \"my-counter\"\nversion = \"0.0.1\"\n\n[addresses]\n\nStarcoinFramework = \"0x1\"\n\nMyCounterAddr = \"0xcada49d6a37864931afb639203501695\"\n\n\n[dependencies]\n\nStarcoinFramework = {git = \"https://github.com/starcoinorg/starcoin-framework.git\", rev=\"2ee2378d0d6eaa4ebc1ac6d3e33c4aee11bc2fe4\"}\n\n\nSince the StarcoinFramework code is possibly updated, the rev(2ee2378d0d6eaa4ebc1ac6d3e33c4aee11bc2fe4) of StarcoinFramework may be invalid for this example causing errors or warnings in the build or test progress. If it is, please check the latest version and update the rev of StarcoinFramework.\n\nLine 14 has a new method borrow_global_mut. Like the previous move_to, it is a built-in method to operate resources on the storage space of the account address.\n\nGAS STATION -- OPERATION OF RESOURCES\nmove_to<T>(&signer, T): Publish and add resources of type T to the address of the signer.\nmove_from<T>(address): T: Delete the resource of type T from the address and return this resource.\nborrow_global<T>(address): &T: Returns an immutable reference to a resource of type T under the address.\nborrow_global_mut<T>(address): &mut T: Returns a mutable reference to a resource of type T under the address.\nexists<T>(address): bool: Judge whether there are resources of type T under the address.\n\nTo use these methods, resource T must be defined in the current module. This ensures that resources can only be operated by the API method provided by the module that defines the resource. The parameters address and signer represent the address stored in a resource of type T.\n\nThen we will try to compile it:\n\n$ mpm package build\nCACHED StarcoinFramework\nBUILDING my-counter\nerror[E04020]: missing acquires annotation\n   ┌─ ./sources/MyCounter.move:14:20\n   │\n14 │         let counter = borrow_global_mut<Counter>(Signer::address_of(account));\n   │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │                       │                 │\n   │                       │                 The call acquires 'MyCounterAddr::MyCounter::Counter', but the 'acquires' list for the current function does not contain this type. It must be present in the calling context's acquires list\n   │                       Invalid call to borrow_global_mut.\n\n\nOh! Something went wrong again. The error message prompts that when we call the method in line 14 to get the Counter structure, the type (Counter structure) must appear in the acquires list of the call context, and the acquires list of the current function does not contain this type.\n\nHere we introduce the concept of acquire.\n\nCONCEPT\n\nWhen a function accesses resources with move_from(), borrow_global() and borrow_global_mut(), the function must show which resource the declaration needs to \"acquire\". This will be ensured by Move's type system that references to resources are safe and there are no suspended references.\n\nThe revised code is as follows:\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n\n    use StarcoinFramework::Signer;\n\n    struct Counter has key {\n        value: u64,\n    }\n\n    public fun init(account: &signer) {\n        move_to(account, Counter { value: 0 });\n    }\n\n\n    public fun incr(account: &signer) acquires Counter {\n\n        let counter = borrow_global_mut<Counter>(Signer::address_of(account));\n        counter.value = counter.value + 1\n    }\n}\n\n\nIt can now be compiled.\n\nNext, we write functions that can be executed directly through the console.\n\nWrite a callable script function​\n\nThe previously written public fun init and public fun incr functions cannot be called and executed directly in the console. You need to use the entry function to call.\n\nAt present, in Move, the entry method is achieved through script function, writing public(script) fun.\n\nThe concept of function visibility is introduced here. Different visibility determines where functions can be called. (The following concept tip can be skipped first)\n\nCONCEPT - FUNCTION VISIBILITY\nvisibility\twrite\texplain\ninternal\tfun\tIt can also be called private, which can only be called in the same module.\npublic\tpublic fun\tIt can be called by functions in any module.\npublic entry\tpublic entry fun\tThe entry function is an entry method in the module, which can be called by initiating a transaction through the console, just like the local execution script (although the code has been stored under the module address on the chain).\npublic friend\tpublic(friend) fun\tIt can be called in the same module and added to the trusted module call of the friend list.\n:::\t\t\n\nNext, let's write the script function corresponding to init and incr functions.\n\nmy-counter/sources/MyCounter.move\nmodule MyCounterAddr::MyCounter {\n\n    use StarcoinFramework::Signer;\n\n    struct Counter has key, store {\n        value: u64,\n    }\n\n    public fun init(account: &signer) {\n        move_to(account, Counter { value: 0 });\n    }\n\n    public fun incr(account: &signer) acquires Counter {\n        let counter = borrow_global_mut<Counter>(Signer::address_of(account));\n        counter.value = counter.value + 1\n    }\n\n\n    public entry fun init_counter(account: signer) {\n\n        Self::init(&account);\n\n    }\n\n\n\n    public entry fun incr_counter(account: signer) acquires Counter {\n\n        Self::incr(&account);\n\n    }\n\n}\n\n\nThe only thing to explain is that Self refers to the current module.\n\nNow, we publish the module to the chain and try to call it.\n\nPublish to the chain and call​\nPublish to the chain​\n\nRun the mpm release command:\n\n$ mpm release\n\nPackaging Modules:\n         0xcada49d6a37864931afb639203501695::MyCounter\nRelease done: release/my-counter.v0.0.1.blob, package hash: 0x31b36a1cd0fd13e84034a02e9972f68f1c9b1cde1c9dfbe7ac69f32f6fc6dafa\n\n\nIt will package the compilation module and get the binary package.\n\nIn the previous article, we have prepared an account with the address 0xcada49d6a37864931afb639203501695. If there is no balance, we can get some test coins through the dev get-coin command. Now deploy the compiled module to this account address.\n\nStarcoin console\nstarcoin% account unlock 0xcada49d6a37864931afb639203501695 -p <MY-PASSWORD>\n\n\n\nstarcoin% dev deploy /path/to/my-counter/release/my-counter.v0.0.1.blob -s 0xcada49d6a37864931afb639203501695 -b\n\n\n\ntxn 0xf60662ba0ac3373c28f827a0ac9d9db6667c3921056905356aa5414b3bf3df09 submitted.\n\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"7800\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n        {\n          \"access_path\": \"0x00000000000000000000000000000001/1/0x00000000000000000000000000000001::TransactionFee::TransactionFee<0x00000000000000000000000000000001::STC::STC>\",\n          \"action\": \"Value\",\n          \"value\": {\n            \"Resource\": {\n              \"json\": {\n                \"fee\": {\n                  \"value\": 292331\n                }\n              },\n              \"raw\": \"0xeb750400000000000000000000000000\"\n            }\n          }\n        },\n...\n\n\n-s that is --sender is the sender, -b is --blocking, blocking and waiting for the command to be executed.\n\nThe txn 0xf60662... submitted on line 5 means that the smart contract of the counter has been successfully deployed to the publisher's address, which belongs to an on-chain transaction, and the chain has recorded the transaction status.\n\nAt this time, we can check the storage of the code on the chain.\n\nStarcoin console\nstarcoin% state list code 0xcada49d6a37864931afb639203501695\n\n\n{\n  \"ok\": {\n    \"codes\": {\n      \"MyCounter\": {\n        \"abi\": {\n          \"module_name\": {\n            \"address\": \"0xcada49d6a37864931afb639203501695\",\n            \"name\": \"MyCounter\"\n          },\n          ...\n}\n\n\nYou can see that there is only MyCounter, the contract code at the address of 0xcada49d6a37864931afb639203501695.\n\nThe state command is used to view the data under the account address. You can enter state --help in the console to see more help. :::\n\nCall init_counter to initialize resources​\n\nUse the account execute-function command to execute a script function. Now we call the init_counter method to initialize the Counter resource to the caller's address.\n\nStarcoin console\nstarcoin% account execute-function --function 0xcada49d6a37864931afb639203501695::MyCounter::init_counter -s 0xcada49d6a37864931afb639203501695 -b\n\n\ntxn 0x032c0eda779157e0ef3949338c3b3e4e6528c7720776d02c2cb0ddd64804f1c2 submitted.\n{\n  \"ok\": {\n    \"dry_run_output\": {\n      \"events\": [],\n      \"explained_status\": \"Executed\",\n      \"gas_used\": \"11667\",\n      \"status\": \"Executed\",\n      \"write_set\": [\n...\n}\n\n\nIn the init_counter function, we initialize a Counter object (resource) and move_to to the caller's address. Let's see if this resource exists. Use the state list resource <ADDRESS> command to view the list of resources under a given address.\n\nStarcoin console\nstarcoin% state list resource 0xcada49d6a37864931afb639203501695\n\n\n{\n    ...（There are many output, we observe the last one）\n    \"0xcada49d6a37864931afb639203501695::MyCounter::Counter\": {\n        \"json\": {\n          \"value\": 0\n        },\n        \"raw\": \"0x0000000000000000\"\n    }\n}\n\n\nYou can see the address 0xcada49d6a37864931afb639203501695 had 0xcada49d6a37864931afb639203501695::MyCounter::Counter type of resource, the content is \"value\": 0.\n\nSome friends may wonder why the Counter resource type name is written so long. Let's first help you recall the concept of FQN.\n\nCONCEPT - FULL NAME FQN\n\nFully Qualified Name (FQN) is a computer term that defines the name of a resource (object, function, domain name, file) in a call context. For example:\n\nThe absolute path name /path/to/file of Linux is the fully qualified file name, and the relative ./to/file is a relative path address.\nIn the domain name system, google.com. is an fully qualified domain name, pay attention to the last .. This means that this domain name should not continue to be recursively resolved.\n\nThen it corresponds to the Move language, and the resource type is published under an address, which belongs to this address. Address 0x001 can create a resource of Counter type, and address 0x002 can also create a resource of Counter type. To distinguish two Counters, you need to bring an address and module name.\n\n<address>::<module_identifier>::<structure>\n\nCall incr_counter incremental counter​\n\nNext, call another function incr_counter to try to add one to the counter.\n\nStarcoin console\nstarcoin% account execute-function --function 0xcada49d6a37864931afb639203501695::MyCounter::incr_counter -s 0xcada49d6a37864931afb639203501695 -b\n\n\ntxn 0x032c0eda779157e0ef3949338c3b3e4e6528c7720776d02c2cb0ddd64804f1c2 submitted.\n...\n\n\nCheck the resources again. With the previous concept of FQN, this time we will use state get resource <ADDRESS> [RESOURCE_TYPE] to view specific resource types under ADDRESS.\n\nStarcoin console\nstarcoin% state get resource 0xcada49d6a37864931afb639203501695 0xcada49d6a37864931afb639203501695::MyCounter::Counter\n\n\n{\n  \"ok\": {\n    \"json\": {\n      \"value\": 1\n    },\n    \"raw\": \"0x0100000000000000\"\n  }\n}\n\n\nYou can see that the value of the counter has changed to 1.\n\nAnother account call​\n\nIn the previous example, we used the same address 0xcada49d6a37864931afb639203501695 to publish modules, create a counter resource type (dev deploy), and call function add counters (account execute-function).\n\nWe will have another account to initialize the counter and the self-increment counter. Suppose a local account is 0x012ABC\n\nStarcoin console\nstarcoin% account execute-function -s 0x012ABC  --function 0xb19b07b76f00a8df445368a91c0547cc::MyCounter::init_counter -b\n\nstarcoin% state get resource 0x012ABC 0xcada49d6a37864931afb639203501695::MyCounter::Counter\n\n\nReaders can observe the changes in resources under 0x012ABC.\n\n历史 —— SCRIPT 和 SCRIPT FUNCTION\n\nIn order to prevent people from being confused by scripts in tutorials read elsewhere, let's briefly talk about the origin of history. This section can be skipped.\n\nWe use Python pip or Node.js npm to assist in understanding.\n\nBefore the emergence of centralized package management hosting platforms such as pip and npm, we want to install a package, which requires setup.py install /path/to/package. Of course, this is not convenient for the distribution, dissemination and indexing of packages. Later, with pip, how did we do it? The package author first uploaded his own package to the pip repository, and the pip will store the package and index it. Ordinary users only need pip install package_name. The pip tool will download the source code according to the package_name you provided, and then install it. The two packages are actually installed in the same way.\n\nIt now corresponds to Move. Before the script function appeared, there was only script, and the script was written in the scripts directory equal to the sources directory.\n\nThe script is like a local Python package. The script can be compiled into bytecode. When calling the script, you need to create a transaction. Bring the compiled bytecode in the payload, and the script can be Mov on the node. E The virtual machine executed it. The right should be in the Starcoin console:\n\nstarcoin% account execute-script </path/to/mv_file>\n\n\nAs an alternative to script, script function has been added to the Move language. Analogy to packages stored in the pip repository. The script function will be published to an address together in the module (just as the package author publishes the package in pip). At this time, to call the script, you need to create a transaction, and the address of the published code in payload. Corresponding to the Starcoin console are:\n\nstarcoin% account execute-function --function  <0xAddress>::<module>::<function> --arg xxx\n\n\nOf course, Move is also an evolving language, and public(script) fun is being replaced by public entry. Let's wait and see.\n\nTo sum up:\n\nThe script may be abandoned, and it is recommended to use the script function as the entry method.\nThe next version of Move will replace public(script) fun with public entry fun.\nWhat course to follow​\n\nCongratulations, you have completed the whole process of writing, deploying and invoking a simple contract.\n\nThe complete code repository is here.\n\nNext,\n\nYou can systematically learn the Move language through the Move language\nView [more Move examples]\nLearn how to Debug/test Move module\nLearn about the Starcoin Move Framework\nAdvanced Move can be learned through [Move Advanced Development].\nLearn about the Move specification language and Move Prover to develop safer Move applications\nExplore more features of Move Package Manager\n\nOr you can directly enter the world of Dapp.\n\nWeb3 and DApp develop\nEdit this page\nPrevious\nSetting up Move develop environment\nNext\nMove Language\nmpm command-line tool and project structure\nCreate a MyCounter module\nThe first version of the code\nInitialization method init\nCounter plus one method incr\nWrite a callable script function\nCall init_counter to initialize resources\nCall incr_counter incremental counter\nAnother account call\nWhat course to follow\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Setting up Move develop environment | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/prepare-move-env/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract DevelopmentSetting up Move develop environment\nSetting up Move develop environment\nInstall mpm​\n\nMove Package Manager(mpm) is a command line tool to develop move projects, like Cargo for Rust, or NPM for NodeJS.\n\nInstall using the convenience script​\nRun scripts/dev_setup.sh(automated installation script) of starcoin-framework, which contains mpm, Rust, PATH config and the move prover environment setup.\ncurl -Ss https://raw.githubusercontent.com/starcoinorg/starcoin-framework/main/scripts/dev_setup.sh | bash /dev/stdin -b -t -p\n\n\nThe command above will install mpm and Rust to default location. It also set the PATH env. Check more arguments in shell script.\n\nInstall from binary​\n\nDownload mpm-[your_os]-latest.zip from the release page of starcoiorg/starcoin, unarchive it and add it to PATH env.\n\nInstall from source​\n\nFrom local source code\n\n$ git clone https://github.com/starcoinorg/starcoin.git\n$ cd starcoin\n$ cargo install --path vm/move-package-manager\n\n\nOr from remote git repo\n\n$ cargo install --git https://github.com/starcoinorg/starcoin move-package-manager --bin mpm\n\n\nThis will install the mpm binary in your Cargo binary directory. On macOS and Linux this is usually ~/.cargo/bin/. You'll want to make sure this location is in your PATH environment variable.\n\nSummary​\n\nNow you should be able to run the mpm:\n\n$ mpm\nmove-package-manager 1.11.11\nStarcoin Core Dev <dev@starcoin.org>\nCLI frontend for the Move compiler and VM\n\nUSAGE:\n    mpm [OPTIONS] <SUBCOMMAND>\n  ...\n\nInstall IDE plugin​\nVS Code​\n\nSearch starcoin-ide in Extensions.\n\nSet up env for move prover​\n\nMove Prover is a formal verification tool designed to prevent bugs in smart contracts written in Move language. more\n\nRun dev_setup.sh(automated installation script) of starcoin-framework\ncurl -Ss https://raw.githubusercontent.com/starcoinorg/starcoin-framework/main/scripts/dev_setup.sh | bash /dev/stdin -bpty\n\n\nWhen the above command is executed, type boogie /version and if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently Move Prover can only run under UNIX-based operating systems (e.g. Linux, macOS). Windows users can run it by installing WSL.\n\nEdit this page\nPrevious\nMove in Action\nNext\nQuick Start\nInstall mpm\nInstall using the convenience script\nInstall from binary\nInstall from source\nSummary\nInstall IDE plugin\nVS Code\nSet up env for move prover\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    },
    {
      "title": "Move in Action | Starcoin Cookbook",
      "url": "https://starcoinorg.github.io/starcoin-cookbook/docs/move/",
      "html": "Skip to main content\nStarcoin Cookbook\nDocuments\nEnglish\nGitHub\nSearch...\nStarcoin CookBook Intro\nGetting Started\nMove and SmartContract Development\nSetting up Move develop environment\nQuick Start\nMove Language\nUnderstanding abilities\nUser Guide of Move Package Manager\nStarcoin Move Framework\nHow to deploy Move smart contracts\nInteracting with the contract by CLI\nUnderstanding module dependency\nHow to upgrade Move Module\nFor solidity developer\nHow to call a function\nREADME\nHow to test Move Module\nMore Move Examples\nAdvance Move Development\nMove Specification Language and Move Prover\nWeb3 and DApp Development\nReference\nConcepts\nMiscellaneous\nMove and SmartContract Development\nMove in Action\n\nThis chapter mainly introduces the related content of Move development.\n\nFirst of all, we will introduce how to build the development environment of Move language, and then you can follow the content of the Quick Start chapter to experience the basic process of Move contract development. Then introduce some important concepts of the Move language, the mpm tool developed by Starcoin, how to interact with the contract, and integration testing.\n\nEdit this page\nPrevious\nmining_protocol\nNext\nSetting up Move develop environment\nDocs\nDocuments\nCommunity\nStack Overflow\nDiscord\nDeveloper Telegram group\nTwitter\nMore\nGitHub\nCopyright © 2023 Starcoin, Inc. Built with Docusaurus."
    }
  ]