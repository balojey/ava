[
    {
      "title": "",
      "url": "https://www.move-patterns.com/accountless_design.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n \nDocument not found (404)\n\nThis URL is invalid, sorry. Please use the navigation bar or search to continue."
    },
    {
      "title": "Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/print.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n \nIntroduction\n\nWhile there have been other resource based programming languages in the past (such as Plaid), for a long time resource based programming has been a niche, lacking applications where resource based approach would excel. However, smart contracts and blockchains introduced software development challenges that can be answered with resource based programming.\n\nThe Move language and its Move Virtual Machine were designed originally by Facebook to power their Diem blockchain platform providing an intuitive environment and ecosystem for resource oriented applications. Fortunately Move was adopted by multiple blockchain projects as their smart contract execution environment before Diem was discontinued, so Move continues living separately as an independent project.\n\nToday Move and its virtual machine are powering multiple blockchains, most of which are still in the early development phase.\n\nBecause Move is currently the most widely developed resource based programming language for blockchains, code examples are written in Move. However it is likely that some of these patterns can be implemented also in some other resource based language and ecosystem.\n\nWhat this book is\n\nThis book is for discussing software design paradigms and best practices for resource based languages, especially Move and its flavors.\n\nWhat this book is not\n\nThis book is not a guide to Move or any other resource based language. For books on Move itself, see this list. Also see awesome-move for a curated list of code and content from the Move programming language community.\n\nTechnical disclaimer\n\nThis book is designed to be viewed digitally with hyperlink support (such as PDF or web format). For now the full software pattern format is not followed, instead the patterns are simply defined by a short summary and examples.\n\nLicense\n\nMove Patterns: Design Patterns for Resource Based Programming Â© 2022-2024 by Ville Sundell and others is licensed under CC BY 4.0. To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/.\n\nCapability\n\t\nName\tCapability\nOrigin\tLibra Project / Unknown Author\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Capability is a resource proving that the owner of the resource is permitted to execute a certain action. This is the oldest known Move design pattern dating back to the Libra project and its token smart contract, where capabilities were used to authorize minting of coins.\n\nExamples\nmodule examples::item {\n    use sui::transfer;\n    use sui::id::VersionedID;\n    use sui::utf8::{Self, String};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Type that marks Capability to create new `Item`s.\n    struct AdminCap has key { id: VersionedID }\n\n    /// Custom NFT-like type.\n    struct Item has key, store { id: VersionedID, name: String }\n\n    /// Module initializer is called once on module publish.\n    /// Here we create only one instance of `AdminCap` and send it to the publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(AdminCap {\n            id: tx_context::new_id(ctx)\n        }, tx_context::sender(ctx))\n    }\n\n    /// The entry function can not be called if `AdminCap` is not passed as\n    /// the first argument. Hence only owner of the `AdminCap` can perform\n    /// this action.\n    public entry fun create_and_send(\n        _: &AdminCap, name: vector<u8>, to: address, ctx: &mut TxContext\n    ) {\n        transfer::transfer(Item {\n            id: tx_context::new_id(ctx),\n            name: utf8::string_unsafe(name)\n        }, to)\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev.\n\nMultiple Configurations\n\t\nName\tMultiple Configurations\nOrigin\tVille Sundell\nExample\tDiem Forum Post\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nIn the Multiple Configurations approach singletons (especially for configuration data) are provided to the module as arguments instead of storing them to any specific location.\n\nBy incorporating this design into your modules, you would automatically add a layer of configurability by giving users or admins (if any) a way to create configurations which others could use. This would be similar to Uniswap which lets anyone create markets others could participate in.\n\nExamples\n\nLet's say you have an auction smart contract X and an admin has created a configuration to account A. Then B could issue a transaction script to bid on C's resource like this:\n\nX::place_bid(A, C, 1234);\n\n\nBy accepting parameters (such as C and the amount 1234), a transaction script could trivially hide the selection of the configuration. This depends, how flexible the final script implementation is in terms of arguments to main(), but the transaction script could look like this (quick mock-up):\n\nscript {\n    use 0xFF::X;\n\n    const CONF: address = 0xCOFFEE;\n\n    fun main(a: address, amount: XUS) {\n        X::place_bid(CONF, a, amount);\n    }\n}\n\nNestable Resources\n\t\nName\tNestable Resources\nOrigin\tVille Sundell\nExample\tTaoHe project\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nNestable Resources pattern provides a resource native approach to code reuse by building a nested structure of resources where each resource can be detached for use if the conditions are satisfied. For example, tokens can be placed into a time locked resource, which in turn can be placed into a resource which can be used only by a certain user, effectively creating a timelocked non-fungible token. For cleaner design and easier integration it is recommended that the nestable resources share a common interface for wrapping and unwrapping.\n\nExamples\n/// A nested resource (tao) for implementing a simple ownership model: owner can extract\n/// the content.\nmodule 0x1::Ownable {\n    use Std::Signer;\n\n    /// Simple ownership tao: the `owner` can extract `content`.\n    struct Tao<Content> has key, store {\n        owner: address,\n        content: Content\n    }\n\n    /// Wrapping `content` into a tao the `owner` can only extract.\n    public fun wrap<Content>(owner: address, content: Content): Tao<Content> {\n        Tao<Content> { owner, content }\n    }\n\n    /// Immutable read-only reference to the owner address, and `content`.\n    public fun read<Content>(tao: &Tao<Content>): (&address, &Content) {\n        let Tao<Content> { owner, content } = tao;\n\n        (owner, content)\n    }\n\n    /// If `account ` is the `owner`, extract `content`.\n    public fun unwrap<Content>(account: &signer, tao: Tao<Content>): Content {\n        let Tao<Content> { owner, content } = tao;\n\n        assert!(owner == Signer::address_of(account), 123);\n\n        content\n    }\n}\n\n/// A folder tao to store an arbitrary number of taos.\nmodule 0x1::Folder {\n    /// A simple tao struct containing a vector of resources.\n    struct Tao<Content> has key, store {\n        content: vector<Content>\n    }\n\n    /// Create a new tao, with the static set of resources inside it.\n    public fun wrap<Content>(content: vector<Content>): Tao<Content> {\n        Tao<Content> { content }\n    }\n\n    /// Immutable read-only reference to the vector containing resources.\n    public fun read<Content>(tao: &Tao<Content>): &vector<Content> {\n        let Tao<Content> { content } = tao;\n\n        content\n    }\n\n    /// Destroy the tao, and return the static set of resources inside it.\n    public fun unwrap<Content>(tao: Tao<Content>): vector<Content> {\n        let Tao<Content> { content } = tao;\n\n        content\n    }\n\n\nA token can be placed inside Ownable and it can be placed inside Folder, or other way around, if so desired.\n\nWitness\n\t\nName\tWitness\nOrigin\tFastX / Sam Blackshear\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Witness is an ephemeral resource designed to prove only once that the a resource in question can be initiated only once after the witness has been created. The resource is dropped after use, ensuring that the same resource cannot be reused to initialize any other struct.\n\nExamples\n/// Module that defines a generic type `Guardian<T>` which can only be\n/// instantiated with a witness.\nmodule examples::guardian {\n    use sui::id::VersionedID;\n    use sui::tx_context::{Self, TxContext};\n\n    /// Phantom parameter T can only be initialized in the `create_guardian`\n    /// function. But the types passed here must have `drop`.\n    struct Guardian<phantom T: drop> has key, store {\n        id: VersionedID\n    }\n\n    /// The first argument of this function is an actual instance of the\n    /// type T with `drop` ability. It is dropped as soon as received.\n    public fun create_guardian<T: drop>(\n        _witness: T, ctx: &mut TxContext\n    ): Guardian<T> {\n        Guardian { id: tx_context::new_id(ctx) }\n    }\n}\n\n/// Custom module that makes use of the `guardian`.\nmodule examples::peace {\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    // Use the `guardian` as a dependency.\n    use 0x0::guardian;\n\n    /// This type is intended to be used only once.\n    struct PEACE has drop {}\n\n    /// Module initializer is the best way to ensure that the\n    /// code is called only once. With `Witness` pattern it is\n    /// often the best practice.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            guardian::create_guardian(PEACE {}, ctx),\n            tx_context::sender(ctx)\n        )\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev.\n\nAccountless Design\n\t\nName\tAccountless Design\nOrigin\tVille Sundell\nExample\tDiem Forum Post\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nMove module following the Accountless Design pattern doesn't handle storage (move_to() / move_from()) directly, instead the storage must be handled outside the module in transaction scripts. This makes the module code footprint smaller, design simpler, implementation more portable and provides a way to implement storage agnostic smart contract design on some Move powered platforms.\n\nExamples\nmodule 0x1::Outbox {\n    use Std::Event;\n    use Std::Signer;\n    use Std::Vector;\n\n    struct Item<Content: key + store> has key, store {\n        from: address,\n        to: address,\n        content: Content\n    }\n\n    struct Outbox<Content: key + store> has key, store {\n        content: vector<Item<Content>>\n    }\n\n    struct Put<phantom Content> has key, drop, store {\n    }\n\n    struct EventHandle<phantom Content: drop + store> has key, store {\n        event_handle: Event::EventHandle<Content>\n    }\n\n    public fun create<Content: key + store>(account: &signer) {\n        move_to<Outbox<Content>>(account, Outbox<Content> { content: Vector::empty<Item<Content>>() });\n        move_to<EventHandle<Put<Content>>>(account, EventHandle<Put<Content>> { event_handle: Event::new_event_handle<Put<Content>>(account) } );\n    }\n\n    public fun put<Content: key + store>(account: &signer, from: address, to: address, content: Content) acquires EventHandle, Outbox {\n        let outbox_owner = Signer::address_of(account);\n        let event_handle = borrow_global_mut<EventHandle<Put<Content>>>(outbox_owner);\n        let outbox = borrow_global_mut<Outbox<Content>>(outbox_owner);\n\n        assert!(to != @0x0, 123);\n\n        Vector::push_back<Item<Content>>(&mut outbox.content, Item<Content>{ from, to, content });\n        Event::emit_event<Put<Content>>(&mut event_handle.event_handle, Put<Content> {});\n    }\n\n    public fun get<Content: key + store>(account: &signer, outbox_owner: address, index: u64): Content acquires Outbox {\n        let account_addr = Signer::address_of(account);\n        let outbox = borrow_global_mut<Outbox<Content>>(outbox_owner);\n\n        let Item<Content>{from, to, content} = Vector::swap_remove<Item<Content>>(&mut outbox.content, index);\n\n        assert!(from == account_addr || to == account_addr, 123);\n\n        content\n    }\n}\n\n\nNow Outbox can be used to retrieve and store resources in transaction scripts, and pass those to modules following the Script Based Design pattern.\n\nHot Potato\n\t\nName\tHot Potato\nOrigin\tSui Project / Todd Nowacki\nExample\tFlashLender.move\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Hot Potato is a struct without key, store and drop abilities forcing the struct to be used within the transaction it was created in. This is desired in applications like flash loans where the loans must be initiated and repaid during the same transaction.\n\nExamples\n// Copyright (c) 2022, Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/// A flash loan that works for any Coin type\nmodule defi::flash_lender {\n    use sui::balance::{Self, Balance};\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, ID, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    /// A shared object offering flash loans to any buyer willing to pay `fee`.\n    struct FlashLender<phantom T> has key {\n        id: UID,\n        /// Coins available to be lent to prospective borrowers\n        to_lend: Balance<T>,\n        /// Number of `Coin<T>`'s that will be charged for the loan.\n        /// In practice, this would probably be a percentage, but\n        /// we use a flat fee here for simplicity.\n        fee: u64,\n    }\n\n    /// A \"hot potato\" struct recording the number of `Coin<T>`'s that\n    /// were borrowed. Because this struct does not have the `key` or\n    /// `store` ability, it cannot be transferred or otherwise placed in\n    /// persistent storage. Because it does not have the `drop` ability,\n    /// it cannot be discarded. Thus, the only way to get rid of this\n    /// struct is to call `repay` sometime during the transaction that created it,\n    /// which is exactly what we want from a flash loan.\n    struct Receipt<phantom T> {\n        /// ID of the flash lender object the debt holder borrowed from\n        flash_lender_id: ID,\n        /// Total amount of funds the borrower must repay: amount borrowed + the fee\n        repay_amount: u64\n    }\n\n    /// An object conveying the privilege to withdraw funds from and deposit funds to the\n    /// `FlashLender` instance with ID `flash_lender_id`. Initially granted to the creator\n    /// of the `FlashLender`, and only one `AdminCap` per lender exists.\n    struct AdminCap has key, store {\n        id: UID,\n        flash_lender_id: ID,\n    }\n\n    /// Attempted to borrow more than the `FlashLender` has.\n    /// Try borrowing a smaller amount.\n    const ELoanTooLarge: u64 = 0;\n\n    /// Tried to repay an amount other than `repay_amount` (i.e., the amount borrowed + the fee).\n    /// Try repaying the proper amount.\n    const EInvalidRepaymentAmount: u64 = 1;\n\n    /// Attempted to repay a `FlashLender` that was not the source of this particular debt.\n    /// Try repaying the correct lender.\n    const ERepayToWrongLender: u64 = 2;\n\n    /// Attempted to perform an admin-only operation without valid permissions\n    /// Try using the correct `AdminCap`\n    const EAdminOnly: u64 = 3;\n\n    /// Attempted to withdraw more than the `FlashLender` has.\n    /// Try withdrawing a smaller amount.\n    const EWithdrawTooLarge: u64 = 4;\n\n    // === Creating a flash lender ===\n\n    /// Create a shared `FlashLender` object that makes `to_lend` available for borrowing.\n    /// Any borrower will need to repay the borrowed amount and `fee` by the end of the\n    /// current transaction.\n    public fun new<T>(to_lend: Balance<T>, fee: u64, ctx: &mut TxContext): AdminCap {\n        let id = object::new(ctx);\n        let flash_lender_id = object::uid_to_inner(&id);\n        let flash_lender = FlashLender { id, to_lend, fee };\n        // make the `FlashLender` a shared object so anyone can request loans\n        transfer::share_object(flash_lender);\n\n        // give the creator admin permissions\n        AdminCap { id: object::new(ctx), flash_lender_id }\n    }\n\n    /// Same as `new`, but transfer `WithdrawCap` to the transaction sender\n    public entry fun create<T>(to_lend: Coin<T>, fee: u64, ctx: &mut TxContext) {\n        let balance = coin::into_balance(to_lend);\n        let withdraw_cap = new(balance, fee, ctx);\n\n        transfer::transfer(withdraw_cap, tx_context::sender(ctx))\n    }\n\n    // === Core functionality: requesting a loan and repaying it ===\n\n    /// Request a loan of `amount` from `lender`. The returned `Receipt<T>` \"hot potato\" ensures\n    /// that the borrower will call `repay(lender, ...)` later on in this tx.\n    /// Aborts if `amount` is greater that the amount that `lender` has available for lending.\n    public fun loan<T>(\n        self: &mut FlashLender<T>, amount: u64, ctx: &mut TxContext\n    ): (Coin<T>, Receipt<T>) {\n        let to_lend = &mut self.to_lend;\n        assert!(balance::value(to_lend) >= amount, ELoanTooLarge);\n        let loan = coin::take(to_lend, amount, ctx);\n        let repay_amount = amount + self.fee;\n        let receipt = Receipt { flash_lender_id: object::id(self), repay_amount };\n\n        (loan, receipt)\n    }\n\n    /// Repay the loan recorded by `receipt` to `lender` with `payment`.\n    /// Aborts if the repayment amount is incorrect or `lender` is not the `FlashLender`\n    /// that issued the original loan.\n    public fun repay<T>(self: &mut FlashLender<T>, payment: Coin<T>, receipt: Receipt<T>) {\n        let Receipt { flash_lender_id, repay_amount } = receipt;\n        assert!(object::id(self) == flash_lender_id, ERepayToWrongLender);\n        assert!(coin::value(&payment) == repay_amount, EInvalidRepaymentAmount);\n\n        coin::put(&mut self.to_lend, payment)\n    }\n\n    // === Admin-only functionality ===\n\n    /// Allow admin for `self` to withdraw funds.\n    public fun withdraw<T>(\n        self: &mut FlashLender<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut TxContext\n    ): Coin<T> {\n        // only the holder of the `AdminCap` for `self` can withdraw funds\n        check_admin(self, admin_cap);\n\n        let to_lend = &mut self.to_lend;\n        assert!(balance::value(to_lend) >= amount, EWithdrawTooLarge);\n        coin::take(to_lend, amount, ctx)\n    }\n\n    /// Allow admin to add more funds to `self`\n    public entry fun deposit<T>(\n        self: &mut FlashLender<T>, admin_cap: &AdminCap, coin: Coin<T>\n    ) {\n        // only the holder of the `AdminCap` for `self` can deposit funds\n        check_admin(self, admin_cap);\n        coin::put(&mut self.to_lend, coin);\n    }\n\n    /// Allow admin to update the fee for `self`\n    public entry fun update_fee<T>(\n        self: &mut FlashLender<T>, admin_cap: &AdminCap, new_fee: u64\n    ) {\n        // only the holder of the `AdminCap` for `self` can update the fee\n        check_admin(self, admin_cap);\n\n        self.fee = new_fee\n    }\n\n    fun check_admin<T>(self: &FlashLender<T>, admin_cap: &AdminCap) {\n        assert!(object::borrow_id(self) == &admin_cap.flash_lender_id, EAdminOnly);\n    }\n\n    // === Reads ===\n\n    /// Return the current fee for `self`\n    public fun fee<T>(self: &FlashLender<T>): u64 {\n        self.fee\n    }\n\n    /// Return the maximum amount available for borrowing\n    public fun max_loan<T>(self: &FlashLender<T>): u64 {\n        balance::value(&self.to_lend)\n    }\n\n    /// Return the amount that the holder of `self` must repay\n    public fun repay_amount<T>(self: &Receipt<T>): u64 {\n        self.repay_amount\n    }\n\n    /// Return the amount that the holder of `self` must repay\n    public fun flash_lender_id<T>(self: &Receipt<T>): ID {\n        self.flash_lender_id\n    }\n}\n\n\nExample for Sui Move is taken from the Sui repository.\n\nScript Based Design\n\t\nName\tScript Based Design\nOrigin\tVille Sundell\nExample\tDiem Forum post lost, April 18 2022\nDepends on\tAccountless Design\nKnown to work on\tMove\nSummary\n\nScript Based Design combines Accountless Design with Move Transaction Scripts enabling a design where most of the business logic resides in transaction scripts, while keeping the most critical parts in modules. This way the transaction scripts can be developed and improved faster than a regular module would, while providing the same kind of guarantees as regular modules by keeping the most critical part (state transitions) in modules.\n\nExamples\nTransferable Witness\n\t\nName\tTransferable Witness\nOrigin\tSui Move by Example / Damir Shamanaev\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tCapability, Witness\nKnown to work on\tMove\nSummary\n\nA Transferable Witness is a semi-ephemeral storable witness wrapped into a disposable capability.\n\nExamples\n/// This pattern is based on combination of two others: Capability and a Witness.\n/// Since Witness is something to be careful with, spawning it should be only\n/// allowed to authorized users (ideally only once). But some scenarios require\n/// type authorization by module X to be used in another module Y. Or, possibly,\n/// there's a case where authorization should be performed after some time.\n///\n/// For these, rather rare, scerarios a storable witness is a perfect solution.\nmodule examples::transferable_witness {\n    use sui::transfer;\n    use sui::id::{Self, VersionedID};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Witness now has a `store` which allows us to store it inside a wrapper.\n    struct WITNESS has store, drop {}\n\n    /// Carries the witness type. Can only be used once to get a Witness.\n    struct WitnessCarrier has key { id: VersionedID, witness: WITNESS }\n\n    /// Send a `WitnessCarrier` to the module publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            WitnessCarrier { id: tx_context::new_id(ctx), witness: WITNESS {} },\n            tx_context::sender(ctx)\n        )\n    }\n\n    /// Unwrap a carrier and get the inner WITNESS type.\n    public fun get_witness(carrier: WitnessCarrier): WITNESS {\n        let WitnessCarrier { id, witness } = carrier;\n        id::delete(id);\n        witness\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev.\n\nID Pointer\n\t\nName\tID Pointer\nOrigin\tSui Project\nExample\texample.move\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nThe following example implements basic Lock and Key mechanics on Sui where Lock<T> is a shared object that can contain any object, and Key is an owned object, which is required to get access to the contents of the lock.\n\nKey is linked to its Lock using an ID field. This check allows off-chain discovery of the target, as well as splits the dynamic transferable capability and the 'static' contents. Another benefit of this approach is that the target asset is always discoverable, while you can wrap its Key into another object (such as a marketplace listing).\n\nID pointer is a technique that separates the main data (an object) and its accessors/capabilities by linking the latter to the original. There's a few different ways you can use this pattern:\n\nIssuing transferable capabilities for shared objects (for example, a TransferCap that changes 'owner' field of a shared object)\nSplitting dynamic data and static (for example, an NFT and its collection information)\nAvoiding unnecessary type linking (and witness requirement) in generic applications (LP token for a LiquidityPool)\nExamples\n\nThe following example implements basic Lock and Key mechanics on Sui where Lock is a shared object that can contain any object, and Key is an owned object, which is required to get access to the contents of the lock.\n\nKey is linked to its Lock using an ID field. This check allows off-chain discovery of the target, as well as splits the dynamic transferable capability and the 'static' contents. Another benefit of this approach is that the target asset is always discoverable, while you can wrap its Key into another object (such as a marketplace listing).\n\n\n// Copyright (c) 2022, Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nmodule examples::lock_and_key {\n    use sui::object::{Self, ID, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::option::{Self, Option};\n\n    /// Lock is empty, nothing to take.\n    const ELockIsEmpty: u64 = 0;\n\n    /// Key does not match the Lock.\n    const EKeyMismatch: u64 = 1;\n\n    /// Lock already contains something.\n    const ELockIsFull: u64 = 2;\n\n    /// Lock that stores any content inside it.\n    struct Lock<T: store + key> has key {\n        id: UID,\n        locked: Option<T>\n    }\n\n    /// A key that is created with a Lock; is transferable\n    /// and contains all the needed information to open the Lock.\n    struct Key<phantom T: store + key> has key, store {\n        id: UID,\n        for: ID,\n    }\n\n    /// Returns an ID of a Lock for a given Key.\n    public fun key_for<T: store + key>(key: &Key<T>): ID {\n        key.for\n    }\n\n    /// Lock some content inside a shared object. A Key is created and is\n    /// sent to the transaction sender. For example, we could turn the\n    /// lock into a treasure chest by locking some `Coin<SUI>` inside.\n    ///\n    /// Sender gets the `Key` to this `Lock`.\n    public fun create<T: store + key>(obj: T, ctx: &mut TxContext) {\n        let id = object::new(ctx);\n        let for = object::uid_to_inner(&id);\n\n        transfer::share_object(Lock<T> {\n            id,\n            locked: option::some(obj),\n        });\n\n        transfer::transfer(Key<T> {\n            for,\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n    }\n\n    /// Lock something inside a shared object using a Key. Aborts if\n    /// lock is not empty or if key doesn't match the lock.\n    public fun lock<T: store + key>(\n        obj: T,\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ) {\n        assert!(option::is_none(&lock.locked), ELockIsFull);\n        assert!(&key.for == object::borrow_id(lock), EKeyMismatch);\n\n        option::fill(&mut lock.locked, obj);\n    }\n\n    /// Unlock the Lock with a Key and access its contents.\n    /// Can only be called if both conditions are met:\n    /// - key matches the lock\n    /// - lock is not empty\n    public fun unlock<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ): T {\n        assert!(option::is_some(&lock.locked), ELockIsEmpty);\n        assert!(&key.for == object::borrow_id(lock), EKeyMismatch);\n\n        option::extract(&mut lock.locked)\n    }\n\n    /// Unlock the Lock and transfer its contents to the transaction sender.\n    public fun take<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n        ctx: &mut TxContext,\n    ) {\n        transfer::public_transfer(unlock(lock, key), tx_context::sender(ctx))\n    }\n}\n\n\nExample for Sui Move is taken from the Sui Doc."
    },
    {
      "title": "",
      "url": "https://www.move-patterns.com/script_based_design.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n \nDocument not found (404)\n\nThis URL is invalid, sorry. Please use the navigation bar or search to continue."
    },
    {
      "title": "ID Pointer - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/id-pointer.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nID Pointer\n\t\nName\tID Pointer\nOrigin\tSui Project\nExample\texample.move\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nThe following example implements basic Lock and Key mechanics on Sui where Lock<T> is a shared object that can contain any object, and Key is an owned object, which is required to get access to the contents of the lock.\n\nKey is linked to its Lock using an ID field. This check allows off-chain discovery of the target, as well as splits the dynamic transferable capability and the 'static' contents. Another benefit of this approach is that the target asset is always discoverable, while you can wrap its Key into another object (such as a marketplace listing).\n\nID pointer is a technique that separates the main data (an object) and its accessors/capabilities by linking the latter to the original. There's a few different ways you can use this pattern:\n\nIssuing transferable capabilities for shared objects (for example, a TransferCap that changes 'owner' field of a shared object)\nSplitting dynamic data and static (for example, an NFT and its collection information)\nAvoiding unnecessary type linking (and witness requirement) in generic applications (LP token for a LiquidityPool)\nExamples\n\nThe following example implements basic Lock and Key mechanics on Sui where Lock is a shared object that can contain any object, and Key is an owned object, which is required to get access to the contents of the lock.\n\nKey is linked to its Lock using an ID field. This check allows off-chain discovery of the target, as well as splits the dynamic transferable capability and the 'static' contents. Another benefit of this approach is that the target asset is always discoverable, while you can wrap its Key into another object (such as a marketplace listing).\n\n\n// Copyright (c) 2022, Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nmodule examples::lock_and_key {\n    use sui::object::{Self, ID, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::option::{Self, Option};\n\n    /// Lock is empty, nothing to take.\n    const ELockIsEmpty: u64 = 0;\n\n    /// Key does not match the Lock.\n    const EKeyMismatch: u64 = 1;\n\n    /// Lock already contains something.\n    const ELockIsFull: u64 = 2;\n\n    /// Lock that stores any content inside it.\n    struct Lock<T: store + key> has key {\n        id: UID,\n        locked: Option<T>\n    }\n\n    /// A key that is created with a Lock; is transferable\n    /// and contains all the needed information to open the Lock.\n    struct Key<phantom T: store + key> has key, store {\n        id: UID,\n        for: ID,\n    }\n\n    /// Returns an ID of a Lock for a given Key.\n    public fun key_for<T: store + key>(key: &Key<T>): ID {\n        key.for\n    }\n\n    /// Lock some content inside a shared object. A Key is created and is\n    /// sent to the transaction sender. For example, we could turn the\n    /// lock into a treasure chest by locking some `Coin<SUI>` inside.\n    ///\n    /// Sender gets the `Key` to this `Lock`.\n    public fun create<T: store + key>(obj: T, ctx: &mut TxContext) {\n        let id = object::new(ctx);\n        let for = object::uid_to_inner(&id);\n\n        transfer::share_object(Lock<T> {\n            id,\n            locked: option::some(obj),\n        });\n\n        transfer::transfer(Key<T> {\n            for,\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n    }\n\n    /// Lock something inside a shared object using a Key. Aborts if\n    /// lock is not empty or if key doesn't match the lock.\n    public fun lock<T: store + key>(\n        obj: T,\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ) {\n        assert!(option::is_none(&lock.locked), ELockIsFull);\n        assert!(&key.for == object::borrow_id(lock), EKeyMismatch);\n\n        option::fill(&mut lock.locked, obj);\n    }\n\n    /// Unlock the Lock with a Key and access its contents.\n    /// Can only be called if both conditions are met:\n    /// - key matches the lock\n    /// - lock is not empty\n    public fun unlock<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n    ): T {\n        assert!(option::is_some(&lock.locked), ELockIsEmpty);\n        assert!(&key.for == object::borrow_id(lock), EKeyMismatch);\n\n        option::extract(&mut lock.locked)\n    }\n\n    /// Unlock the Lock and transfer its contents to the transaction sender.\n    public fun take<T: store + key>(\n        lock: &mut Lock<T>,\n        key: &Key<T>,\n        ctx: &mut TxContext,\n    ) {\n        transfer::public_transfer(unlock(lock, key), tx_context::sender(ctx))\n    }\n}\n\n\nExample for Sui Move is taken from the Sui Doc."
    },
    {
      "title": "Transferable Witness - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/transferable-witness.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nTransferable Witness\n\t\nName\tTransferable Witness\nOrigin\tSui Move by Example / Damir Shamanaev\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tCapability, Witness\nKnown to work on\tMove\nSummary\n\nA Transferable Witness is a semi-ephemeral storable witness wrapped into a disposable capability.\n\nExamples\n/// This pattern is based on combination of two others: Capability and a Witness.\n/// Since Witness is something to be careful with, spawning it should be only\n/// allowed to authorized users (ideally only once). But some scenarios require\n/// type authorization by module X to be used in another module Y. Or, possibly,\n/// there's a case where authorization should be performed after some time.\n///\n/// For these, rather rare, scerarios a storable witness is a perfect solution.\nmodule examples::transferable_witness {\n    use sui::transfer;\n    use sui::id::{Self, VersionedID};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Witness now has a `store` which allows us to store it inside a wrapper.\n    struct WITNESS has store, drop {}\n\n    /// Carries the witness type. Can only be used once to get a Witness.\n    struct WitnessCarrier has key { id: VersionedID, witness: WITNESS }\n\n    /// Send a `WitnessCarrier` to the module publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            WitnessCarrier { id: tx_context::new_id(ctx), witness: WITNESS {} },\n            tx_context::sender(ctx)\n        )\n    }\n\n    /// Unwrap a carrier and get the inner WITNESS type.\n    public fun get_witness(carrier: WitnessCarrier): WITNESS {\n        let WitnessCarrier { id, witness } = carrier;\n        id::delete(id);\n        witness\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev."
    },
    {
      "title": "Script Based Design - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/script-based-design.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nScript Based Design\n\t\nName\tScript Based Design\nOrigin\tVille Sundell\nExample\tDiem Forum post lost, April 18 2022\nDepends on\tAccountless Design\nKnown to work on\tMove\nSummary\n\nScript Based Design combines Accountless Design with Move Transaction Scripts enabling a design where most of the business logic resides in transaction scripts, while keeping the most critical parts in modules. This way the transaction scripts can be developed and improved faster than a regular module would, while providing the same kind of guarantees as regular modules by keeping the most critical part (state transitions) in modules.\n\nExamples"
    },
    {
      "title": "Hot Potato - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/hot-potato.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nHot Potato\n\t\nName\tHot Potato\nOrigin\tSui Project / Todd Nowacki\nExample\tFlashLender.move\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Hot Potato is a struct without key, store and drop abilities forcing the struct to be used within the transaction it was created in. This is desired in applications like flash loans where the loans must be initiated and repaid during the same transaction.\n\nExamples\n// Copyright (c) 2022, Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/// A flash loan that works for any Coin type\nmodule defi::flash_lender {\n    use sui::balance::{Self, Balance};\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, ID, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    /// A shared object offering flash loans to any buyer willing to pay `fee`.\n    struct FlashLender<phantom T> has key {\n        id: UID,\n        /// Coins available to be lent to prospective borrowers\n        to_lend: Balance<T>,\n        /// Number of `Coin<T>`'s that will be charged for the loan.\n        /// In practice, this would probably be a percentage, but\n        /// we use a flat fee here for simplicity.\n        fee: u64,\n    }\n\n    /// A \"hot potato\" struct recording the number of `Coin<T>`'s that\n    /// were borrowed. Because this struct does not have the `key` or\n    /// `store` ability, it cannot be transferred or otherwise placed in\n    /// persistent storage. Because it does not have the `drop` ability,\n    /// it cannot be discarded. Thus, the only way to get rid of this\n    /// struct is to call `repay` sometime during the transaction that created it,\n    /// which is exactly what we want from a flash loan.\n    struct Receipt<phantom T> {\n        /// ID of the flash lender object the debt holder borrowed from\n        flash_lender_id: ID,\n        /// Total amount of funds the borrower must repay: amount borrowed + the fee\n        repay_amount: u64\n    }\n\n    /// An object conveying the privilege to withdraw funds from and deposit funds to the\n    /// `FlashLender` instance with ID `flash_lender_id`. Initially granted to the creator\n    /// of the `FlashLender`, and only one `AdminCap` per lender exists.\n    struct AdminCap has key, store {\n        id: UID,\n        flash_lender_id: ID,\n    }\n\n    /// Attempted to borrow more than the `FlashLender` has.\n    /// Try borrowing a smaller amount.\n    const ELoanTooLarge: u64 = 0;\n\n    /// Tried to repay an amount other than `repay_amount` (i.e., the amount borrowed + the fee).\n    /// Try repaying the proper amount.\n    const EInvalidRepaymentAmount: u64 = 1;\n\n    /// Attempted to repay a `FlashLender` that was not the source of this particular debt.\n    /// Try repaying the correct lender.\n    const ERepayToWrongLender: u64 = 2;\n\n    /// Attempted to perform an admin-only operation without valid permissions\n    /// Try using the correct `AdminCap`\n    const EAdminOnly: u64 = 3;\n\n    /// Attempted to withdraw more than the `FlashLender` has.\n    /// Try withdrawing a smaller amount.\n    const EWithdrawTooLarge: u64 = 4;\n\n    // === Creating a flash lender ===\n\n    /// Create a shared `FlashLender` object that makes `to_lend` available for borrowing.\n    /// Any borrower will need to repay the borrowed amount and `fee` by the end of the\n    /// current transaction.\n    public fun new<T>(to_lend: Balance<T>, fee: u64, ctx: &mut TxContext): AdminCap {\n        let id = object::new(ctx);\n        let flash_lender_id = object::uid_to_inner(&id);\n        let flash_lender = FlashLender { id, to_lend, fee };\n        // make the `FlashLender` a shared object so anyone can request loans\n        transfer::share_object(flash_lender);\n\n        // give the creator admin permissions\n        AdminCap { id: object::new(ctx), flash_lender_id }\n    }\n\n    /// Same as `new`, but transfer `WithdrawCap` to the transaction sender\n    public entry fun create<T>(to_lend: Coin<T>, fee: u64, ctx: &mut TxContext) {\n        let balance = coin::into_balance(to_lend);\n        let withdraw_cap = new(balance, fee, ctx);\n\n        transfer::transfer(withdraw_cap, tx_context::sender(ctx))\n    }\n\n    // === Core functionality: requesting a loan and repaying it ===\n\n    /// Request a loan of `amount` from `lender`. The returned `Receipt<T>` \"hot potato\" ensures\n    /// that the borrower will call `repay(lender, ...)` later on in this tx.\n    /// Aborts if `amount` is greater that the amount that `lender` has available for lending.\n    public fun loan<T>(\n        self: &mut FlashLender<T>, amount: u64, ctx: &mut TxContext\n    ): (Coin<T>, Receipt<T>) {\n        let to_lend = &mut self.to_lend;\n        assert!(balance::value(to_lend) >= amount, ELoanTooLarge);\n        let loan = coin::take(to_lend, amount, ctx);\n        let repay_amount = amount + self.fee;\n        let receipt = Receipt { flash_lender_id: object::id(self), repay_amount };\n\n        (loan, receipt)\n    }\n\n    /// Repay the loan recorded by `receipt` to `lender` with `payment`.\n    /// Aborts if the repayment amount is incorrect or `lender` is not the `FlashLender`\n    /// that issued the original loan.\n    public fun repay<T>(self: &mut FlashLender<T>, payment: Coin<T>, receipt: Receipt<T>) {\n        let Receipt { flash_lender_id, repay_amount } = receipt;\n        assert!(object::id(self) == flash_lender_id, ERepayToWrongLender);\n        assert!(coin::value(&payment) == repay_amount, EInvalidRepaymentAmount);\n\n        coin::put(&mut self.to_lend, payment)\n    }\n\n    // === Admin-only functionality ===\n\n    /// Allow admin for `self` to withdraw funds.\n    public fun withdraw<T>(\n        self: &mut FlashLender<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut TxContext\n    ): Coin<T> {\n        // only the holder of the `AdminCap` for `self` can withdraw funds\n        check_admin(self, admin_cap);\n\n        let to_lend = &mut self.to_lend;\n        assert!(balance::value(to_lend) >= amount, EWithdrawTooLarge);\n        coin::take(to_lend, amount, ctx)\n    }\n\n    /// Allow admin to add more funds to `self`\n    public entry fun deposit<T>(\n        self: &mut FlashLender<T>, admin_cap: &AdminCap, coin: Coin<T>\n    ) {\n        // only the holder of the `AdminCap` for `self` can deposit funds\n        check_admin(self, admin_cap);\n        coin::put(&mut self.to_lend, coin);\n    }\n\n    /// Allow admin to update the fee for `self`\n    public entry fun update_fee<T>(\n        self: &mut FlashLender<T>, admin_cap: &AdminCap, new_fee: u64\n    ) {\n        // only the holder of the `AdminCap` for `self` can update the fee\n        check_admin(self, admin_cap);\n\n        self.fee = new_fee\n    }\n\n    fun check_admin<T>(self: &FlashLender<T>, admin_cap: &AdminCap) {\n        assert!(object::borrow_id(self) == &admin_cap.flash_lender_id, EAdminOnly);\n    }\n\n    // === Reads ===\n\n    /// Return the current fee for `self`\n    public fun fee<T>(self: &FlashLender<T>): u64 {\n        self.fee\n    }\n\n    /// Return the maximum amount available for borrowing\n    public fun max_loan<T>(self: &FlashLender<T>): u64 {\n        balance::value(&self.to_lend)\n    }\n\n    /// Return the amount that the holder of `self` must repay\n    public fun repay_amount<T>(self: &Receipt<T>): u64 {\n        self.repay_amount\n    }\n\n    /// Return the amount that the holder of `self` must repay\n    public fun flash_lender_id<T>(self: &Receipt<T>): ID {\n        self.flash_lender_id\n    }\n}\n\n\nExample for Sui Move is taken from the Sui repository."
    },
    {
      "title": "Accountless Design - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/accountless-design.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nAccountless Design\n\t\nName\tAccountless Design\nOrigin\tVille Sundell\nExample\tDiem Forum Post\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nMove module following the Accountless Design pattern doesn't handle storage (move_to() / move_from()) directly, instead the storage must be handled outside the module in transaction scripts. This makes the module code footprint smaller, design simpler, implementation more portable and provides a way to implement storage agnostic smart contract design on some Move powered platforms.\n\nExamples\nmodule 0x1::Outbox {\n    use Std::Event;\n    use Std::Signer;\n    use Std::Vector;\n\n    struct Item<Content: key + store> has key, store {\n        from: address,\n        to: address,\n        content: Content\n    }\n\n    struct Outbox<Content: key + store> has key, store {\n        content: vector<Item<Content>>\n    }\n\n    struct Put<phantom Content> has key, drop, store {\n    }\n\n    struct EventHandle<phantom Content: drop + store> has key, store {\n        event_handle: Event::EventHandle<Content>\n    }\n\n    public fun create<Content: key + store>(account: &signer) {\n        move_to<Outbox<Content>>(account, Outbox<Content> { content: Vector::empty<Item<Content>>() });\n        move_to<EventHandle<Put<Content>>>(account, EventHandle<Put<Content>> { event_handle: Event::new_event_handle<Put<Content>>(account) } );\n    }\n\n    public fun put<Content: key + store>(account: &signer, from: address, to: address, content: Content) acquires EventHandle, Outbox {\n        let outbox_owner = Signer::address_of(account);\n        let event_handle = borrow_global_mut<EventHandle<Put<Content>>>(outbox_owner);\n        let outbox = borrow_global_mut<Outbox<Content>>(outbox_owner);\n\n        assert!(to != @0x0, 123);\n\n        Vector::push_back<Item<Content>>(&mut outbox.content, Item<Content>{ from, to, content });\n        Event::emit_event<Put<Content>>(&mut event_handle.event_handle, Put<Content> {});\n    }\n\n    public fun get<Content: key + store>(account: &signer, outbox_owner: address, index: u64): Content acquires Outbox {\n        let account_addr = Signer::address_of(account);\n        let outbox = borrow_global_mut<Outbox<Content>>(outbox_owner);\n\n        let Item<Content>{from, to, content} = Vector::swap_remove<Item<Content>>(&mut outbox.content, index);\n\n        assert!(from == account_addr || to == account_addr, 123);\n\n        content\n    }\n}\n\n\nNow Outbox can be used to retrieve and store resources in transaction scripts, and pass those to modules following the Script Based Design pattern."
    },
    {
      "title": "Witness - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/witness.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nWitness\n\t\nName\tWitness\nOrigin\tFastX / Sam Blackshear\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Witness is an ephemeral resource designed to prove only once that the a resource in question can be initiated only once after the witness has been created. The resource is dropped after use, ensuring that the same resource cannot be reused to initialize any other struct.\n\nExamples\n/// Module that defines a generic type `Guardian<T>` which can only be\n/// instantiated with a witness.\nmodule examples::guardian {\n    use sui::id::VersionedID;\n    use sui::tx_context::{Self, TxContext};\n\n    /// Phantom parameter T can only be initialized in the `create_guardian`\n    /// function. But the types passed here must have `drop`.\n    struct Guardian<phantom T: drop> has key, store {\n        id: VersionedID\n    }\n\n    /// The first argument of this function is an actual instance of the\n    /// type T with `drop` ability. It is dropped as soon as received.\n    public fun create_guardian<T: drop>(\n        _witness: T, ctx: &mut TxContext\n    ): Guardian<T> {\n        Guardian { id: tx_context::new_id(ctx) }\n    }\n}\n\n/// Custom module that makes use of the `guardian`.\nmodule examples::peace {\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    // Use the `guardian` as a dependency.\n    use 0x0::guardian;\n\n    /// This type is intended to be used only once.\n    struct PEACE has drop {}\n\n    /// Module initializer is the best way to ensure that the\n    /// code is called only once. With `Witness` pattern it is\n    /// often the best practice.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(\n            guardian::create_guardian(PEACE {}, ctx),\n            tx_context::sender(ctx)\n        )\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev."
    },
    {
      "title": "Nestable Resources - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/nestable-resources.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nNestable Resources\n\t\nName\tNestable Resources\nOrigin\tVille Sundell\nExample\tTaoHe project\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nNestable Resources pattern provides a resource native approach to code reuse by building a nested structure of resources where each resource can be detached for use if the conditions are satisfied. For example, tokens can be placed into a time locked resource, which in turn can be placed into a resource which can be used only by a certain user, effectively creating a timelocked non-fungible token. For cleaner design and easier integration it is recommended that the nestable resources share a common interface for wrapping and unwrapping.\n\nExamples\n/// A nested resource (tao) for implementing a simple ownership model: owner can extract\n/// the content.\nmodule 0x1::Ownable {\n    use Std::Signer;\n\n    /// Simple ownership tao: the `owner` can extract `content`.\n    struct Tao<Content> has key, store {\n        owner: address,\n        content: Content\n    }\n\n    /// Wrapping `content` into a tao the `owner` can only extract.\n    public fun wrap<Content>(owner: address, content: Content): Tao<Content> {\n        Tao<Content> { owner, content }\n    }\n\n    /// Immutable read-only reference to the owner address, and `content`.\n    public fun read<Content>(tao: &Tao<Content>): (&address, &Content) {\n        let Tao<Content> { owner, content } = tao;\n\n        (owner, content)\n    }\n\n    /// If `account ` is the `owner`, extract `content`.\n    public fun unwrap<Content>(account: &signer, tao: Tao<Content>): Content {\n        let Tao<Content> { owner, content } = tao;\n\n        assert!(owner == Signer::address_of(account), 123);\n\n        content\n    }\n}\n\n/// A folder tao to store an arbitrary number of taos.\nmodule 0x1::Folder {\n    /// A simple tao struct containing a vector of resources.\n    struct Tao<Content> has key, store {\n        content: vector<Content>\n    }\n\n    /// Create a new tao, with the static set of resources inside it.\n    public fun wrap<Content>(content: vector<Content>): Tao<Content> {\n        Tao<Content> { content }\n    }\n\n    /// Immutable read-only reference to the vector containing resources.\n    public fun read<Content>(tao: &Tao<Content>): &vector<Content> {\n        let Tao<Content> { content } = tao;\n\n        content\n    }\n\n    /// Destroy the tao, and return the static set of resources inside it.\n    public fun unwrap<Content>(tao: Tao<Content>): vector<Content> {\n        let Tao<Content> { content } = tao;\n\n        content\n    }\n\n\nA token can be placed inside Ownable and it can be placed inside Folder, or other way around, if so desired."
    },
    {
      "title": "Multiple Configurations - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/multiple-configurations.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nMultiple Configurations\n\t\nName\tMultiple Configurations\nOrigin\tVille Sundell\nExample\tDiem Forum Post\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nIn the Multiple Configurations approach singletons (especially for configuration data) are provided to the module as arguments instead of storing them to any specific location.\n\nBy incorporating this design into your modules, you would automatically add a layer of configurability by giving users or admins (if any) a way to create configurations which others could use. This would be similar to Uniswap which lets anyone create markets others could participate in.\n\nExamples\n\nLet's say you have an auction smart contract X and an admin has created a configuration to account A. Then B could issue a transaction script to bid on C's resource like this:\n\nX::place_bid(A, C, 1234);\n\n\nBy accepting parameters (such as C and the amount 1234), a transaction script could trivially hide the selection of the configuration. This depends, how flexible the final script implementation is in terms of arguments to main(), but the transaction script could look like this (quick mock-up):\n\nscript {\n    use 0xFF::X;\n\n    const CONF: address = 0xCOFFEE;\n\n    fun main(a: address, amount: XUS) {\n        X::place_bid(CONF, a, amount);\n    }\n}\n"
    },
    {
      "title": "Capability - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/capability.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nCapability\n\t\nName\tCapability\nOrigin\tLibra Project / Unknown Author\nExample\tSui Move by Example / Damir Shamanaev\nDepends on\tNone\nKnown to work on\tMove\nSummary\n\nA Capability is a resource proving that the owner of the resource is permitted to execute a certain action. This is the oldest known Move design pattern dating back to the Libra project and its token smart contract, where capabilities were used to authorize minting of coins.\n\nExamples\nmodule examples::item {\n    use sui::transfer;\n    use sui::id::VersionedID;\n    use sui::utf8::{Self, String};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Type that marks Capability to create new `Item`s.\n    struct AdminCap has key { id: VersionedID }\n\n    /// Custom NFT-like type.\n    struct Item has key, store { id: VersionedID, name: String }\n\n    /// Module initializer is called once on module publish.\n    /// Here we create only one instance of `AdminCap` and send it to the publisher.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(AdminCap {\n            id: tx_context::new_id(ctx)\n        }, tx_context::sender(ctx))\n    }\n\n    /// The entry function can not be called if `AdminCap` is not passed as\n    /// the first argument. Hence only owner of the `AdminCap` can perform\n    /// this action.\n    public entry fun create_and_send(\n        _: &AdminCap, name: vector<u8>, to: address, ctx: &mut TxContext\n    ) {\n        transfer::transfer(Item {\n            id: tx_context::new_id(ctx),\n            name: utf8::string_unsafe(name)\n        }, to)\n    }\n}\n\n\nExample for Sui Move is taken from the book Sui Move by Example by Damir Shamanaev."
    },
    {
      "title": "Introduction - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/index.html",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nIntroduction\n\nWhile there have been other resource based programming languages in the past (such as Plaid), for a long time resource based programming has been a niche, lacking applications where resource based approach would excel. However, smart contracts and blockchains introduced software development challenges that can be answered with resource based programming.\n\nThe Move language and its Move Virtual Machine were designed originally by Facebook to power their Diem blockchain platform providing an intuitive environment and ecosystem for resource oriented applications. Fortunately Move was adopted by multiple blockchain projects as their smart contract execution environment before Diem was discontinued, so Move continues living separately as an independent project.\n\nToday Move and its virtual machine are powering multiple blockchains, most of which are still in the early development phase.\n\nBecause Move is currently the most widely developed resource based programming language for blockchains, code examples are written in Move. However it is likely that some of these patterns can be implemented also in some other resource based language and ecosystem.\n\nWhat this book is\n\nThis book is for discussing software design paradigms and best practices for resource based languages, especially Move and its flavors.\n\nWhat this book is not\n\nThis book is not a guide to Move or any other resource based language. For books on Move itself, see this list. Also see awesome-move for a curated list of code and content from the Move programming language community.\n\nTechnical disclaimer\n\nThis book is designed to be viewed digitally with hyperlink support (such as PDF or web format). For now the full software pattern format is not followed, instead the patterns are simply defined by a short summary and examples.\n\nLicense\n\nMove Patterns: Design Patterns for Resource Based Programming Â© 2022-2024 by Ville Sundell and others is licensed under CC BY 4.0. To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/."
    },
    {
      "title": "Introduction - Move Patterns: Design Patterns for Resource Based Programming",
      "url": "https://www.move-patterns.com/",
      "html": "Introduction\nDesign Patterns\n1. Capability\n2. Multiple Configurations\n3. Nestable Resources\n4. Witness\n5. Accountless Design\n6. Hot Potato\n7. Script Based Design\n8. Transferable Witness\n9. ID Pointer\nMove Patterns: Design Patterns for Resource Based Programming\n  \nIntroduction\n\nWhile there have been other resource based programming languages in the past (such as Plaid), for a long time resource based programming has been a niche, lacking applications where resource based approach would excel. However, smart contracts and blockchains introduced software development challenges that can be answered with resource based programming.\n\nThe Move language and its Move Virtual Machine were designed originally by Facebook to power their Diem blockchain platform providing an intuitive environment and ecosystem for resource oriented applications. Fortunately Move was adopted by multiple blockchain projects as their smart contract execution environment before Diem was discontinued, so Move continues living separately as an independent project.\n\nToday Move and its virtual machine are powering multiple blockchains, most of which are still in the early development phase.\n\nBecause Move is currently the most widely developed resource based programming language for blockchains, code examples are written in Move. However it is likely that some of these patterns can be implemented also in some other resource based language and ecosystem.\n\nWhat this book is\n\nThis book is for discussing software design paradigms and best practices for resource based languages, especially Move and its flavors.\n\nWhat this book is not\n\nThis book is not a guide to Move or any other resource based language. For books on Move itself, see this list. Also see awesome-move for a curated list of code and content from the Move programming language community.\n\nTechnical disclaimer\n\nThis book is designed to be viewed digitally with hyperlink support (such as PDF or web format). For now the full software pattern format is not followed, instead the patterns are simply defined by a short summary and examples.\n\nLicense\n\nMove Patterns: Design Patterns for Resource Based Programming Â© 2022-2024 by Ville Sundell and others is licensed under CC BY 4.0. To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/."
    }
  ]